<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>SystemVerilog学习（三） - Wenhui&#39;s Rotten Pen</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="文辉" />
  <meta name="description" content="本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要" />

  <meta name="keywords" content="Hugo, linux, emacs, CPU" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://wenhui.space/post/digital_verifer/study_systemverilog_three/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.0995afa14b62cd93e93cfc066b646c4c17a3eddca0e9d52a1d9dcf5d90aaacd3.css" integrity="sha256-CZWvoUtizZPpPPwGa2RsTBej7dyg6dUqHZ3PXZCqrNM=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="SystemVerilog学习（三）" />
<meta property="og:description" content="本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wenhui.space/post/digital_verifer/study_systemverilog_three/" />
<meta property="article:published_time" content="2020-01-16T20:17:00+08:00" />
<meta property="article:modified_time" content="2020-03-02T17:39:35+08:00" />
<meta itemprop="name" content="SystemVerilog学习（三）">
<meta itemprop="description" content="本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要">


<meta itemprop="datePublished" content="2020-01-16T20:17:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-02T17:39:35&#43;08:00" />
<meta itemprop="wordCount" content="8067">



<meta itemprop="keywords" content="SystemVerilog," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SystemVerilog学习（三）"/>
<meta name="twitter:description" content="本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">文辉的烂笔头</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/about/">关于</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/links/">友链</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/index.xml">订阅</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css" integrity="sha256-LWdHSKWG7zv3DTpee8YAgoTfkj3gNkfauF624h4P2Nw=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css" integrity="sha256-Q9bBMw/rHRRag46GDWY84J3elDNc8JJjKXL9tIC4oe8=" crossorigin="anonymous" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      文辉的烂笔头
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/about/">关于</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/links/">友链</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/index.xml">订阅</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">SystemVerilog学习（三）</h1>
      
      <div class="post-meta">
        <time datetime="2020-01-16" class="post-time">
          2020-01-16
        </time>
        <div class="post-category">
            <a href="https://wenhui.space/categories/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%B7%A5%E7%A8%8B%E5%B8%88/"> 芯片验证工程师 </a>
            
          </div>
        <span class="more-meta"> 约 8067 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#本文">本文</a></li>
<li><a href="#参考">参考</a></li>
<li><a href="#概览">概览</a></li>
<li><a href="#类和对象的概述">类和对象的概述</a>
<ul>
<li><a href="#类和对象">类和对象</a></li>
<li><a href="#验证为什么需要oop-面向对象编程">验证为什么需要OOP（面向对象编程）</a></li>
<li><a href="#oop的概念要素">OOP的概念要素</a></li>
<li><a href="#创建对象">创建对象</a></li>
<li><a href="#句柄的传递">句柄的传递</a></li>
<li><a href="#对象的销毁">对象的销毁</a></li>
<li><a href="#句柄的使用">句柄的使用</a></li>
<li><a href="#静态变量">静态变量</a></li>
<li><a href="#静态方法">静态方法</a></li>
</ul></li>
<li><a href="#类的成员">类的成员</a>
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#定义和调用成员方法">定义和调用成员方法</a></li>
<li><a href="#类的封装">类的封装</a></li>
<li><a href="#思考">思考</a></li>
</ul></li>
<li><a href="#类的继承">类的继承</a>
<ul>
<li><a href="#概述-1">概述</a></li>
<li><a href="#案例">案例</a></li>
<li><a href="#成员的覆盖">成员的覆盖</a></li>
</ul></li>
<li><a href="#句柄的使用-1">句柄的使用</a>
<ul>
<li><a href="#句柄的传递-1">句柄的传递</a></li>
<li><a href="#句柄的动态修改">句柄的动态修改</a></li>
</ul></li>
<li><a href="#包的使用">包的使用</a>
<ul>
<li><a href="#包的意义">包的意义</a></li>
<li><a href="#包的定义">包的定义</a></li>
<li><a href="#包与库的区分">包与库的区分</a></li>
<li><a href="#包的命名规则">包的命名规则</a></li>
<li><a href="#包的使用建议">包的使用建议</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h2 id="本文">本文</h2>

<p>SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要介绍类和对象的概述、类的成员、类的继承、句柄的使用、包的使用。</p>

<table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>0.1</td>
<td>初版发布</td>
</tr>
</tbody>
</table>

<h2 id="参考">参考</h2>

<ul>
<li>《SystemVerilog验证》，也就是所谓的绿皮书</li>
<li>路科验证。</li>
</ul>

<h2 id="概览">概览</h2>

<p><center>
<img width="800" src="/image/digital-verifer/Study-SystemVerilog-Three.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h2 id="类和对象的概述">类和对象的概述</h2>

<h3 id="类和对象">类和对象</h3>

<ul>
<li>面向对象的编程语言更符号人对自然语言的理解（属性property和功能function）。</li>
<li>这个世界由无数的类（class）和对象（object）构成的。 <strong>类</strong> 是将相同的个体抽象出来的描述方式， <strong>对象</strong> 是实体，其具备有独立行为能力。</li>
<li>具有相同属性和功能的对象属于同一类，而不同的类之间可能有联系（继承关系）或没有关系。</li>
<li>在C语言中，编程基于过程方法（function）；在verilog中，提供了笨拙的“类对象编程”可能性，也就是在module中定义方法（function/task/always/initial），而后调用module实例中的方法。</li>
<li>verilog中module+method的方式与sv中class定义有本质的区别，即面向对象的三要素：封装（encapsulation）、继承（inheritance）、多态（polymorphism）。本节只阐述类的封装和继承，多态在后续高级章节介绍。</li>
<li>类的定义核心是属性声明和方法定义，所以类既可以保存数据，也可以处理数据。这与struct结构体的重要区别就是，结构体只是数据的集合，而类不仅保存数据，还可以进行数据处理。</li>
</ul>

<p>为了直观说明类的属性和方法，举例如下：</p>

<ul>
<li>类名： 鸟</li>
<li>属性： 翅膀：有，羽毛：有</li>
<li>方法： 飞</li>
</ul>

<p>例化一个类的过程，就是创建类的一个实例，类的实例就是对象。比如家里养了一只喜鹊，这就是对象，它属于鸟类，满足鸟类的属性，具有鸟类的方法，同时也可以拥有自己的属性，如下：</p>

<ul>
<li>实例名： 喜鹊1</li>
<li>属性： 翅膀：有，羽毛：有，颜色：黑白，体重：700g &hellip;&hellip;</li>
<li>方法： 飞</li>
</ul>

<h3 id="验证为什么需要oop-面向对象编程">验证为什么需要OOP（面向对象编程）</h3>

<p>验证环境的各个组件具有以下特点：</p>

<ul>
<li>验证环境中不同组件其功能和所需处理的数据内容是不同的。</li>
<li>验证环境中同一类组件其所具备的功能和数据内容相似。</li>
</ul>

<p>所以，基于以上两点，验证环境中各个组件角色明确、功能独立，使用面向对象编程与验证环境的构建原则十分吻合。</p>

<p>第一个transaction事务类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">transaction</span><span class="p">;</span>
    <span class="kt">bit</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mh">8</span><span class="p">];</span>

    <span class="k">function</span> <span class="k">void</span> <span class="n">display</span><span class="p">;</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;transaction: %h&#34;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div>
<p>可见class的定义和module的定义类似，不过module和class完全不同：</p>

<ul>
<li>module属于硬件域，class属于软件域。</li>
<li>module内的变量是静态的，代表硬件电路，class内的变量是动态的，代表软件行为。</li>
<li>class内可以并且建议定义软件变量（bit等），而module只能定义硬件变量（reg、wire等）（其实也可以定义bit，只不过最后工具还是默认为reg类型）。</li>
<li>class例化后称为对象，module例化后称为实例。</li>
<li>class内不能出现initial和always。</li>
</ul>

<h3 id="oop的概念要素">OOP的概念要素</h3>

<ul>
<li>class类： 基本模块包含成员变量（属性）和方法。module也可以存在变量和方法，不过属于硬件域。</li>
<li>object对象： 类的实例。module也可以例化，属于硬件域。</li>
<li>Handle句柄（指针）： 用来指向对象的指针。module通过层级索引找到设计的实例。</li>
<li>property属性（变量）： 在类中声明的存储数据的变量。在module中就是reg和wire。</li>
<li>method方法： 在类中可以使用function/task来定义方法，在module中定义function/task，也可以定义always/initial。</li>
</ul>

<h3 id="创建对象">创建对象</h3>

<ul>
<li>再次强调v module和sv class的区别：

<ul>
<li>两者共同点在于均使用“模板”来创建内存实例。</li>
<li>不同点在于v module例化是静态的，编译时完成，而sv class例化是动态的，可以任意时间点发生，这也使得类的例化方式更加灵活和节省空间。</li>
<li>v module中没有句柄概念，而是通过层级索引方式找到实例（A.B.C.sig1），而sv class通过句柄使操作更加灵活。</li>
</ul></li>
<li>创建对象时，需要清楚什么是声明，什么是创建（例化）：

<ul>
<li>声明： transaction trans;</li>
<li>创建： trans = new();</li>
</ul></li>
<li>创建对象时创建了什么？ 开辟了新的内存空间，用来存放对象的成员变量和方法。</li>
<li>创建对象时可以通过自定义构建函数来完成变量的初识化和其他操作。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">transaction</span><span class="err">；</span>
    <span class="kt">bit</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mh">8</span><span class="p">];</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="mh">3</span><span class="p">;</span>
        <span class="n">foreach</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">5</span><span class="p">;</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>构建函数new()系统预定义的函数，不需要指定返回值，函数会隐式的返回例化后的对象指针，所以并不是没有返回值，不能加void。</li>
<li>new函数也可以定义多个参数作为初始化时外部传入数值的手段。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">transaction</span><span class="err">；</span>
    <span class="kt">bit</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mh">8</span><span class="p">];</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">(</span><span class="kt">bit</span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="o">=</span><span class="mh">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mh">5</span><span class="p">);</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">foreach</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="k">initial</span> <span class="k">begin</span>
    <span class="n">transaction</span> <span class="n">trans</span><span class="p">;</span> <span class="c1">//声明
</span><span class="c1"></span>    <span class="n">trans</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="mh">10</span><span class="p">,</span> <span class="mh">20</span><span class="p">);</span> <span class="c1">//带初始化数据的创建
</span><span class="c1"></span><span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="句柄的传递">句柄的传递</h3>

<p>区分了类（抽象）和对象（具体）之后，还需要区分对象（存储空间）和句柄（对象指针）。也就是说，在创建了对象之后，该对象的存储空间位置不会变，而指向该空间的句柄可以有多个。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">transaction</span> <span class="n">trans1</span><span class="p">,</span> <span class="n">trans2</span><span class="p">;</span> <span class="c1">//声明句柄 trans1和trans2（此时句柄悬空，无指向对象）
</span><span class="c1"></span><span class="n">trans1</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span> <span class="c1">//例化对象，将其句柄赋予trans1
</span><span class="c1"></span><span class="n">trans2</span> <span class="o">=</span> <span class="n">trans1</span><span class="p">;</span> <span class="c1">//将trans1的值赋予trans2，也就是句柄trans1和trans2指向同一对象
</span><span class="c1"></span><span class="n">trans1</span> <span class="o">=</span><span class="n">new</span><span class="p">();</span> <span class="c1">//例化第二个对象，并将其句柄赋予trans1
</span></code></pre></td></tr></table>
</div>
</div>
<p>首先两个new就代表创建了两个对象，最终trans1指向第二个对象，trans2指向了第一个对象。</p>

<h3 id="对象的销毁">对象的销毁</h3>

<ul>
<li>软件编程的灵活在于动态的分配内存空间，在资源闲置时可以回收空间。</li>
<li>C++语言中的类除了有构建函数，还有析构函数，析构函数的作用就是手动释放空间，这对编程人员的细心和经验提出了要求；而Java和Python等后续的OOP语言不再需要手动定义析构函数，而是自动回收释放空间。</li>
<li>sv也采用自动回收空间的处理方式。回收原则：当一个对象在整个程序中没有任何地方再需要它时，便会被销毁，也即是回收空间。不需要的意思就是没有句柄指向该对象。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">word</span><span class="p">;</span>
    <span class="kt">byte</span> <span class="n">nb</span><span class="p">[];</span> <span class="c1">//声明动态数组
</span><span class="c1"></span>    <span class="k">function</span> <span class="n">new</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">//创建动态数组（创建类的对象是使用&#34;new()&#34;）
</span><span class="c1"></span>    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="k">initial</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">initial_1</span>
  <span class="n">word</span> <span class="n">wd</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mh">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">wd</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="k">end</span>

<span class="k">initial</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">initial_2</span>
    <span class="p">#</span><span class="mh">1</span><span class="n">p3</span>
    <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;How many Bytes are allocated for word instances??&#34;</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
<p>根据以上代码，假设wd=new(1)需要分配1Byte空间，那么在initial_2中当打印语句时，需要为例化开辟多少空间呢？答案是4Byte，原因是wd是静态的；如果将wd声明改为“automatic word wd;”，答案就是0Byte，原因是wd是动态的，且#0ps时刻被创建，而#1ps打印时，wd变量已经消失，空间被回收了。</p>

<h3 id="句柄的使用">句柄的使用</h3>

<ul>
<li>句柄可以用来创建多个对象，也可以前后指向不同对象。</li>
<li>可以使用句柄来使用对象中的成员变量或者成员方法，如下：</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">transaction</span> <span class="n">trans</span><span class="p">;</span> <span class="c1">//声明句柄
</span><span class="c1"></span><span class="n">trans</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span> <span class="c1">//例化对象
</span><span class="c1"></span><span class="n">trans</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">32</span><span class="mi">&#39;d10</span><span class="p">;</span> <span class="c1">// 为对象的成员变量赋值
</span><span class="c1"></span><span class="n">trans</span><span class="p">.</span><span class="n">display</span><span class="p">();</span> <span class="c1">//调用对象的成员方法
</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="静态变量">静态变量</h3>

<ul>
<li>与硬件域不同的是，class中声明的变量默认是动态的，其生命周期在仿真中的某一时间点，也就是对象的创建到对象的销毁。</li>
<li>如果使用关键字static来声明class内的变量，则其为静态变量。静态变量的生命周期贯穿整个仿真阶段。</li>
<li>如果类中声明了静态变量，那么可以直接引用该变量class::var，或者通过例化对象引用object.var。类中静态变量声明后，无论例化多少个对象，只可以共享一个同名的静态变量，因此类的静态变量的使用可以打通各个对象，但是要注意共享资源的保护，换句话说，任何地方修改静态变量，大家都会看到它的修改。</li>
</ul>

<h3 id="静态方法">静态方法</h3>

<ul>
<li>类似与静态变量，在class中定义的方法默认为动态的，我们可以通过static关键字将其声明为静态方法。</li>
<li>静态方法内可以声明并使用动态变量，但是不能使用类的动态变量。原因是咋调用静态方法时，可能还没有创建具体的对象，对应的动态变量也就没有被创建，这时候是无法使用类的动态变量，编译时就会报错；静态方法中可以使用类的静态变量，因为静态变量和静态方法一样，编译时就创建了。</li>
</ul>

<h2 id="类的成员">类的成员</h2>

<h3 id="概述">概述</h3>

<ul>
<li>类是成员变量和成员方法的载体，这些成员可以完成保存数据和处理数据的功能，并且类的变量和方法应该遵循“聚拢”原则，也就是一个类的功能要尽可能单一，做好专职工作。</li>
<li>类作为载体，天生具备了闭合属性，也就是将其属性（变量）和方法封装在类的内部，不会直接暴露给外部，并且可以通过protected和local的关键词，设置变量和方法的外部访问权限。</li>
<li>如果没有指明访问类型，成员默认为public（public并不是关键字），意味着子类和外部都可以访问。</li>
<li>如果指明访问类型为protecd，那么只有该类及其子类可以访问，外部无法访问。</li>
<li>如果指明访问类型为local，那么只有该类可以访问，子类和外部无法访问。</li>
<li>访问类型的设定是为了更好的封装类，尤其是发布供他人使用的软件包，如果验证环境应用范围较窄，可以使用默认的public访问类型，方便类的外部更好的使用变量和方法。</li>
</ul>

<h3 id="定义和调用成员方法">定义和调用成员方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">transaction1</span><span class="err">；</span>
    <span class="kt">bit</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mh">8</span><span class="p">];</span>
    <span class="c1">// ......
</span><span class="c1"></span>    <span class="k">function</span> <span class="k">void</span> <span class="n">display</span><span class="p">();</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;dispaly transaction1&#34;</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">transaction2</span><span class="err">；</span>
    <span class="kt">bit</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mh">8</span><span class="p">];</span>
    <span class="c1">// ......
</span><span class="c1"></span>    <span class="k">function</span> <span class="k">void</span> <span class="n">display</span><span class="p">();</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;dispaly transaction2&#34;</span><span class="p">);</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">transaction1</span>  <span class="n">t1</span><span class="p">;</span> <span class="c1">//声明句柄t1
</span><span class="c1"></span><span class="n">transaction2</span>  <span class="n">t2</span><span class="p">;</span> <span class="c1">//声明句柄t2
</span><span class="c1"></span><span class="k">initial</span> <span class="k">begin</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span> <span class="c1">//创建对象
</span><span class="c1"></span>    <span class="n">t1</span><span class="p">.</span><span class="n">display</span><span class="p">();</span> <span class="c1">//调用transaction1::display()
</span><span class="c1"></span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span> <span class="c1">//创建对象
</span><span class="c1"></span>    <span class="n">t2</span><span class="p">.</span><span class="n">display</span><span class="p">();</span> <span class="c1">//调用transaction2::display()
</span><span class="c1"></span><span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="类的封装">类的封装</h3>

<ul>
<li>类和结构体的异同：

<ul>
<li>二者本身都可以定义数据成员。</li>
<li>类变量在声明后，需要构造才会创建对象实体，而struct在变量声明时已经开辟内存。（有时候类没有new函数，也并不会出错，并不是不需要new，而是系统自动调用了new函数）</li>
<li>类除了可以声明数据变量，还可以声明方法，而struct不能。换句话说，struct就是个数据结构，而class包含了数据成员以及对数据成员处理的方法。</li>
</ul></li>
<li>类与module的异同：

<ul>
<li>从数据和方法来看，两者都可以作为封闭容器来定义和存储。</li>
<li>从例化来看，module必须在仿真开始时就确定是否要例化，而类可以在仿真的任意时刻被例化。换句话说，module是硬件域，静态的，class是软件域，动态的。</li>
<li>从封装性来看，module内的变量和方法是对外部公共开发的，而类可以定义为公共的、受保护的和私有的。</li>
<li>从继承性来看，module没有继承性可言，也就是无法在原有的module的基础上进行module的功能扩展，而继承性是类的一大特点。</li>
</ul></li>
</ul>

<h3 id="思考">思考</h3>

<ul>
<li>可以在哪里定义类？ 答案：module、interface、program和package，也就是所有“盒子”。</li>
<li>可以在类中再声明类成员吗？ 答案：可以，类也是一种数据载体。</li>
<li>What is <strong>this</strong> ？ 答案：如果在类中使用 <strong>this</strong> ，即表明this.X所调用的成员是当前类的成员，而非同名的局部变量或者形式参数等。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="n">new</span><span class="p">(</span><span class="k">string</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">this</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span> <span class="c1">//将参数传递的name赋值给当前类的name变量
</span><span class="c1"></span><span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>类有编译顺序吗？ 答案：有，建议的编译顺序是先编译基类，再编译高级类，或者说先编译将被引用的类，再编译引用 之前已经编译过的类 的类，其实就是个依赖关系。</li>
</ul>

<h2 id="类的继承">类的继承</h2>

<h3 id="概述-1">概述</h3>

<ul>
<li>继承也符合我们的认识世界的观点，我们对世界的认识无外乎归纳法和演绎法。</li>
<li>归纳法就是从个别特别到一般属性的方法，从具体对象中抽象出类的属性和方法，这就是定义类的思维方式。</li>
<li>“白猫黑猫都是猫，抓住老鼠就是好猫”，这里白猫黑猫都继承于猫类，他们有一个属性是颜色，另一个属性是好坏。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">cat</span><span class="p">;</span>
    <span class="n">protected</span> <span class="n">color_t</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">local</span> <span class="kt">bit</span> <span class="n">is_good</span><span class="p">;</span>
    <span class="k">function</span> <span class="n">set_good</span><span class="p">(</span><span class="kt">bit</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">this</span><span class="p">.</span><span class="n">is_good</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">black_cat</span> <span class="n">extends</span> <span class="n">cat</span><span class="p">;</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">this</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="s">&#34;BLACK&#34;</span><span class="p">;</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">white_cat</span> <span class="n">extends</span> <span class="n">cat</span><span class="p">;</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">this</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="s">&#34;WHITE&#34;</span><span class="p">;</span>
    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">black_cat</span> <span class="n">bk</span><span class="p">;</span>
<span class="n">white_cat</span> <span class="n">wt</span><span class="p">;</span>
<span class="k">initial</span> <span class="k">begin</span>
    <span class="n">bk</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
    <span class="n">wt</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
    <span class="n">bk</span><span class="p">.</span><span class="n">set_good</span><span class="p">(</span><span class="mh">1</span><span class="p">);</span>
    <span class="n">wt</span><span class="p">.</span><span class="n">set_good</span><span class="p">(</span><span class="mh">0</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
<p>由上面代码得出结论：</p>

<ul>
<li>不可以通过外部修改黑/白猫的颜色，因为声明的是受保护的变量。</li>
<li>黑/白猫不可以自己初始化时设置is_good夸自己是好猫，因为cat类定义的is_good是local类型。</li>
<li>外部不可以通过访问黑/白猫的is_good属性来得知是不是好猫，因为cat类定义的is_good是local类型，无法访问。</li>
<li>黑/白猫是不是大脸猫，无从得知，因为没有这个属性。</li>
</ul>

<h3 id="案例">案例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">basic_test</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">def</span> <span class="o">=</span> <span class="mh">100</span><span class="p">;</span> <span class="c1">//成员变量赋予默认值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">fin</span><span class="p">;</span>
    <span class="k">task</span> <span class="n">test</span><span class="p">(</span><span class="n">sim_ini</span> <span class="n">ini</span><span class="p">);</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;basic_test::test&#34;</span><span class="p">);</span>
    <span class="k">endtask</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">(</span><span class="kt">int</span> <span class="k">var</span><span class="p">);</span>
        <span class="c1">//......
</span><span class="c1"></span>    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">test_wr</span> <span class="n">extends</span> <span class="n">basic_test</span><span class="p">;</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">super</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">def</span><span class="p">);</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;test_wr::new&#34;</span><span class="p">);</span>
    <span class="k">endfunction</span>
    <span class="k">task</span> <span class="n">test</span><span class="p">(</span><span class="n">stm_ini</span> <span class="n">ini</span><span class="p">);</span>
        <span class="n">super</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="n">ini</span><span class="p">);</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;test_wr::test&#34;</span><span class="p">);</span>
        <span class="c1">//......
</span><span class="c1"></span>    <span class="k">endtask</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">test_rd</span> <span class="n">extends</span> <span class="n">basic_test</span><span class="p">;</span>
    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">super</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">def</span><span class="p">);</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;test_rd::new&#34;</span><span class="p">);</span>
    <span class="k">endfunction</span>
    <span class="k">task</span> <span class="n">test</span><span class="p">(</span><span class="n">stm_ini</span> <span class="n">ini</span><span class="p">);</span>
        <span class="n">super</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="n">ini</span><span class="p">);</span>
        <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;test_rd::test&#34;</span><span class="p">);</span>
        <span class="c1">//......
</span><span class="c1"></span>    <span class="k">endtask</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>类test_wr和test_rd是子类，其父类为basic_test，也叫基类。</li>
<li>子类在定义new函数时，应该首先调用父类的new函数，即super.new()。如果父类的new无任何参数，也可以省略super.new()，因为系统会自动调用。</li>
<li>要想继承父类的属性和方法，必须调用（显式或隐式）super.new()。</li>
<li>从创建对象的初始化来看，用户应该注意如下的规则：

<ul>
<li>子类的实例对象在初始化时首先会调用父类的构造函数。</li>
<li>当父类构造函数完成时，会将子类实例对象中各个成员变量按照他们定义时的默认值初始化，如果没有默认值则不初始化。</li>
<li>在成员的变量默认值赋予后（声明的同时即赋值），才会最后进入用户定义的new函数中执行剩余的初始化代码。</li>
</ul></li>
</ul>

<h3 id="成员的覆盖">成员的覆盖</h3>

<p>在父类和子类里，可以定义相同名称的成员变量和方法（形式参数和返回值也应该相同），而在引用时，也将按照句柄类型来确定作用域。举例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">basic_test</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">def</span> <span class="o">=</span> <span class="mh">100</span><span class="p">;</span> <span class="c1">//成员变量赋予默认值
</span><span class="c1"></span>    <span class="k">function</span> <span class="n">new</span><span class="p">(</span><span class="kt">int</span> <span class="k">var</span><span class="p">);</span>
        <span class="c1">//......
</span><span class="c1"></span>    <span class="k">endfunction</span>
<span class="n">endclass</span>

<span class="n">class</span> <span class="n">test_wr</span> <span class="n">extends</span> <span class="n">basic_test</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">def</span> <span class="o">=</span> <span class="mh">200</span><span class="p">;</span> <span class="c1">//成员变量赋予默认值
</span><span class="c1"></span>    <span class="k">function</span> <span class="n">new</span><span class="p">();</span>
        <span class="n">super</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">def</span><span class="p">);</span>
        <span class="n">$dispaly</span><span class="p">(</span><span class="s">&#34;test_wr::super.def =%0d&#34;</span><span class="p">,</span> <span class="n">super</span><span class="p">.</span><span class="n">def</span><span class="p">);</span> <span class="c1">//super.def为100
</span><span class="c1"></span>        <span class="n">$dispaly</span><span class="p">(</span><span class="s">&#34;test_wr::this.def =%0d&#34;</span><span class="p">,</span> <span class="n">this</span><span class="p">.</span><span class="n">def</span><span class="p">);</span> <span class="c1">//this.def为200
</span><span class="c1"></span>    <span class="k">endfunction</span>
    <span class="c1">//......
</span><span class="c1"></span><span class="n">endclass</span>

<span class="k">module</span> <span class="n">tb</span><span class="p">;</span>
<span class="c1">//......
</span><span class="c1"></span><span class="n">basic_test</span> <span class="n">t</span><span class="p">;</span>
<span class="n">test_wr</span> <span class="n">wr</span><span class="p">;</span>
<span class="k">initial</span> <span class="k">begin</span>
    <span class="n">wr</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">wr</span><span class="p">;</span> <span class="c1">//将子类对象句柄赋值给父类句柄（实际上父类句柄t仍旧只能访问父类变量，而并没有扩大作用域至子类，如果想扩大作用域，只能使用$cast，而不是等号）
</span><span class="c1"></span>    <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;wr.def = %0d&#34;</span><span class="p">,</span> <span class="n">wr</span><span class="p">.</span><span class="n">def</span> <span class="p">);</span>
    <span class="nb">$display</span><span class="p">(</span><span class="s">&#34;t.def = %0d&#34;</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">def</span> <span class="p">);</span>
<span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<p>最后打印的wr.def和t.def的值分别为多少？答案是200和100。首先声明了父类的句柄t和子类句柄wr，创建了子类的实例wr，又将子类的句柄wr赋给了父类句柄t。此时句柄t和wr都指向了这个对象，这里就有区分了，虽然都指向同一对象，但是子类句柄wr可以访问这个对象中的全部变量，也就是def默认值为200，而父类句柄t只能访问子类继承自父类的变量，也就是def默认值为100。这里有两个关键点，一是父类和子类都声明了相同名字的变量，二是子类句柄赋值给了父类句柄，在此场景下需要特别注意。</p>

<p>总结：</p>

<ul>
<li>test_wr类新定义的变量test_wr::def和basic_test::有冲突（同名），但是在类的定义里， <strong>父类和子类拥有同名的变量和方法也是允许的</strong> 。当子类作用域中出现父类同名的变量和方法，则 <strong>以子类作用域为准</strong> 。同时也可以使用this/super来指明使用子类/父类的变量/方法。</li>
<li>父类和子类拥有同名或非同名的变量或方法时，子类使用变量和方法，如果不指明super/this，则依照由近及远的原则来引用变量。

<ul>
<li>首先看变量是否是在函数内部定义的局部变量。</li>
<li>其次看变量是否是当前类定义的成员变量。</li>
<li>最好再看变量是否是父类或更底层类的变量。</li>
</ul></li>
</ul>

<h2 id="句柄的使用-1">句柄的使用</h2>

<h3 id="句柄的传递-1">句柄的传递</h3>

<ul>
<li>句柄可以作为形式参数通过方法来完成对象指针的传递，从外部传入方法内部（注意：传递的参数是句柄，而不是对象，并且对象是创建在一块内存里的，永远不可能作为参数传递）。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">task</span> <span class="n">generator</span><span class="p">;</span>
    <span class="n">tranctions</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
    <span class="n">transmit</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="k">endtask</span>

<span class="k">task</span> <span class="n">transmit</span><span class="p">(</span><span class="n">transaction</span> <span class="n">t</span><span class="p">);</span>
    <span class="c1">//......
</span><span class="c1"></span><span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>句柄也可以在在方法内部首先完成修改，而后再由外部完成使用。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="k">void</span> <span class="n">create</span><span class="p">(</span><span class="n">tranction</span> <span class="n">tr</span><span class="p">);</span> <span class="c1">//Bug, miss ref
</span><span class="c1"></span>    <span class="n">tr</span> <span class="o">=</span><span class="n">new</span><span class="p">();</span>
    <span class="n">tr</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">100</span><span class="p">;</span>
    <span class="c1">//initialize other fields
</span><span class="c1"></span>    <span class="c1">//......
</span><span class="c1"></span><span class="k">endfunction</span>

<span class="n">transaction</span> <span class="n">t</span><span class="p">;</span>
<span class="k">initial</span> <span class="k">begin</span>
    <span class="n">create</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">10</span><span class="p">;</span>
    <span class="nb">$display</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
<p>问题：最后显示的t.addr的数值是多少？ 答案：报错。分析：create函数的参数默认为input，没有返回值，也就是create函数内所做的操作都是局部的，而在外部看来，句柄t还是个null，没有实例，所以在引用t.addr时会报错。改进方法是：参数声明为inout 或 添加ref关键字。</p>

<h3 id="句柄的动态修改">句柄的动态修改</h3>

<p>程序执行时，可以在任何时候为句柄创建新的对象，并将新的指针赋值给句柄。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">task</span> <span class="k">generate</span> <span class="n">trans</span><span class="p">();</span>
    <span class="n">transaction</span> <span class="n">t</span><span class="p">;</span> <span class="c1">//声明句柄
</span><span class="c1"></span>    <span class="n">tranction</span> <span class="n">fifo</span><span class="p">[</span><span class="err">$</span><span class="p">];</span> <span class="c1">//声明存放句柄的队列
</span><span class="c1"></span>    <span class="n">t</span> <span class="o">=</span><span class="n">new</span><span class="p">();</span> <span class="c1">//创建对象
</span><span class="c1"></span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mh">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">t</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">i</span><span class="o">&lt;&lt;</span><span class="mh">2</span><span class="p">;</span>
        <span class="n">fifo</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">fifo</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
<span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<p>问题：最后t.addr数值多少？  答案：8。分析：首先循环对t.addr的赋值依次为0 4 8，队列依次存入三个t，最后弹出第一个赋给t，仿佛最后t.addr的值应该是第一个数字0，为什么会是8，原因就一个，队列里存放的是句柄，不是对象，三次存入的句柄t的内容不变，都指向对象t，而对象t的addr变量是8。所以牢记： *传递和传递的是句柄，而不是对象*。</p>

<h2 id="包的使用">包的使用</h2>

<h3 id="包的意义">包的意义</h3>

<ul>
<li>sv语言提供了一种在多个module、interface和program中共享parameter、data、type、task、function、class等的方法，即利用package（包）的方式来实现。如果装修一个大房子（完整的验证环境）来看的话，我们喜欢将不同的模块的类定义归整到不同的package中。</li>
<li>这么做的好处在于将一簇相关的类组织在单一的命名空间下，使得分属于不同模块验证环境的类来自于不同package，这样便于通过package来解决类的归属问题。</li>
</ul>

<h3 id="包的定义">包的定义</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="kn">package</span> <span class="n">regs_pkg</span><span class="p">;</span>
    <span class="no">`include</span> <span class="s">&#34;stimulator.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;monitor.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;checker.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;env.sv&#34;</span>
<span class="k">endpackage</span>

<span class="kn">package</span> <span class="n">arb_pkg</span><span class="p">;</span>
    <span class="no">`include</span> <span class="s">&#34;stimulator.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;monitor.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;checker.sv&#34;</span>
    <span class="no">`include</span> <span class="s">&#34;env.sv&#34;</span>
<span class="k">endpackage</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>两个package regs_pkg和arb_pkg中都定义了4个与模块验证相关的类，即stimulator、monitor、checker、env。两个不同的package内存在同名的类，但是它们的内容是不同的。</li>
<li>如果我们将这些重名的类归属到不同的package中去编译，不需要担心命名冲突的问题，因为package会将命名空间分隔开率，在使用同名类时，注明要使用哪个package的即可。</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">regs_pkg</span><span class="o">::</span><span class="n">monitor</span> <span class="n">mon1</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
<span class="n">arb_pkg</span><span class="o">::</span><span class="n">monitor</span> <span class="n">mon2</span> <span class="o">=</span> <span class="n">new</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="包与库的区分">包与库的区分</h3>

<ul>
<li>package可以对类名做一个隔离的作用，使用不同的package管理同名的类，可以解决命名冲突问题。（使用域名索引符“::”）</li>
<li>package更多的意义是将软件封装在不同的命名空间中，以此来与全局的命名空间进行隔离。</li>
<li>library是编译的产物，硬件都会被编译到库中，如果不指明编译库，会被编译到默认的库中（worklibrary），同样可以解决命名冲突的问题（不过设计中我认为都会依靠一套完整的命名规则来命名，这样不仅解决同名冲突问题，还可以从名字上了解到模块的更多信息）。</li>
<li>库既可以容纳硬件、也可以容纳软件，包括package。</li>
</ul>

<h3 id="包的命名规则">包的命名规则</h3>

<ul>
<li>在创建package的时候，已经在指定包名称的时候隐含地指定了包的默认路径，即包文件所在的路径，如果在package中要include该路径之外的文件，需要额外指定搜索路径“+incdir+PATH”。</li>
<li>如果遵循package的命名习惯，不但要求定义的package名称独一无二，其内部定义的类也应该尽可能独一无二。</li>
<li>如果不同package中定义的类名也不相同，在顶层的引用可以通过“import pkg_name::*”的形式，来表示在tb中引用的类如果在当前域中没有定义，会搜寻regs_pkg和arb_pkg中定义的类（前提是所有类不同名）。</li>
<li>类的命名上，建议加上指明特定身份的前缀，比如package名。</li>
</ul>

<h3 id="包的使用建议">包的使用建议</h3>

<ul>
<li>在包中可以定义类、静态方法和静态变量。</li>
<li>如果将类封装在某一个包中，那么它就不应该在其他地方编译，这样可以方便后面对类的引用。</li>
<li>类和包是好朋友，包是类的归宿，类是包的子民。</li>
<li>一个完整模块的验证环境组件类，应该由一个对应的模块包来封装。</li>
<li>使用`include关键词完成类在包中的封装，要注意编译的前后顺序。</li>
<li>编译一个包的背后实际是将各类文件平铺在包中，按照顺序完成包和包内各类的有序编译。</li>
<li>使用类的可以通过`import完成包中所有类或者某个类的导入，使得新环境可以识别出来，否则类会躺在包外不被外部识别。</li>
</ul>

<hr />

<p><strong><em>文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。</em></strong></p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">文辉</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-03-02
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">文辉原创文章，如需转载请注明出处，谢谢！！！</span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://wenhui.space/tags/systemverilog/">SystemVerilog</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/digital_designer/random_in_verilog/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">Verilog中获取随机数</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/digital_designer/verilog_coding_three_tools/">
            <span class="next-text nav-default">简化verilog编码的全套解决方案</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  


 
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        文辉
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.bootcss.com/slideout/1.0.1/slideout.min.js" crossorigin="anonymous"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script src="/js/load-photoswipe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc="
      crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk="
      crossorigin="anonymous"></script>
  















</body>
</html>

<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>UVM与验证平台 - Wenhui&#39;s Rotten Pen</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="文辉" />
  <meta name="description" content="本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。 版本 说明 0.1 初版发布 参考 参考自文彬师兄的UVM培训资料。 初识UVM 什么是UVM" />

  <meta name="keywords" content="Hugo, linux, emacs, CPU" />






<meta name="generator" content="Hugo 0.58.3" />


<link rel="canonical" href="https://wenhui.space/post/digital_verifer/uvm_and_verification_platforms/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.0995afa14b62cd93e93cfc066b646c4c17a3eddca0e9d52a1d9dcf5d90aaacd3.css" integrity="sha256-CZWvoUtizZPpPPwGa2RsTBej7dyg6dUqHZ3PXZCqrNM=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="UVM与验证平台" />
<meta property="og:description" content="本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。 版本 说明 0.1 初版发布 参考 参考自文彬师兄的UVM培训资料。 初识UVM 什么是UVM" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wenhui.space/post/digital_verifer/uvm_and_verification_platforms/" />
<meta property="article:published_time" content="2020-02-25T10:19:00+08:00" />
<meta property="article:modified_time" content="2020-02-25T10:46:59+08:00" />
<meta itemprop="name" content="UVM与验证平台">
<meta itemprop="description" content="本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。 版本 说明 0.1 初版发布 参考 参考自文彬师兄的UVM培训资料。 初识UVM 什么是UVM">


<meta itemprop="datePublished" content="2020-02-25T10:19:00&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-25T10:46:59&#43;08:00" />
<meta itemprop="wordCount" content="12070">



<meta itemprop="keywords" content="芯片验证,UVM," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="UVM与验证平台"/>
<meta name="twitter:description" content="本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。 版本 说明 0.1 初版发布 参考 参考自文彬师兄的UVM培训资料。 初识UVM 什么是UVM"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">文辉的烂笔头</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/about/">关于</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/links/">友链</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/index.xml">订阅</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css" integrity="sha256-LWdHSKWG7zv3DTpee8YAgoTfkj3gNkfauF624h4P2Nw=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css" integrity="sha256-Q9bBMw/rHRRag46GDWY84J3elDNc8JJjKXL9tIC4oe8=" crossorigin="anonymous" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      文辉的烂笔头
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/about/">关于</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/links/">友链</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://wenhui.space/index.xml">订阅</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">UVM与验证平台</h1>
      
      <div class="post-meta">
        <time datetime="2020-02-25" class="post-time">
          2020-02-25
        </time>
        <div class="post-category">
            <a href="https://wenhui.space/categories/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E5%B7%A5%E7%A8%8B%E5%B8%88/"> 芯片验证工程师 </a>
            
          </div>
        <span class="more-meta"> 约 12070 字 </span>
          <span class="more-meta"> 预计阅读 25 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#本文">本文</a></li>
<li><a href="#参考">参考</a></li>
<li><a href="#初识uvm">初识UVM</a>
<ul>
<li><a href="#什么是uvm">什么是UVM？</a></li>
<li><a href="#什么是uvm验证平台">什么是UVM验证平台？</a></li>
</ul></li>
<li><a href="#uvm基础">UVM基础</a>
<ul>
<li><a href="#一个基于sv的简单验证平台">一个基于SV的简单验证平台</a></li>
<li><a href="#一个基于uvm的简单验证平台">一个基于UVM的简单验证平台</a></li>
<li><a href="#基于uvm验证平台原则">基于UVM验证平台原则</a></li>
<li><a href="#uvm中两大最重要基类">UVM中两大最重要基类</a></li>
<li><a href="#uvm中常用类的继承关系">UVM中常用类的继承关系</a></li>
<li><a href="#什么是uvm-factory">什么是UVM Factory</a></li>
<li><a href="#uvm验证平台启动执行流程">UVM验证平台启动执行流程</a></li>
</ul></li>
<li><a href="#搭建uvm验证平台">搭建UVM验证平台</a>
<ul>
<li><a href="#uvm验证平台基本组成">UVM验证平台基本组成</a></li>
<li><a href="#一个只有driver的测试平台">一个只有driver的测试平台</a>
<ul>
<li><a href="#driver代码示例">driver代码示例：</a></li>
<li><a href="#top-tb代码示例">top_tb代码示例：</a></li>
<li><a href="#top-tb顶层与uvm树形结构的交互">top_tb顶层与uvm树形结构的交互：</a></li>
</ul></li>
<li><a href="#树形结构构造">树形结构构造</a>
<ul>
<li><a href="#driver-monitor-agent和env">driver、monitor、agent和env：</a></li>
<li><a href="#加入checker">加入checker：</a></li>
<li><a href="#加入sequencer">加入sequencer：</a></li>
<li><a href="#加入transaction">加入transaction：</a></li>
<li><a href="#加入sequence">加入sequence：</a></li>
<li><a href="#my-driver向my-sequencer发送申请">my_driver向my_sequencer发送申请：</a></li>
<li><a href="#my-sequence向my-sequencer发送my-transaction">my_sequence向my_sequencer发送my_transaction：</a></li>
<li><a href="#my-sequence自动启动机制default-sequence">my_sequence自动启动机制default_sequence：</a></li>
<li><a href="#树形结构通信通道变化">树形结构通信通道变化：</a></li>
<li><a href="#截至目前的树形结构">截至目前的树形结构：</a></li>
<li><a href="#加入base-test">加入base_test：</a></li>
<li><a href="#加入my-case0">加入my_case0：</a></li>
<li><a href="#加入my-case0-sequence">加入my_case0_sequence：</a></li>
<li><a href="#将顶层base-test替换成my-case0">将顶层base_test替换成my_case0：</a></li>
</ul></li>
<li><a href="#用例构造">用例构造</a></li>
<li><a href="#uvm测试用例启动">UVM测试用例启动</a></li>
</ul></li>
<li><a href="#uvm验证平台启动和封装">UVM验证平台启动和封装</a>
<ul>
<li><a href="#非基于uvm验证平台仿真启动">非基于uvm验证平台仿真启动</a></li>
<li><a href="#基于uvm验证平台仿真启动">基于uvm验证平台仿真启动</a></li>
<li><a href="#基于uvm验证平台的封装">基于uvm验证平台的封装</a>
<ul>
<li><a href="#为什么要对验证平台封装">为什么要对验证平台封装？</a></li>
<li><a href="#封装的原则是什么">封装的原则是什么？</a></li>
<li><a href="#如何对验证平台封装">如何对验证平台封装？</a></li>
<li><a href="#封装脚本的构造">封装脚本的构造</a></li>
</ul></li>
</ul></li>
<li><a href="#uvm验证平台的优化">UVM验证平台的优化</a>
<ul>
<li><a href="#优化目的是什么">优化目的是什么？</a></li>
<li><a href="#如何优化验证平台">如何优化验证平台？</a></li>
<li><a href="#uvm验证平台目录组织结构">uvm验证平台目录组织结构</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h2 id="本文">本文</h2>

<p>主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。</p>

<table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>0.1</td>
<td>初版发布</td>
</tr>
</tbody>
</table>

<h2 id="参考">参考</h2>

<p>参考自文彬师兄的UVM培训资料。</p>

<h2 id="初识uvm">初识UVM</h2>

<h3 id="什么是uvm">什么是UVM？</h3>

<ul>
<li>VMM(Verification Methodology Manual)，Synopsys在2006年推出的，VMM当中集成了寄存器解决方案RAL(Register Abstraction Layer)。</li>
<li>OVM(Open Verification Methodology)，Cadence和Mentor在2008年推出的，它引进了factory机制，功能非常强大，但是没有寄存器解决方案。</li>
<li>UVM(Universal Verification Methodology)，即通用验证方法学，其正式版本在2011年2月由Accellera推出的，UVM几乎完全继承了OVM，同时又采纳了VMM中的寄存器解决方案。</li>
</ul>

<h3 id="什么是uvm验证平台">什么是UVM验证平台？</h3>

<ul>
<li>UVM是基于System Verilog的一种验证方法学，也可以看成是一个库，提供一系列的接口，可以利用UVM搭建验证平台，用于验证数字逻辑电路的正确性。</li>
<li>注意，UVM本身并不是一个验证平台，他只是一个库，而一个验证平台引入了UVM相关库，称为基于UVM的验证平台，或者简称为UVM验证平台。</li>
<li>支持UVM的EDA厂商：Cadence、Synopsys、Mentor&hellip;</li>
</ul>

<h2 id="uvm基础">UVM基础</h2>

<h3 id="一个基于sv的简单验证平台">一个基于SV的简单验证平台</h3>

<p>注：这里“基于SV”指平台仅仅使用SystemVerilog语言搭建。
<center>
<img width="600" src="/image/digital-verifer/UVM1.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h3 id="一个基于uvm的简单验证平台">一个基于UVM的简单验证平台</h3>

<p><center>
<img width="600" src="/image/digital-verifer/UVM2.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h3 id="基于uvm验证平台原则">基于UVM验证平台原则</h3>

<ul>
<li>类： UVM中几乎所有的东西都是用类(class)来实现的，所以，搭建uvm平台第一条原则，所有的组件都用类来完成。</li>
<li>基于UVM类： 当要实现一个功能时，首先应该想到的是从UVM的某个类派生出一个新的类来实现期望功能，所以，搭建uvm平台第二条原则，所有的组件应该派生自uvm类。</li>
</ul>

<h3 id="uvm中两大最重要基类">UVM中两大最重要基类</h3>

<ul>
<li>uvm_object： 它是UVM最基本的类，几乎所有的类都派生自uvm_object，它的拓展性是最好的，当然能力也是最差的。它主要构成了环境的属性（例如配置）和数据传输。</li>
<li>uvm_component： 它派生自uvm_object ，却拥有自己独有的强大特性，它有两大独有特点，一是通过new形成树形结构，二是自动执行phase。它主要构成了环境的层次。</li>
</ul>

<h3 id="uvm中常用类的继承关系">UVM中常用类的继承关系</h3>

<p><center>
<img width="600" src="/image/digital-verifer/UVM3.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h3 id="什么是uvm-factory">什么是UVM Factory</h3>

<p>所谓Factory就是工厂，是通过一个字符串（类名）创建一个此字符串所代表的的类的一个实例，并且能够自动调用其phase执行的机制，也就相当于加工工厂。理解上可能比较抽象，我们举例来说明。</p>

<p>如下图，一个汽车工厂好比我们的验证平台，支持宝马和奔驰两条生产线，两位老板只需下令生产奔驰还是宝马，工厂按照生产线自动加工，最终产出汽车，这里指令（奔驰/宝马）就是上述中的字符串，生产线就是调用其phase执行的机制，整个验证平台也就相当于工厂，这就是UVM Factory。
<center>
<img width="600" src="/image/digital-verifer/UVM4.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p>我们的工厂可以支持生产哪些“汽车”，是由验证平台决定的，如果向验证平台输入不支持的指令，比如指定工厂生产“永久自行车”，会被视为错误指令。
<center>
<img width="600" src="/image/digital-verifer/UVM5.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p>如果就想生产“永久自行车”，我们需要添加永久自行车生产线:
<center>
<img width="600" src="/image/digital-verifer/UVM6.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p>然后我们就可以向工厂输入指令，生产“永久自行车”了。
<center>
<img width="600" src="/image/digital-verifer/UVM7.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p><strong>总结</strong> ：</p>

<ul>
<li>run_test()语句会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的phase，但是前提是你已经注册了这个类。</li>
<li>对于uvm_component类，注册是通过uvm_component_utils宏来进行的。所有派生自uvm_component以及其派生类都应使用uvm_component_utils来注册</li>
<li>对于uvm_object类，注册是通过uvm_object_utils宏来进行的。所有派生自uvm_object以及其派生类(除uvm_component外)都应使用uvm_object_utils来注册</li>
<li>由上述例子可以看出：run_test()是启动整个验证平台的UVM库函数。</li>
</ul>

<h3 id="uvm验证平台启动执行流程">UVM验证平台启动执行流程</h3>

<p><center>
<img width="200" src="/image/digital-verifer/UVM8.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h2 id="搭建uvm验证平台">搭建UVM验证平台</h2>

<h3 id="uvm验证平台基本组成">UVM验证平台基本组成</h3>

<p><center>
<img width="600" src="/image/digital-verifer/UVM9.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h3 id="一个只有driver的测试平台">一个只有driver的测试平台</h3>

<h4 id="driver代码示例">driver代码示例：</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_driver</span> <span class="n">extends</span> <span class="n">uvm_driver</span><span class="p">;</span>     <span class="c1">//继承uvm库中的uvm_driver类
</span><span class="c1"></span>       <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">my_driver</span><span class="p">)</span>  <span class="c1">//将my_driver类注册到factory
</span><span class="c1"></span>
       <span class="n">virtual</span> <span class="n">my_if</span> <span class="n">vif</span><span class="p">;</span>   <span class="c1">//声明driver的interface, interface my_if的定义这里不再介绍
</span><span class="c1"></span>
       <span class="n">extern</span> <span class="n">virtual</span> <span class="k">function</span> <span class="k">void</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
       <span class="n">extern</span> <span class="n">virtual</span> <span class="k">task</span> <span class="k">void</span> <span class="n">main_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
<span class="n">endclass</span>

<span class="k">function</span> <span class="k">void</span> <span class="n">my_driver</span><span class="o">::</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>  <span class="c1">//将顶层实例化的interface指针传递给driver的insterface
</span><span class="c1"></span>        <span class="n">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">vif</span><span class="p">))</span>
                <span class="no">`uvm_fatal</span><span class="p">(</span><span class="err">“</span><span class="n">my_driver</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">virtual</span> <span class="n">interface</span> <span class="n">must</span> <span class="n">be</span> <span class="n">set</span> <span class="k">for</span> <span class="n">vif</span> <span class="o">!!!</span><span class="err">”</span><span class="p">)</span>
<span class="k">endfunction</span>

<span class="k">task</span> <span class="k">void</span> <span class="n">my_driver</span><span class="o">::</span> <span class="n">main_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
       <span class="c1">//略去
</span><span class="c1"></span><span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="top-tb代码示例">top_tb代码示例：</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">tob_tb</span>
       <span class="n">my_if</span> <span class="n">input_if</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rstn</span><span class="p">);</span>  <span class="c1">//声明top_tb的interface，在dut实例化时可直接使用
</span><span class="c1"></span>       <span class="n">dut</span> <span class="n">my_dut</span><span class="p">(.</span><span class="n">clk</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span>
                          <span class="p">.</span><span class="n">rst_n</span><span class="p">(</span><span class="n">rst_n</span><span class="p">),</span>
                          <span class="p">.</span><span class="n">rxd</span><span class="p">(</span><span class="n">input_if</span><span class="p">.</span><span class="n">data</span><span class="p">));</span>  <span class="c1">//dut实例化
</span><span class="c1"></span>       <span class="k">initial</span> <span class="k">begin</span>
             <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="err">“</span><span class="n">uvm_test_top</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">input_if</span><span class="p">)</span> <span class="c1">//与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来
</span><span class="c1"></span>             <span class="n">run_test</span><span class="p">(</span><span class="err">“</span><span class="n">my_driver</span><span class="err">”</span><span class="p">);</span>  <span class="c1">//实例化my_driver类，实例的名字是uvm_test_top，并执行类my_driver中的main_phase任务
</span><span class="c1"></span>        <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注意: uvm_test_top是run_test产生的my_driver类的实例化对象名字，run_test(“my_driver”)可以简单的看成:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">my_driver</span> <span class="n">uvm_test_top</span><span class="err">；</span>
<span class="n">uvm_test_top</span><span class="p">.</span><span class="n">main_phase</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这里，任何被run_test()实例化的类的对象的名字都会被UVM平台默认成uvm_test_top，这个被实例化的类也就是整个uvm平台的顶层，而且只允许有一个顶层，即一个验证平台只调用一个run_test()。</p>

<h4 id="top-tb顶层与uvm树形结构的交互">top_tb顶层与uvm树形结构的交互：</h4>

<ul>
<li>uvm_config_db</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">function</span> <span class="k">void</span> <span class="n">my_driver</span><span class="o">::</span> <span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>  <span class="c1">//将顶层实例化的interface指针传递给driver的insterface
</span><span class="c1"></span>        <span class="n">super</span><span class="p">.</span><span class="n">build_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">vif</span><span class="p">))</span>
                <span class="no">`uvm_fatal</span><span class="p">(</span><span class="err">“</span><span class="n">my_driver</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">virtual</span> <span class="n">interface</span> <span class="n">must</span> <span class="n">be</span> <span class="n">set</span> <span class="k">for</span> <span class="n">vif</span> <span class="o">!!!</span><span class="err">”</span><span class="p">)</span>
<span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<p>top_tb顶层与uvm树形结构的交互为什么要用这种看起来很怪的uvm_config_db方式获得top_tb的interface，不能直接调用得到吗？ 按道理来讲，是可以的，uvm本来就是基于sv的函数库，其底层肯定也是有sv去实现的，既然uvm将其封装为uvm_config_db，建议统一使用此方法，使用uvm提供的函数也是最好的避免出错的办法。</p>

<ul>
<li>top_tb顶层与uvm树形结构：</li>
</ul>

<p><center>
<img width="600" src="/image/digital-verifer/UVM10.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<ul>
<li>如果将top_tb中的第3点去掉，请回答以下问题：

<ul>
<li>top_tb如何获取dut内部信号？答：通过top_tb.my_dut.xxx可以获取。</li>
<li>top_tb如何获取右侧树形结构的内部信息？答：通过top_tb.uvm_test_top.xxx是不可行的，因为run_test实例化了一个脱离了top_tb层次结构的实例对象，建立了一个新的层次，所以不能通过top_tb.uvm_test_top.xxx直接访问。所以针对这种情况，UVM引入了config_db的机制，也就是前面分别在top_tb和my_driver类中build_phase提到的:</li>
</ul></li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="err">“</span><span class="n">uvm_test_top</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">input_if</span><span class="p">)</span>
<span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">vif</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div>
<p>这样我们通过uvm_config_db将top_tb顶层与uvm树形结构打通。</p>

<ul>
<li>top_tb与树形结构中driver的交互流：</li>
</ul>

<p><center>
<img width="600" src="/image/digital-verifer/UVM11.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
注意：top_tb与树形结构之间的交互用虚线，是因为my_driver.interface.output_xxx不是直接给top_tb.interface.input_xxx传值，而是在采用了config_db机制后，类似于两边在操作同一个指针地址，即改变my_driver.interface.output_xxx的值，就等于直接改变了top_tb.interface.input_xxx中变量的值。另外：uvm_config_db将top_tb顶层与uvm树形结构打通，我们可以将top_tb与树形结构任意组件进行交互，而不仅限于driver和monitor。
<center>
<img width="600" src="/image/digital-verifer/UVM12.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h3 id="树形结构构造">树形结构构造</h3>

<p>目前，一个只含有driver驱动的UVM验证平台已经形成，那么接下来要考虑树形结构的构造，即添加新部件并使其层次化。</p>

<h4 id="driver-monitor-agent和env">driver、monitor、agent和env：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM13.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
注意：此时树形结构的顶层变成了my_env, 所以在top_tb中run_test(“my_driver”)应改成run_test(“my_env”)，之前讲过,run_test(“my_driver”)实例化之后对象的名字是uvm_test_top, 那么run_test(“my_env”)实例化之后顶层对象的名字是什么？答案是仍然为uvm_test_top。树形结构发生了层次改变，此时top_tb怎么和my_driver交互？如下top_tb代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">tob_tb</span>
       <span class="n">my_if</span> <span class="n">input_if</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">rstn</span><span class="p">);</span>  <span class="c1">//声明top_tb的interface，在dut实例化时可直接使用
</span><span class="c1"></span>       <span class="n">dut</span> <span class="n">my_dut</span><span class="p">(.</span><span class="n">clk</span><span class="p">(</span><span class="n">clk</span><span class="p">),</span>
                          <span class="p">.</span><span class="n">rst_n</span><span class="p">(</span><span class="n">rst_n</span><span class="p">),</span>
                          <span class="p">.</span><span class="n">rxd</span><span class="p">(</span><span class="n">input_if</span><span class="p">.</span><span class="n">data</span><span class="p">));</span>  <span class="c1">//dut实例化
</span><span class="c1"></span>       <span class="k">initial</span> <span class="k">begin</span>
             <span class="c1">// uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if)
</span><span class="c1"></span>             <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="err">“</span><span class="n">uvm_test_top</span><span class="p">.</span><span class="n">agt</span><span class="p">.</span><span class="n">drv</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">input_if</span><span class="p">)</span> <span class="c1">//与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来
</span><span class="c1"></span>             <span class="c1">// run_test(“my_driver”)
</span><span class="c1"></span>             <span class="n">run_test</span><span class="p">(</span><span class="err">“</span><span class="n">my_env</span><span class="err">”</span><span class="p">);</span>  <span class="c1">//实例化my_env类，实例的名字是uvm_test_top，并执行类my_env中的phase
</span><span class="c1"></span>        <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="加入checker">加入checker：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM14.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
注意：这里的checker是将reference model和scoreboard统一看成一个整体。reference model和scoreboard的定义和其他component的方式一样，这里不再赘述。</p>

<ul>
<li>树形结构通信通道</li>
</ul>

<p><center>
<img width="600" src="/image/digital-verifer/UVM15.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h4 id="加入sequencer">加入sequencer：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM16.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
这里sequencer是一个固定组件，sequencer主要将激励承接给driver，my_transaction是一个数据包，也就是测试激励，这里还要有一个sequence概念，sequence里存放一组trans，提供给sequencer，可见sequencer属于component类，sequence和trans属于object类。关于sequencer、sequence和trans，还有这样一个比喻，trans好比子弹，sequence好比弹夹，而sequencer是枪。</p>

<h4 id="加入transaction">加入transaction：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM17.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<ul>
<li>transaction使用`uvm_object_utils注册。</li>
<li>transaction可以看成是数据包，把数据打包传输，便于交互。</li>
<li>在组件之间(driver,checker,monitor等)的信息传递都是基于transaction。</li>
</ul>

<p>加入transaction后driver的变化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_driver</span> <span class="n">extends</span> <span class="n">uvm_driver</span>  <span class="p">#(</span><span class="n">my_transaction</span><span class="p">);</span> <span class="c1">//uvm_driver是参数化类，参数类型为my_transaction
</span><span class="c1"></span>       <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">my_driver</span><span class="p">)</span>
       <span class="n">virtual</span> <span class="n">my_if</span> <span class="n">vif</span><span class="p">;</span>
       <span class="err">……</span>
<span class="n">endclass</span>

<span class="k">task</span> <span class="k">void</span> <span class="n">my_driver</span><span class="o">::</span> <span class="n">main_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
     <span class="err">将：</span>
          <span class="n">vif</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mh">8</span><span class="err">’</span><span class="n">b1</span><span class="p">;</span>
     <span class="err">改成：</span>
          <span class="n">req</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="err">“</span><span class="n">req</span><span class="err">”</span><span class="p">);</span> <span class="c1">//等价于my_transaction tr; tr = new(“tr”);
</span><span class="c1"></span>          <span class="n">req</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mh">8</span><span class="err">’</span><span class="n">b1</span><span class="p">;</span>   <span class="c1">//等价于tr.data = 8’b1;
</span><span class="c1"></span>          <span class="n">vif</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">req</span><span class="p">.</span><span class="n">data</span><span class="p">;</span> <span class="c1">//等价于vif.data &lt;= tr.data;
</span><span class="c1"></span><span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>req是父类uvm_driver中变量，类型是传递给uvm_driver的参数，这里传递的参数是my_transaction，所以父类uvm_driver中的req类型就是my_transaction。</li>
<li>my_driver继承了uvm_driver类，所以可以直接使用uvm_driver中的req，而不需要在my_driver中声明定义req。</li>
</ul>

<h4 id="加入sequence">加入sequence：</h4>

<p>前面所示代码中激励都是在driver产生的，正常情况driver只是传递激励，而不是产生激励，所以要将激励产生从driver中移除，从外界获得激励，那driver的激励应该从哪里产生呢？这就是sequencer要做的事情，也就是说sequencer要提供req(这里为my_transaction)给my_driver。那么sequencer的transaction从哪里来？
<center>
<img width="600" src="/image/digital-verifer/UVM18.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p>`uvm_do(my_trans)实现了以下操作:</p>

<ul>
<li>创建一个my_transaction的实例my_trans</li>
<li>将其随机化</li>
<li>最终将其传送给my_sequencer(此宏不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer)</li>
</ul>

<p>sequence工作机制：
<center>
<img width="600" src="/image/digital-verifer/UVM19.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<ul>
<li>对于1， my_sequencer等待。</li>
<li>对于2， my_sequencer等待。</li>
<li>对于3， my_sequencer将my_sequence中的my_trans发送给my_driver。</li>
</ul>

<p>待解决问题：</p>

<ul>
<li>my_driver如何向my_sequencer发送transaction接收请求？</li>
<li>my_sequence如何向my_sequencer发送transaction？</li>
</ul>

<h4 id="my-driver向my-sequencer发送申请">my_driver向my_sequencer发送申请：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM20.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
注意：</p>

<ul>
<li>seq_item_port是uvm_driver中的成员变量。</li>
<li>seq_item_export是uvm_sequencer中的成员变量。</li>
</ul>

<h4 id="my-sequence向my-sequencer发送my-transaction">my_sequence向my_sequencer发送my_transaction：</h4>

<p>前面提到， my_sequence中的`uvm_do不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer，所以需要额外启动连接，以在当前顶层my_env中手工启动为例(一般都是在顶层启动)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">task</span> <span class="k">void</span> <span class="n">my_env</span><span class="o">::</span> <span class="n">main_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
      <span class="n">my_sequence</span> <span class="n">seq</span><span class="p">;</span>
      <span class="n">seq</span> <span class="o">=</span> <span class="n">my_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="err">“</span><span class="n">seq</span><span class="err">”</span><span class="p">);</span>
      <span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">);</span> <span class="c1">//将此sequence产生的transaction发送给agent中的my_sequencer.
</span><span class="c1"></span><span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<p><center>
<img width="600" src="/image/digital-verifer/UVM21.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<h4 id="my-sequence自动启动机制default-sequence">my_sequence自动启动机制default_sequence：</h4>

<p>前面my_sequence是在my_env中手工启动的，default_sequence可以自动启动my_sequence 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">task</span> <span class="k">void</span> <span class="n">my_env</span><span class="o">::</span> <span class="n">main_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
    <span class="err">将下列代码去掉：</span>
         <span class="n">my_sequence</span> <span class="n">seq</span><span class="p">;</span>
         <span class="n">seq</span> <span class="o">=</span> <span class="n">my_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="err">“</span><span class="n">seq</span><span class="err">”</span><span class="p">);</span>
         <span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">);</span> <span class="c1">//将此sequence产生的transaction发送给agent中的my_sequencer.
</span><span class="c1"></span><span class="k">endtask</span>

<span class="n">virtual</span> <span class="k">function</span> <span class="k">void</span> <span class="n">my_env</span><span class="o">::</span><span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
     <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">uvm_object_wrapper</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">.</span><span class="n">main_pahse</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">default_sequence</span><span class="err">”</span><span class="p">,</span> <span class="n">my_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
<span class="k">endtask</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="树形结构通信通道变化">树形结构通信通道变化：</h4>

<p>原始：
<center>
<img width="600" src="/image/digital-verifer/UVM22.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
现在：
<center>
<img width="600" src="/image/digital-verifer/UVM23.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
注意：</p>

<ul>
<li>蓝色部分: top_tb与树形结构的连接</li>
<li>紫色部分: transaction在my_checker和monitor之间的通信通道</li>
<li>红色部分: transaction在my_sequence,my_sequencer和my_driver之间的通信通道</li>
<li>单箭头虚线部分: 实际没有显性直接通道，均通过上一层connect实现</li>
<li>双箭头虚线部分: 代表同一模块</li>
</ul>

<h4 id="截至目前的树形结构">截至目前的树形结构：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM24.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center>
目前，树形结构除my_case0顶层之后，均已构建完成，并全部打通。后面要添加my_case0。</p>

<h4 id="加入base-test">加入base_test：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM25.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>

<p>base_test.sv代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">base_test</span> <span class="n">extends</span> <span class="n">uvm_test</span><span class="p">;</span>
      <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">base_test</span><span class="p">)</span>
      <span class="n">my_env</span> <span class="n">env</span><span class="p">;</span> <span class="c1">//my_env会在base_test中实例化,base_test取代env称为顶层。
</span><span class="c1"></span><span class="n">endclass</span>
<span class="k">function</span> <span class="k">void</span> <span class="n">base_test</span><span class="o">::</span><span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
    <span class="c1">//my_sequence需要在顶层启动连接,因为base_test变成顶层,所以从my_env中移到此处
</span><span class="c1"></span>    <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">uvm_object_wrapper</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“</span><span class="n">env</span><span class="p">.</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">.</span><span class="n">main_pahse</span><span class="err">”</span><span class="p">,</span>
                                                                     <span class="err">“</span><span class="n">default_sequence</span><span class="err">”</span><span class="p">,</span>
                                                                     <span class="n">my_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
<span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<p>top_tb.sv代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">tob_tb</span>
    <span class="k">initial</span> <span class="k">begin</span>
<span class="c1">//       将：
</span><span class="c1">//            uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.agt.drv”, “vif”, input_if)
</span><span class="c1">//            run_test(“my_env”);
</span><span class="c1">//       改成：
</span><span class="c1"></span>            <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">virtual</span> <span class="n">my_if</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="err">“</span><span class="n">uvm_test_top</span><span class="p">.</span><span class="n">env</span><span class="p">.</span><span class="n">agt</span><span class="p">.</span><span class="n">drv</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">vif</span><span class="err">”</span><span class="p">,</span> <span class="n">input_if</span><span class="p">)</span>
            <span class="n">run_test</span><span class="p">(</span><span class="err">“</span><span class="n">base_test</span><span class="err">”</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="加入my-case0">加入my_case0：</h4>

<p><center>
<img width="600" src="/image/digital-verifer/UVM26.png">
<div style="color:darkorange;"> <b>  </b>  </div>
</center></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_case0</span> <span class="n">extends</span> <span class="n">base_test</span><span class="p">;</span>
       <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">my_case0</span><span class="p">)</span>
<span class="n">endclass</span>
<span class="k">function</span> <span class="k">void</span> <span class="n">my_case0</span><span class="o">::</span><span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
   <span class="c1">//以下重载了base_test中的my_sequence的启动，注意bast_test中的仍保留。
</span><span class="c1"></span>   <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">uvm_object_wrapper</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“</span><span class="n">env</span><span class="p">.</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">.</span><span class="n">main_pahse</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">default_sequence</span><span class="err">”</span><span class="p">,</span> <span class="n">my_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
<span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注意：</p>

<ul>
<li>my_case0是继承了base_test的一个子类, 是base_test的一个更具体的实现，也就从这里形成了testcase的概念，这个testcase的名字就是my_case0。</li>
<li>my_case0没有改变激励产生的方式，即仍然是启动了my_sequence，并利用my_sequence中`uvm_do(my_trans)来全随机产生激励。</li>
</ul>

<h4 id="加入my-case0-sequence">加入my_case0_sequence：</h4>

<p>my_case0_sequence.sv代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_case0_sequence</span> <span class="n">extends</span> <span class="n">my_sequence</span> <span class="p">#(</span><span class="n">my_transaction</span><span class="p">);</span>
     <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">my_sequence</span><span class="p">)</span>
      <span class="n">my_transaction</span> <span class="n">my_trans</span><span class="p">;</span>

      <span class="n">virtual</span> <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
          <span class="no">`uvm_do_with</span><span class="p">(</span><span class="n">my_trans</span><span class="p">,</span> <span class="p">{</span><span class="n">my_trans</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="mh">8</span><span class="err">’</span><span class="n">hff</span><span class="p">;})</span>
      <span class="k">endtask</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注意：</p>

<ul>
<li>my_case0_sequence是继承了my_sequence的一个子类, 是my_sequence的一个更具体的实现。</li>
<li>my_case0_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’hff的数据激励。</li>
</ul>

<p>my_case0.sv代码:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_case0</span> <span class="n">extends</span> <span class="n">base_test</span><span class="p">;</span>
       <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">my_case0</span><span class="p">)</span>
<span class="n">endclass</span>
<span class="k">function</span> <span class="k">void</span> <span class="n">my_case0</span><span class="o">::</span><span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
   <span class="c1">//以下将my_case0_sequence中的trans传递给了sequencer，最终传给driver。
</span><span class="c1"></span>   <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">uvm_object_wrapper</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">.</span><span class="n">main_pahse</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">default_sequence</span><span class="err">”</span><span class="p">,</span> <span class="n">my_case0_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
<span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注：</p>

<ul>
<li>这里制造了一个用例my_case0，此用例每个transaction产生8’hff数据的激励。</li>
<li>这里my_case0成为新的顶层。</li>
</ul>

<h4 id="将顶层base-test替换成my-case0">将顶层base_test替换成my_case0：</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">tob_tb</span>
    <span class="k">initial</span> <span class="k">begin</span>
<span class="c1">//       将：
</span><span class="c1">//            run_test(“base_test”);
</span><span class="c1">//       改成：
</span><span class="c1"></span>            <span class="n">run_test</span><span class="p">(</span><span class="err">“</span><span class="n">my_case0</span><span class="err">”</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<p>run_test()作用：它会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的main_phase。
run_test给我们最初的印象是构建了一个脱离了top_tb的树形结构，并完成了所有内部需要交互部件的打通。现在我们需要改变一下思维，这里当调用run_test(“my_case0”)时，不再考虑树形结构，我们用一个更抽象的概念来描述run_test的行为，那就是：它执行一个用例my_case0，而且只有一个用例在执行，这条用例每个transaction都在产生数值为8’hff的数据。我们平时所谓的跑各种各样的用例，这些用例其实都是基于这个去构造和命名的(在uvm平台中)。</p>

<h3 id="用例构造">用例构造</h3>

<p>构造另一个用例my_case1:</p>

<ul>
<li>my_case1_sequence.sv:</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_case1_sequence</span> <span class="n">extends</span> <span class="n">my_sequence</span> <span class="p">#(</span><span class="n">my_transaction</span><span class="p">);</span>
     <span class="no">`uvm_object_utils</span><span class="p">(</span><span class="n">my_sequence</span><span class="p">)</span>
      <span class="n">my_transaction</span> <span class="n">my_trans</span><span class="p">;</span>

      <span class="n">virtual</span> <span class="k">task</span> <span class="n">body</span><span class="p">();</span>
          <span class="no">`uvm_do_with</span><span class="p">(</span><span class="n">my_trans</span><span class="p">,</span> <span class="p">{</span><span class="n">my_trans</span><span class="p">.</span><span class="n">data</span> <span class="o">==</span> <span class="mh">8</span><span class="err">’</span><span class="n">haa</span><span class="p">;})</span>
      <span class="k">endtask</span>
<span class="n">endclass</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注意：my_case1_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’haa的数据激励。</p>

<ul>
<li>my_case1.sv:</li>
</ul>

<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="n">class</span> <span class="n">my_case1</span> <span class="n">extends</span> <span class="n">base_test</span><span class="p">;</span>
       <span class="no">`uvm_component_utils</span><span class="p">(</span><span class="n">my_case1</span><span class="p">)</span>
<span class="n">endclass</span>
<span class="k">function</span> <span class="k">void</span> <span class="n">my_case1</span><span class="o">::</span><span class="n">build_phase</span><span class="p">(</span><span class="n">uvm_phase</span> <span class="n">phase</span><span class="p">);</span>
   <span class="c1">//以下将my_case1_sequence中的trans传递给了sequencer，最终传给driver。
</span><span class="c1"></span>   <span class="n">uvm_config_db</span><span class="p">#</span> <span class="p">(</span><span class="n">uvm_object_wrapper</span><span class="p">)</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="err">“</span><span class="n">agt</span><span class="p">.</span><span class="n">sqr</span><span class="p">.</span><span class="n">main_pahse</span><span class="err">”</span><span class="p">,</span>
                                                                <span class="err">“</span><span class="n">default_sequence</span><span class="err">”</span><span class="p">,</span>
                                                                <span class="n">my_case1_sequence</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">get</span><span class="p">());</span>
<span class="k">endfunction</span>
</code></pre></td></tr></table>
</div>
</div>
<p>注意：这里制造了一个用例my_case1，此用例每个transaction产生8’haa数据的激励； 如果想要运行这个用例，那my_case1将成为新的顶层，也就是将top_tb中的 <strong>run_test(“my_case0”)</strong> 改为 <strong>run_test(“my_case1”)</strong></p>

<h3 id="uvm测试用例启动">UVM测试用例启动</h3>

<p>由于run_test在top_tb中只能调用一次，所以每次跑新的用例，都要手动改一下run_test()的参数名字，试想我们有10000个用例，如果都手动改，那肯定是不可行的，所以UVM提供了另外一种启动方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">top_tb</span>
    <span class="k">initial</span> <span class="k">begin</span>
        <span class="n">run_test</span><span class="p">();</span>
    <span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></td></tr></table>
</div>
</div>
<p>此方式将run_test()中的参数去掉，并利用UVM_TESTNAME从命令行中获得测试用例的名字，例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-nil" data-lang="nil"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-nil" data-lang="nil">&lt;sim command&gt; … + UVM_TESTNAME=my_case0
&lt;sim command&gt; … + UVM_TESTNAME=my_case1</code></pre></td></tr></table>
</div>
</div>
<p>注：sim command为eda厂商提供的仿真命令，后面会有介绍。</p>

<h2 id="uvm验证平台启动和封装">UVM验证平台启动和封装</h2>

<h3 id="非基于uvm验证平台仿真启动">非基于uvm验证平台仿真启动</h3>

<p>注意：.f文件里分别是验证环境和设计的代码文件列表。</p>

<ul>
<li>sysnopsys:

<ul>
<li>编译：vcs –f env_vcs.f –f design_vcs.f –verdi_compile_option –coverage_compile_option ……</li>
<li>仿真：./simv –verdi_rrun_option –coverage_run_option ……</li>
</ul></li>
<li>cadence:

<ul>
<li>编译：irun –f env_irun.f –f design_irun.f –verdi_compile_option –coverage_compile_option ……</li>
<li>仿真：irun –verdi_irun_option –coverage_run_option ……</li>
<li>编译：xrun –f env_xrun.f –f design_xrun.f –verdi_compile_option –coverage_compile_option ……</li>
<li>仿真：xrun –verdi_run_option –coverage_run_option ……</li>
</ul></li>
</ul>

<h3 id="基于uvm验证平台仿真启动">基于uvm验证平台仿真启动</h3>

<ul>
<li>sysnopsys:

<ul>
<li>编译：vcs –f env_vcs.vf –f design_vcs.f –verdi_compile_option –coverage_compile_option –ntb_opts uvm ……</li>
<li>仿真：./simv –verdi_rrun_option –coverage_run_option +UVM_TESTNAME=my_case0 ……</li>
</ul></li>
<li>cadence:

<ul>
<li>编译：irun –f env_irun.vf –f design_irun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 ……</li>
<li>仿真：irun –verdi_irun_option –coverage_run_option +UVM_TESTNAME=my_case0 ……</li>
<li>编译：xrun –f env_xrun.vf –f design_xrun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 ……</li>
<li>仿真：xrun –verdi_run_option –coverage_run_option +UVM_TESTNAME=my_case0 ……</li>
</ul></li>
</ul>

<p>注意：需要在env.vf中包含uvm的库文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-nil" data-lang="nil"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-nil" data-lang="nil">$UVM_HOME/src/uvm_macros.svh
$UVM_HOME/src/uvm.sv
$UVM_HOME/src/uvm_pkg.sv
$UVM_HOME/dpi/uvm_dpi.sv
+incdir+$UVM_HOME/src</code></pre></td></tr></table>
</div>
</div>
<p>对于vcs和irun/xrun还有一点需要注意：</p>

<ul>
<li>对于vcs,使用uvm库时需: include ”uvm_pkg.sv”</li>
<li>对于irun/xrun,使用uvm库时需: import uvm_pkg::*</li>
</ul>

<h3 id="基于uvm验证平台的封装">基于uvm验证平台的封装</h3>

<h4 id="为什么要对验证平台封装">为什么要对验证平台封装？</h4>

<p>到目前为止，我们就可以利用基于uvm的验证平台跑用例进行验证了。经历了漫长痛苦的uvm环境开发之后，当我们在自己独立开发的uvm验证环境中，成功跑完第一条用例my_case0仿真用例的那一刻，发现之前的付出都是值得的，当我们利用自己制造的人生第一条用例my_case0找到人生第一个设计bug的那一刻，发现人生已经达到了巅峰。但是作为一名优秀的验证工程师，我们的成就不仅如此，因为我们的目的不仅仅是找到bug，而是快速高效的找到bug。</p>

<p>当基本验证平台可以使用，进入初期验证阶段之后，你会发现，可能会有不同的验证工程师在此验证环境中开发新的功能，可能会有不同的设计人员在此验证环境中复现bug，也可能包括自己在内的工程师需要在此验证环境中运行各种各样配置的用例，如果每次都需要自己去改变底层仿真命令或者告诉其它人怎么改底层仿真命令，你会发现整个人都不好了。而且如果所有人都自己去手动改环境底层代码跑用例，到最后整个验证平台也会变得非常杂乱，非常不好维护，并且就实际情况，大部分设计工程师是不接受每次跑用例都需要自己手动改代码的。</p>

<p><strong>为了解决这些问题，使环境变得更加整洁高效，维护简单，便于扩展，我们将环境进行封装。</strong></p>

<h4 id="封装的原则是什么">封装的原则是什么？</h4>

<ul>
<li>对自己白盒： 所有的底层运行验证环境的编译选项和仿真选项都要自己维护开发；所有的新的开发需求需要自己来指定结构和位置；所有的内部uvm固有部件骨架都要自己维护开发。</li>
<li>对验证工程师灰盒： 熟悉整体环境运行原理；熟悉各编译和仿真选项含义，验证过程中知道如何增减选项；在指定的结构和位置开发新的功能；不需要对此uvm环境固有骨架进行全面掌握。</li>
<li>对设计工程师黑盒： 不需要知道任何环境内部构造，只需要按照验证工程师提供的脚本命令运行用例即可。</li>
</ul>

<h4 id="如何对验证平台封装">如何对验证平台封装？</h4>

<p>环境采用脚本封装，一般只需提供命令和接口选项，脚本可以使用Makefile，python，perl，shell等。以python脚本封装为例。</p>

<ul>
<li>仿真命令： ./runtest.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim

<ul>
<li>seed        : 提供仿真种子号</li>
<li>-dump       : 产生波形</li>
<li>-cov        : 打开code coverage收集</li>
<li>-funcov     : 打开function coverage收集</li>
<li>-debug      : 仿真结束后自动弹出波形</li>
<li>-covermerge : 仿真结束后自动merge coverage数据</li>
<li>simpath     : 指定生成log的文件夹</li>
</ul></li>
</ul>

<p>上述接口选项最终都会呈现在底层编译和仿真命令中，使用者可以根据需求打开关闭提供选项，而不必需要知道环境内部的细节。如果有新的需求，开发完毕后提供对应的接口即可，大大减少了使用的低效性。</p>

<h4 id="封装脚本的构造">封装脚本的构造</h4>

<p>封装脚本一般分为两部分： 单条用例运行脚本 和 回归用例运行脚本。</p>

<ul>
<li>单条用例运行脚本：

<ul>
<li>用户提供testcase list。</li>
<li>根据脚本提供用例名字在tclist找到对应的用例属性，包括uvm中提供的test名字(如my_case0),用例所在路径等。</li>
<li>在sim下创建以用例名字+种子号命名的文件夹，后面生成的这条用例的所有相关信息，包括log和波形等都会存放在这里。</li>
<li>根据脚本提供选项进行整个环境的编译工作。</li>
<li>根据脚本提供选项进行整个环境的仿真运行。</li>
<li>用例运行结束后，根据仿真产生的log，得到并打印出pass还是fail的信息，方便使用者进行快速判断。</li>
<li>使用者到对应的sim/testcase_name_seed/下查找所有相关log和波形，进行相关debug。</li>
<li>添加其它功能，例如coverage的merge，但是一般只有回归才会涉及到merge的工作，所以这部分功能可以放到回归脚本中。</li>
</ul></li>

<li><p>回归用例运行脚本：</p>

<ul>
<li>识别脚本提供的tclist中提供的回归组名，将所有指定组的用例进行仿真回归。</li>
<li>内部调用单条用例脚本，并将回归用例脚本输入参数全部转换为单条用例脚本输入参数需要的格式。</li>
<li>监测每条用例的仿真结果，并累加计数得到总的tc数，总pass tc数，总fail tc数，和总的没有产生仿真log的tc数。</li>
<li>判断是否所有用例运行结束，并打印最终回归报告。</li>
<li>如果打开coverge merge选项，会自动merge所有回归用例的coverage数据。</li>
<li>回归结束后在sim下生成pass，fail的tclist, 同样每条用例的结果也都存在以用例名字+种子号命名的文件夹中，可以实时查看。</li>
</ul></li>

<li><p>跑单条用例命令： ./rt.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim</p></li>

<li><p>跑回归用例命令： ./rt.py –regress –rgr_group=my_regression -seedrand –dump –cov –funcov –covmerge simpath=./sim</p></li>
</ul>

<h2 id="uvm验证平台的优化">UVM验证平台的优化</h2>

<h3 id="优化目的是什么">优化目的是什么？</h3>

<ul>
<li>针对平台结构优化： 使环境结构简洁，清晰明了，重用性好，移植性强，拓展性高，让新的用户和开发者能够快速切入。</li>
<li>针对平台性能优化： 使环境运行速度提升，提高验证效率</li>
</ul>

<h3 id="如何优化验证平台">如何优化验证平台？</h3>

<ul>
<li><p>针对平台结构优化：</p>

<ul>
<li>加入readme，包含运行方法等必要信息。</li>
<li>加入setup脚本，所需一切配置均在此一键完成。</li>
<li>环境中用到所有路径宏均统一管理，方便更改和移植。</li>
<li>运行中间文件统一管理，方便查看和删除。</li>
<li>目录结构清晰，文件夹命名需简洁易懂。</li>
<li>删除开发过程中的无效代码和目录。</li>
<li>加入必要信息打印开关，方便读取层次结构。</li>
<li>撰写平台使用手册，进行环境详细说明。</li>
</ul></li>

<li><p>针对平台性能优化：</p>

<ul>
<li>检查变量定义，减少存储空间占用，如需要超大容量数组时，需使用关联数组。</li>
<li>检查哪些任务可以并行执行，改成fork_join*多线程机制。</li>
<li>检查是否transaction约束过多，如过多速度会明显变慢。</li>
<li>检查dut文件列表，去掉不必要文件，减少环境编译时间。</li>
<li>检查是否有不必要打印，关掉以减少log输出占用的时间。</li>
<li>检查model，checker，driver中是否有过多占用时间的函数，重新考虑是否有高效替代方案。</li>
<li>利用第三方工具得到平台各个部件的时间占用分布，分析占用最多的几个部件原因，寻找解决方案。</li>
</ul></li>
</ul>

<h3 id="uvm验证平台目录组织结构">uvm验证平台目录组织结构</h3>

<p>verif/my_ut/env下文件：</p>

<ul>
<li>agents/ ： agent文件目录，内含一个或多个agent，agent包含driver、sequencer、monitor组件，agent从行为上可以理解为与dut交互的模块或组织。</li>
<li>coverage/ ： coverage文件目录，内含一个或多个模块的覆盖率文件，也就是covergroup。</li>
<li>checker/ ： checker文件目录，也就是reference model和scoreboard文件，不过有时候会将两者融合成一个checker文件。</li>
<li>include/ ： include文件，一些环境路径的宏定义以及其他include文件存放在这里。</li>
<li>interface/ ： interface文件目录，内含一个或多个接口文件。</li>
<li>script/ ： script文件目录，一些验证平台封装的脚本文件存放在这里。</li>
<li>setup/ ： setup文件目录，一些平台初始化文件存放在这里，如环境变量的初始化和工具的配置。</li>
<li>tests/ ： tests文件目录，所有测试用例存放在这里。</li>
<li>readme ： readme文件，对环境和使用的说明文件。</li>
<li>tb.v ： tb文件，顶层testbench。</li>
<li>env_vcs.f ： env_vcs.f文件，针对vcs工具的filelist文件，包含设计和验证平台的文件列表。</li>
<li>env_xrun.f ： env_xrun.f文件，针对xrun工具的filelist文件，包含设计和验证平台的文件列表。</li>
<li>tc.list ： tc.list文件，包含所有测试用例信息，可为测试用例设定分组，方便回归测试。</li>
<li>my_env_cfg.sv ： my_env_cfg.sv文件，整个验证平台的配置文件，内含静态变量，可传递至平台任意模块，完成验证平台的配置。</li>
</ul>

<hr />

<p><strong><em>文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。</em></strong></p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">文辉</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-02-25
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">文辉原创文章，如需转载请注明出处，谢谢！！！</span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://wenhui.space/tags/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81/">芯片验证</a>
          <a href="https://wenhui.space/tags/uvm/">UVM</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/digital_designer/resolve_dependencies_rtl_compile/">
            <span class="next-text nav-default">如何更好的解决RTL编译时依赖关系问题</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  


 
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        文辉
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js" crossorigin="anonymous"></script>
  <script type="text/javascript" src="https://cdn.bootcss.com/slideout/1.0.1/slideout.min.js" crossorigin="anonymous"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script src="/js/load-photoswipe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc="
      crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk="
      crossorigin="anonymous"></script>
  















</body>
</html>

[{"content":"本文 主要对版本控制工具Git进行简单介绍，以及一些高级场景的应用。\n   版本 说明     0.1 初版发布    背景 本文非原创，整理自掘金小册收费文章《Git 原理详解及实用指南》，作者： 抛物线。\n什么是Git 什么是版本控制 所谓版本控制，意思就是在文件的修改历程中保留修改历史，让你可以方便地撤销之前对文件的修改操作。\n版本控制的三个功能需求：\n 版本控制：在项目开发中我们需要能够回退到任何一个版本状态。 主动提交：在项目开发中我们需要能够主动提交版本状态，而不是自动保存修改内容某版本，这样可以避免大量的无效版本状态。 中央仓库：在项目开发中大多数是多人合作的，需要有一个中央仓库作为代码的存储中心，所有人的改动都会上传到这里，所有人也从这里下载到别人上传的改动。  总结：开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。\n中央式版本控制系统   中央式版本控制系统    假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 VCS 来管理代码。于是：\n 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架； 然后，你在公司的服务器上创建了一个中央仓库，并把你的代码提交到了中央仓库上； 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库； 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。  而对于团队中的每个人来说，就会更简单一点：\n 第一次加入团队时，把中央仓库的代码取下来； 写完的新功能提交到中央仓库； 同事提交到中央仓库的新代码，及时同步下来。  这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。\n分布式版本控制系统   分布式版本控制系统    分布式与中央式相比多了本地仓库，一部分版本历史保存在本地仓库，代码同步和版本历史保存在中央仓库。\n依然以三人团队为例，分布式 VCS 的工作模型大致是这样：\n 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库； 然后，你在服务器上创建了一个中央仓库，并把 1）中的提交从本地仓库推送到了服务器的中央仓库； 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库； 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。  优点与缺点 分布式 VCS 的优点：\n 大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制（例如，你可以在飞机上提交代码、切换分支等等）； 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。  分布式 VCS 的缺点：\n 由于每一个机器都有完整的本地仓库，所以初次获取项目（Git 术语：clone）的时候会比较耗时； 由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。 补充：项目的大多数内容都是文本形式的代码，再加上版本控制工具可以将文本内容极大的压缩，所以实际上内存大和下载慢的问题并不严重。  如何上手之单人开发 已经有 Git 经验的可以跳过这一节。\n安装Git 点击去这里下载个Git，选择对应的平台版本（Linux or Windows），安装到你的机器上。\n建个练习仓库 学习的时候最好别拿团队的正式项目练手，先在 GitHub 上建一个自己的练习项目。\n 访问Github。 注册或登录您的账号。 点击右上角的「New Repository」来新建远程仓库。 填写仓库名称（其他的设置可以先不管，默认即可），点击创建。 点击右边的「Clone or download」，然后把仓库的 clone 地址复制到剪贴板。 把远程仓库取到本地，在 Terminal 或 cmd 中切换到你希望放置项目的目录中，然后输入“git clone 你刚复制的地址”，然后输入正确的用户名和密码。 自己写个提交试试：在克隆到本地的仓库目录下新建个文件，比如temp.txt  使用“git status” 查看当前状态，temp.txt 文件目前属于 \u0026ldquo;untracked\u0026rdquo; 状态，意思是该文件未添加到仓库里，也就没有进行版本追踪。 使用“git add temp.txt”将其添加到仓库，仓库开始对齐进行版本追踪。可以看看再使用“git status”会有什么变化。 使用add后文件添加到了本地仓库的暂存区，现在需要提交到本地仓库，“git commit -m \u0026ldquo;这里写提交注释\u0026rdquo;”，可以看看再使用“git status”会有什么变化，再使用“git log”查看提交历史，可以看到此次的提交。 修改temp.txt文件，执行“git status”会发现文件被修改的提示，重复添加和提交命令，再使用“git log”查看提交历史，可以看到两次的提交。 推送到远程仓库：使用 git push 来把本地提交上传到远程中央仓库。可以在github网页上看到自己本地内容已经更新到远程仓库。    总结 单人开发的基本工作模式如下：\n 从 GitHub 把中央仓库 clone 到本地（使用命令： git clone） 把写完的代码提交（先用 git add 文件名 把文件添加到暂存区，再用 git commit 提交）  在这个过程中，可以使用 git status 来随时查看工作目录的状态 每个文件有 \u0026ldquo;changed / unstaged\u0026rdquo;（已修改）, \u0026ldquo;staged\u0026rdquo;（已修改并暂存）, \u0026ldquo;commited\u0026rdquo;（已提交） 三种状态，以及一种特殊状态 \u0026ldquo;untracked\u0026rdquo;（未跟踪）   提交一次或多次之后，把本地提交 push 到中央仓库（git push）  如何上手之多人协作 对于 Git 来说，团队合作和个人独立工作最大的不同在于，你会提交代码，别人也会提交；你会 push，别人也会 push，因此除了把代码上传，每个人还需要把别人最新的代码下载到自己的电脑。而且，这些工作都是并行进行的。\n把别人的新提交拿到本地  首先你需要一饰多角，除非有同事和你一起练习。为了模拟同事的操作，你需要创建两个文件夹worker1和worker2，在这两个文件夹下将远程仓库clone到本地。现在两个本地仓库就可以代表两个同事在操作了。 worker1提交代码并push到中央仓库：切换worker1的本地仓库，帮他创建个文件写点代码，并依次进行add、commit、push。此时远程中央仓库可以看到已经更新的内容。 worker2更新远程仓库到本地：切换worker2的本地仓库，使用“git pull”将远程仓库内容更新到本地，这时候可以看到worker1的修改的内容。  多人合作的基本工作模型 这就完成了一次简单的合作流程：\n worker1 commit 代码到他的本地，并 push 到 GitHub 中央仓库 worker2把 GitHub 的新提交通过 pull 指令来取到你的本地  比如worker1是同事，worker2是自己，通过这个流程，你和同事就可以简单地合作了：你写了代码，commit，push 到 GitHub，然后他 pull 到他的本地；他再写代码，commit, push 到 GitHub，然后你再 pull 到你的本地。你来我往，配合得不亦乐乎。\n但是，这种合作有一个严重的问题：同一时间内，只能有一个人在工作。你和同事其中一个人写代码的时候，另一个人不能做事，必须等着他把工作做完，代码 push 到 GitHub 以后，自己才能把 push 上去的代码 pull 到自己的本地。而如果同时做事，就会发生冲突：当一个人先于另一个人 push 代码（这种情况必然会发生），那么后 push 的这个人就会由于中央仓库上含有本地没有的提交而导致 push 失败。因为 Git 的push 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库含有本地没有的 commits 的时候，push （如果成功）将会导致远端的 commits 被擦掉。这种结果当然是不可行的，因此 Git 会在 push 的时候进行检查，如果出现这样的情况，push 就会失败。\n解决push冲突 在现实的团队开发中，全队是同时并行开发的，所以必然会出现当一人 push 代码时，中央仓库已经被其他同事先一步 push 了的情况。为了不让文段显得太过混乱，这里我就不带着你一步步模拟这个过程了。如果你希望模拟的话，这里是步骤：\n 切换到worker1，做一个 commit，然后 push 到 GitHub 切换到worker2，做一个不一样的 commit。  这个时候，远端中央仓库已经有了别人 push 的 commit，现在你如果 push 的话，由于 GitHub 的远端仓库上含有本地仓库没有的内容，所以这次 push 被拒绝了。\n这种冲突的解决方式其实很简单：先用 pull 把远端仓库上的新内容取回到本地和本地合并，然后再把合并后的本地仓库向远端仓库推送。这次的 git pull 操作并没有像之前的那样直接结束，而是进入了上图这样的一个输入提交信息的界面。这是因为当 pull 操作发现不仅远端仓库包含本地没有的 commits，而且本地仓库也包含远端没有的 commits 时，它就会把远端和本地的独有 commits 进行合并，自动生成一个新的 commit ，而上图的这个界面，就是这个自动生成的 commit 的提交信息界面。另外，和手动的 commit 不同，这种 commit 会自动填入一个默认的提交信息，简单说明了这条 commit 的来由。你可以直接退出界面来使用这个自动填写的提交信息，也可以修改它来填入自己提交信息。在退出提交信息的界面后，这次 pull 就完成了：远端仓库被取到了本地，并和本地仓库进行了合并。在这个时候，就可以再 push 一次了。由于现在本地仓库已经包含了所有远端仓库的 commits，所以这次 push 不会再失败。\n补充：这种“把不同的内容进行合并，生成新的提交”的操作，叫做合并，它所对应的 Git 指令是 merge。事实上，git pull 这个指令的内部实现就是把远程仓库使用 git fetch 取下来以后再进行 merge 操作的。\n总结 多人协作的基本工作模式如下：\n 写完所有的 commit 后，不用考虑中央仓库是否有新的提交，直接 push 就好 如果 push 失败，就用 pull 把本地仓库的提交和中央仓库的提交进行合并，然后再 push 一次  到此为止，这个工作模型已经是一个最简单的可用的工作模型了。一个小团队如果对版本管理没有什么要求的话，这个工作模型已经可以让团队用来合作开发了。复杂的版本管理还会设计branch，不过对于新人上手，应该先掌握以上内容就基本可以应付日常操作了。\n进阶1：HEAD、master 与 branch 引用：commit 的快捷方式 首先使用“git log”查看一些提交信息：第一行的 commit 后面括号里的 HEAD -\u0026gt; master, origin/master, origin/HEAD ，是几个指向这个 commit 的引用。在 Git 的使用中，经常会需要对指定的 commit 进行操作。每一个 commit 都有一个它唯一的指定方式——它的 SHA-1 校验和，也就是上图中每个黄色的 commit 右边的那一长串字符。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 commit，也可以只使用它的前几位来指代它（例如第一个 78bb0ab7d541…16b77，你使用 78bb0ab 甚至 78bb 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 commit，作为操作 commit 时的快捷方式。\nHEAD：当前 commit 的引用 这个括号里的 HEAD 是引用中最特殊的一个：它是指向当前 commit 的引用。所谓 当前 commit 这个概念很简单，它指的就是当前工作目录所对应的 commit。\n当前 commit 就是第一行中的那个最新的 commit。每次当有新的 commit 的时候，工作目录自动与最新的 commit 对应；而与此同时，HEAD 也会转而指向最新的 commit。事实上，当使用 checkout、reset 等指令手动指定改变当前 commit 的时候，HEAD 也会一起跟过去。\n总之，当前 commit 在哪里，HEAD 就在哪里，这是一个永远自动指向当前 commit 的引用，所以你永远可以用 HEAD 来操作当前 commit。\nbranch HEAD 是 Git 中一个独特的引用，它是唯一的。而除了 HEAD 之外，Git 还有一种引用，叫做 branch（分支）。HEAD 除了可以指向 commit，还可以指向一个 branch，当它指向某个 branch 的时候，会通过这个 branch 来间接地指向某个 commit；另外，当 HEAD 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 branch 一起移动。\n“git log”显示结果中，HEAD -\u0026gt; master 中的 master 就是一个 branch 的名字，而它左边的箭头 -\u0026gt; 表示 HEAD 正指向它（当然，也会间接地指向它所指向的 commit）。如果我在这时创建一个 commit，那么 HEAD 会带着 master 一起移动到最新的。\n     master:默认的 branch 上面的这个 master ，其实是一个特殊的 branch：它是 Git 的默认 branch（俗称主 branch / 主分支）。\n所谓的「默认 branch」，主要有两个特点：\n 新创建的 repository（仓库）是没有任何 commit 的。但在它创建第一个 commit 时，会把 master 指向它，并把 HEAD 指向 master。 当有人使用 git clone 时，除了从远程仓库把 .git 这个仓库目录下载到工作目录中，还会 checkout （签出） master（checkout 的意思就是把某个 commit 作为当前 commit，把 HEAD 移动过去，并把工作目录的文件内容替换成这个 commit 所对应的内容）。       另外，需要说一下的是，大多数的开发团队会规定开发以 master 为核心，所有的分支都在一定程度上围绕着 master 来开发。这个在事实上构成了 master 和其它分支在地位上的一个额外的区别。 branch 的通俗化理解 尽管在 Git 中，branch 只是一个指向 commit 的引用，但它有一个更通俗的理解：你还可以把一个 branch 理解为从初始 commit 到 branch 所指向的 commit 之间的所有 commits 的一个「串」。这种理解方式比较符合 branch 这个名字的本意（branch 的本意是树枝，可以延伸为事物的分支），也是大多数人对 branch 的理解。不过如果你选择这样理解 branch，需要注意下面两点：\n 所有的 branch 之间都是平等的，如下图，branch1 是 1 2 5 6 的串，而不要理解为 2 5 6 或者 5 6 。其实，起点在哪里并不是最重要的，重要的是你要知道，所有 branch 之间是平等的，master 除了上面我说的那几点之外，并不比其他 branch 高级。这个认知的理解对于 branch 的正确使用非常重要。        branch 包含了从初始 commit 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。如下图，master 在合并了 branch1 之后，从初始 commit 到 master 有了两条路径。这时，master 的串就包含了 1 2 3 4 7 和 1 2 5 6 7 这两条路径。而且，这两条路径是平等的，1 2 3 4 7 这条路径并不会因为它是「原生路径」而拥有任何的特别之处。       branch 的创建、切换和删除 创建 branch： 如果你想在某处创建 branch ，只需要输入一行 git branch 名称。例如“git branch feature1”\n     切换 branch： 新建的 branch 并不会自动切换，你的 HEAD 在这时依然是指向 master 的。你需要用 checkout 来主动切换到你的新 branch 去“git checkout feature1”。（也可以使用git checkout -b 名称 来把上面两步操作合并执行）\n     在切换到新的 branch 后，再次 commit 时 HEAD 就会带着新的 branch 移动了：      而这个时候，如果你再切换到 master 去 commit，就会真正地出现分叉了：      删除 branch： 删除 branch 的方法非常简单：git branch -d 名称。例如要删除 feature1 这个 branch：“git branch -d feature1”\n需要说明的有三点：\n HEAD 指向的 branch 不能删除。如果要删除 HEAD 指向的 branch，需要先用 checkout 把 HEAD 指向其他地方。 由于 Git 中的 branch 只是一个引用，所以删除 branch 的操作也只会删掉这个引用，并不会删除任何的 commit。（不过如果一个 commit 不在任何一个 branch 的「路径」上，或者换句话说，如果没有任何一个 branch 可以回溯到这条 commit（也许可以称为野生 commit？），那么在一定时间后，它会被 Git 的回收机制删除掉。） 出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败（因为怕你误删掉「未完成」的 branch 啊），这种情况如果你确认是要删除这个 branch （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 -d 改成 -D，小写换成大写，就能删除了。  引用的本质 所谓「引用」（reference），其实就是一个个的字符串。这个字符串可以是一个 commit 的 SHA-1 码（例：c08de9a4d8771144cd23986f9f76c4ed729e69b0），也可以是一个 branch（例：ref: refs/heads/feature3）。\nGit 中的 HEAD 和每一个 branch 以及其他的引用，都是以文本文件的形式存储在本地仓库 .git 目录中，而 Git 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。\n总结  HEAD 是指向当前 commit 的引用，它具有唯一性，每个仓库中只有一个 HEAD。在每次提交时它都会自动向前移动到最新的 commit 。 branch 是一类引用。HEAD 除了直接指向 commit，也可以通过指向某个 branch 来间接指向 commit。当 HEAD 指向一个 branch 时，commit 发生时，HEAD 会带着它所指向的 branch 一起移动。 master 是 Git 中的默认 branch，它和其它 branch 的区别在于：  新建的仓库中的第一个 commit 会被 master 自动指向； 在 git clone 时，会自动 checkout 出 master。   branch 的创建、切换和删除：  创建 branch 的方式是 git branch 名称 或 git checkout -b 名称（创建后自动切换）； 切换的方式是 git checkout 名称； 删除的方式是 git branch -d 名称。    进阶2：push的本质 在之前的内容里，我粗略地说过，push 指令做的事是把你的本地提交上传到中央仓库去，用本地的内容来覆盖掉远端的内容。这个说法其实是不够准确的，但 Git 的知识系统比较庞大，在你对 Git 了解比较少的时候，用「上传本地提交」来解释会比较好理解；而在你知道了 branch，并且明白了 branch 的具体含义以后，我就可以告诉你 push 到底是什么了。\npush：把 branch 上传到远端仓库 实质上，push 做的事是：把当前 branch 的位置（即它指向哪个 commit）上传到远端仓库，并把它的路径上的 commits 一并上传。\n例如，我现在的本地仓库有一个 master ，它超前了远程仓库两个提交；另外还有一个新建的 branch 叫 feature1，远程仓库还没有记载过它。这时我执行 git push，就会把 master 的最新位置更新到远端，并且把它的路径上的 5 6 两个 commits 上传：\n     而如果这时候我再切到 feature1 去后再执行一次 push，就会把 feature1 以及它的 commit 4 上传到远程仓库。 1 2  git checkout feature1 git push origin feature1   这里的 git push 和之前有点不同：多了 origin feature1 这两个参数。其中 origin 是远程仓库的别名，是你在 git clone 的时候 Git 自动帮你起的；feature1 是远程仓库中目标 branch 的名字。这两个参数合起来指定了你要 push 到的目标仓库和目标分支，意思是「我要 push 到 origin 这个仓库的 feature1 分支」。\n在 Git 中（2.0 及它之后的版本），默认情况下，你用不加参数的 git push 只能上传那些之前从远端 clone 下来或者 pull 下来的分支，而如果需要 push 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同），就像上面这样。你也可以通过 git config 指令来设置 push.default 的值来改变 push 的行为逻辑，例如可以设置为「所有分支都可以用 git push 来直接 push，目标自动指向 origin 仓库的同名分支」（对应的 push.default 值：current）。\n     细心的人可能会发现，在 feature1 被 push 时，远程仓库的 HEAD 并没有和本地仓库的 HEAD 一样指向 feature1。这是因为，push 的时候只会上传当前的 branch 的指向，并不会把本地的 HEAD 的指向也一起上传到远程仓库。事实上，远程仓库的 HEAD 是永远指向它的默认分支（即 master，如果不修改它的名称的话），并会随着默认分支的移动而移动的。 总结  push 是把当前的分支上传到远程仓库，并把这个 branch 的路径上的所有 commits 也一并上传。 push 的时候，如果当前分支是一个本地创建的分支，需要指定远程仓库名和分支名，用 git push origin branch_name 的格式，而不能只用 git push；或者可以通过 git config 修改 push.default 来改变 push 时的行为逻辑。 push 的时候上传当前分支，并不会上传 HEAD；远程仓库的 HEAD 是永远指向默认分支（即 master）的。  进阶3：merge commits 含义和用法 merge 的意思是「合并」，它做的事也是合并：指定一个 commit，把它合并到当前的 commit 来。具体来讲，merge 做的事是： 从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。merge命令为“git merge branch1”。如下图，Git 会把 5 和 6 这两个 commit 的内容一并应用到 4 上，然后生成一个新的提交，并跳转到提交信息填写的界面，merge 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 merge 就算完成了。\n     适用场景  合并分支： 当一个 branch 的开发已经完成，需要把内容合并回去时，用 merge 来进行合并。 pull 的内部操作： 之前说过，pull 的实际操作其实是把远端仓库的内容用 fetch 取下来之后，用 merge 来合并。  特殊情况 1：冲突 为什么产生冲突 merge 在做合并的时候，是有一定的自动合并能力的：如果一个分支改了 A 文件，另一个分支改了 B 文件，那么合并后就是既改 A 也改 B，这个动作会自动完成；如果两个分支都改了同一个文件，但一个改的是第 1 行，另一个改的是第 2 行，那么合并后就是第 1 行和第 2 行都改，也是自动完成。\n     但，如果两个分支修改了同一部分内容，merge 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。直白点说就是，你的两个分支改了相同的内容，Git 不知道应该以哪个为准。如果在 merge 的时候发生了这种情况，Git 就会把问题交给你来决定。具体地，它会告诉你 merge 失败，以及失败的原因。这时候需要做两件事：决掉冲突，手动commit 一下。 解决冲突 Git 虽然没有帮你完成自动 merge，但它对产生冲突的文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用符号标记出了它们的边界以及它们的出处。打开文件会发现文件内容标记为 HEAD 中的的内容和 feature1 中的内容。这两个内容 Git 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 HEAD 的修改，那么只要删除掉 feature1 的修改，再把 Git 添加的那三行 \u0026laquo;\u0026lt; = \u0026raquo;\u0026gt; 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。\n手动提交 解决完冲突以后，就可以进行第二步—— commit 了（需要先add）。提交后可以看到，被冲突中断的 merge，在手动 commit 的时候依然会自动填写提交信息。这是因为在发生冲突后，Git 仓库处于一个「merge 冲突待解决」的中间状态，在这种状态下 commit，Git 就会自动地帮你添加「这是一个 merge commit」的提交信息。\n放弃解决冲突，取消 merge？ 同理，由于现在 Git 仓库处于冲突待解决的中间状态，所以如果你最终决定放弃这次 merge，也需要执行一次 merge \u0026ndash;abort 来手动取消它：“git merge \u0026ndash;abort”。输入这行代码，你的 Git 仓库就会回到 merge 前的状态。\n特殊情况 2：HEAD 领先于目标 commit 如果 merge 时的目标 commit 和 HEAD 处的 commit 并不存在分叉，而是 HEAD 领先于目标 commit，那么 merge 就没必要再创建一个新的 commit 来进行合并操作，因为并没有什么需要合并的。在这种情况下， Git 什么也不会做，merge 是一个空操作。\n     特殊情况 3：HEAD 落后于 目标 commit——fast-forward 而另一种情况：如果 HEAD 和目标 commit 依然是不存在分叉，但 HEAD 不是领先于目标 commit，而是落后于目标 commit，那么 Git 会直接把 HEAD（以及它所指向的 branch，如果有的话）移动到目标 commit。这种操作有一个专有称谓，叫做 \u0026ldquo;fast-forward\u0026rdquo;（快速前移）。\n     一般情况下，创建新的 branch 都是会和原 branch （例如上图中的 master ）并行开发的，不然没必要开 branch ，直接在原 branch 上开发就好。但事实上，上图中的情形其实很常见，因为这其实是 pull 操作的一种经典情形：本地的 master 没有新提交，而远端仓库中有同事提交了新内容到 master。那么这时如果在本地执行一次 pull 操作，就会由于 HEAD 落后于目标 commit （也就是远端的 master）而造成 \"fast-forward\"。      简单解释一下上图中的 origin/master 和 origin/HEAD 是什么鬼：它们是对远端仓库的 master 和 HEAD 的本地镜像，在 git pull 的「两步走」中的第一步——git fetch 下载远端仓库内容时，这两个镜像引用得到了更新，也就是上面这个动图中的第一步：origin/master 和 origin/HEAD 移动到了最新的 commit。而 git pull 的第二步操作 merge 的目标 commit ，是远端仓库的 HEAD，也就是 origin/HEAD ，所以 git pull 的第二步的完整内容是“git merge origin/HEAD”。因此 HEAD 就会带着 master 一起，也指向图中绿色的最新 commit 了。 总结  merge 的含义：从两个 commit「分叉」的位置起，把目标 commit 的内容应用到当前 commit（HEAD 所指向的 commit），并生成一个新的 commit； merge 的适用场景：  单独开发的 branch 用完了以后，合并回原先的 branch； git pull 的内部自动操作。   merge 的三种特殊情况：  冲突：  原因：当前分支和目标分支修改了同一部分内容，Git 无法确定应该怎样合并； 应对方法：解决冲突后手动 commit。   HEAD 领先于目标 commit：Git 什么也不做，空操作； HEAD 落后于目标 commit：fast-forward。    进阶4：Feature Branching：最流行的工作流 简介 这种工作流的核心内容可以总结为两点：\n 任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； branch 写完后，合并到 master，然后删掉这个 branch。       这就是这种工作流最基本的模型。从上面的动图来看，这种工作流似乎没什么特别之处。但实质上，Feature Branching 这种工作流，为团队开发时两个关键的问题——代码分享和一人多任务——提供了解决方案。 代码分享 举例说明 假设你在一个叫做「掘金」的团队工作，现在你要开发一个叫做「掘金小册」的功能（呵呵），于是你创建了一个新的 branch 叫做 books，然后开始在 books 上进行开发工作。\n1  git checkout -b books”   在十几个 commits 过后，「掘金小册」的基本功能开发完毕，你就把代码 push 到中央仓库（例如 GitHub）去，然后告诉同事：「嘿，小册的基本功能写完了，分支名是 books，谁有空的话帮我 review 一下吧。」\n1  git push origin books”        然后你的同事小明正好有空，他就从中央仓库拉下来了你的代码开始读 1 2  git pull git chekcout books”。   如果同事没意见 读完以后，小明对你说，嗯我看完了，我觉得不错，可以合并到 master！于是你就把 books 合并到了 master 上去。\n1 2 3  git checkout master git pull # merge 之前 pull 一下，让 master 更新到和远程仓库同步 git merge books        紧接着，你把合并后的结果 push 到了中央仓库，并删掉了 books 这个 branch 1 2 3  git push git branch -d books git push origin -d books # 用 -d 参数把远程仓库的 branch 也删了        如果同事有意见 上面讲的是小明对你的代码没有意见，而假如他在你的代码里看到了问题，例如他跑来对你说：「嘿，你的代码缩进为什么用的是 TAB？快改成空格，不然砍死你哦。」这时，你就可以把你的缩进改成空格，然后做一个新的提交，再 push 上去，然后通知他：「我改完啦！」小明 pull 下来你的新提交看了看：「嗯，这下可以合并了。」\n于是你依照上面的那一套操作，把代码合并进 master，并 push 了上去，然后删掉了 books。瞧，代码在同事竖大拇指之前都不会正式发布到 master，挺方便的吧？\n一人多任务 除了代码分享的便捷，基于 Feature Branch 的工作流对于一人多任务的工作需求也提供了很好的支持。\n安安心心做事不被打扰，做完一件再做下一件自然是很美好的事，但现实往往不能这样。对于程序员来说，一种很常见的情况是，你正在认真写着代码，忽然同事过来跟你说：「内个……你这个功能先放一放吧，我们最新讨论出要做另一个更重要的功能，你来做一下吧。」\n其实，虽然这种情况确实有点烦，但如果你是在独立的 branch 上做事，切换任务是很简单的。你只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上「TODO」），然后回到 master 去创建一个新的 branch 就好了。\n1 2  git checkout master git checkout -b new_feature   如果有一天需要回来继续做这个 branch，你只要用 checkout 切回来，就可以继续了。\n总结  每个新功能都新建一个 branch 来写。 写完以后，把代码分享给同事看；写的过程中，也可以分享给同事讨论。 分支确定可以合并后，把分支合并到 master ，并删除分支。  进阶5：关于 add add . add 指令除了 git add 文件名 这种用法外，还可以使用 add . 来直接把工作目录下的所有改动全部放进暂存。这个用法没什么特别的好处，但就俩个字：方便，不过要注意不要误添加其他文件，不想添加到仓库的要使用.gitignore文件。\nadd 添加文件改动，而非文件名 假如你修改了文件 a.txt，然后把它 add 进了暂存区，然后你又往 a.txt 里写了几行东西。这时候你再 status 一下的话，会发现你的 a.txt 既在 \u0026ldquo;Changes to be commited\u0026rdquo; 的暂存区，又在 \u0026ldquo;Changes not staged for commit\u0026rdquo;。不用觉得奇怪，这是因为通过 add 添加进暂存区的不是文件名，而是具体的文件改动内容。你在 add 时的改动都被添加进了暂存区，但在 add 之后的新改动并不会自动被添加进暂存区。在这时如果你提交，那么你那些新的改动是不会被提交的。\n进阶6：看看我都改了什么 log -p 查看详细历史 -p 是 \u0026ndash;patch 的缩写，通过 -p 参数，你可以看到具体每个 commit 的改动细节，log -p 可以看到每一个 commit 的每一行改动，所以很适合用于代码 review。\nlog \u0026ndash;stat 查看简要统计 如果你只想大致看一下改动内容，但并不想深入每一行的细节（例如你想回顾一下自己是在哪个 commit 中修改了 games.txt 文件），那么可以把选项换成 \u0026ndash;stat。\nshow 查看具体的 commit 如果你想看某个具体的 commit 的改动内容，可以用 show。\n  看当前 commit：直接输入“git show”\n  看任意一个 commit：在 show 后面加上这个 commit 的引用（branch 或 HEAD 标记）或它的 SHA-1 码“git show 5e68b0d8”。\n  看指定 commit 中的指定文件：在 commit 的引用或 SHA-1 后输入文件名”git show 5e68b0d8 shopping\\ list.txt“\n  看未提交的内容：如果你想看未提交的内容，可以用 diff。\n  比对暂存区和上一条提交：使用 git diff \u0026ndash;staged 可以显示暂存区和上一条提交之间的不同。换句话说，这条指令可以让你看到「如果你立即输入 git commit，你将会提交什么」”git diff \u0026ndash;staged/\u0026ndash;cached“。\n  比对工作目录和暂存区:使用 git diff （不加选项参数）可以显示工作目录和暂存区之间的不同。换句话说，这条指令可以让你看到「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」\u0026ldquo;git diff\u0026rdquo;。\n  比对工作目录和上一条提交：使用 git diff HEAD 可以显示工作目录和上一条提交之间的不同，它是上面这二者的内容相加。换句话说，这条指令可以让你看到「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」不过需要注意，没有被 Git 记录在案的文件（即从来没有被 add 过 的文件，untracked files 并不会显示出来。）”git diff HEAD“（也可以换为其他commit）\n  总结  查看历史中的多个 commit： git log  查看详细改动： git log -p 查看大致改动：git log \u0026ndash;stat   查看具体某个 commit：show  要看最新 commit ，直接输入 git show ；要看指定 commit ，输入 git show commit的引用或SHA-1 如果还要指定文件，在 git show 的最后加上文件名   查看未提交的内容：diff  查看暂存区和上一条 commit 的区别：git diff \u0026ndash;staged（或 \u0026ndash;cached） 查看工作目录和暂存区的区别：git diff 不加选项参数 查看工作目录和上一条 commit 的区别：git diff HEAD    高级1：不喜欢 merge 的分叉？用 rebase 吧 rebase——在新位置重新提交 rebase ，又是一个中国人看不懂的词。这个词的意思，你如果查一下的话是“变基”。（哈？玩个 Git 就弯了？）其实这个翻译还是比较准确的。rebase 的意思是，给你的 commit 序列重新设置基础点（也就是父 commit）。展开来说就是，把你指定的 commit 以及它所在的 commit 串，以指定的目标 commit 为基础，依次重新提交一次。\n1 2  git checkout branch1 git rebase master        可以看出，通过 rebase，5 和 6 两条 commits 把基础点从 2 换成了 4 。通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 rebase 的含义。另外，在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit： 1 2  git checkout master git merge branch1        为什么要从 branch1 来 rebase，然后再切回 master 再 merge 一下这么麻烦，而不是直接在 master 上执行 rebase？从图中可以看出，rebase 后的 commit 虽然内容和 rebase 之前相同，但它们已经是不同的 commits 了。如果直接从 master 执行 rebase 的话，就会是下面这样：\n     这就导致 master 上之前的两个最新 commit 被剔除了。如果这两个 commit 之前已经在中央仓库存在，这就会导致没法 push 了：      所以，为了避免和远端仓库发生冲突，一般不要从 master 向其他 branch 执行 rebase 操作。而如果是 master 以外的 branch 之间的 rebase（比如 branch1 和 branch2 之间），就不必这么多费一步，直接 rebase 就好。（你想保留哪个分支就rebase到哪个分支） 总结 本节介绍的是 rebase 指令，它可以改变 commit 序列的基础点。它的使用方式很简单：\n1  git rebase 目标基础点   需要说明的是，rebase 是站在需要被 rebase 的 commit 上进行操作，这点和 merge 是不同的。\n高级2：刚刚提交的代码，发现写错了怎么办？ 刚提交了一个代码，发现有几个字写错了，怎么修复？当场再写一个修复这几个错别字的 commit？可以是可以，不过还有一个更加优雅和简单的解决方法：commit -—amend。\n\u0026ldquo;amend\u0026rdquo; 是「修正」的意思。在提交时，如果加上 \u0026ndash;amend 参数，Git 不会在当前 commit 上增加 commit，而是会把当前 commit 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 commit，用这个新的 commit 把当前 commit 替换掉。所以 commit \u0026ndash;amend 做的事就是它的字面意思：对最新一条 commit 进行修正。\n1 2  git add demo.txt git commit --amend   Git 会把你带到提交信息编辑界面。可以看到，提交信息默认是当前提交的提交信息。你可以修改或者保留它，然后保存退出。然后，你的最新 commit 就被更新了。\n     总结 这一节的内容只有一点：用 commit \u0026ndash;amend 可以修复当前提交的错误。使用方式：\n1  git commit --amend   需要注意的有一点：commit \u0026ndash;amend 并不是直接修改原 commit 的内容，而是生成一条新的 commit。\n高级3：写错的不是最新的提交，而是倒数第二个？ rebase -i：交互式 rebase 如果不是最新的 commit 写错，就不能用 commit \u0026ndash;amend 来修复了，而是要用 rebase。不过需要给 rebase 也加一个参数：-i。\nrebase -i 是 rebase \u0026ndash;interactive 的缩写形式，意为「交互式 rebase」。所谓「交互式 rebase」，就是在 rebase 的操作执行之前，你可以指定要 rebase 的 commit 链中的每一个 commit 是否需要进一步修改。那么你就可以利用这个特点，进行一次「原地 rebase」。\n例如你是在写错了 commit 之后，又提交了一次才发现之前写错了。\n开启交互式 rebase 过程 现在再用 commit \u0026ndash;amend 已经晚了，但可以用 rebase -i：\n1  git rebase -i HEAD^^   补充说明：在 Git 中，有两个「偏移符号」： ^ 和 ~。\n ^ 的用法：在 commit 的后面加一个或多个 ^ 号，可以把 commit 往回偏移，偏移的数量是 ^ 的数量。例如：master^ 表示 master 指向的 commit 之前的那个 commit； HEAD^^ 表示 HEAD 所指向的 commit 往前数两个 commit。 ~ 的用法：在 commit 的后面加上 ~ 号和一个数，可以把 commit 往回偏移，偏移的数量是 ~ 号后面的数。例如：HEAD~5 表示 HEAD 指向的 commit往前数 5 个 commit。  上面这行代码表示，把当前 commit （ HEAD 所指向的 commit） rebase 到 HEAD 之前 2 个的 commit 上：\n     如果没有 -i 参数的话，这种「原地 rebase」相当于空操作，会直接结束。而在加了 -i 后，就会跳到一个编辑界面。\n     编辑界面：选择 commit 和对应的操作 这个编辑界面的最顶部，列出了将要「被 rebase」的所有 commits，也就是倒数第二个 commit 「增加常见笑声集合」和最新的 commit「增加常见哭声集合」。需要注意，这个排列是正序的，旧的 commit 会排在上面，新的排在下面。\n这两行指示了两个信息： 需要处理哪些 commits； 怎么处理它们。\n你需要修改这两行的内容来指定你需要的操作。每个 commit 默认的操作都是 pick （从图中也可以看出），表示「直接应用这个 commit」。所以如果你现在直接退出编辑界面，那么结果仍然是空操作。但你的目标是修改倒数第二个 commit，也就是上面的那个「增加常见笑声集合」，所以你需要把它的操作指令从 pick 改成 edit 。 edit 的意思是「应用这个 commit，然后停下来等待继续修正」。把 pick 修改成 edit 后，就可以退出编辑界面了。\n修改写错的 commit 修改完成之后，和上节里的方法一样，用 commit \u0026ndash;amend 来把修正应用到当前最新的 commit：\n1 2  git add demo.txt git commit --amend   继续 rebase 过程 在修复完成之后，就可以用 rebase \u0026ndash;continue 来继续 rebase 过程，把后面的 commit 直接应用上去。然后，这次交互式 rebase 的过程就完美结束了，你的那个倒数第二个写错的 commit 就也被修正了.\n1  git rebase --continue        总结  使用方式是 git rebase -i 目标commit； 在编辑界面中指定需要操作的 commits 以及操作类型； 操作完成之后用 git rebase \u0026ndash;continue 来继续 rebase 过程。  高级4：比错还错，想直接丢弃刚写的提交？ 有的时候，刚写完的 commit 写得实在太烂，连自己的都看不下去，与其修改它还不如丢掉重写。这种情况，就可以用 reset 来丢弃最新的提交。\nreset \u0026ndash;hard 丢弃最新的提交 比如你刚写了一个 commit，写完回头看了看，你觉得「不行这得重新写」。那么你可以用 reset \u0026ndash;hard 来撤销这条 commit（HEAD 表示 HEAD^ 往回数一个位置的 commit）。HEAD^ 表示你要恢复到哪个 commit。因为你要撤销最新的一个 commit，所以你需要恢复到它的父 commit ，也就是 HEAD^。那么在这行之后，你的最新一条就被撤销了\n1  git reset --hard HEAD^        不过，就像图上显示的，你被撤销的那条提交并没有消失，只是你不再用到它了。如果你在撤销它之前记下了它的 SHA-1 码，那么你还可以通过 SHA-1 来找到他它。 总结 这一节的内容是撤销最新的提交，方式是通过 reset \u0026ndash;hard：\n1  git reset --hard 目标commit   高级5：想丢弃的也不是最新的提交？ 还没看懂。\n高级6：代码已经 push 上去了才发现写错？ 有的时候，代码 push 到了中央仓库，才发现有个 commit 写错了。这种问题的处理分两种情况：\n出错的内容在你自己的 branch 假如是某个你自己独立开发的 branch 出错了，不会影响到其他人，那没关系用前面几节讲的方法把写错的 commit 修改或者删除掉，然后再 push 上去就好了。不过由于你在本地对已有的 commit 做了修改，这时你再 push 就会失败，因为中央仓库包含本地没有的 commits。但这个和前面讲过的情况不同，这次的冲突不是因为同事 push 了新的提交，而是因为你刻意修改了一些内容，这个冲突是你预料到的，你本来就希望用本地的内容覆盖掉中央仓库的内容。那么这时就不要乖乖听话，按照提示去先 pull 一下再 push 了，而是要选择「强行」push（-f 是 \u0026ndash;force 的缩写，意为「忽略冲突，强制 push」）：\n1  git push origin branch1 -f   这样，在本地修改了错误的 commits，然后强制 push 上去，问题就解决了。\n出错的内容已经合并到 master 这就不能用上面那招了。同事的工作都在 master 上，你永远不知道你的一次强制 push 会不会洗掉同事刚发上去的新提交。所以除非你是人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 master 上强制 push。\n在这种时候，你只能退一步，选用另一种策略：增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。这种事做起来也不算麻烦，因为 Git 有一个对应的指令：revert。\n它的用法很简单，你希望撤销哪个 commit，就把它填在后面：\n1  git revert HEAD^   上面这行代码就会增加一条新的 commit，它的内容和倒数第二个 commit 是相反的，从而和倒数第二个 commit 相互抵消，达到撤销的效果。\n在 revert 完成之后，把新的 commit 再 push 上去，这个 commit 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 commit ：一个原始 commit ，一个对它的反转 commit。\n总结 这节的内容是讲当错误的 commit 已经被 push 上去时的解决方案。具体的方案有两类：\n 如果出错内容在私有 branch：在本地把内容修正后，强制 push (push -f）一次就可以解决； 如果出错内容在 master：不要强制 push，而要用 revert 把写错的 commit 撤销。  高级7：reset 的本质\u0026ndash;不止可以撤销提交 待补充\n高级8：checkout 的本质 介绍 在前面的 branch 的部分，我说到 checkout 可以用来切换 branch。不过实质上，checkout 并不止可以切换 branch。checkout 本质上的功能其实是：签出（ checkout ）指定的 commit。\ngit checkout branch名 的本质，其实是把 HEAD 指向指定的 branch，然后签出这个 branch 所对应的 commit 的工作目录。所以同样的，checkout 的目标也可以不是 branch，而直接指定某个 commit：\n1 2 3 4  git checkout HEAD^^ git checkout master~5 git checkout 78a4bc git checkout 78a4bc^   另外，如果你留心的话可能会发现，在 git status 的提示语中，Git 会告诉你可以用 checkout \u0026ndash; 文件名 的格式，通过「签出」的方式来撤销指定文件的修改。\n总结 这节的内容是对 checkout 的本质进行简述：checkout 的本质是签出指定的 commit，所以你不止可以切换 branch，也可以直接指定 commit 作为参数，来把 HEAD 移动到指定的 commit。\ncheckout 和 reset 的不同 checkout 和 reset 都可以切换 HEAD 的位置，它们除了有许多细节的差异外，最大的区别在于：reset 在移动 HEAD 时会带着它所指向的 branch 一起移动，而 checkout 不会。当你用 checkout 指向其他地方的时候，HEAD 和 它所指向的 branch 就自动脱离了。\n高级9：紧急情况：「立即给我打个包，现在马上！」 介绍 前面在讲 branch 的时候讲到，利用 branch 可以实现一人多任务的需求，从而可以轻松应对「嘿，这个先别做了，给你个新活」的情况。但有时，尤其是在互联网公司，你可能会遇到比这更紧急的情况：你正对着电脑发呆，忽然见到一个同事屁股着着火就跑来找你了：「快快快，立即给我打个包，现在马上，拜托拜托！」\n这种情况和「这个 branch 先放放吧」不同，你没时间、也没必要当场慌慌张张把文件的所有改动做个临时的 commit 然后去救同事的火，救完火再重新把 commit 撤销回来。这时候你只要先把所有文件一股脑扔在一边就可以去给同事打包了，打完包再把刚才扔到一边的文件重新取过来就好。\n这一「扔」一「取」，用的是 Git 的 stash 指令。\nstash：临时存放工作目录的改动 \u0026ldquo;stash\u0026rdquo; 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。在 Git 中，stash 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。具体说来，stash 的用法很简单。当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么你可以”git stash“。\n就这么简单，你的工作目录的改动就被清空了，所有改动都被存了起来。然后你就可以从你当前的工作分支切到 master 去给你的同事打包了打完包，切回你的分支，然后”git stash pop“。你之前存储的东西就都回来了。很方便吧？\n注意：没有被 track 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 `-u` 参数，它是 `\u0026ndash;include-untracked` 的简写。就像这样”git stash -u\n“。\n高级10：branch 删过了才想起来有用？ branch 用完就删是好习惯，但有的时候，不小心手残删了一个还有用的 branch ，或者把一个 branch 删掉了才想起来它还有用，怎么办？\nreflog ：引用的 log reflog 是 \u0026ldquo;reference log\u0026rdquo; 的缩写，使用它可以查看 Git 仓库中的引用的移动记录。如果不指定引用，它会显示 HEAD 的移动记录。假如你误删了 branch1 这个 branch，那么你可以查看一下 HEAD 的移动历史”git reflog“。从移动历史中可以看出 HEAD 的最后一次移动行为是「从 branch1 移动到 master」。而在这之后，branch1 就被删除了。所以它之前的那个 commit 就是 branch1 被删除之前的位置了，也就是第二行的 c08de9a。所以现在就可以切换回 c08de9a，然后重新创建 branch1。\n1 2  git checkout c08de9a git checkout -b branch1   这样，你刚删除的 branch1 就找回来了。\n注意：不再被引用直接或间接指向的 commits 会在一定时间后被 Git 回收，所以使用 reflog 来找回删除的 branch 的操作一定要及时，不然有可能会由于 commit 被回收而再也找不回来。\n查看其他引用的 reflog reflog 默认查看 HEAD 的移动历史，除此之外，也可以手动加上名称来查看其他引用的移动历史，例如某个 branch ”git reflog master“。\n额外说点：.gitignore——排除不想被管理的文件和目录 在 Git 中有一个特殊的文本文件：.gitignore。这个文本文件记录了所有你希望被 Git 忽略的目录和文件。\n如果你是在 GitHub 上创建仓库，你可以在创建仓库的界面中就通过选项来让 GitHub 帮你创建好一个符合项目类型的 .gitignore 文件，你就不用再自己麻烦去写一大堆的配置了。不过如果你不是在 GitHub 上创建的项目，或者你对 GitHub 帮你创建的 .gitignore 文件有一些额外的补充，那么你可以自己来编辑这个文件。\n.gitignore大概长这样（#是注释内容，*是通配符）：\n# ignore file type1 *.o *.elf tmp.s # ignore file type2 bin/ gen/ out/file1/ 总结 写给读者 Git 内容非常多，这本小册我已经尽量克制，可是还是写了二十多节出来。尽管这样，有些很有用的内容我依然没有写出来。因为我写这本小册的目的是解决大部分人「学不会 Git」和「用了很久却总用不好 Git」这两个问题，所以我在这本小册里重点讲的也是 Git 的学习和使用中那些既重要又困难的关键点。\n如果你在整个阅读过程中是边读边练的，相信读到这里，你对 Git 已经有一个较为全面和深刻的认识了。接下来你只要在平时使用 Git 的过程中多留心一些，找机会把这本小册中的内容应用在实战，很快就可以成为众人眼中的「Git 高手」了。当然，到时候你也许也会发现，其实大家眼中的「Git 高手」远没有那么神秘，并不一定比别人懂很多，只是更加了解 Git 的工作原理和一些关键概念罢了。\n几个「不难但却很有用」的 Git 技能点 除了这本小册里讲到的那些「关键点」，还有些 Git 的相关知识虽然也比较有用，但属于稍微研究一下就可以学会的内容，我就不讲了，只在这里做一个简单的列举，你在平时使用 Git 的时候记得抽空学习一下就好。\n tag：不可移动的 branch。tag 是一个和 branch 非常相似的概念，它和 branch 最大的区别是：tag 不能移动。所以在很多团队中，tag 被用来在关键版本处打标记用。 cherry-pick：把选中的 commits 一个个合并进来。cherry-pick 是一种特殊的合并操作，使用它可以点选一批 commits，按序合并。 git config： Git 的设置。git config 可以对 Git 做出基础设置，例如用户名、用户邮箱，以及界面的展示形式。内容虽然多，但都不难，整体看一遍，把 Git 设置成你最舒服的样子，从此就再也不用管它了。属于「一次付出，终身受用」的高性价比内容。 Git Flow：复杂又高效的工作流。除了前面讲到的 \u0026ldquo;Feature Branching\u0026rdquo;，还有一个也很流行的工作流：Git Flow。Git Flow 的机制非常完善，很适合大型团队的代码管理。不过由于它的概念比较复杂（虽然难度并不高），所以并不适合新手直接学习，而更适合在不断的自我研究中逐渐熟悉，或者在团队合作中慢慢掌握。基于这个原因，我最终也没有在这本小册里讲 Git Flow，但我推荐你自己在有空的时候了解一下它。  更多内容 更多内容可到Git官网查看详细文档。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":0,"section":"docs","tags":["Git"],"title":"Git原理详解及实用指南","uri":"https://www.wenhui.space/docs/about_linux/use_notes/git_introduction_and_userguide/"},{"content":"本文 主要介绍将网页内容保存到本地的几个方法。\n   版本 说明     0.1 初版发布    网页另存为 浏览器对网页都有一个另存为的功能，右键选择另存为或快捷键Ctrl-s。网页另存为是将整个网页以静态网页形式下载到本地。下载的文件包含个文件夹和html文件，文件夹内包含js（JavaScript）文件，css（Cascading Style Sheets）文件，以及一些图标文件等，总之文件夹内的内容是对网页显示进行渲染，而html文件是网页主要内容和框架文件，会调用文件夹内一些文件。以上是非专业的解释，总之有文件夹内的内容网页就相当于是彩色的，没有就变成黑白的了，而且还会丢失一些图标显示。对于使用者将文件夹和html文件通通保留，使用浏览器打开html文件即可。\n使用网页另存为的方式保存网页内容，是可以高度还原的，换句话说只不过将服务器的网页内容下载到了本地。\n网页打印 谷歌浏览器（可能还有别的浏览器）提供了网页打印功能。打开网页，右键选择打印或快捷键Ctrl-p，其中可以直接使用打印机进行打印，还可以使用另存为pdf。另存为pdf就很实用了，相当于将网页内容进行扫描保存在pdf文件，另外还可以自定义页数。除此之外，还可以选择保存到谷歌云端，保存到云端就相当于自己备份了内容，即便网页源内容删除了，自己还可以通过谷歌云端查看；类似的功能firefox可以保存到pocket，不过这个pocket是本地和云端同步的，也就是说除了备份了内容你还可以离线查看。\n网页截图 firefox提供了网页截图功能，不同于电脑自带的截图工具，它可以对整个网页进行截图。相当于手机中的长截图功能。截图的好处就是，如果你想将网页内容分享给其他人，但是又想隐藏部分内容，那就可以通过网页截图，再使用图片编辑工具进行截图，既能截去部分内容，还可以保持图片内容基本的清晰度（相对于缩小页面在通过自带截图工具截图）。\n另一种无耻做法 浏览的网页内容，往往我们只是对部分内容感兴趣，我们可以将部分内容保存截图，当然这不是一个好的方法，最好的方法是将需要的内容提取出来，保存到自己的文档中。一般会有以下几种情况：\n 有的网页是支持文字复制的，那就直接复制即可，这里就有个小技巧了，如果不想复制字体格式颜色等等，可以右键选择只复制文本，如果还行不通的话，可以临时打开一个txt文件，将复制内容粘贴到txt文档，再次复制粘贴到文档中。 有的网页出于各种原因（主要是知识产权和会员权限），不支持复制功能，这时候就需要其他方法了，可以使用图片文字识别工具，截图后上传到该工具，识别为文字。这里推荐使用迅捷工具，可以选择txt，直接复制粘贴识别的文字，也可以选择doc或docx，只不过识别的文字需要下载文件。其他功能请自行探索。 如果是视频呢，怕是我们只能依赖图片识别工具了。 迅捷图片文字识别工具网页版 迅捷工具具有一系列功能： 文档转换如pdf转doc，文档处理如分割pdf，文档翻译，图片文字识别，以及语音识别。 友情提示： 如果采用他人知识产物，请注明出处，这是对作者的尊重。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":1,"section":"docs","tags":null,"title":"如何保存网页内容到本地","uri":"https://www.wenhui.space/docs/about_windows/save_web_content_to_local/"},{"content":"本文 UVM学习系列主要介绍UVM的基础知识，UVM是目前芯片验证界最主流的验证方法学。此为第二篇，主要介绍核心基类、phase机制、config机制和消息管理。\n   版本 说明     0.1 初版发布    参考  《UVM实战》，也就是所谓的白皮书。 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      核心基类 uvm_obiect  UVM世界中的类最初都是从一个uvm_void根类(root class) 继  承来的，而实际上这个类并没有成员变量和方法。\n uvm_void只是一个虚类(virtual class)，还在等待将来继承于它的子类去开垦。在继承于uvm_void的子类中， 有两个类， 一个为uvm_object类， 另外一个为uvm_port_base类。 在UVM世界的类库地图中除过事务接口(transaction interface)类继承于uvm_port_base， 其它所有的类都是从uvm_object类一步步继承而来的。 从uvm_object提供的方法和相关的宏操作来看， 它的核心方法主要提供与数据操作的相关服务：  Copy Clone Compare Print Pack/Unpack   在SV模块的学习中，我们懂得了什么是句柄拷贝和对象拷贝。因此， 无论是copy或者clone， 都需要确保在操作的过程中， 需要有source object和target object。  域的自动化(field automation)  从UVM通过域的自动化， 使得用户在注册UVM类的同时也可以声明今后会参与到对象拷贝、克隆、打印等操作的成员变量。 域的自动化解放了verifier的双手， 这使得在使用uvm_object提供的一些预定义方法时，非常便捷，而无需再实现自定义方法。 在了解了域的自动化常用的宏之后，用户需要考虑哪些成员变量在注册UVM类(`uvm_{component/object}_utils) 的时候，也一并将它们归置到对应的域列表中，以便为稍后的域方法提供可以自动实现的基础。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name = \u0026#34;box\u0026#34;; //域自动化声明变量  //备注：红宝书P275，域的自动化宏列表  `uvm_object_utils_begin(box) `uvm_field_int(volume, UVM_ALL_ON) `uvm_field_enum(color_t, color, UVM_ALL_ON) `uvm_field_string(name, UVM_ALL_ON) `uvm_object_utils_end ... endclass box b1, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;); b1.volume = 80; b1.color = BLACK; b2 = new(); b2.copy(b1); //把b1里的成员变量数据拷贝到b2  b2.name = \u0026#34;box2\u0026#34;; end    从这个域的自动化宏的例子来看，在注册box的同时， 也声明了将来会参与到uvm_object数据操作的成员变量。 凡是声明了的成员变量，都将在数据操作时自动参与进来。 如果有一些数据没有通过域的自动化来声明的话，它们也将不会自动参与到数据的拷贝、打印等操作，除非用户自己去定义这些数据操作方法。 所以对于新手，请养成习惯，即：  在注册component或者object的时候， 使用`uvm_{component/object}_utils_begin和`uvm_{component/object}_utils_end来配对包裹接下来的域的自动化。 域的自动化为了尽量识别多数的变量，以及做相应的处理，对应的宏的种类非常多，但是也不需要额外的担心，你可以使用红宝书来查各种域的自动化时所对应的宏。 域的自动化的相关宏都是`uvm_field_{int/object/string/enum/event/real\u0026hellip;}{ARG，FLAG}。ARG表示成员变量， FLAG表示用来标记的数据操作。 FLAG的具体表示可以参照红宝书的表10.3， 初学者只需要默认采取UVM_ALL_ON或者UVM_DEFAULT， 即将所有的数据操作方法都打开。 常见的数据操作方法， 包括之前所介绍的copy， compare， print， record， pack和其它。我们将在接下来的部分逐一介绍这些数据操作方法。    拷贝（copy）  在UVM的数据操作中， 需要对copy和clone加以区分。前者默认已经创建好了对象，只需要对数据进行拷贝；后者则会自动创建对象并对source object进行数据拷贝， 再返回target object句柄。 无论是copy或者clone， 都需要对数据进行复制。 但是如果数据成员包括句柄，那么拷贝的时候，是否只拷贝该成员句柄本身，还是也额外创建新的对象，拷贝该句柄指向的对象? 从示例可以看到， 在进行copy时， 默认进行的是深拷贝(deep copy) ， 即会执行copy() 和do_copy() 。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  class ball extends uvm_object; int diameter = 10; color_t color = RED; `uvm_object_utils_begin(ball) `uvm_field_int(diameter, UVM_DEFAULT) `uvm_field_enum(color_t, color, UVM_NOCOPY)//不参与copy  `uvm_object_utils_end ... function void do_copy(uvm_object rhs);//copy的回调函数  ball b; $cast(b, rhs) ; $display(\u0026#34;ball::do_copy entered..\u0026#34;); if(b.diameter \u0026lt;= 20) begin diameter = 20; end endfunction endclass class box extends uvm_object; int volume = 120; color_t color = WHITE; string name=\u0026#34;box\u0026#34;; ball b; `uvm_object_utils_begin(box) `uvm_field_int(volume, UV_ALL_ON) `uvm_field_enum(color_t, color, UVM_ALL_ON) `uvm_field_string(name, UVM_ALL_ON) `uvm_field_object(b, UVM_ALL_ON) `uvm_object_utils_end ... endclass box bl, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b1.volume = 80; b1.color = BLACK; bl.b.color = WHITE; b2 = new() ; b2.copy(b1) ; b2.name = \u0026#34;box2\u0026#34;; $display(\u0026#34;%s\u0026#34;, b1.sprint() ) ; $display(\u0026#34;%s\u0026#34;, b2.sprint() ) ; end //输出结果： //ball::do_copy entered.. //------------------------------- //Nama Type size Value //------------------------------- //box1 box - @336 // volume integral 32 \u0026#39;h50 // color color_t 32 BLACK // name string 4 box1 // b ball - @337 // diameter integral 32 \u0026#39;ha // color color_t 32 WHITE // //box2 box - @338 // volume integral 32 \u0026#39;h50 // color color_t 32 WHITE // name string 4 box2 // b ball - @340 // diameter integral 32 \u0026#39;h14 // color color_t 32 RED    新添加了一个类ball， 并且在box中例化了一个ball的对象。在拷贝过程中， box的其它成员都正常拷贝了， 但对于box::b的拷贝则通过了ball的深拷贝方式进行。 即先执行自动拷贝copy() ， 来拷贝允许拷贝的域， 由于ball::color不允许拷贝， 所以只拷贝了ball::diameter。 接下来， 再执行do_copy() 函数， 这个函数是需要用户定义的回调函数(callback function) ， 即在copy() 执行完后会执行do_copy() 。 如果用户没有定义该函数，那么则不会执行额外的数据操作。从ball::do_copy() 函数可以看到， 如果被拷贝对象的diameter小于20， 那么则将自身的diameter设置为20。因此， 最后对象b2.b的成员与b1.b的成员数值不同。  比较（compare） 1  function bit compare (uvm_object rhs, uvm_comparer comparer=null);    默认情况下，如果不对比较的情况作出额外配置，用户可以在调用compare() 方法时， 省略第二项参数， 即采用默认的比较配置。 比较方法经常会在两个数据类中进行。例如从generator产生的一个transaction(数据类) ， 和在设计输出上捕捉的transaction(数据类) ， 如果它们为同一种类型， 除了可以自定义数据比较之外， 也可以直接使用uvm_object::compare() 函数来实现数据比较和消息打印。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name=\u0026#34;box\u0026#34;; `uvm_object_utils_begin(box) ... `uvm_object_utils_end ... endclass //============================ box b1, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b1.volume = 80; b1.color = BLACK; b2 = new(\u0026#34;box2\u0026#34;) ; b2.volume = 90; if(!b2.compare(b1)) begin `uvm_info(\u0026#34;COMPARE\u0026#34;, \u0026#34;b2 compared with b1 failure\u0026#34;, UVM LOW) end else begin `uvm_info(\u0026#34;COMPARE\u0026#34;, \u0026#34;b2 compared with b1 success\u0026#34;, UVM LOW) end end //========================== //输出结果： //UVM_INFO @O: reporter[MISCMP] Miscompare for box2.volume:lhs=\u0026#39;h5a:rhs=\u0026#39;h50 //UVM_INFO @0: reporter[MISCMP| Miscompare(s) for object box1@336 vs.box2@337 //UVM_INFO @O: reporter[COMPARE] b2 comapred with bl failure    在上面的两个对象比较中，会将每一个自动化的域进行比较，所以在执行compare() 函数时， 内置的比较方法也会将比较错误输出。 从结果来看， 比较发生了错误， 返回0值。那么， b1.color和b2.color虽然不相同， 为什么没有比较错误的信息呢? 原因在于，默认的比较器，即uvm_package::uvm_default_comparer最大输出的错误比较信息是1，也就是说当比较错误发生时，不会再进行后续的比较。 实际上， 在uvm_object使用到的方法compare() 、print() 和pack() ， 如果没有指定数据操作配置对象作为参数时， 会使用在uvm_pkg中例化的全局数据操作配置成员。  全局对象  在uvm_pkg中例化了不少全局对象，而在本节中我们会使用到的全局配置对象包括有uvm_default_comparer，uvm_default_printer和uvm_default_packer。 如果用户不想使用默认的比较配置，而是想自己对比较进行设定，可以考虑创建一个uvm_comparer对象， 或者修改全局的uvm_comparer对象。  打印（print）  打印方法是核心基类提供的另外一种便于开发和调试的功能。 通过field automation， 使得声明之后的各个成员域会在调用uvm_object::print() 函数时自动打印出来。 相比于在仿真中设置断点，逐步调试，打印是另外一种调试方式。它的好处在于可以让仿真继续进行，会在最终回顾执行过程中，从全局理解执行的轨迹和逻辑。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name = \u0026#34;box\u0026#34;; `uvm_object_utils_begin(box) ... `uvm_object_utils_end endclass //================================== box b1; uvm_table_printer local_printer; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; local_printer = new() ; $display(\u0026#34;default table printer format\u0026#34;) ; b1.print() ; $display(\u0026#34;default line printer format\u0026#34;) ; uvm_default_printer = uvm_default_line_printer; b1.print(); $display(\u0026#34;default tree printer format\u0026#34;) ; uvm_default_printer = uvm_default_tree_printer; b1.print() ; $display(\u0026#34;customized printer format\u0026#34;) ; local_printer.knobs.full_name = 1; b1.print(local_printer) ; end //==================================== //输出结果（只是显示格式不同而已）： //default table printer format //Name Type size Value // box1 box - @336 // volume integral 32 \u0026#39;h78 // color color_t 32 WHITE // name string 4 box1 // //default line printer format //box1: (box@336) {volume：\u0026#39;h78 color; WHITE name: box1} // //default tree printer format //box1: (box@336) { // volume: \u0026#39;h78 // color: WHITE // name: box1 //} // //customized printer format //Name Type size Value //box1 box - @336 // box1.volume integral 32 \u0026#39;h78 // box1.color color_t 32 WHITE // box1.name string 4 box1    只要在field automation中声明过的域， 在稍后的print() 函数执行时，都将打印出它们的类型、大小和数值。如果用户不对打印的格式做出修改， 那么在打印时， UVM会按照uvm_default_printer规定的格式来打印。 uvm_pkg所包含的用于打印的全局对象， 它们分别是：  uvm_default_tree_printer：可以将对象按照树状结构打印。 uvm_default_line_printer：可以将对象数据打印到一行上面。 uvm_default_table_printer：可以将对象按照表格的方式打印。 uvm_default_printer：UVM环境默认的打印设置，该句柄默认指向了 uvm_default_table_printer。   通过给全局打印机uvm_default_printer赋予不同的打印机句柄， 就可以在调用任何uvm_object的print() 方法时， 得到不同的打印格式。 如果用户需要自定义一些打印属性，可以自己创建一个打印机，进而通过修改其属性uvm_printer：：knobs中的成员， 来定制打印格式。  打包和解包（pack \u0026amp; unpack） 1 2  function int pack(ref bit bitstream[], input uvm_packer packer=null); function int unpack(ref bit bitstream[], input uvm_packer packer=null);    pack是为了将自动化声明后的域(标量) 打包为比特流(bit stream) 。即将各个散乱的数据， 整理到bit数据串中， 类似于struct packed的整理方式， 但又能充分利用数据空间， 也更容易与硬件之间进行数据传递和比对。 unpack与pack相反， 即将串行数据解包变为原有的各自域。该操作适用于从硬件一侧接收串行数据，进行校验之后，还原为软件一侧对象中各自对应的成员变量。 pack与unpack在通常的UVM环境中使用较少， 但是当与外界环境， 例如System C发生大规模数据传递， 该方法是首选， 因为可以通过简单数据流实现精确的数据传输， 另外， 在UVM与FPGA、emulator之间进行数据交换时， 该方法也由于简便得到了青睐。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class box extends uvm_object; int volume = 120; int height = 20; color_t color = WHITE; `uvm_object_utils_begin(box) ... `uvm_object_utils_end endclass box b1, b2; bit packed_bits[]; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b2 = new(\u0026#34;box2\u0026#34;) ; b1.volume = 100; b1.height = 40; b1.color = RED; b1.print(); b1.pack(packed_bits); $display(\u0026#34;packed bit stream size is %d \\n\u0026#34;, packed_bits.size()) ; b2.unpack(packed_bits) ; b2.print() ; end //================================ //输出结果： //Name Type Size Value //box1 box - @336 // volume integral 32 \u0026#39;h64 // height integral 32 \u0026#39;h28 // color color_t 32 RED //packed bits stream size is 96 //box2 box - @337 // volume integral 32 \u0026#39;h64 // height integral 32 \u0026#39;h28 // color color_t 32 RED   phase机制 概述  SV的验证环境构建中，我们可以发现，传统的硬件设计模型在仿真开始前，已经完成例化和连接了；而SV的软件部分对象例化则需要在仿真开始后执行。 虽然对象例化通过调用构建函数new() 来实现， 但是单单通过new() 函数无法解决一个重要问题， 那就是验证环境在实现层次化时，如何保证例化的先后关系，以及各个组件在例化后的连接。 此外如果需要实现高级功能，例如在顶层到底层的配置时，SV也无法在底层组件例化之前完成对底层的配置逻辑。 因此UVM在验证环境构建时， 引入了phase机制， 通过该机制我们可以很清晰地将UVM仿真阶段层次化。 这里的层次化， 不单单是各个phase的先后执行顺序， 而且处于同一phase中的层次化组件之间的phase也有先后关系。 如果暂时抛开phase的机制剖析， 对于UVM组件的开发者而言，他们主要关心各个phase执行的先后顺序。 在定义了各个phase虚方法后， UVM环境会按照phase的顺序分别调用这些方法。     phase 函数/任务 执行顺序 功能 典型应用     build 函数 自顶向下 创建和配置测试平台的结构 创建组件和寄存器模型，设置或者获取设置   connect 函数 自底向上 建立组件之间的连接 连接TLM的接口，连接寄存器模型和adapter   end_of_elaboration 函数 自底向上 测试环境的微调 显示环境结构、打开文件，为组件添加额外配置   start_of_simulation 函数 自底向上 准备测试环境的仿真 显示环境结构、设置断点，设置初始运行时的配置值   run 任务 自底向上 激励设计 提供激励、采集数据、数据比较   extract 函数 自底向上 从测试环境中收集数据 从测试平台提取剩余数据，从设计观察最终状态   check 函数 自底向上 检查任何不期望的行为 检查不期望的数据   report 函数 自底向上 报告测试数据 报告测试结果，并将其写入文件中   final 函数 自顶向下 完成测试活动、结束仿真 关闭文件，结束联合仿真引擎    执行机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  class subcomp extends uvm_component; `uvm_component_utils(subcomp) function new(string name, uvm_component parent) ; super.new(name, parent); endfunction function void build_phase(uvm_phase phase); `uvm_info(\u0026#34;build_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void connect_phase(uvm_phase phanse); `uvm_info(\u0026#34;connect_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void end_of_elaboration_phase(uvm_phase phase); `uvm_info(\u0026#34;end_of_elaboration_phase\u0026#34;, UVM_LOW) endfunction function void start_of_simulation_phase(uvm_phase phase); `uvm_info(\u0026#34;start_of_simulation_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction task run_phase(uvm_phase phase); `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endtask function void extract_phase(uvm_phase phase); `uvm_info(\u0026#34;extract_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void check_phase(uvm_phase phase); `uvm_info(\u0026#34;check_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void report_phase(uvm_phase phase); `uvm_info(\u0026#34;report_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void final_phase(uvm_phase phase); `uvm_info(\u0026#34;final_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction endclass class topcomp extends subcomp; subcomp cl, c2; ... function void build_phase(uvm_phase phase); uvm_info(\u0026#34;build_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) c1 = subcomp::type_id::create(\u0026#34;c1\u0026#34;, this); c2 = subcomp::type_id::create(\u0026#34;c2\u0026#34;, this); endfunction endclass class test1 extends uvm_test; topcomp t1; ... function void build_phase(uvm_phase phase) ; t1 = topcomp::type_id::create(\u0026#34;t1\u0026#34;,this); endfunction endclass    输出结果   UVM_INFO @0: uvm_test_top.t1 [build_phase] UVM_INFo @0: uvm_test_top.t1.c1 [build_phase】 UVM_INFO @0: uvm_test_top.t1.c2 [build_phase] UVM_INFO @0: uvm_test_top.t1.cl [connectJphase] UvM_INFO @0: uvm_test_top.t1.c2 [connect_phase] UVM_INFO @0: uvm_test_top.t1 [connect_phase] UVM_INFO @0: uvm_test_top.t1.c1 [end_of_elaboration_phase] UVM_INFO @0: uvm_test_top.t1.c2 [end_of_elaboration_phase] UVM_INFO @0: uvm_test_top.t1 [end_of_elaboration_phase] UVM_INFO @O: uvm_test_top.t1.c1 [start_of_simulation_phase] UVM_INFO @0: uvm_test_top.t1.c2 [start_of_simulation_phase] UVM_INFO @0: uvm_test_top.t1. [start_of_simulation_phase] UVM_INFO @O: uvm_test_top.t1.c1 [run_phase] UVM_INFO @0: uvm_test_top.t1.c2 [run_phase] UVM_INFO @0: uvm_test_top.t1. [run_phase] UVM_INFO @O: uvm_test_top.t1.c1 [extract_phase] UVM_INFO @0: uvm_test_top.t1.c2 [extract_phase] UVM_INFO @0: uvm_test_top.t1. [extract_phase] UVM_INFO @O: uvm_test_top.t1.c1 [check_phase] UVM_INFO @0: uvm_test_top.t1.c2 [check_phase] UVM_INFO @0: uvm_test_top.t1. [check_phase] UVM_INFO @O: uvm_test_top.t1.c1 [report_phase] UVM_INFO @0: uvm_test_top.t1.c2 [report_phase] UVM_INFO @0: uvm_test_top.t1. [report_phase] UVM_INFO @O: uvm_test_top.t1.c1 [final_phase] UVM_INFO @0: uvm_test_top.t1.c2 [final_phase] UVM_INFO @0: uvm_test_top.t1. [final_phase] 9个主要phase  上面的九个phase对于一个测试环境的生命周期而言， 是有固定的先后执行顺序的； 同时对于同一个phase中的组件，执行也会按照层次的顺序或者自顶向下、或者自底向上来执行。 对于build phase， 执行顺序按照自顶向下， 这符合验证结构建设的逻辑。因为只有先例化高层组件，才会创建空间来容纳低层组件。 只有uvm_component及其继承于uvm_component的子类， 才会按照phase机制将上面的九个phase先后执行完毕。 常用的phase包括build、connect、run和report， 它们分别完成了组件的建立、连接、运行和报告。这些phase在uvm_component中通过_phase的后缀完成了虚方法的定义，比如build_phase() 可以定义一些组件例化和配置的任务。 在所有phase中， 只有run_phase方法是一个可以耗时的任务，这意味着该方法可以完成一些等待、激励、采样的任务。对于其它phase对应的方法都是函数， 必须立即返回(0耗时) 在run_phase中， 用户如果要完成测试， 通常需要组织下面的激励序列：  上电 复位 寄存器配置 发送主要测试内容 等待DUT完成测试    12个分之phase  在用户发送激励的一种简单方式是， 在run_phase中完成上面所有的激励；另外一种方式是，如果用户可以将上面几种典型序列划分到不同区间，让对应的激励按区间顺序发送的话，可以让测试更有层次。因此run_phase又可以分为下面12个phase：  pre_reset_phase reset_phase post_reset_phase pre_configure_phase configure_phase post_configure_phase pre_main_phase main_phase post_main_phase pre_shutdown_phase shutdown_phase post_shutdown_phase   实际上run_phase任务和上面细分的12个phase是并行的，即在start_of_simulation_phase任务执行以后， run_phase和reset_phase开始执行，而在shutdown_phase执行完成之后，需要等待run_phase执行完才可以进入extract_phase。       UVM编译和运行顺序      UVM仿真开始  要在仿真开始时建立验证环境，用户可以考虑选择下面几种方式：  可以通过全局函数(由uvm_pkg提供) run_test() 来选择性地指定要运行哪一个uvm_test。这里的test类均继承于uvm_test。这样的话， 指定的test类将被例化并指定为顶层的组件。一般而言， run_test() 函数可以在合适module/program中的initial进程块中调用。 如果没有任何参数传递给run_test() ， 那么用户可以在仿真时通过传递参数+UVM_TEST NAME=\u0026lt;test_name\u0026gt;， 来指定仿真时调用的uvm_test。当然， 即便run_test() 函数在调用时已经有test名称传递， 在仿真时+UVM_TEST NAME=\u0026lt;test_name\u0026gt;也可以从顶层覆盖已指定的test。这种方式使得仿真不需要通过再次修改run_test(调用的test名称和重复编译， 就可以灵活选定test。   无论上面哪一种方式， 都必须在顶层调用全局函数run_test() ， 用户可以考虑不传递test名称作为参数， 而在仿真时通过传递参数+UVM_TEST NAME=\u0026lt;test_name\u0026gt;来选择test。 全局函数run_test() 的重要性， 正是从uvm_root创建了一个UVM世界。  UVM世界的”诞生“ 1 2 3 4 5 6 7  task run_test(string test_name=\u0026#34;\u0026#34;); uvm_root top; uvm_coreservice_t cs; cs=uvm_coreservice_t::get(); top=cs.get_root(); top.run_test(test_name); endtask    UVM顶层类uvm_root。该类也继承于uvm_component，它也是UVM环境结构中的一  员，而它可以作为顶层结构类。\n 它提供了一些像run_test() 的这种方法， 来充当了UVM世界中的核心角色。 在uvm_pkg中， 有且只有一个顶层类uvm_root所例化的对象， 即uvm_top。 uvm_top（也就是uvm_root）承担的核心职责包括：  作为隐形的UVM世界顶层， 任何其它的组件实例都在它之下， 通过创建组件时指定parent来构成层次。 如果parent设定为null， 那么它将作为uvm_top的子组件。 phase控制。控制所有组件的phase顺序。 索引功能。通过层次名称来索引组件实例。 报告配置。通过uvm_top来全局配置报告的繁简度(verbosity) 。 全局报告设备。由于可以全局访问到uvm_top实例， 因此UVM报告设备在组件内部和组件外部(例如module和sequence) 都可以访问。   通过uvm_top调用方法run_test(test_name) ， uvm_top做了如下的初始化：  得到正确的test_name。 初始化objection机制（控制仿真退出）。 创建uvm_test_top实例。 调用phase控制方法， 安排所有组件的phase方法执行顺序。 等待所有phase执行结束， 关闭phase控制进程。 报告总结和结束仿真。    UVM仿真结束  UVM-1.1之后， 结束仿真的机制有且只有一种， 那就是利用objection挂起机制来控制仿真结束。 uvm_objection类提供了一种供所有component和sequence共享的计数器。如果有组件来挂起objection， 那么它还应该记得落下objection。 参与到objection机制中的参与组件， 可以独立的各自挂起objection， 来防止run phase退出， 但是只有这些组件都落下objection后， uvm_objection共享的counter才会变为0， 这意味run phase退出的条件满足， 因此可以退出run phase。 对于uvm_objection类， 用来反停止的控制方法包括：  raise_objection(uvm_object obj=null, string description=\u0026rdquo;\u0026quot;, int count=1) 挂起objection drop_objection(uvm_object obj=null, string description=\u0026rdquo;\u0026quot;, int count=1) 落下objection set_drain_time(uvm_object obj=null, time drain) 设置退出时间   对这几种方法，在实际应用中的建议有：  对于component() 而言， 用户可以在run_phase() 中使用phase.raise_objection() /phase.drop_objection() 来控制run phase退出。 用户最好为description字符串参数提供说明， 这有利于后期的调试。 应该使用默认count值。 对于uvm_top或者uvm_test_top应该尽可能少地使用set_drain_time() 。    objection防止仿真退出 1 2 3 4 5 6 7 8 9 10  class test1 extends uvm_test; ... task run_phase(uvm_phase phase) ; phase.raise_objection(this) ; `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;entered..\u0026#34;, UVM_LOW) #1us; `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;exited..\u0026#34;, UVM_LOW) phase.drop_objection(this); endtask endclass    如果要在component中挂起objection， 建议在一进入run_phase(后就挂起， 保证objection counter及时被增加。 另外， 用户需要习惯在sequence中挂起objection， 由于sequence不是uvm_component类， 而是uvm_object类， 因此它只有body() 方法， 而没有run_phase() 方法。 所以在sequence中使用objection机制时， 可以在body() 中的首尾部分挂起和落下objection。  config机制 概述  在验证环境的创建过程build phase中， 除了组件的实例化， 配置也是必不可少的。 为了验证环境的复用性，通过外部的参数配置，使得环境在创建时可以根据不同参数来选择创建的组件类型、组件实例数目、组件之间的连接以及组件的运行模式等。 在更细致的环境调节(environment tuning) 中有更多的变量需要配置， 例如for-loop的阈值、字符串名称、随机变量的生成比重等。 比起重新编译来调节变量，如果在仿真中可以通过变量设置来修改环境， 那么就更灵活了， 而UVM config机制正提供了这样的便捷。 在UVM提供了uvm_config_db配置类以及几种方便的变量设置方法来实现仿真时的环境控制， 常见的uvm_config_db类的使用方式包括：  传递virtual interface到环境中 设置单一变量值， 例如int、string、enum等 传递配置对象(config object) 到环境   uvm_config_db#(T)::set(uvm_component cntxt, string inst_name, string field_name, T value); uvm_config_db#(T)::get(uvm_component cntxt, string inst_name, string field_name, inout T value);  interface传递  interface传递可以很好地解决了连接硬件世界和软件世界。 而在之前SV验证模块中， 虽然SV可以通过层次化的interface的索引来完成了传递，但是这种方式不利于软件环境的封装和复用。 UVM的uvm_config_db使得接口的传递和获取彻底分离开来。 在实现接口传递的过程中需要注意：  接口传递应该发生在run_test()之前。这保证了在进入build phase之前，virtual interface已经被传递到uvm_config_db中。 用户应当把interface与virtual interface的声明区分开来， 在传递过程中的类型应当为virtual interface， 即实际接口的句柄。     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  interface intf1; logic enable = 0; endinterface class comp1 extends uvm_component; `uvm component_utils(comp1) virtual intf1 vif; ... function void build_phase(uvm_phase phase) ; if(!uvm_config_db#(virtual intf1)::get(this, \u0026#34;\u0026#34;, \u0026#34;vif\u0026#34;, vif) ) begin `uvm_error(\u0026#34;GETVIF\u0026#34;, \u0026#34;no virtual interface is assigned\u0026#34;) end `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;vif.enable is %b before set\u0026#34;, vif.enable), UVM_LOW) vif.enable = 1; `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;vif.enable is tb after set\u0026#34;, vif.enable), UVM_LOW) endfunction endclass //=================================== class test1 extends uvm_test; `uvm_component_utils(test1) comp1 cl; ... endclass //=================================== intf1 intf(); initial begin uvm_config_db#(virtual intf1)::set(uvm_root::get() , \u0026#34;uvm_test_top.c1\u0026#34;, \u0026#34;vif\u0026#34;, intf); run_test(\u0026#34;test1\u0026#34;); end //=================================== //输出结果： //UVM_INFO @O: reporter[RNTST] Running test test 1... //UVM_INFO @O: uvm_test_top.c1 [SETVAL] vif.enable is O before set //UVM_INFO @o: uvm_test_top.c1 [SETVAL] vif.enable is 1 after set   变量设置  在各个test中，可以在build_phase对底层组件变量加以配置，进而在环境例化之前完成配置，使得环境可以按照预期运行。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class comp1 extends uvm_component; uvm_component_utils(comp1) int val1=1; string str1=\u0026#34;null\u0026#34;; function void build_phase(uvm_phase phase); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;val1 is %d before get\u0026#34;, val1), UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;str1 is %s before get\u0026#34;, str1), UVM_LOW) uvm_config_db#(int)::get(this, \u0026#34;\u0026#34;, \u0026#34;val1\u0026#34;, vall); uvm config_db#(string)::get(this, \u0026#34;\u0026#34;, \u0026#34;str1\u0026#34;, str1); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;val1 is·%d after get\u0026#34;, v al1) , UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;str1 is %s after get\u0026#34;, str1) , UVM_LOW) endfunction endclass //===================================== class test1 extends uvm_test; `uvm_component_utils(test1) comp1 cl; ... function void build_phase(uvm_phase phase); uvm_config_db#(int)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;val1\u0026#34;, 100); uvm_config_db#(string)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;str1\u0026#34;, \u0026#34;comp1\u0026#34;) ; c1 = comp1::type_id::create(\u0026#34;c1\u0026#34;, this); endfunction endclass //===================================== //输出结果： // UVM_INFO @O: uvm_test_top.c1 [SETVAL] val1 is 1 before get // UVM_INFO @O: uvm_test_top.c1 [SETVAL] str1 is null before get // UVM_INFO @O: uvm_test_top.c1 [SETVAL] val1 is 100 after get // UVM INFO @O: uvm test_top.c1 [SETVALl str1 is comp1 after get    注意细节：先传递后创建  object传递  在test配置中， 需要配置的参数不只是数量多， 而且可能还分属于不同的组件。 那么如果对这么多层次中的变量做出类似上面的变量设置，那会需要更多的代码，容易出错还不易于复用，甚至底层组件的变量被删除后， 也无法通过uvm_config_db::set() 得知配置是否成功。 然而如果将每个组件中的变量加以整合，首先放置到一个uvm_object中， 再对中心化的配置对象进行传递， 那么将会更有利于整体环境的修改维护。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class config1 extends uvm_object; int val1 = 1; int str1 = \u0026#34;null\u0026#34;; `uvm_object_utils(config1) ... endclass //================================= class comp1 extends uvm_component; uvm_component_utils(comp1) config1 cfg; ... function void build_phase(uvm_phase phase) ; uvm_object tmp; uvm_config_db#(uvm_object)::get(this, \u0026#34;\u0026#34;, \u0026#34;cfg\u0026#34;, tmp); void\u0026#39;($cast(cfg, tmp)); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;cfg.val1 is %d after get\u0026#34;, cfg.val1), UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;cfg.str1 is %s after get\u0026#34;, cfg.str1) , UVM_LOW) endfunction endclass //================================= class test1 extends uvm_test; `uvm_component_utils(test1) comp1 c1, c2; config1 cfg1, cfg2; ... function void build_phase(uvm_phase phase); cfg1 = config1::type_id::create(\u0026#34;cfg1\u0026#34;); cfg2 = config1::type_id::create(\u0026#34;cfg2\u0026#34;); cfg1.val1 = 30; cfgl.strl = \u0026#34;c1\u0026#34;; cfg2.val1 = 50; cfg2.str1 = \u0026#34;c2\u0026#34;; uvm_config_db#(uvm_object)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;cfg\u0026#34;, cfg1) ; uvm_config_db#(uvm_object)::set(this, \u0026#34;c2\u0026#34;, ”cfg”, cfg2) ; c1 = comp1::type_id::create(\u0026#34;c1\u0026#34;, this); c2 = comp1::type_id::create(\u0026#34;c2\u0026#34;, this); endfunction endclass   总结  在使用uvm_config_db::set() /get()时， 实际发生了这些后台操作：  uvm_config_db::set() 通过层次和变量名， 将这些信息放置到uvm_pkg唯一的全局变量uvm_pkg::uvm_resources. 全局变量uvm_resources用来存储和释放配置资源信息(resource information) 。uvm_resources是uvm_resource_pool类的全局唯一实例，该实例中有两个resource数组用来存放配置信息， 这两个数组中一个由层次名字索引，一个由类型索引，通过这两个关联数组可以存放通过层次配置的信息。 同时，底层的组件也可以通过层次或者类型来取得来自高层的配置信息。这种方式使信息的配置和获取得到剥离，便于调试复用。 在使用uvm_config_db::get()方法时，通过传递的参数构成索引层次，然后在uvm_resource已有的配置信息池中索引该配置， 如果索引到， 方法返回1，否则返回0。    建议  在使思set()/get() 方法时， 传递的参数类型应当上下保持一致。对于uvm_object等实例的传递如果get型与set类型不一致， 应当首先通过$cast() 完成类型转换， 再对类型转换后的对象进行操作。 set()/get()方法传递的参数可以使用通配符”*“来表示任意的层次，类似于正则表达式的用法。同时用户需要懂得”*.comp1“与”*comp1“的区别，前者表示在目前层次以下所有名称为”comp1“的组件，而后者表示包括当前层次及当前层次以下所有名为”comp1“的组件。 在module环境中如果要使用uvm_config_db::set()， 则传递的第一个参数uvm_component_cntxt参数用来表示当前的层次。如果当前的层次为最高层，用户可以设置为null，也可以设置为uvm_root::get()来表示uvm_root的全局顶层实例。 在使用配置变量时，应当确保先进行uvm_config_db::get()操作，在获得了正确的配置值以后再使用。 应当尽量确保uvm_config_db::set() 方法在相关配置组件创建前调用。这是因为只有先完成配置，相关组件在例化前才可以得到配置值继而正确地例化。 在set()方法第一个参数使用当前层次的前提下，对于同一组件的同一个变量，如果有多个高层组件对该变量进行设置，那么较高层组件的配置会覆盖较低层的配置，但是如果是同一层次组件对该变量进行多次配置时，应该遵循后面的配置会覆盖前面的配置。 用户应该在使用uvm_config_db::get()方法时， 添加便于调试的语句，例如通过UVM报告信息得知get()方法中的配置变量是否从uvm_confog_db获取到，如果没有获取，是否需要采取其他措施。  消息管理 概述  在一个好的验证系统应该具有消息管理特性，它们是：  通过一种标准化的方式打印信息 过滤(重要级别)信息 打印通道   这些特性在UVM中均有支持， UVM提供了一系列丰富的类和方法来生成和过滤消息：  消息方法 消息处理 消息机制    消息方法  在UVM环境中或者环境外， 只要有引入uvm_pkg， 均可以通过下面的方法来按照消息的严重级别和冗余度来打印消息。   1 2 3 4 5 6 7  function void uvm_report_info(string id, string message, int verbosity=UVM MEDIUM, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm_report_warning(string id, string message, int verbosity=UVM_MEDIUM, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm report error(string id, string message, int verbosity=UVM_LOW, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm_report_fatal(string id, string message, int verbosity=UVM_NONE, string filename=\u0026#34;\u0026#34;, int line=0) ;    四个消息函数有若干共同的信息， 它们是严重级别(severity) 、冗余度(verbosity) 、消息ID、消息、文件名和行号：  严重级别：从函数名本身也可以得出， 这四个严重级别分别是UVM_INFO、UVM_WARNING、UVM_ERROR、UVM_FATAL。不同的严重级别在打印的消息中也会有不同的指示来区别，同时仿真器对不同严重级别消息的处理方式也不一样。例如对于UVM_FATAL的消息， 默认情况下仿真会停止。 消息ID：该ID可以是任意的字符串，用来标记该消息。这个标记会同消息本身打印出来，同时不同的标记也可以用来进行消息处理。 消息：即消息文本的主体。 冗余度：冗余度与消息处理中的过滤直接相关。冗余度的设置如果低于过滤的开关，那么该消息会打印出来，否则不会被打印出来。但是无论信息是否会被打印出来，这都与对消息采取的其它措施没有关系，例如仿真停止。 文件名和行号：这些信息用来提供消息发生时所在的文件和行号。用户可以使用默认值， 而UVM后台会自动填补它们原本的文件名和行号， 同时也在打印时将文件名和行号输出。    消息处理  与每一条消息对应的是如何处理这些消息。通常情况下，消息处理的方式是同消息的严重级别对应的。如果用户有额外的需求，也可以修改对各个严重级别的消息处理方式。     处理方式 说明     NO_ACTION 不做任何处理   UVM_DISPLAY 将消息输出到标准输出端口   UVM_LOG 将消息写入到文件   UVM_COUNT 增加退出计算变量quit_count，达到一定数值时则停止仿真   UVM_EXIT 立刻停止仿真   UVM_CALL_HOOK 调用对应的回调函数   UVM_STOP 停止仿真     不同的严重级别消息，用户可以使用默认的消息处理方式     严重级别 默认处理方式     UVM_INFO UVM_DISPLAY   UVM_WARNING UVM_DISPLAY   UVM_ERROR UVM_DISPLAY \u0026amp; UVM_COUNT   UVM_FATAL UVM_DISPLAY \u0026amp; UVM_EXIT    消息宏  如果要做自定义的消息处理方式，用户可以通过uvm_report_object类提供的方法进行配置。 uvm_report_object类是间于uvm_object类与uvm_component类之间的中间类， 它的主要功能是完成消息打印和管理。 UVM也提供了一些宏来对应上面的消息方法，用户也可以使用这些宏来处理消息。     方法调用 宏调用     uvm_report_info() `uvm_info(ID, MESSAGE, VERBOSITY)   uvm_report_warning() `uvm_warning(ID, MESSAGE)   uvm_report_error() `uvm_error(ID, MESSAGE)   uvm_report_fatal() `uvm_fatal(ID, MESSAGE)    消息机制  消息处理是由uvm_report_handler类来完成的， 而每一个uvm_report_object类中都有一个uvm_report_handler实例。 上面的uvm_report_object消息处理方法或者uvm_component消息处理方法， 都是针对于这些uvm_report_handler做出的配置。 除了上面的常见使用方法，用户还可以做出更高级的消息控制。例如，当UVM_ERROR出现之后， 仿真默认会停止， 这是由于设置了UVM_ERROR的处理方式是UVM_COUNT数量达到上限(默认为1)，即停止仿真。可以通过set_max_quit_count来修改UVM_COUNT值。  回调函数  消息用户在处理信息时还希望做出额外的处理，这时回调函数就显得很有必要了，uvm_report_object类提供了下面的回调函数满足用户更多的需求：   1 2 3 4 5 6 7 8 9  function bit report_hook(string id, string message, int verbosity, string filename, int line ); function bit report_info_hook(string id, string message, int verbosity, string filename, int line ); function bit report_warning_hook(string id, string message, int verbosity, string filename, int line ); function bit report_error_hook(string id, string message, int verbosity, string filename, int line ); function bit report_fatal_hook(string id, string message, int verbosity, string filename, int line );    report_hook(函数通过结合消息管理时的UVM_CALL_HOOK参数， 结合用户自定义的回调函数，就可以实现更丰富的配置。 这样用户在调用回调函数时， 首先会调用report_hook() 函数， 接下来才按照severity级别来选择更细致的回调函数report_SEVERITY_hook() 。 默认情况下， report_hook) 函数返回值为1， 进而再转入severity hook函数。 如果report_hook() 函数由用户自定义且返回0的话， 那么后续report_SEVERITY_hook) 函数不会执行。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class test1 extends uvm_test; integer f; `uvm_component_utils(test1) ... function void build_phase(uvm_phase phase) ; set_report_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_CALL_HOOK); set_report_verbosity_level(UVM_LOW) ; endfunction task run_phase(uvm_phase phase) ; uvm_report_info(\u0026#34;RUN\u0026#34;, \u0026#34;infol\u0026#34;, UVM_MEDIUM) ; uvm_report_info(\u0026#34;RUN\u0026#34;, \u0026#34;info2\u0026#34;, UVM_LOW) ; uvm_report_warning(\u0026#34;RUN\u0026#34;, \u0026#34;warning1\u0026#34;, UVM_LOW) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error1\u0026#34;, UVM LOW) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error2\u0026#34;, UVM_HIGH) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error3\u0026#34;, UVM_LOW) ; endtask function void report_phase(uvm_phase phase) ; $fclose(f) ; endfunction function bit report_hook(string id, string message, int verbosity, string filename, int line) ; uvm_report_info(\u0026#34;RPTHOOK\u0026#34;, $sformatf(\u0026#34;%s: %s\u0026#34;, id, message), UVM_LOW) ; return 1; endfunction function bit report_error_hook(string id, string message, int verbosity, string filename, int line) ; uvm_report_info(\u0026#34;ERRHOOK\u0026#34;, $sformatf(\u0026#34;%s: %s\u0026#34;, id, message) , UVM LOW) ; return 1; endfunction endclass   消息管理  report_hook() 函数通过结合消息管理时的UVM_CALL_HOOK参数， 结合用户自定义的回调函数，就可以实现更丰富的配置。 这样用户在调用回调函数时， 首先会调用report_hook(函数， 接下来才按照severity级别来选择更细致的回调函数report_SEVERITY_hook() 。 默认情况下， report_hook(函数返回值为1， 进而再转入severity hook函数。 如果report_hook() 函数由用户自定义且返回0的话， 那么后续report_SEVERITY_hook() 函数不会执行。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":2,"section":"docs","tags":["UVM"],"title":"UVM学习（二）","uri":"https://www.wenhui.space/docs/digital_verifer/study_uvm/study-uvm-two/"},{"content":"本文 UVM学习系列主要介绍UVM的基础知识，UVM是目前芯片验证界最主流的验证方法学。此为第一篇，主要介绍验证方法学概述、类库地图、工厂机制和覆盖方法。\n   版本 说明     0.1 初版发布    参考  《UVM实战》，也就是所谓的白皮书。 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      验证方法学概述 所处的验证时代  国内验证起步较晚，历史包袱不重，在验证整合的尾期才开始发育，因此验证技术的更替较少。 超过20年的IC公司，存在几代的验证结构和较难彼此复用的测试代码，由于项目复用和进度的考虑，这些本该淘汰的技术依然在使用中，这对工程师造成了额外的负担。 原有的HDL描述语言受限于静态例化， 无法随着仿真场景做动态变换。同时，天生地随机约束短板也让后期发展的功能覆盖率驱动验证方式没有可以依靠的专用验证语言。 验证技术在融合进步的过程中，逐渐偏向软件化。在意识到验证环境应该提供更多的灵活性的同时， EDA公司们都开发出了良好的平台限定性语言， 例如Specman/e和Vera。 平台限定性语言在一开始符合IC研发的封闭生态特点，但验证工程师们的交流远甚于设计工程师(DVC on、SNUG、CDN Live等)，而且在技术交流和人员流动的过程中，逐渐提出了统一验证语言的要求。 SystemVerilog从早先的Accellera 2002年的SystemVerilog 3.0标准逐步发展到IEEE-1800 SystemVerilog 2017标准， 经历了十五年的更新和完善，已经全面雄起为IC验证领域的霸主。 上层的高级验证方法学也在2011年2月份之后逐步得到了融合，即UVM(Universal Verification Methodology)1.0的发布。 现在步入芯片验证，可以躲过AVM、VMM、OVM的学习， 而直接学习融合以后的验证方法学UVM。 UVM融合的积极意义在于， 打通了各个EDA公司和IC设计公司的验证技能通道，便于验证技术交流和人才流动，也方便了IC设计公司的技术及工具选择。 用户不再受限于使用何种仿真器、使用哪一家的验证IP，而只需要将主要精力着眼于设计的功能验证，由此也提升了验证效率。 SV的核心特性包括面向对象、随机约束、线程通信、功能覆盖率收集等，这些特性也为建立一个验证环境提供了足够多的便利。 UVM方法学的验证方法学通过吸取eRM(Spec man/e验证方法学) ， AVM， OVM， UVM等之前不同方法学的优点， 可谓集众家之所长。  UVM的优势  所有的验证方法学服务目的都在于提供一些可以重用的类来减轻在项目之间水平复用和垂直复用的工作量，而同时对于验证新人又能提供一套可靠的框架，帮助他们摆脱搭建房子构思图纸的苦恼。 UVM面向所有数字设计， 涵盖了从模块级到芯片级， ASIC到FPGA， 以及控制逻辑、数据通路到处理器验证对象的全部场景。 UVM中的Universal(通用) 的含义代表的是该方法学可以适用于大多数的验证项目， 而它自身提供的基础类库(basic class library) 和基本验证结构可以让具有不同软件编程经验的verifier们能够快速构建起一个结构可靠的验证框架。 UVM自定义的框架构建类和测试类能够帮助verifier减轻环境构建的负担，进而将更多的精力集中在如何制定验证计划和创建测试场景。  UVM的发展历程  2010年， 发布了UVM 1.0EA(Early Adopter) 版本。 目前已经发展到UVM 1.2， 并且在2017年被IEEE宣布为正式标准， 即IEEE 1800.2 UVM1.1之前的演变进化更多地是在于汲取OVM的方法学框架以及创建UVM的寄存器模型。 在UVM1.2版本的重要变化是UVM的消息机制更新和transaction记录能力的增强。  UVM的学习  在UVM的演变发展历史中， 在新版本虫新的构建平台方式和测试方式可以同旧的方法并存。UVM的新版本在兼容老版本用法的同时，也注毁了一些之前的陈旧用法。 在探索UVM世界时， 我们会遵循着下面的结构来帮助读者全面认识业界统一的验证方法学：  认识UVM世界的版图(类库) 和核心机制 学习核心的UVM组件和层次构建方式 了解常见的UVM组件间的通信方式 深入UVM测试场景的构成 UVM的寄存器模型应用    类库地图 概述  在SV模块中，验证环境整体的构建，是从底层模块的验证组件搭建到通信和激励生成。 这些元素无论是软件对象的创建、访问、修改、配置，还是组件之间的通信等都是通过用户自定义的方式来实现的。 UVM验证方法学作为之前所有方法学的融合版本， 从自身初衷而言，就是将验证过程中可以重用和标准化的部分都规定在其方法学的类库当中，通过标准化的方式减轻了验证人员构建环境的负担。  对验证环境的共同需求  在可以看到对验证环境的共同需求是：  组件的创建和访问 环境的结构创建、组件之间的连接和运行 不同阶段的顺序安排 激励的生成、传递和控制 测试的报告机制   由于软件环境中对象的生成是动态的，验证环境中的组件也需要UVM提供底层功能来完成对象的创建和访问。 在组件创建之外， UVM也需要提供环境上下层次中创建、连接和运行组件的顺序控制方法，只有在底层机制上有效地保证这一点，才会避免可能发生的句柄悬空问题。 在组件通信中， UVM也提供了功能更丰富的TLM(Transaction Level Model) 接口， 这可以保证相邻组件的通信不再通过显式句柄引用，而是独立于组件的通信方式。 对于测试序列(sequence) 的生成和传输也是利用了TLM传输在sequence和driver之间完成。而对于不同sequence的发送顺序控制， 也类似于SV测试M CDF子系统的要求， 需要实现sequence之间的灵活调度。 为了便于验证环境的调试， UVM的报告机制可以将来自于不同组件不同级别的信息并且加以过滤.最终生成测试报告。  UVM世界观       UVM类库地图按照UVM的核心机制将地图进行了分块：  核心基类 工厂(factory) 类 事务(transaction) 和序列(sequence) 类 结构创建(structure creation) 类 环境组件(environment component) 类 通信管道(channel) 类 信息报告(message report) 类 寄存器模型(register model) 类 线程同步(thread synchronization) 类 事务接口(transaction interface) 类    工厂机制 概述  工厂(factory) 机制是UVM的真正魅力所在。 工厂机制也是软件的一种典型设计模式(design pattern)。  工厂的意义  UVM工厂的存在就是为了更方便地替换验证环境中的实例或者注册了的类型，同时工厂的注册机制也带来了配置的灵活性。 这里的实例或者类型替代， 在UVM中称作覆盖(override) ，而被用来替换的对象或者类型， 应该满足注册(registration) 和多态(polymorphism) 的要求。 UVM的验证环境构成可以分为两部分， 一部分构成了环境的层次，这部分代码是通过uvm_component类完成， 另外一部分构成了环境的属性(例如配置)和数据传输，这一部分通过uvm_object类完成。 这两种类的集成关系从UVM类库地图可以看到，uvm_component类继承于uvm_object类， 而这两种类也是进出工厂的主要模具和生产对象。 之所以称为模具，是因为通过注册，可以利用工厂完成对象创建。 而之所以对象由工厂生产，也是利用了工厂生产模具可灵活替代的好处，这使得在不修改原有验证环境层次和验证包的同时，实现了对环境内部组件类型或者对象的覆盖。  uvm_component和uvm_object  uvm_component和uvm_object将会伴随着整个UVM的学习。 参照SV模块学习中的组件概念，即验证环境的不动产，大致包含：  generator stimulator monitor agent checker/reference model environment test   这些组件在uvm_component的子类中均有对应的组件。 SV中的非固定资产即那些TLM transaction， 从generator流向stimulator的数据包， 而这些类在UVM中统一由uvm_obiect表示。  uvm_{component/object}的例化  每一个uvm_{component/object} 在例化的时候都应该给予一个名字(string)。 “fullname”指的是component所处的完整层次结构。 在每个层次中例化的组件名称，应该独一无二(unique) 。 创建component或者object的方法如下：   1 2 3 4  //创建uvm_component对象时: comp_type::type_id::create(string name, uvm_component parent); //创建uvm_object对象时: object_type::type_id::create(string name);   工厂提供的便利\u0026ndash;创建（create）（掌握） 1 2 3 4 5 6 7 8 9 10  class comp1 extends uvm_component; `uvm_component_utils(comp1) //固定注册格式  function new(string name=\u0026#34;comp1\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;%s is created\u0026#34;, name)); endfunction:new function void build_phase(uvm_phase phase); super.build_phase(phase); endfunction:build_phase endclass   1 2 3 4 5 6 7  class obj1 extends uvm_object; uvm_object_utils(obj1) function new(string name=\u0026#34;obj1\u0026#34;); super.new(name); $display($sformatf(\u0026#34;%s is created\u0026#34;, name)); endfunction：new endclass   1 2 3 4 5 6 7 8 9 10 11 12  comp1 c1, c2; obj1 o1, o2； initial begin //SV的创建方式  cl=new(\u0026#34;cl\u0026#34;); o1=new(\u0026#34;o1\u0026#34;); //UVM工厂的创建方式  c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); o2=obj1::type_id::create(\u0026#34;o2\u0026#34;); end    c2和o2的例化方式也是最后通过调用new() 函数实现的。毕竟对于任何对象的例化， 最终都要通过new() 构建函数来实现的。 一般来说运用factory的步骤可分为：  将类注册到工厂 在例化前设置覆盖对象和类型(可选的) 对象创建   在两种类comp1和objl的注册中， 分别使用了UVM宏uvm_component_utils和~uvm_object_utils。  什么是宏(macro) 呢? 为什么需要宏呢?   这两个宏做的事情就是将类注册到factory中。在解释注册函数之前，我们需要懂得在整个仿真中， factory是独有的， 即有且只有一个， 这保证了所有类的注册都在一个“机构”中。  uvm_coreservice_t类  该类内置了UVM世界核心的组件和方法， 它们主要包括  唯一的uvm_factory， 该组件用来注册、覆盖和例化 全局的report_server， 该组件用来做消息统筹和报告 全局的tr_database， 该组件用来记录transaction记录 get_root() 方法用来返回当前UVM环境的结构顶层对象   而在UVM-1.2中， 明显的变化是通过uvm_coreservice_t将最重要的机制(也是必须做统一例化处理的组件)都放置在了uvm_core serice_t类中。 该类并不是uvm_component或者uvm_object， 它也并没有例化在UVM环境中， 而是独立于UVM环境之外的。 uvm_coreservice_t只会被UVM系统在仿真开始时例化一次。用户无需，也不应该自行再额外例化该核心服务组件。 这个核心组件如同一个随时待命的仆人，做好服务的准备。 理论上，用户可以获取核心服务类中的任何一个对象，例如uvm_default_factory对象， 继而直接利用factory来实现创建和覆盖。当然，创建和覆盖也可以由其它方式完成。  注册宏`uvm_{component/object}_utils  `uvm_component_utils用来注册组件类uvm_component `uvm_object_utils用来注册核心基类uvm_object 利用工厂注册机制的细节请参考红宝书P265，而对于验证工程师会使用uvm工厂注册是必要的，而具体实现机制细节不是必要的。 无论对于uvm_component或者uvm_object，在UVM世界中， 请养成习惯使用注册宏`uvm_component/object_utils 对于注册，并不是真正地将一个抽象的类型(空壳)放置在什么地方，而是通过例化该类的对象来完成。 由于一种类型在通过宏调用时只注册一次，那么在不考虑覆盖的情况下，uvm_default_factory就将每一个类对应的对象都放置到了factory的字典当中。 uvm_default_factory::create_component_by_type() 经过代码简化，读者可以看到关键语句，它们首先检查处在该层次路径中需要被例化的对象，是否受到了“类型覆盖”或者“实例覆盖”的影响，进而将最终类型对应的对象句柄(正确的产品模板)交给工厂。 有了正确的产品模板，接下来就可以通过uvm_component_registry::create_component() 来完成例化。  注册后的对象创建  uvm_component和uvm_object在创建时虽然都需要调用create()函数， 但最终创建出来的uvm_component是会表示在UVM层次结构中的， 而uvm_object则不会显示在层次中。 这一点也可以从uvm_component::new(name, parent) 和uvm_object::new(name) 中看得出来。 uvm_component::new(name, parent) 保留两个参数， 就是为了通过类似“钩子”的做法，一层层由底层勾住上一层，这样就能够将整个UVM结构串接起来了。 uvm_object::new(name) 则没有parent参数， 因此也不会显示在UVM层次中， 只能作为configuration或者transaction等用来做传递的配置结构体或者抽象数据传输的数据结构体，成为uvm_component的成员变量。 创建对象时，需要结合工厂的注册和覆盖机制来决定，应该使用哪一个类型来创建。       工厂创建compon/obiect的方法  除了使用component/object来创建实例， 也可以利用factory来创建：  create_component_by_name() create_component_by_type() create_obj eat_by_name() create_object_by_type()   为了避免不必要的麻烦， 我们在使用宏`uvm_component_utils和`uvm_object_utils注册类型时， 宏内部就将类型T作为类型名Tname=‘T’注册到factory中去。这就使得通过上面的任何一种方法在创建对象时，不会受困于类型与类型名不同的苦恼。  component/object与工厂有关的方法  配合工厂的注册、创建和覆盖的相关方法：  create() create_component() get() get_type_name() set_inst_override() set_type_override()   每一个uvm_component的类在注册时， 会定义一个新的uvm_component_registry类， 其如同一个外壳， 一个包装模板的纸箱， 在factory中注册时， 该纸箱中容纳的是被注册类的“图纸”，并没有一个“实例”。  建议 对于创建对象的方法，以上有工厂提供的创建对象的方法，有组件提供的创建对象的方法，并不需要全部掌握，而只需要记住 工厂提供的便利\u0026ndash;创建（create） ，之所以讲这么多是在看到别人的环境中出现这些方法时，要知道是做什么的。\n1 2  c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); o2=obj1::type_id::create(\u0026#34;o2\u0026#34;);   覆盖方法 工厂提供的便利\u0026ndash;覆盖(override)  覆盖机制可以将其原来所属的类型替换为另外一个新的类型。 在覆盖之后，原本用来创建原属类型的请求，将由工厂来创建新的替换类型。  无需再修改原始代码，继而保证了原有代码的封装性。 新的替换类型必须与被替换类型相兼容，否则稍后的句柄赋值将失败，所以新的类型要继承于原有的类型。   做顶层修改时，非常方便!  允许灵活的配置，例如可使用子类来覆盖原本的父类 可使用不同的对象来修改其代码行为   要想实现覆盖特性，原有类型和新类型均需要注册。 当使用create（) 来创建对象时：  工厂会检查，是否原有类型被覆盖。 如果是，那么它会创建一个新类型的对象。 如果不是，那么它会创建一个原有类型的对象。   覆盖发生时，可以使用“类型覆盖”或者“实例覆盖”  类型覆盖指， UVM层次结构下的所有原有类型都被覆盖类型所替换。 实例覆盖指，在某些位置中的原有类型会被覆盖类型所替换。    set_type_override() 替换类型 1  static function void set_type_override(uvm_object_wrapper override_type, bit replace=1);    uvm_object_wrapper override_type 这是什么?并不是某一个具体实例的句柄，实际上是注册过后的某一个类在工厂中注册时的句柄。怎么找到它呢?就使用new_type::get_type() 。 bit replace=1  1： 如果已经有覆盖存在，那么新的覆盖会替代旧的覆盖。 0： 如果已经有覆盖存在，那么该覆盖将不会生效。   set_type_override是一个静态函数   1 2  orig_type::type_id::set_type_override(new_type::get_type()) //---typedef------|----静态函数-------|------静态函数--------|   set_inst_override() 替换实例 1  static function void set_inst_override(uvm_object_wrapper override_type, string inst_path, uvm_component parent=null);    string inst_path指向的是组件结构的路径字符串 uvm_component parent=null 如果缺省， 表示使用inst_path内容为绝对路径，如果有值传递， 则使用(parent.get_full_name() ， \u0026lsquo;， inst_path)来作为目标路径。 set_type_override是一个静态函数   1 2  orig_type::type_id::set_inst_override(new_type::get_type(), \u0026#34;orig_inst_path\u0026#34;) //----typedef-----|------静态函数-----|------静态函数-------|   如何使用覆盖相关的函数  首先需要知道，有不止一个类提供与覆盖有关的函数，然而名称与参数列表可能各不相同：  uvm_component::set_{type/inst}_override{_by_type} uvm_component_registry::set_{type/inst}_override uvm_object_registry::set_{type/inst}_override uvm_factory::set_{type/inst}_override   因此，想要实现类型替换，也有不止一种方式。包括上述给的例子中通过orig_type::type_id来调用覆盖函数，还可以在uvm_component的域中直接调用， 或者使用uvm_factory来做覆盖。  覆盖实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  module factory_override; import uvm_pkg::*; `include \u0026#34;uvm_macros.svh\u0026#34; class comp1 extends uvm_component; `uvm_component_utils(comp1) function new(string name=\u0026#34;comp1\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;comp1:: %s is created\u0026#34;, name)); endfunction:new virtual function void hello(string name); $display($sformatf(\u0026#34;comp1:: %s said hello!\u0026#34;, name)) ; endfunction endclass class comp2 extends comp1; // 必须继承于comp1  `uvm_component_utils(comp2) function new(string name=\u0026#34;comp2\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;comp2:: %s is created\u0026#34;, name) ); endfunction:new function void hello(string name); $display($sformatf(\u0026#34;comp2:: %s said hello!\u0026#34;, name)); endfunction endclass //c1 c2 都是comp1 comp1 c1, c2; initial begin // 覆盖  comp1::type_id::set_type_override(comp2::get_type()); // 两种例化方式  c1=new(\u0026#34;c1\u0026#34;); c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); //调用hello函数  c1.hello(\u0026#34;c1\u0026#34;); c2.hello(\u0026#34;c2\u0026#34;); end endmodule //输出结果 // comp1:: c1 is created // comp1:: c2 is created // comp2:: c2 is created // comp1:: c1 said hello! // comp2:: c2 said hello!  //可见new例化的对象没有实现覆盖， create例化的对象实现了覆盖   确保正确覆盖的代码要求  将UVM环境中所有的类都注册到工厂中， 并通过工厂来创建对象。 在使用某些类的时候， 确保该类已经被导入(import) 到当前域(scope) 中。 通过工厂创建对象时， 句柄名称应该同传递到create() 方法中的字符串名称相同。无论是通过层次路径名称来覆盖还是配置，将例化组件的句柄名称同创建时create() 方法中的字符串名称保持一致。 由于覆盖是采用parent wins模式，也就是高层次的替换优先级高， 因此要注意在同一个顶层build_phase() 中覆盖方法应发生在对象创建之前。 为了尽量保证运行时覆盖类可以替换原始类，覆盖类最好是原始类的子类，而调用成员方法也应当声明为虚方法。 另外一种确保运行时覆盖类型句柄正确使用的方式， 需要通过$cast()进行动态类型转换。  总结  将浏览完UVM工厂后， 你有没有觉得它就像一个大大的乐高世界。 一旦把那些组件装载盒子注册之后， 接下来的UVM环境搭建就变得更加容易、更方便日后维护了。 整个UVM世界的构建， 离不开factory的三个核心要素：注册、创建和覆盖。  `uvm_{component/object} _utils uvm_{component/object}::type_id::create() set_{type/inst} _override{_by_type}()   UVM学习中的一大阻碍就是， 实现某一种效果的方法有很多种，但是对于初学者，你只需要掌握最常用的一种实现方式，就足够了!因为我们最终需要掌握UVM世界的全貌， 而不是研究全部的用法，毕竟我们时间非常有限!  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":3,"section":"docs","tags":["UVM"],"title":"UVM学习（一）","uri":"https://www.wenhui.space/docs/digital_verifer/study_uvm/study-uvm-one/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第七篇，主要介绍类型转换、虚方法、对象拷贝、回调函数和参数化类。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      类型转换 概述  类型转换可以分为静态转换和动态转换。 静态转换即需要在转换的表达式前加上单引号即可，该方式并不会对转换值做检查。如果发生转换失败，我们也无从得知。 动态转换即需要使用系统函数$cast(tgt， src) 做转换。 静态转换和动态转换均需要操作符号或者系统函数介入，统称为显式转换。 不需要进行转换的一些操作，我们称之为隐式转换。例如赋值语句右侧是4位的矢量，而左侧是5位的矢量，隐式转换会先做位宽扩展(隐式)，然后再做赋值。  动态转换  当我们使用类的时候，类句柄的向下转换，即从父类句柄转换为子类句柄时， 需要使用$cast() 函数进行转换， 否则会出现编译错误，这一步也是编译器的保护措施，防止用户出现错误的赋值。 如果将子类句柄赋值给父类句柄时，编译器则认为赋值是合法的，但分别利用子类句柄和父类句柄调用相同对象的成员时，将可能有不同的表现。  子类句柄赋值于父类句柄 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Transaction; rand bit[31:0] src; function void display(input string prefix=\u0026#34;\u0026#34;); $display(\u0026#34;%s Transaction: src=%0d\u0026#34;, prefix, src); endfunction endclass class BadTr extends Transaction; bit bad_crc; function void display(input string prefix=\u0026#34;\u0026#34;); $display(\u0026#34;%s BadTr: bad_crc=%b\u0026#34;, prefix, bad_crc); super.display(prefix); endfunction endclass Transaction tr; BadTr bad, bad2;        1 2 3 4 5 6  Transaction tr; BadTr bad; bad=new() ; //构建BadTr扩展对象 tr=bad; //基类句柄指向扩展对象 $display(tr.src) ; //显示基类对象的变量成员 tr.display() ; //??    tr.display() ; 调用的是父类的display。  父类句柄转换为子类句柄 1 2 3  tr=new() ; //创建一个父类对象 bad=tr; //ERROR：编译错误，即便使用cast进行转换，虽然解决编译错误，但是返回值为0，bad仍为空句柄。 $display(bad.bad_crc) ; //bad_crc成员不在父类对象中    将一个父类句柄赋值给一个子类句柄并不总是非法的。 但是SV编译器对这种直接赋值的做法是禁止的，也就是说无论父类句柄是否真正指向了一个子类对象，赋值给子类句柄时，编译(静态)都将出现错误。 因此需要$cast(tgt， src) 来实现句柄类型的动态转换。 $cast(tgt， src) 会检查句柄所指向的对象类型， 而不仅仅检查句柄本身。 一旦源对象跟目的句柄是同一类型，或者是目的句柄的扩展类，$cast() 函数执行即会成功， 返回1， 否贝返回0。   1 2 3 4 5 6 7 8 9  bad=new(); //创建Bad Tr子对象 tr=bad; //父类句柄指向子类对象 //动态类型转换， 检查tr的源对象是否是bad 2类型或者其子类 //如果转换失败，将报告错误信息 if(!$cast(bad2, tr)) $display(\u0026#34;cannot assign tr to bad2\u0026#34;); $display(bad2.bad_crc); //bad 2指向的对象包含band_src成员 bad2.display() ; //??    bad2.display() ; 调用子类的方法。  虚方法 概述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class basic_test; int fin; int def = 100; function new() ; $display(\u0026#34;basic_test::new\u0026#34;) ; endfunction task test() ; $display(\u0026#34;basic_test::test\u0026#34;) ; endtask endclass class test_wr extends basic_test; int def = 200; function new() ; super.new() ; $display(\u0026#34;test_wr::new\u0026#34;) ; endfunction task test() ; super.test() ; $display(\u0026#34;test_wr::test\u0026#34;) ; endtask endclass    类的继承是从继承成员变量和成员方法两个方面。 从例码中可以看到test_wr类和test_rd类分别继承了basic_test类的成员变量以及成员方法。 除了介绍的类的封装和继承，关于类的多态性(polymorphism) 也是必须关注的。 正是由于类的多态性，使得用户在设计和实现类时，不需要担心句柄指向的对象类型是父类还是子类，只要通过虚方法，就可以实现动态绑定(dynamic binding) ， 或者在SV中称之为动态方法查找(dynamic method lookup) 。  非虚函数的调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  basic_test t; test_wr wr; initial begin wr=new() ; t=wr; $display(\u0026#34;wr test starts\u0026#34;) ; wr.test() ; $display(\u0026#34;wr test ends\u0026#34;) ; $display(\u0026#34;t test starts\u0026#34;) ; t.test() ; $display(\u0026#34;t test ends\u0026#34;) ; end //输出结果： // wr test starts // basic_test::test // test_wr::test // wr test ends // t test starts // basic_test::test // t test ends    首先， 在执行wr.test() 时， 由于wr类型为test_wr， 则索引到的test() 应该为test_wr类的方法test。 同时， 由于在test_wr::test中显式调用了super.test() ， 则会先执行basic_test::test， 然后再执行test_wr::test中其余的代码。 这里值得注意的是， 默认情况下， 子类覆盖(override) 的方法并不会继承父类同名的方法， 而只有通过super.method()的方式显式执行，才会达到继承父类方法的效果，初学SV的用户容易在这里混淆方法覆盖和类继承的概念。 当wr对象的句柄传递给t后， 由于t本身是basic_test类， 所以，在执行t.test时， t只会搜寻basic_test::test方法。 （多态的问题是什么？在句柄传递中，子类句柄赋值给父类句柄，调用同名函数时，子类句柄调用的是子类函数，父类句柄调用的是父类函数，即便把子类句柄赋值给了父类句柄，也无法通过父类句柄调用子类函数）  虚函数的调用  我们将已经在编译阶段就可以确定下来调用方法所处作用域的方式称之为静态绑定(static binding) ， 而与之相对的是动态绑定。 动态绑定指的是，在调用方法时，会在运行时来确定句柄指向对象的类型，再动态指向应该调用的方法。 为了实现动态绑定， 我们将basic_test::test定义为虚方法。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class basic_test; ... virtual task test(stm_ini ini) ; $display(\u0026#34;basic_test::test\u0026#34;) ; endtask ... endclass //wr test starts只做了这么一个改动以后，我们重复运行之前的测试代码，可以看到运行结果变为： // wr test starts // basic_test::test // test_wr::test // wr test ends // t test start.s // basic_test::test // test_wr::test // t test ends    由于声明了basic_test::test为虚方法， 系统在执行t.test时，会检查t所指向对象的类型为test_wr类， 进而调用test_wr::test。 于是， 输出结果与调用wr.test一致。 我们就可以通过虚方法的使用来实现类成员方法调用时的动态查找，用户无需担心使用的是父类句柄还是子类句柄，因为最终都会实现动态方法查找，执行正确的方法。  建议  在为父类定义方法时，如果该方法日后可能会被覆盖或者继承，那么应该声明为虚方法。 虚方法如果要定义，应该尽量定义在底层父类中。这是因为如果virtual是声明在类继承关系的中间层类中， 那么只有从该中间类到其子类的调用链中会遵循动态查找，而最底层类到该中间类的方法调用仍然会遵循静态查找。 虚方法通过virtual声明， 只需要声明一次即可。例如上面代码中，只需要将basic_test::test声明为virtual， 而其子类则无需再次声明，当然再次声明来表明该方法的特性也是可以的。 虚方法的继承也需要遵循相同的参数和返回类型，否则，子类定义的方法须归为同名不同参的其它方法。  对象拷贝 赋值和拷贝  声明变量和创建对象是两个过程，也可以一步完成。  Packet pl; p1=new;   如果将p1赋值给另外一个变量p2，那么依然只有一个对象，只是指向这个对象的句柄有p1和p2. 以下这种方式表示p1和p2代表两个不同的对象。在创建p2对象时， 将从p 1拷贝其成员变量例如integer、string和句柄等， 该种拷贝方式称为浅拷贝(shallowcopy) 。   1 2 3 4  Packet pl; Packet p2; p1=new; p2=new p1;   概述  对于拷贝(copy) ， 对象的拷贝要比其它SV的变量类型都让人”当心”。 因为就SV普通的变量拷贝而言，只需要通过赋值操作符“=”就足够了。 而对象的拷贝则无法通过“=”来实现，因为这一操作是句柄的赋值，而不是对象的拷贝。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  test_wr h; initial begin wr = new(); h = wr; $display(\u0026#34;wr.def=%Od\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); h.def = 300; $display(\u0026#34;wr.def=%Od\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); end //输出结果： // wr.def = 200 // h.def = 200 // wr.def = 300 // h.def = 300    在h=wr之后，由于是句柄的赋值，所以h.def=300的操作， 实际上是对这两个句柄指向的共同对象做的成员变量赋值。所以，从最终打印的结果可以看出，wr.def与h.def的值相同。 那么如果要拷贝对象，指的是首先创建一个新的对象(开辟新的空间)，再将目标对象的成员变量值拷贝给新对象的成员，这就使得新对象与目标对象的成员变量数值保持一致，即完成了对象的拷贝(成员变量的拷贝)。 初学者需要区别句柄拷贝与对象拷贝的区别。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class basic_test; //父类  ... virtual function void copy_data(basic_test t) ; t.def=def; t.fin=fin; endfunction virtual function basic_test copy() ; basic_test t=new(0) ; //创建父类对象  copy_data(t) ; return t; endfunction endclass class test_wr extends basic_test; //子类  ... function void copy_data(basic_test t) ; test_wr h; super.copy_data(t) ; $cast(h, t); //关键代码，句柄转化  h.def=def; endfunction function basic_test copy() ; test_wr t=new() ; //创建子类对象  copy_data(t) ; return t; endfunction endclass   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  module tb; .... test_wr wr; //子类  test_wr h; //子类  initial begin wr=new() ; $cast(h, wr.copy()); //copy会返回父类句柄，所以这里将父类句柄转化为子类句柄  $display(\u0026#34;wr.def=%0d\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); h.def=300; $display(\u0026#34;wr.def=%0d\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); end ... endmodule //输出结果： // wr.def=200 // h.def=200 // wr.def=200 // h.def=300   总结  将成员拷贝函数copy_data() 和新对象生成函数copy() 分为两个方法，这样使得子类继承和方法复用较为容易。 为了保证父类和子类的成员均可以完成拷贝，将拷贝方法声明为虚方法，且遵循只拷贝该类的域成员的原则，父类的成员拷贝应由父类的拷贝方法完成。 在实现copy_data() 过程中应该注意句柄的类型转换， 保证转换后的句柄可以访问类成员变量。  回调函数 概述  理想的验证环境是在被移植做水平复用或者垂直复用时，应当尽可能少地修改模块验证环境本身，只在外部做少量的配置，或者定制化修改就可以嵌入到新的环境中。 要做到这一点，一方面我们可以通过顶层环境的配置对象自顶向下进行配置参数传递，另外一方面我们可以在测试程序不修改原始类的情况下注入新的代码。 例如， 当我们需要修改stimulator的行为时， 有两种选择， 一个是修改父类，但针对父类的会传播到其它子类；另外一个选择是，在父类定义方法时，预留回调函数入口，使得在继承的子类中填充回调函数，就可以完成对父类方法的修改。       实例 1 2 3 4 5 6 7 8 9  - 示意： virtual class Driver_cbs; //Driver回调虚类  virtual task pre_tx(ref Transaction tr, ref bit drop) ; //默认不做操作  endtask virtual task post_tx(ref Transaction tr) ; //默认不做操作  endtask endclass    实例：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Driver; Driver_ebs cbs[$]; task run() ; bit drop; Transaction tr; forever begin drop=0; agt2drv.get(tr) ; foreach(ebs[il) cbs[il.pre_tx(tr, drop) ; if(drop) continue; transmit(tr) ; foreach(cbs[il) cbs[i] .post_tx(tr) ; end endtask endclass class Driver_cbs_drop extends Driver_abs; virtual task pre_tx(ref Transaction tr, ref bit drop) ; //1/100的传输事务丢弃概率  drop=($urandom range(0, 99) ==0) ; endtask endclass program automatic test; Environment env; initial begin env=new() ; env.gen_cfg() ; env.build() ; begin//创建回调对象井且植入driver  Driver_abs_drop dcd=new() ; env.drv.cbs.push_back(dcd) ; end env.run() ; env.wrap_up(); end endprogram   完成回调函数功能需要三步：  预留回调函数入口 定义回调的类和回调函数 例化和添加回调的类  参数化类 概述  参数化的使用是为了提高代码的复用率。 无论是设计还是验证，如果代码会被更多的人使用或者被更多的项目所采用，那么就需要考虑使用参数来提高复用率。 参数的使用越合理，后期维护的成本就会相应降低。 在硬件设计中，参数往往是整型，例如端口数目或者位宽。在验证环境中，参数的使用更加灵活，可以使用各种类型来做类定义时的参数。 在SV中，可以为类增加若干个数据类型参数，并在声明类句柄的时候指定类型。 SV的类参数化近似于C++中的模板。  实现一个简化的mailbox 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class mailbox; local int queue[$] ; task put(input int i) ; queue.push_back(i) ; endtask task get(ref int o) ; wait(queue.size() \u0026gt;0) ; o=queue·pop_front() ; endtask task peek(ref int o) ; wait(queue.size() \u0026gt;0) ; o=queue[0] ; endtask endclass    这个简化的mailbox的问题在于它只能用于操作整数类型。 如果要存储real类型， 或者某一个类的句柄，那么就得复制该类，然后将数据类型由int类型转换为real类型或者某一个类的类型。 这样将导致类的快速增长，而且是重复代码的大规模增长，代码维护将变得冗长乏味而且还容易出错。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class mailbox #(type T=int) ; local T queue[$] ; task put(input T i) ; queue.push_back(i) ; endtask task get(ref T o) ; wait(queue.size() \u0026gt;0) ; o=queue.pop_front() ; endtask task peek(ref T o) ; wait(queue.size() \u0026gt;0) ; o=queue[Ol; endtask endclass initial begin real o; mailbox #(real) mb; //创建一个存储real类型的mailbox  mb=new() ; for(inti=0; i\u0026lt;5; i++) mb.put(i*2.0) ; //将real值存储入mb  for(inti=0; i\u0026lt;5; i++) mb.get(o) ; //从mb取出real值 end    在类定义时添加参数#(typeT=int) ， 这表示后期类在声明变量时如果不指定参数类型， 则默认采用int类型。 将原代码int用参数T来代替。 参数化的类将可以在后期例化时使用不同的参数，以此来存储不同的数据类型。  文章原创,可能存在部分错误,欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":4,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（七）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_seven/"},{"content":"本文 主要记录SV与UVM的一些知识点，每日一问，每日一记。\n   版本 说明     0.1 初版发布    写在前头 本文非原创，内容来自路科验证，整理成文并持续更新。\n每日一问 在一些头文件(.svh) 中， 会有typedef class X， 这是什么意思?  回答： 首先这需要与常见的typedef enum/struct\u0026hellip;x_t的类型定义区别；真正的类的定义依然是利用“Xextends\u0026hellip;”的方式实现， 而这里则是为了编译时能够让编译器识别class X采取的“占坑”方法， 即先“声明”类X的存在，并且在后续将X的定义字段“Xextends\u0026hellip;”进行补充编译。 关键词： typedef class 避坑指南： typedef class常常用来解决两个类之间的互相引用问题，即在A中使用B，且在B中使用A。  在enum/struct类型声明时， 添加typedef与否的差别是什么?  回答： 如果不添加typedef， 例如enum(NO， YES) bool，那么bool为枚举类型“变量”， 而“enum(NO， YES) ” 按照“匿名类型”(implicit type)来理解；如果添加typedef， 例如typedef enum(NO， YES) bool_t， 那么bool_t为枚举类型， 即通过typedef将匿名类型“显式”(explicitly) 定义为bool_t， 并且接下来可重复利用bool_t来声明多个变量。 关键词： enum，struct， typedef 避坑指南： 对于重复使用的enum/struct定义， 默认添加typedef先定义类型， 再利用该类型声明变量。  Interface的mod port和clocking block如何使用?  回答： 这两个概念得需要独立看待。Mod port是将interface中的信号列表按类分簇(grouping)，便于模块之间、模块与TB之间的连线管理； clocking block并非interface的专属产物， 不过多见于interface使用它进行数据信号采样或者驱动， 继而有效避免delta cycle问题，并通过波形上的可见延迟帮助理解仿真时序。 关键词： interface，mod port， clocking block 避坑指南： mod port和clocking在连接时方向不要混淆，在它们中只需对若干已声明信号再次声明方向即可。  Module中的Initial额always执行先后顺序是否与它们的代码位置有关?  回答： Module中的initial和always执行先后顺序是always在综合逻辑中， 以及initial在初始化激励序列中，彼此过程块之间都是“并行”的，这是从模拟硬件执行角度来理解“并行”；同时，仿真器即便要处理这些过程块语句，也需要从软件语句执行着手，这意味着同一个仿真时刻执行的并行语句，也需要由仿真器安排它们的执行顺序，这是从仿真软件执行角度来理解“顺序”。 关键词： 执行顺序， initial， always 避坑指南： 不对多个initial执行顺序做假设。如果要按照顺序执行， 可将逻辑放置在同一个initial块， 或者使用event实现线程间同步。  组合型数组和非组合型数组如何做赋值?  回答： 组合型数组之间赋值时可以将不同维度、不同元素数量的数组直接做赋值(注意位宽默认补全或者截取)；非组合型数组之间赋值有严格要求必须相同维度且各维度元素数量须相等，可直接赋值，但如果不满足该条件则只能对数组中的元素做逐一赋值。 关键词： 组合型，非组合型，赋值 避坑指南： 组合型数组可直接赋值；非组合型数组直接赋值要求繁多，逐一赋值最安全。  类中的成员变量在声明时初始化或者在new函数中初始化是否有区别?  回答： 从实现结果来看都可以对成员变量在对象创建时完成初始化，但如果两个动作均发生了，那么应该注意变量声明初始化执行在前(空间开辟动作)，而new函数对成员变量初始化在后(构建函数体内部对成员变量做初始化操作) 关键词： 变量声明，构建函数，初始化 避坑指南： 搞清楚两者的执行顺序，按照代码习惯只选择一种即可。  组合型(packed)数组和非组合型数组(unpacked)怎么区分?  回答： 数组维度声明在数组变量名左侧的为组合型数组，例如byte[3：0] [1：0] array 1为组合型4*2二维数组。数组维度声明在数组变量名右侧的为非组合型数组，例如bytearray 2[5：0] [7：0] 为非组合型6*8二维数组。混合型数组byte[3：0] [1：O] array 3[5：O] [7：0] 为6*8*4*2的四维混合数组。 关键词： 组合型，非组合型 避坑指南： 数组维度从高到低是先看数组名右侧(从左到右)，再看数组名左侧(人左到右)o  include和import的差别在哪里?  回答： SV常会用\u0026rsquo;include将多个文件“平铺”(flatten) 置于某个域中(scope) ， 这个域可能是package/ module/ interface等， 简单理解`include就是将对应文本的  内容“平铺”到当前域的字段中。import则是从包(package) 中引用某些需要的数据类型，例如class/parameter/enum到当前域中， 以帮助编译器能够识别被亏用的类型。\n 关键词： `include， import 避坑指南： `include部分会由编译器编译， import部分会由编译器从库中查找导出。  在哪里应该使用`include?  回答： `include使用的地方多见于在包(package) 文件中将多个其它类文件“平铺”于其中，从而在编译时能够将多个文件中定义的类置于这个包中，形成一种逻辑上的包含关系； 同时， 在module文件也可能会使用`include， 使其“平铺”一些宏定义文件或者接口文件。 关键词： include 避坑指南： 一个包通过include包含多个文件， 在编译该包后， 不再需要对被＼include文件做额外编译。  module和interface之间可以相互例化吗?  回答： module可以例化module， 也可以例化interface；interface可以例化interface， 但是不可以例化module。就硬件实现逻辑而言， module之间的嵌套、interface之间的嵌套以及module嵌套interface都符合设计理念， 而interface不需要(也不应该) 例化module。 关键词： module， interface 避坑指南： interface可以例化interface， 但无法例化module。  方法中的参数的默认方向如何辨别?  回答： 关注于系统验证思想和前沿验证资讯，为IC从业人员提供技术食粮。对于function/task， 如果其参数的方向未声明， 那么它的方向为input方向， 如果声明了方向， 那么该参数以及其后续的参数方向均相同。例如function void foo(A， B， output C， D) 中， A和B由于为声明方向， 为input， C和D为声明后的方向，即output。 关键词： 参数方向，默认方向 避坑指南： 对每一个参数都应该声明方向。  return的使用场景有哪些?  回答： return可在function和task中使用。在返回值为void的function， 或者task中调用return， 即会立即退出该方法； 如果function返回值非void， 那么在退出function的同时还会返回数值。 关键词： return， function， task 避坑指南： 在task中也可以使用return立即退出。  task与function的联系差另在哪里?  回答： 二者均可在module、interface、package和class中定义， 并实现一些功能。function执行须即刻返回，无法内置阻塞等待语句，在声明时需指定返回值(包括void) 。task执行无须即刻返回， 可以内置阻塞等待语句(wait、#、@) ， 返回数值只能依靠参数列表中的参数。 关键词： task， function 避坑指南： function可以调用function， 但无法调用task； task既可以调用task， 也可以调用function。  {}操作符号的使用场景有哪些?  回答： 第一，可作为并置运算符“串联”其一些向量或者字符串，例如{a,b}； 第二，可作为复制运算符，例如{4{w}}中内嵌的一对{}； 第三，对组合型数组赋值时，可采用{}，对非组合型数组赋值时，可采用\u0026rsquo;{} (注意单撇号)； 第四，在描述覆盖点和仓时使用{}； 第五，在定义enum/struct时， 使用{} 。 关键词： 花括号，() 避坑指南： SV中应该使用begin\u0026hellip;end的字段切勿使用{}去替代。  方法中的参数如果具有默认值该如何使用?  回答： 方法中参数默认值是实用方式(不建议使用参数默认方向和默认数值类型)。在调用方法并传递参数过程中可按位置或按名称传递参数。在更常见的按位置传递参数过程中，如果某个参数可采用其默认值，那么需要为它留好“空的位置”，除非该默认参数的位置在参数列表的最后。 关键词： 参数默认值，参数传递 避坑指南： 将所有带有默认值的参数声明均放在参数列表的最后，便于外部调用方法时的参数省略。  方法中形式参数的方向描述符inout和ref的差别?  回答： inout方向会在方法调用中完成入口处由外部变量到形式参数的拷贝，以及在方法退出时，由形式参数到外部变量的拷贝， 即一共2次值的拷贝； ref则是将外部变量本身传递进入，即不再发生形式参数的值拷贝过程， ref也可理解为指针(reference) 。 关键词： 形式参数方向， in out， ref 避坑指南： 如果要对某个外部变量进行持续“跟踪”那么应该使用ref方向描述符， 并且在task中对其跟踪。  package中可以定义什么类型?  回答： package中可以定义数据变量、方法(task/function) 、DPI方法声明、class、parameter、cover group和property(断言属性) 等。 关键词： package 避坑指南： package中不可以包含(或编译)module和interface哦~  持续更新\n","description":"","id":5,"section":"docs","tags":null,"title":"SV与UVM每日一问","uri":"https://www.wenhui.space/docs/digital_verifer/creation/sv_uvm_daily_question/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第六篇，主要介绍覆盖率类型、功能覆盖策略、覆盖组、数据采样、覆盖选项和数据分析。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      覆盖率类型 概述  覆盖率是衡量设计验证完备性的一个通用词。 随着测试逐步覆盖各种合理的组合，仿真过程会慢慢勾画出你的设计情况。 覆盖率工具会在仿真过程中收集信息，然后进行后续处理并且得到覆盖率报告。 通过这个报告找出覆盖之外的盲区，然后修改现有的测试或者创建新的测试来填补这些盲区。 这个过程可以一直迭代进行，直到你对覆盖率满意为止。  可以使用一个反馈回路来分析覆盖率的结果，并决定采取哪种行动来达到100%的覆盖率。 首要的选择是使用更多的种子来运行现有的测试程序。 当大量种子依然对于覆盖率增长没有帮助时，需要建立新的约束。 只有在确实需要的时候才会求助于创建定向测试。    代码覆盖率   不添加任何额外的HDL代码，工具会通过分析源代码和增加隐藏代码来自动完成代码覆盖率的统计。\n  当运行完所有测试，代码覆盖率工具便会创建相应的数据库。\n  仿真器都带有代码覆盖率的工具，覆盖率数据也可被转换为可读格式。\n  行覆盖率：多少行代码已经被执行过。\n  路径覆盖率：在穿过代码和表达式的路径中有哪些已经被执行过。\n  翻转覆盖率：哪些单位比特变量的值为0或1。\n  状态机覆盖率：状态机哪些状态和状态转换已经被访问过。\n  代码覆盖率最终的结果用于衡量你执行了设计中的多少代码。\n  关注点应该放在设计代码的分析上，而不是测试平台。\n  未经测试的设计代码里可能隐藏硬件漏洞，也可能仅仅就是冗余的代码。\n  代码覆盖率衡量的是测试对于硬件设计描述的”实现”究竟测试得有多彻底，而非针对验证计划。\n  代码覆盖率达到了100%，并不意味着验证的工作已经完成，但代码覆盖率100%是验证工作完备性的必要条件。\n  断言覆盖率  断言是用于一次性地或在一段时间对一个或者多个设计信号在逻辑或者时序上的声明性代码。 断言可以跟随设计和测试平台一起仿真，也可以被形式验证工具所证实。 你可以使用SV的程序性代码编写等效性检查， 但使用SVA(SV断言)来表达会更容易。 断言最常用于查找错误，例如两个信号是否应该互斥，或者请求与许可信号之间的时序等。 一旦检测到问题，仿真就可以立即停止。 有些断言可以用于查找感兴趣的信号值或者设计状态。 可以使用cover property来测量这些关心的信号值或者状态是否发生。 在仿真结束时，仿真工具可以自动生成断言覆盖率数据。 断言覆盖率数据以及其它覆盖率数据都会被集成在同一个覆盖率数据库中，verifier可以对其展开分析。  功能覆盖率  验证的目的就是确保设计在实际环境中的行为正确。 功能描述文档详细说明了设计应该如何运行，而验证计划则列出了相应的功能应该如何激励、验证和测量。 当你收集测量数据希望找出那些功能已经被覆盖时，你其实就是在计算”设计”的覆盖率。 功能覆盖率是和功能设计意图紧密相连的，有时也被称为”描述覆盖率”，而代码覆盖率则是衡量设计的实现情况。 某个功能在设计中可以被遗漏，代码覆盖率不能发现这个错误，但是功能覆盖率可以。        每一次仿真都会产生一个带有覆盖率信息的数据库，记录随机游走的轨迹。 把这些信息全部合并在一起就可以得到功能覆盖率，从而衡量整体的进展程度。 通过分析覆盖率数据可以决定如何修改回归测试集。 如果覆盖率在稳步增长，那么添加新种子或者加长测试实际即可。 如果覆盖率增速放缓，那么需要添加额外的约束来产生更多”有意思”的激励。 如果覆盖率停止增长，然而设计某些测试点没有被覆盖到，那么就需要创建新的测试了。 如果覆盖率为100%但依然有新的设计漏洞，那么覆盖率可能没有覆盖到设计中的某些设计功能区域。  漏洞率曲线  在一个项目实施期间，你应该保持追踪每周有多少个漏洞被发现。 一开始，当你创建测试程序时，通过观察可能就会发现很多漏洞。 当设计逐渐稳定时，你需要利用自动化的检查方式来协助发现可能的漏洞。 在设计临近流片时，漏洞率会下降，甚至有望为零。即便如此，验证工作仍然不能结束。 每次漏洞率下降时，就应该寻找各种不同的办法去测试可能的边界情况(corner case)。 漏洞率可能每周都有变化，这跟很多因素都有关。不过漏洞率如果出现意外的变化，可能预示着潜在的问题。  功能覆盖策略 收集信息而非数据  比如MCDF， 你需要关心的是合法的寄存器地址和非法的寄存器地址，可写的寄存器域和非法的寄存器域，而不是具体的寄存器地址数值。 一旦关注的地方着眼于感兴趣的状态，而不是具体数值，那么这对于你如何定义功能覆盖率，以及如何收集信息会减轻很大的负担。 设计信号如果数量范围太大，应该拆分为多个小范围再加上边界情况。  只测量需要的内容  Verifier需要懂得， 在使能覆盖率收集时， 这一特性会降低很大的仿真性能。 由于收集功能覆盖率数据的开销很大，所以应该只测量你会用来分析并且改进测试的那部分数据。 同时也需要设定合理的覆盖率采样的事件，一方面提升采样效率，一方面也可以降低收集覆盖率的开销。  验证的完备性  完备的覆盖率测量结果和漏洞增长曲线，可以帮助确认设计是否被完整地验证过。 如果代码覆盖率低但功能覆盖率高，这说明验证计划不完整，测试没有执行设计的所有代码。 如果代码覆盖率高但功能覆盖率低，这说明即使测试平台很好地执行了设计所有代码，但是测试还是没有把设计定位到所有感兴趣的状态上。 你的目标是同时驱动高的代码覆盖率和功能覆盖率。  覆盖组 概述  覆盖组(covergroup) 与类相似， 一次定义后便可以多次实例化。 covergroup可以包含一个或者多个coverpoint， 且全都在同一时间采集。 covergroup可以定义在类中，也可以定义在interface或者module中。 covergroup可以采样任何可见的变量，例如程序变量、接口信号或者设计端口。 一个类里可以包含多个covergroup。 当你拥有多个独立的covergroup时， 每个covergroup可以根据需要自行使能或者禁止。 每个covergroup可以定义单独的触发采样事件，允许从多个源头收集数据。 covergroup必须被例化才可以用来收集数据。  在类里定义covergroup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Transactor; Transaction tr; mailbox mbx_in; covergroup CovPort; coverpoint tr.port; endgroup function new(mailbox mbx_in) ; //CovPort = new() ;  CovPort cg1 = new() ; //使用这种例化方式可以给对象设定名字  this.mbx_in=mbx_in; endfunction task main; forever begin tr=mbx_in.get; ifc.cb.port \u0026lt;= tr.port; ifc.cb.data \u0026lt;= tr.data; CovPort.sample() ; end endtask endclass    covergroup由采样的数据和数据被采样的事件构成。 当这两个条件都准备好以后，测试平台便会触发covergroup。 这个过程可以通过直接使用sample() 函数完成， 也可以在covergroup中采样阻塞表达式或者使用wait或@实现在信号或事件上的阻塞。 如果你希望在代码中显式地触发covergroup采样， 或者不存在采样时刻的信号或事件， 又或者一个covergroup被例化为多个实例需要单独触发， 那么可以使用sample()方法。 如果你想借助已有的事件或者信号触发covergroup， 可以在covergroup声明中使用阻塞语句。   1 2 3 4  event trans_ready； covergroup CovPort @(trans_ready) ； coverpoint ifc.cb.port; endgroup    与直接调用sample() 相比， 使用事件触发的好处在于你能够借助已有的事件。  数据采样 概述  当你在coverpoint指定采样一个变量或表达式时， SV会创建很多的”仓(bin) ”来记录每个数值被捕捉到的次数。 这些bin是衡量功能覆盖率的基本单位。 covergroup中可以定义多个coverpoint， coverpoint中可以自定义多个cover bin或者SV帮助自动定义多个cover bin（建议自己定义，原因有两点：一是工具可能会多定义其他的bin，二是工具定义的bin不能很好的命名，基于这两点，自己定义bin在覆盖率分析时更容易）。 每次covergroup采样， SV都会在一个或者多个cover bin中留下标记， 用来记录采样时变量的数值和匹配的cover bin。 在仿真之后，可以使用分析工具读取这些数据库来生成覆盖率报告，包含了各部分和总体的覆盖率。  coverpoint和bin  为了计算一个coverpoint上的覆盖率， 首先需要确定可能数值的个数，这也被称为域。 覆盖率就是采样值的数目除以bin的数目。例如一个3比特变量的域是0：7， 正常情况下会自动分配8个bin。如果仿真过程中有7个值被采样到， 那么最终该coverpoint的覆盖率是7/8。 所有的coverpoint的覆盖率最终构成一个covergroup的覆盖率。 所有的covergroup的覆盖率构成了整体的功能覆盖率。  bin的创建和应用  SV会默认为某个cover point创建bin， 用户也可以自己定义bin的采样域。 如果采样变量的域范围过大而又没有指定bin， 那么系统会默认分配64个bin， 将值域范围平均分配给这64个bin。 用户可以通过covergroup的选项auto_bin_max来指定自动创建bin的最大数目（默认64）。 实际操作中， 自动创建bin的方法不实用， 建议用户自行定义bin，或者减小auto_bin_max的数值。   1 2 3 4 5  covergroup CovPort; options.auto_bin_max=8; //所有cover point auto_bin数量=8  coverpoint tr.port {options.auto_bin_maxm 2; } //特定cover point auto_bin数量=2 endgroup   命名coverpoint和bin 1 2 3 4 5 6 7 8  covergroup CovKind; coverpoint tr.kind{ bins zero=(0) ; //1个仓代表kind==0  bins lo=([1：3] ， 5) ; //1个仓代表1:3和5  bins hi[] =([8：S] 1; //8个独立的仓代表8:15  bins misc=default; //1个仓代表剩余的所有值  }//没有分号 endgroup    注意coverpoint定义使用{} 而不是begin\u0026hellip;end。大括号的结尾没有带分号， 这和end一样。  条件覆盖率  可以使用关键词iff给coverpoint添加条件。 这种做法常用于在复位期间关闭覆盖以忽略不合理的条件触发。 也可以使用start和stop函数来控制covergroup各个独立实例。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  covergroup CoverPort; coverpoint port iff (!bus_if.reset); endgroup //===========================================  initial begin CovPort ck = new(); #1ns; ck.stop(); bus_if.reset=1; #100ns bus_if.reset=0; ck.start(); ck.sample(); end   翻转覆盖率  coverpoint也可以用来记录变量从A值到B值的跳转情况。 还可以确定任何长度的翻转次数。   1 2 3 4 5  covergroup CoverPort; coverpoint port { bins t1 = (0=\u0026gt;1), (0=\u0026gt;2), (0=\u0026gt;3); } endgroup   wildcard覆盖率  可以使用关键字wildcard来创建多个状态或者翻转。 在表达式中，任何x，z或者?都会被当成0或1的通配符。   1 2 3 4 5 6 7  bit [2:0] port; covergroup CoverPort; coverpoint port{ wildcard bins even={3\u0026#39;b??0}; wildcard bins odd={3\u0026#39;b??1} } endgroup   忽略bin  在某些coverpoint可能始终无法得到全部的域值。 对于那些不计算功能的域值可以使用ignore_bins来排除， 最终它们并不会计入coverpoint的覆盖率。   1 2 3 4 5  bit[2:0] low_ports_0_5; //只使用数值0-5 covergroup CoverPort; coverpoint low_ports_0_5 { ignore_bins hi={[6, 7]}; //忽略数值6-7 endgroup   非法的bin  有些采样值不仅应该被忽略，而且如果出现还应该报错。 这种情况可以在测试平台中监测， 也可以使用illegal_bins对特定的bin进行标示。   1 2 3 4 5 6  bit[2:0] low_ports_0_5; //只是用数值0-5 covergroup CoverPort; coverpoint low_ports_0_5{ illegal_bins hi={[6, 7]}; //如果出现6-7便报错  } endgroup   交叉覆盖率  coverpoint是记录单个变量或者表达式的观测值。 如果想记录在某一时刻，多个变量之间值的组合情况，需要使用交叉(cross) 覆盖率。 cross语句只允许带coverpoint或者简单的变量名。   1 2 3 4 5 6 7 8 9 10 11  class Transaction; rand bit[3：0] kind; rand bit[2：0] port; endclass Transaction tr; covergroup CovPort; kind: coverpoint tr.kind; //kind是coverpoint名称  port: coverpoint tr.port; //port是coverpoint名称  cross kind, port; endgroup   排除部分cross bin  通过使用ignore bins、binsof和intersect分别指定coverpoint和值域， 这样可以清除很多不关心的cross bin。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  covergroup Covport; port: coverpoint tr.port { bins port[] = {[O:$]}; } kind: coverpoint tr.kind { bins zero = {0}; bins lo = {[1:3]}; bins hi[] = {[8:$]}; bins misc = default; } cross kind, port { ignore_bins hi = binsof(port) intersect {7}; ignore_bins md = binsof(port) intersect {0} \u0026amp;\u0026amp; binsof(kind) intersect {[9:11]}; ignore_bins lo = binsof(kind.lo); } endgroup    原来port有8个bin，kind有11个bin，正常cross会产生88个bin，通过ignore_bins，hi排除了11个，md排除了3个，lo排除了24个。具体自行分析。  指定精细的交叉覆盖率  随着cross覆盖率越来越精细， 可能需要花费不少的时间来指定哪些bin应该被使用或者被忽略。 更适合的方式是不使用自动分配的cross bin， 而自己声明感兴趣的cross bin。 假如有两个随机变量a和b，它们带着三种感兴趣的状态，(a==0，b==0)、(a==1、b==0)和(b==1)。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Transaction; rand bit a, b; endclass covergroup CrossBinNames; a: coverpoint tr.a { bins a0 = {0}; bins a1 = {1}; option.weight=0; } //不计算覆盖率  b: coverpoint tr.b { bins b0 = {0}; bins b1 = {1}; option.weight=0; } //不计算覆盖率  ab: cross a, b { bins aOb0 = binsof(a.a0) \u0026amp;\u0026amp; binsof(b.b0); bins a1b0 = binsof(a.a1) \u0026amp;\u0026amp; binsof(b.b0); bins b1 = binsof(b.bl);} endgroup   1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Transaction; rand bit a, b; endclass covergroup CrossBinsofIntersect; a: coverpoint tr.a { option.weight=0; } //Do nOt count this cover point  b: coverpoint tr.b { option.weight=0; } //Do nOt count this cover point  ab: cross a, b { bins aOb0 = binsof(a) intersect{O} \u0026amp;\u0026amp; binsof(b) intersect{O}; bins alb0 = binsof(a) intersect{1} \u0026amp;\u0026amp; binsof(b) intersect{O}; bins b1 = binsof(b) intersect{1}; } endgroup   覆盖选项 单个实例的覆盖率  如果对一个covergroup例化多次， 那么默认情况下SV会将所有实例的覆盖率合并到一起。如果需要单独列出每个covergroup实例的覆盖率，需要设置覆盖选项。   1 2 3 4  covergroup CoverLength; coverpoint tr.length; option.per_instance=l; //每个实例单独收集 endgroup   注释  如果有多个covergroup实例， 可以通过参数来对每一个实例传入单独的注释。这些注释最终会显示在覆盖率数据的总结报告中。   1 2 3 4 5 6 7 8 9 10 11 12  covergroup CoverPort(int lo, hi, string comment); option.comment = comment; option.per_instance = 1; coverpoint port { bins range= {[lo:hi]}; } endgroup ... CoverPort cp_lo = new(0, 3, \u0026#34;Low port numbers\u0026#34;); CoverPort cp_hi = new(4, 7, \u0026#34;High port numbers\u0026#34; ;   覆盖次数限定  默认情况下， 数值采样了1次就可以计入有效的bin。可以通过修改atleast来修改每个bin的数值最少的采样次数， 如果低于at_least数值， 则不会被计入bin中。 option.at_least可以在covergroup中声明来影响所有的coverpoint，也可以在coverpoint中声明来只影响该coverpoint下所有的bin。 一般会使用默认的1，除非有特殊要求。  覆盖率目标  一个covergroup或者一个coverpoint的目标是100%覆盖率。 不过你也可以将其设置为低于100%的目标。这个选项只会影响覆盖率报告。 一般会使用默认的100，除非有特殊要求。   1 2 3 4  covergroup CoverPort; coverpoint port; option.goal=90; endgroup   covergroup方法  sample() ： 采样。 get_coverage() /get_inst_coverage() ： 获取覆盖率，返回0-100的real数值。 set_inst_name(string) ： 设置cover group的名称。 start() /stop() ： 使能或者关闭覆盖率的收集。  数据分析  使用$get_coverage() 可以得到总体的覆盖率。 也可以使用covergroup_inst.get_inst_coverage() 来获取单个covergroup实例的覆盖率。 这些函数最实际的用处是在一个测试当中监测覆盖率的变化。 如果覆盖率水平在一段时间之后没有提高，那么这个测试就应该停止。 重启新的随机种子或者测试可能有望提高覆盖率。 如果测试可以基于功能覆盖率采取一些深入的行动，例如重新限定随机的约束，那将是一件非常好的事情，但是这种测试很难编写。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":6,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（六）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_six/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第五篇，主要介绍线程的使用、线程的控制和线程的通信。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      线程的使用 程序和模块  module（模块）作为SV从verilog继承过来的概念，自然地保持了它的特点，除了作为RTL模型的外壳包装和实现硬件行为，在更高层的集成层面，模块之间也需要通信和同步。 对于硬件的过程块，他们之间的通信可理解为不同逻辑/时序块之间的通信或同步，是通过信号的变化来完成的。 从硬件实现角度来看，Verilog通过Always、initial过程语句块和信号数据连接实现进程间通信。 我们可以将不同的module作为独立的程序块，他们之间的同步通过信号的变化（event触发）、等待特定事件（时钟周期）或时间（固定延时）来完成。 如果按照软件的思维理解硬件仿真，仿真中各个模块首先是独立运行的线程（thread）。 模块（线程）在仿真一开始便并行执行，除了每个线程会依照自身内部产生的事件来触发过程语句块之外，也同时依靠相邻模块间信号变化来完成模块之间的线程同步。       什么是线程  线程即独立运行的程序。 线程需要被触发，可以结束或者不结束。 在module中的initial和always，都可以看做独立的线程，它们会在仿真0时刻开始，而选择结束或者不结束（对initial而言）。 硬件模型中由于都是always语句块，所以可以看成是多个独立运行的线程，而这些线程会一直占用仿真资源，因为它们不会结束。 软件测试平台中的验证环境都需要initial语句块去创建，而在仿真过程中，验证环境中的对象可以创建和销毁，因此软件测试端的资源占用是动态的。 软件环境中的initial块对语句有两种分组方式，使用 begin\u0026hellip;end 或 fork\u0026hellip;join。 begin\u0026hellip;end 中的语句是顺序执行的，而 fork\u0026hellip;join 中的语句是并发执行的。 与 fork\u0026hellip;join 类似的并发执行语句还有 fork\u0026hellip;join_any 和 fork\u0026hellip;join_none。  线程的概念澄清  线程的执行轨迹是呈树状结构的，即任何线程都应该有父线程。 父线程可以开辟若干子线程，父线程可以暂停或终止子线程。 当子线程终止时，父线程可以继续执行。 当父线程终止时，其开辟的所有子线程都应当会终止。  线程的控制 fork并行线程语句块      fork\u0026hellip;join  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join $display(\u0026#34;@%0t: after join\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join example @10: sequential after #10 @10: parallel start @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @60: after join @140: finish after 80  总结：可见fork\u0026hellip;join内是并行执行的，initial块内程序作为父线程，并创建了四个子线程。  $display\u0026hellip; #50 $display\u0026hellip; #10 $display\u0026hellip; begin #30 $display\u0026hellip; #10 $display\u0026hellip; end    fork\u0026hellip;join_any  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join_any example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join_any $display(\u0026#34;@%0t: after join_any\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join_any example @10: sequential after #10 @10: parallel start @10: after join_any @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @90: finish after 80  总结：子线程的创建与fork\u0026hellip;join是一致的，不同的是，fork\u0026hellip;join要等所有子线程执行完毕才会继续执行父线程的程序，而fork\u0026hellip;join_any中只要有一个子线程（最短的）执行完毕，父线程的程序就会被执行的。  fork..,join_none  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join_none example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join_none $display(\u0026#34;@%0t: after join_none\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join_none example @10: sequential after #10 @10: after join_none @10: parallel start @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @90: finish after 80  总结：子线程的创建与fork\u0026hellip;join是一致的，不同的是，fork\u0026hellip;join要等所有子线程执行完毕才会继续执行父线程的程序，而fork\u0026hellip;join_none中父线程与子线程是并行执行的。  等待所有衍生线程  在SV中，当程序中的initial块全部执行完毕，仿真器就退出了，也就是如果以上测试代码中没有最后的\u0026hellip;finish after\u0026hellip;语句，对于join_any和join_none其子线程没有全部执行完毕仿真就结束了。 如果需要等待所有fork块中的子线程全部执行完毕在退出结束initial块，可以使用wait fork语句来等待所有子线程结束。   1 2 3 4 5 6 7 8 9 10 11 12  task run_thread; ... fork check_trans(tr1); //thread1  check_trans(tr2); //thread2  check_trans(tr3); //thread3  join_none ... // 等待所有fork中的线程结束  wait fork; endtask   停止单个线程  在使用了fork\u0026hellip;join_any和fork\u0026hellip;join_none以后，我们可以使用disable来指定需要停止的线程。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  parameter TIME_OUT = 1000; task check_trans(transaction tr); fork begin // 等待回应或达到某个最大延时  fork : timeout_block begin wait (bus.cb.addr == tr.addr); $display(\u0026#34;@%0t: Addr match %d\u0026#34;, $time, tr.addr); end #TIME_OUT $display(\u0026#34;@%0t: Error: timeout\u0026#34;, $time); join_any disable timeout_block; end join_none endtask   停止多个线程  disable fork可以停止从当前线程中衍生出来的所有子线程。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  initial begin check_trans(tr0); //线程0  //创建一个线程来控制disable fork的作用范围  fork //线程1  begin check_trans(tr1); //线程2  fork //线程3  check_trans(tr2); //线程4  join // 停止线程1-4， 单独保留线程0  #(TIME_OUT/2) disable fork; end join end    其实最准确的关闭线程的方法是，给定线程的标号，关闭指定的线程。  停止被多次调用的任务  如果给线程指明标号，那么当这个任务或线程被多次调用后，使用disable去终止这个线程时，会将所有的同名线程全部终止。 在创建task时，如果使用disable进程标号，一定要确认该task是否会被多处调用，如果多处调用要避免使用disable进程标号。  线程的通信 概述  测试平台中的所有线程都需要同步并交换数据。 一个线程可能需要等待另一个线程。 多个线程可能同时访问同一个资源。 线程之间可能需要交换数据。 所有这些数据交换和同步称之为线程间的通信（IPC，Interprocess Communication）。  event事件  verilog中，一个线程总是要等待一个带@操作符的事件。这个操作符是边沿敏感的，所以它总是阻塞着、等待着事件的变化。 其他线程可以通过-\u0026gt;操作符来触发事件，结束对一个线程的阻塞。 这就像在打电话时，一个人等待另一个人的呼叫。 测试代码（注意，event需声明而不需要new）：   1 2 3 4 5 6 7 8 9 10 11 12 13 14  event el,\te2; initial begin $display(\u0026#34;@t0t: 1: before trigger\u0026#34;, $time); -\u0026gt; el; @e2; $display(\u0026#34;@%0t: 1: after trigger\u0026#34;, $time); end initial begin $display(\u0026#34;@t0t: 2: before trigger\u0026#34;, $time); -\u0026gt; e2; @e1; $display(\u0026#34;@t0t: 2: after trigger\u0026#34;, $time); end    测试结果：   @0: 1: before trigger @0: 2: before trigger @0: 1: after trigger  总结：  第一个initial启动，触发e1事件，然后阻塞在e2上。 第二个initial启动，触发e2事件，然后阻塞在e1上。 e1和e2同一时刻被触发，但由于delta cycle的时间差使得两个initial块可能无法等到e1或e2。（根据上面的执行结果，可以分析得出，虽然是同一时刻，initial 1 还是被先执行了，先打印了before，然后拨打了电话（e1），然后等待接电话（e2），此时initial 2被执行，打印了before，拨打电话（e2），此时initial已经等待接听电话，所以initial 1打印了after，也就是接通了电话，而initial 2是接不到电话的，因为在接听之前tinitial 1已经拨出去了，所以没有打印出after） 也就是，等待事件触发要在事件发生之前，否则将错过事件，所以，更安全的方式可以使用event的方法triggered()，相当于为拨打电话提供了留言功能。   测试代码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14  event el,\te2; initial begin $display(\u0026#34;@t0t: 1: before trigger\u0026#34;, $time); -\u0026gt; el; wait (e2.triggered()); $display(\u0026#34;@%0t: 1: after trigger\u0026#34;, $time); end initial begin $display(\u0026#34;@t0t: 2: before trigger\u0026#34;, $time); -\u0026gt; e2; wait (e1.triggered()); $display(\u0026#34;@t0t: 2: after trigger\u0026#34;, $time); end    测试结果：   @0: 1: before trigger @0: 2: before trigger @0: 1: after trigger @0: 2: after trigger  总结：  对于triggered()而言，如果事件在当前时刻已经被触发，则不会引起阻塞，否则会一直等到事件被触发为止。 这个方法相对@而言，更与能力保证，只要event被触发过，就可以防止引起阻塞。    通知的需求  不同的线程之间，有时会有互相告知的需求。比如，我们要开一辆车，在踩油门要行驶之前，首先得看一下汽车有没有发动，那么这辆车可能是这样设计的：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module road; initial begin automatic car byd = new(); byd.drive(); end endmodule class car; bit start=0; task launch(); start=1; $display(”car is launched”); endtask task move(); wait(start==1); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; join endtask endclass //输出结果： // car is launched // car is moving    以上的例子可以看出，两个线程launch和move是通过线程间共享变量car::start和wait语句来实现了线程launch通知线程move的功能。 我们也可以将线程间共享变量car::start改为事件来触发。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class car; event e_start; task launch(); -\u0026gt; e_start; $display(”car is launched”); endtask task move(); wait(e_start.triggered()); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; join endtask endclass    当汽车要加速的时候，添加速度显示功能：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  module road; initial begin automatic car byd = new(); byd.drive(); byd.speedup(); byd.speedup(); byd.speedup(); end endmodule class car; event e_start; event e_speedup; int speed = 0; ...... task speedup(); #10ns; -\u0026gt; e_speedup; endtask task display(); forever begin @e_speedup; speed++; $display(\u0026#34;speed is %0d\u0026#34;, speed); end endtask task launch(); start=1; $display(”car is launched”); endtask task move(); wait(start==1); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; this.display() ; join_none endtask endclass //输出结果： // car is launched // car is moving // speed is 1 // speed is 2 // speed is 3     这里有两点值得分析：\n 为什么使用@e_speedup？因为使用 triggered的话，再第一次触发以后，下次会认为已经触发过而不再继续等待触发，这和设计功能是违背的，这里需要对@和triggerd按功能区分使用（UVM中提供一种event使用方式，当第一次事件触发以后，会清除此次触发，这样就不存在triggerd的问题了）。 为什么改为join_none？ 因为父线程中的speedup需要和三个子线程并行执行。    总结：\n 从这个汽车加速的例子来看，如果你需要一直踩着油门不放的话，这个加速的event必定会被不断触发，而当线程A要给线程B传递超过一次事件时，使用公共变量就不再是一个好的选择了。 通过event的触发，可以多次通知另一个线程，注意此时应该使用@。    semaphore旗语  semaphore可以实现对同一资源的访问控制。 对于初学者而言，无论线程之间在共享什么资源，都应该使用semaphore等资源访问控制的手段， 以此避免可能出现的问题。 semaphore有三种基本操作。new() 方法可以创建一个带单个或者多个钥匙的semaphore，使用get() 可以获取一个或者多个钥匙，而put()可以返回一个或者多个钥匙。 如果你试图获取一个semaphore而希望不被阻塞， 可以使用try_get() 函数。它返回1表示有足够多的钥匙， 而返回0则表示钥匙不够。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  program automatic test(bus_ifc.TB bus); semaphore sem; //创建一个semaphore  initial begin sem=new(1) ; //分配一个钥匙  fork sequencer() ; //产生两个总线事务线程  sequencer() ; join end task sequencer; repeat($urandom%10) //随机等待0-9个周期  @bus.cb; send Trans() ; //执行总线事务  endtask task sendTrans; sem.get(1) ; //获取总线钥匙  @bus.cb; //把信号驱动到总线上  bus.cb.addr\u0026lt;=t.addr; ...... sem.put(1) ; //处理完成时把钥匙返回  endtask endprogram     线程之间除了”发球”和接球”这样的打乒乓以外，还有更深入的友谊，比如共用一些资源。\n  对于线程间共享资源的使用方式， 应该遵循互斥访问(mutex access) 原则。\n  控制共享资源的原因在于，如果不对其访问做控制，可能会出现多个线程对同一资源的访问，进而导致不可预期的数据损坏和线程的异常，这种现象称之为\u0026quot;线程不安全\u0026rdquo;。\n  以这里比亚迪为例：\n   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  class car; semaphore key; function new(); key=new(1) ; endfunction task get_on(string p); $display(\u0026#34;%s is waiting for the key\u0026#34;, p); key.get(); #1ns; $display(\u0026#34;%s got on the car\u0026#34;, p); endtask task get_off(string p); $display(\u0026#34;%s got off the car\u0026#34;, p); key.put(); #1ns; $display(\u0026#34;%s returned the key\u0026#34;, p); endtask endclass module family; car byd=new(); string p1=\u0026#34;husband\u0026#34;; string p2=\u0026#34;wife\u0026#34;; initial begin fork begin//丈夫开车  byd.get_on(p1); byd.get_off(p1); end begin//妻子开车  byd.get_on(p2); byd.get_off(p2); end join end endmodule //打印结果 // husband is waiting for the key // wife is waiting for the key // husband got on the car // husband got off\tthe car // husband returned the key // wife got on the car // wife got off the car // wife returned the key    一开始在拿到这辆车的时候，只有一把钥匙，而丈夫和妻子如果都想开车的话，也得遵循先到先得的原则。所以，当丈夫和妻子同时都想用车的时候， 一把钥匙(semaphore key) 只可以交给他们中的一位， 另外一位则需要等待，直到那把钥匙归还之后才可以使用。 从上面的输出结果来看，也是能够看出来，虽然丈夫和妻子在同一时间想开这辆车，然而也只能允许一位家庭成员来驾驶。直到丈夫从车上下来，归还了钥匙以后，妻子才可以上车。 我们用这个生动的例子来解释semaphore对于控制访问共享资源的帮助， 从上面对于semaphore key的使用来看， key在使用前必须要做初始化，即要告诉用户它原生自带几把钥匙。 从例子来看，它只有1把钥匙，而丈夫和妻子在等待和归还钥匙时，没有在semaphore::get() /put() 函数中传递参数， 即默认他们等待和归还的钥匙数量是1。semaphore可以被初始化为多个钥匙， 也可以支持每次支取和归还多把钥匙用来控制资源访问。 semaphore存在一些问题，这些问题就需要在coding时格外注意。  即使semaphore中没有钥匙，仍然可以执行还钥匙。 即使A拿到了钥匙，B没拿到钥匙，B仍然可以还钥匙。    mailbox信箱  线程之间如果传递信息，可以使用mailbox，mailbox和队列queue有相近之处。 mailbox是一种对象，因此也需要使用new()来例化。例化时有一个可选的参数size来限定其存储的最大数量。如果size是0或者没有指定，则信箱是无限大的，可以容纳任意多的条目。 使用put()可以把数据放入mailbox，使用get()可从信箱移除数据。 如果信箱为满，则put()会阻塞；如果信箱为空，则get()会阻塞。 peek()可以获取对信箱里数据的拷贝而不移除它。 线程之间的同步方法需要注意，哪些是阻塞方法，哪些是非阻塞方法，即哪些是立即返回的，而哪些可能需要等待时间的。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  program automatic bounded; mailbox mbx; initial begin mbx=new(1); //容量为1  fork //Producer线程  for(inti=1; i\u0026lt;4; i++) begin $display(\u0026#34;Producer: before put(%0d)\u0026#34;, i); mbx.put(i); $display(\u0026#34;Producer: after put(%0d)\u0026#34;, i); end //consumer线程  repeat(3) begin int j; #1ns mbx.get(j); $display(\u0026#34;Consumer: after get(%0d)\u0026#34;, j); end join end endprogram //测试结果 // Producer: before put(1) // Producer: after put(1) // Producer: before put(2) // Consumer: after get(1) // Producer: after put(2) // Producer: before put(3) // Consumer: after get(2) // Producer: after put(3) // Consumer: after get(3)    mailbox和queue的区别：  maibox必须通过new() 例化， 而队列只需要声明。 mailbox可以将不同的数据类型同时存储，不过这么做是不建议的；对于队列来讲，它内部存储的元素类型必须一致。 maibox的存取方法put() 和get() 是阻塞方法，即使用时方法不一定立即返回；而队列所对应的存取方式，push_back()和pop_front()方法是非阻塞的，会立即返回。注意在用队列时要先判断空满，根据功能需求可以用wait等待，也可以使用if判断；此外调用阻塞方法时，要在task中调用，因为阻塞方法是耗时的，调用非阻塞可以在task也可以在function。 mailbox只能够用作FIFO，而queue除了按照FIFO使用，还有其它应用的方式例如LIFO(Last In First Out) 。 对于mailbox变量的操作， 在传递形式参数时，实际传递并拷贝的是mailbox的指针；等同于队列参数声明为ref，也就是指针，区别就是对参数是引用而不是拷贝。   关于mailbox的其它特性：  mailbox在例化时， 通过new(N) 的方式可以使其变为定长(fixed length)容器。这样在负载到长度N以后， 无法再对其写入。如果用new() 的方式， 则表示信箱容量不限大小。 除了put() /get() /peek() 这样的阻塞方法， 用户也可以考虑使用try_put() /try_get() /try_peek() 等非阻塞方法。 如果要显式地限定mailbox中元素的类型， 可以通过mailbox #(type=T)的方式来声明。例如上面的三个mailbox存储的是int， 则可以在声明时进一步限定其类型为mailbox #(int) 。    三种通信的比较和应用  event： 最小信息量的触发，即单一的通知功能。可以用来做事件的触发， 也可以多个event组合起来用来做线程之间的同步。 semaphore： 共享资源的安全卫士。如果多线程间要对某一公共资源做访问，即可以使用此方式。 mailbox： 精小的SV原生FIFO。在线程之间做数据通信或者内部数据缓存时可以考虑使用此方式。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":7,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（五）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_five/"},{"content":"本文 主要介绍一个基于AArch64的bootloader程序框架，其结构和功能都比较简单，主要为CPU验证使用。\n   版本 说明     0.1 初版发布   0.2 增加对A32的支持，并对程序结构进行了优化    背景 在CPU验证中，出于各种原因，经常需要通过汇编程序来实现定向测试，不管是TOP验证环境还是UT验证环境，都有这样的需求。\nTOP环境的定向测试就像raven测试集，提供elf文件然后生成二进制指令码存入指令存储器模型，指定复位地址，整个CPU就可以运行起来了。我们的汇编程序定向测试也可以生成elf文件，使用同样的方式运行在TOP验证环境，当然这里的功能正确性的保证还需要ARM提供的参考模型fastmodel，我们需要做的仅仅是想办法灌入测试指令。\nUT环境中，有些与指令耦合度较高的模块，使用汇编程序的测试用例也是很有必要的。这里与指令耦合度高是指，容易从指令码转换为模块接口信号，比如DPU模块，DPU前接IFU模块，IFU对指令码进行预译码然后交给DPU，这里在DPU验证环境中只需要将IFU的预译码逻辑植入就可以将指令码转为DPU的接口信号，从而实现汇编程序定向测试的支持。\n工具下载 ARM编译器下载网址：https://releases.linaro.org/components/toolchain/binaries/。\n本文AArch64使用aarch64-linux-gnu； AArch32使用armv8l-linux-gnueabihf。\nBootloader需要做什么 以下只是我这个非专业人士的了解，仅供参考。\n 初始化系统寄存器 设置异常向量表 初始化栈和堆 检查和初始化外设 初始化内存管理、开启mmu和cache \u0026hellip;\u0026hellip;  而我们只需要完成系统寄存器的初始化和异常向量表，如果使用c程序的话需要初始化栈。\nAArch64 文件结构 ├── hello.c ├── Makefile └── sys ├── asmlib.s ├── evt.s ├── link.lds ├── main_test.s ├── Makefile.rule ├── start.s └── sysregs_init.s 主要程序在sys目录下，每个文件内容后文会一一说明。hello.c是测试程序，可以自己定义，可以是汇编程序，也可以是简单的c程序。\nstart.s start.s是主程序，也是整个程序的入口。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  .global _start _start: bl _disable_mp bl _sysregs_init bl _stack_init bl _el3_to_el0_ns .global _test _test: //for test code //---------------------------- //el0 test bl _main_test //el1 test svc #0x0  bl _main_test //el2 test hvc #0x0  bl _main_test //el3 test smc #0x0  bl _main_test //---------------------------- bl _end_cpu b .    global： 声明标号为全局，这样其他文件程序可以直接使用该标号 这里通过svc hvc smc来产生异常，改变exception level，来实现在不同level下测试程序，如果不需要可以将bl _main_test注释掉，注意这里exception level的改变需要配合异常处理程序来实现。 start程序就是整个程序的入口，并在这里调用其他子程序。  evt.s evt.s是指异常向量表（exception vector table），异常向量表是ARM定义好的，可以查看之前文章，这里只是按照异常向量表来进行代码实现，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463  /* Vector offsets from vector table base address |--------------------------------------------------------------------------------------------------| | Exception taken from | Offset for exception type | | | Synchronous | IRQ or vIRQ | FIQ or vFIQ | SError or vSError| |*************************************|*************|*************|*************|******************| | Current Exception level with SP_EL0.| 0x000 | 0x080 | 0x100 | 0x180 | |-------------------------------------|-------------|-------------|-------------|------------------| | Current Exception level with SP_ELx,| 0x200 | 0x280 | 0x300 | 0x380 | | x\u0026gt;0. | | | | | |-------------------------------------|-------------|-------------|-------------|------------------| | Lower Exception level, where the | 0x400 | 0x480 | 0x500 | 0x580 | | implemented level immediately lower | | | | | | than the target level is using | | | | | | AArch64. | | | | | |-------------------------------------|-------------|-------------|-------------|------------------| | Lower Exception level, where the | 0x600 | 0x680 | 0x700 | 0x780 | | implemented level immediately lower | | | | | | than the target level is using | | | | | | AArch32. | | | | | |--------------------------------------------------------------------------------------------------| */ //{{{异常路由至el1 .global _vector_table_route_to_el1 .balign 0x1000 //2K对齐，因为VBAR_EL1寄存器低11bit是reserve的 _vector_table_route_to_el1: //offset: 0x000 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el1_current_withspel0_sync //offset: 0x080 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el1_current_withspel0_irq //offset: 0x100 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el1_current_withspel0_fiq //offset: 0x180 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el1_current_withspel0_serror //offset: 0x200 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el1_current_withspelx_sync //offset: 0x280 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el1_current_withspelx_irq //offset: 0x300 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el1_current_withspelx_fiq //offset: 0x380 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el1_current_withspelx_serror //offset: 0x400 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el1_LoA64toHi_sync //offset: 0x480 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el1_LoA64toHi_irq //offset: 0x500 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el1_LoA64toHi_fiq //offset: 0x580 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el1_LoA64toHi_serror //offset: 0x600 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el1_LoA32toHi_sync //offset: 0x680 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el1_LoA32toHi_irq //offset: 0x700 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el1_LoA32toHi_fiq //offset: 0x780 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el1_LoA32toHi_serror //}}} //{{{异常路由至el2 .global _vector_table_route_to_el2 .balign 0x1000 //2K对齐，因为VBAR_EL2寄存器低11bit是reserve的 _vector_table_route_to_el2: //offset: 0x000 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el2_current_withspel0_sync //offset: 0x080 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el2_current_withspel0_irq //offset: 0x100 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el2_current_withspel0_fiq //offset: 0x180 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el2_current_withspel0_serror //offset: 0x200 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el2_current_withspelx_sync //offset: 0x280 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el2_current_withspelx_irq //offset: 0x300 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el2_current_withspelx_fiq //offset: 0x380 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el2_current_withspelx_serror //offset: 0x400 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el2_LoA64toHi_sync //offset: 0x480 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el2_LoA64toHi_irq //offset: 0x500 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el2_LoA64toHi_fiq //offset: 0x580 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el2_LoA64toHi_serror //offset: 0x600 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el2_LoA32toHi_sync //offset: 0x680 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el2_LoA32toHi_irq //offset: 0x700 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el2_LoA32toHi_fiq //offset: 0x780 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el2_LoA32toHi_serror //}}} //{{{异常路由至el3 .global _vector_table_route_to_el3 .balign 0x1000 //2K对齐，因为VBAR_EL3寄存器低11bit是reserve的 _vector_table_route_to_el3: //offset: 0x000 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el3_current_withspel0_sync //offset: 0x080 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el3_current_withspel0_irq //offset: 0x100 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el3_current_withspel0_fiq //offset: 0x180 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el3_current_withspel0_serror //offset: 0x200 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el3_current_withspelx_sync //offset: 0x280 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el3_current_withspelx_irq //offset: 0x300 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el3_current_withspelx_fiq //offset: 0x380 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el3_current_withspelx_serror //offset: 0x400 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el3_LoA64toHi_sync //offset: 0x480 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el3_LoA64toHi_irq //offset: 0x500 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el3_LoA64toHi_fiq //offset: 0x580 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el3_LoA64toHi_serror //offset: 0x600 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el3_LoA32toHi_sync //offset: 0x680 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el3_LoA32toHi_irq //offset: 0x700 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el3_LoA32toHi_fiq //offset: 0x780 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el3_LoA32toHi_serror //}}} //{{{异常路由至el1-子程序 //-------------------------------------------------------- //rt2el1_current_withspel0 _rt2el1_current_withspel0_sync: // eret mrs x30, elr_el1 ret _rt2el1_current_withspel0_irq: eret _rt2el1_current_withspel0_fiq: eret _rt2el1_current_withspel0_serror: eret //rt2el1_current_withspelx _rt2el1_current_withspelx_sync: // eret mrs x30, elr_el1 ret _rt2el1_current_withspelx_irq: eret _rt2el1_current_withspelx_fiq: eret _rt2el1_current_withspelx_serror: eret //rt2el1_LoA64toHi _rt2el1_LoA64toHi_sync: // eret mrs x30, elr_el1 ret _rt2el1_LoA64toHi_irq: eret _rt2el1_LoA64toHi_fiq: eret _rt2el1_LoA64toHi_serror: eret //rt2el1_LoA32toHi _rt2el1_LoA32toHi_sync: // eret mrs x30, elr_el1 ret _rt2el1_LoA32toHi_irq: eret _rt2el1_LoA32toHi_fiq: eret _rt2el1_LoA32toHi_serror: eret //}}} //{{{异常路由至el2-子程序 //rt2el2_current_withspel0 _rt2el2_current_withspel0_sync: // eret mrs x30, elr_el2 ret _rt2el2_current_withspel0_irq: eret _rt2el2_current_withspel0_fiq: eret _rt2el2_current_withspel0_serror: eret //rt2el2_current_withspelx _rt2el2_current_withspelx_sync: // eret mrs x30, elr_el2 ret _rt2el2_current_withspelx_irq: eret _rt2el2_current_withspelx_fiq: eret _rt2el2_current_withspelx_serror: eret //rt2el2_LoA64toHi _rt2el2_LoA64toHi_sync: // eret mrs x30, elr_el2 ret _rt2el2_LoA64toHi_irq: eret _rt2el2_LoA64toHi_fiq: eret _rt2el2_LoA64toHi_serror: eret //rt2el2_LoA32toHi _rt2el2_LoA32toHi_sync: // eret mrs x30, elr_el2 ret _rt2el2_LoA32toHi_irq: eret _rt2el2_LoA32toHi_fiq: eret _rt2el2_LoA32toHi_serror: eret //}}} //{{{异常路由至el3-子程序 //rt2el3_current_withspel0 _rt2el3_current_withspel0_sync: // eret mrs x30, elr_el3 ret _rt2el3_current_withspel0_irq: eret _rt2el3_current_withspel0_fiq: eret _rt2el3_current_withspel0_serror: eret //rt2el3_current_withspelx _rt2el3_current_withspelx_sync: // eret mrs x30, elr_el3 ret _rt2el3_current_withspelx_irq: eret _rt2el3_current_withspelx_fiq: eret _rt2el3_current_withspelx_serror: eret //rt2el3_LoA64toHi _rt2el3_LoA64toHi_sync: // eret mrs x30, elr_el3 ret _rt2el3_LoA64toHi_irq: eret _rt2el3_LoA64toHi_fiq: eret _rt2el3_LoA64toHi_serror: eret //rt2el3_LoA32toHi _rt2el3_LoA32toHi_sync: // eret mrs x30, elr_el3 ret _rt2el3_LoA32toHi_irq: eret _rt2el3_LoA32toHi_fiq: eret _rt2el3_LoA32toHi_serror: eret //}}}    注意，每一级异常向量要2K对齐，因为VBAR_EL3/2/1寄存器低11bit是reserve的。 注意，sync异常处理没有进行异常返回，而是使用ret返回elr，这样配合svc hvc smc指令来实现el0 -\u0026gt; el1 -\u0026gt; el2 -\u0026gt; el3。  main_test.s main_test.s只是个测试程序调用的地方，注意这里提供了check结果打印功能，最后返回时寄存器x0值为0xff的话，fail，如果不需要Check，也要保证寄存器x0值为非0xff，否则trace结果有“TEST FAILED”关键字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  .global _main_test _main_test: stp x29, x30, [sp, #-16]! //Push lr to stack  //test code is here //---------------------------------- bl hello_world // c function mov x0, #0xff  //---------------------------------- //check code is here //---------------------------------- // pass : x0=0x11 // fail : x0=0xff mov x0, #0x11  //---------------------------------- ldp x29, x30, [sp], #16 //Pop lr from stack  b _print_result   sysregs_init.s sysregs_init.s就是系统寄存器初始化，ARMv8的系统寄存器控制比较复杂，需要使用者根据具体项目进行配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  //{{{ 初始化系统寄存器 .global _sysregs_init _sysregs_init: mrs x9, CurrentEL cmp x9, #(0b11 \u0026lt;\u0026lt; 2)  b.eq 3f cmp x9, #(0b10 \u0026lt;\u0026lt; 2)  b.eq 2f cmp x9, #(0b01 \u0026lt;\u0026lt; 2)  b.eq 1f b . //系统启动不会在el0状态，这里设置个死循环 3: //scr_el3 ldr x9, =0x0000000000000430 //rtl默认的初始值 msr scr_el3, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, scr_el3 bfi x9, x10, #8, #1 // set scr_el3.hce to 1  bfi x9, x10, #0, #1 // set scr_el3.ns to 1  bfi x9, x10, #10, #1 // set scr_el3.rw to 1  msr scr_el3, x9 //cptr_el3 ldr x9, =0x0000000000000000 //rtl默认的初始值 msr cptr_el3, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, cptr_el3 bfi x9, x11, #10, #1 // set scr_el3.tfp to 0  msr scr_el3, x9 //sctlr_el3 ldr x9, =0x0000000000c50838 //rtl默认的初始值 msr sctlr_el3, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el3 msr vbar_el3, x9 2: //hcr_el2 ldr x9, =0x0000000080000002 //rtl默认的初始值 msr hcr_el2, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, hcr_el2 bfi x9, x10, #34, #1 // set hcr_el2.e2h to 1  bfi x9, x11, #27, #1 // set hcr_el2.tge to 0  bfi x9, x10, #31, #1 // set hcr_el2.rw to 1  msr hcr_el2, x9 //cptr_el2 ldr x9, =0x00000000000033ff //rtl默认的初始值 msr cptr_el2, x9 mov x10, #0x3  mov x11, #0x0  mrs x9, cptr_el2 bfi x9, x10, #20, #2 // set cptr_el2.fpen to 11  bfi x9, x11, #10, #1 // set cptr_el2.tfp to 0  msr cptr_el2, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el2 msr vbar_el2, x9 1: //cpacr_el1 ldr x9, =0x0000000000000000 //rtl默认的初始值 msr cpacr_el1, x9 mov x10, #0x3  mov x11, #0x0  mrs x9, cpacr_el1 bfi x9, x10, #20, #2 // set cpacr_el1.fpen to 11  msr cpacr_el1, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el1 msr vbar_el1, x9 //barrier instr and Synchronize the sysregs isb dsb sy ret //}}}    注意，这里 b.eq 1f 的用法，1是指标号，f代表向下寻找，这属于常用的汇编技巧。 注意，系统寄存器配置后需要使用isb指令隔离命令，是因为系统寄存器可能存在多个备份来解决负载问题，使用isb指令可以实现各个副本的更新，保持一致。  asmlib.s asmlib.s就是各个子程序的集合，包括如下：\n 关闭非主核（主要是为fastmodel跑出的trace只保留主核） 栈的初始化，初始化栈之后才可以使用c语言 打印测试结果信息 结束cpu el3切换到el0 np secure状态   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  //{{{ 关闭非主核 .global _disable_mp _disable_mp: mrs x9, mpidr_el1 and x9, x9, #0xff  cbnz x9, _cpu_sleep ret _cpu_sleep: wfi b _cpu_sleep //}}} //{{{ 初始化栈 .global _stack_init _stack_init: //STACK_TOP_ADDR = BOARD_BASE_ADDR + BOARD_MEM_SIZE - RESERVE_MEM_TOP // = RVBAR + 2G - 1M //EACH_STACK_SIZE = 64M ldr x9, =RVBAR ldr x10, =0x7ff00000 add x0, x9, x10 //x9: STACK_TOP_ADDR ldr x1, =0x04000000 //x1: EACH_STACK_SIZE mrs x9, CurrentEL cmp x9, #(0b11 \u0026lt;\u0026lt; 2)  b.eq 3f cmp x9, #(0b10 \u0026lt;\u0026lt; 2)  b.eq 2f cmp x9, #(0b01 \u0026lt;\u0026lt; 2)  b.eq 1f b . //系统启动不会在el0状态，这里设置个死循环 3: mov sp, x0 //sp_el3 sub x0, x0, x1 2: msr sp_el2, x0 sub x0, x0, x1 1: msr sp_el1, x0 sub x0, x0, x1 0: msr sp_el0, x0 ret //}}} //{{{ 打印测试结果 .global _print_result _print_result: sub x9, x0, #0xff  cbz x9, _test_fail _test_pass: ldr x9, =0x13000000 //Tube address adr x10, _pass_message_ ldrb w11, [x10], #1 _loop_print_pass: strb w11, [x9] ldrb w11, [x10], #1  cbnz w11, _loop_print_pass ret _test_fail: ldr x9, =0x13000000 //Tube address adr x10, _fail_message_ ldrb w11, [x10], #1 _loop_print_fail: strb w11, [x9] ldrb w11, [x10], #1  cbnz w11, _loop_print_fail ret .align 2 _pass_message_: .asciz \u0026#34;*** TEST PASSED OK ***\\n\u0026#34; _fail_message_: .asciz \u0026#34;*** TEST FAILED ***\\n\u0026#34; //}}} .align 2 //{{{ 结束CPU .global _end_cpu _end_cpu: mov w9, #0x04  ldr x10, =0x13000000 //Tube address strb w9, [x10] dsb sy ret //}}} //{{{ el3切换到el0_ns .global _el3_to_el0_ns _el3_to_el0_ns: ldr x9, =0x000002c0 msr spsr_el3, x9 adr x9, _test msr elr_el3, x9 eret //}}}   link.lds link.lds是链接脚本，编译是文件各自独立的，编译后还需要将各个编译后的文件链接在一起，链接脚本就是用来指定链接规则，或者说为各个编译后的文件指定存储位置。\nOUTPUT_ARCH(aarch64) ENTRY(_start) SECTIONS { . = RVBAR; .setup : { start.o evt.o } .text : { * (.text) } .data : { * (.data) } .bss : { * (.bss) } }  注意，RVBAR是一个宏参数，在链接时传递，指明存储程序的开始地址。RVBAR是指 Reset Vector Base Address Register，也就是保存复位后程序初始地址的寄存器。  Makefile.rule Makefile.rule内容主要是编译和链接处理命令，之所以定义Makefile.rule，而不是将其整个写在Makefile，主要考虑是只将参数定义暴露给用户，而底层逻辑不需要用户关心。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  SYS_PATH = $(PROJ_PATH)/sys/ SYS_OBJS = start.o asmlib.o evt.o main_test.o sysregs_init.o OBJS = $(SYS_OBJS) $(TST_OBJS) DEFINES := --defsym RVBAR=$(RVBAR) ASM_A64 = $(COMPILER_A64)-as CC_A64 = $(COMPILER_A64)-gcc LD_A64 = $(COMPILER_A64)-ld OBJDUMP_A64 = $(COMPILER_A64)-objdump OBJCOPY_A64 = $(COMPILER_A64)-objcopy #=======================================  build: $(OBJS) $(LD_A64) -T $(SYS_PATH)/link.lds $(DEFINES) $^ -o $(FNAME).elf $(OBJCOPY_A64) -O binary $(FNAME).elf $(FNAME).bin $(OBJDUMP_A64) -D $(FNAME).elf \u0026gt; $(FNAME).dis %.o: $(SYS_PATH)/%.s $(ASM_A64) -march=$(MARCH) $(DEFINES) -c $^ -o $@ %.o: $(PROJ_PATH)/%.c $(CC_A64) -c $^ -o $@ -nostdlib clean: rm *.o *.dis *.bin *.elf -f   Makefile 主要是用户需要自定义的参数\n1 2 3 4 5 6 7 8 9  RVBAR = 0x0 MARCH = armv8.2-a+crypto #COMPILER_A64 = \u0026#34;../tools/aarch64_bin/aarch64-linux-gnu\u0026#34; COMPILER_A64 = \u0026#34;../gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu\u0026#34; FNAME = test_a64 TST_OBJS = hello.o PROJ_PATH = $(shell pwd) include $(PROJ_PATH)/sys/Makefile.rule   hello.c 随便写了写。\n1 2 3 4 5 6  void hello_world(void) { int a; a = 0; a = a + 1; }   AArch32 这里没有对AArch32做单独程序框架，而是采用了将AArch64和AArch32混合编程的方法。\nAArch64与AArch32混合编程 ARMv8中，AArch64和AArch32是通过异常进行切换的。而A32和T32是通过bx指令进行切换的。如下图：\n     也就是CPU启动是在EL3，处于AArch64，在EL3设置EL2的架构为AArch32，设置好返回地址，通过ERET指令，切换到EL2，就可以执行A32指令了。\n这里会有一个问题，AArch64和AArch32的编译链接工具不同，无法进行混合的链接。解决办法是将A32测试程序生成elf文件再生成bin文件，在链接时链接A32的bin文件。顺便这里干脆把A64的测试程序也使用bin文件链接的方式，顶层只保留系统文件，这样结够更加清晰。另外A64和A32测试程序使用单独的环境，并且不依赖系统程序，可以在单独的环境进行编译调试。具体文件结构如下：\n. ├── a32_test │ ├── a32_test.s │ ├── link.lds │ ├── Makefile │ ├── test.c │ └── thumb_test.inc ├── a64_test │ ├── a64_test.s │ ├── link.lds │ ├── Makefile │ └── test.c ├── link.lds ├── Makefile ├── Makefile.def ├── script │ └── readme.org └── system ├── asmlib.inc ├── evt.inc ├── Makefile ├── start.s └── sysregs_init.inc 在Makefile.def中定义了各种参数，其中包含对测试程序的调用，可以选择el0,el1,el2,el3，也可以打开和关闭A32的测试以及是否打印测试结果。\n代码中添加了必要的注释，这里就不展开介绍了，可以参考程序代码，分享如下： 链接：https://pan.baidu.com/s/1vGm6wRuMbzm9-0rZUsPpFw 密码：nymn\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":8,"section":"docs","tags":null,"title":"一个简易bootloader框架","uri":"https://www.wenhui.space/docs/about_arm/aarch64/bootloader/"},{"content":"本文 主要介绍AArch64的一些异常基础知识，异常向量表的设定，以及AArch64的异常处理。\n   版本 说明     0.1 初版发布    关于异常的基础知识 什么是异常？ 对于AArch64而言，exception是指cpu的某些异常状态或者一些系统的事件（可能来自外部，也可能来自内部），这些状态或者事件可以导致cpu去执行一些预先设定的，具有更高执行权利的软件（也叫exception handler）。执行exception handler可以进行异常的处理，从而让系统平滑的运行。exception handler执行完毕之后，需要返回发生异常的现场。\n异常等级（exception level） AArch64有四个 exception level：\n EL0 normal用户应用程序 EL1 操作系统内核 EL2 Hypervisor(vm 虚拟化) EL3 底层固件，包括secure monitor  之前说到异常发生后系统将切换到具有更高执行权限的状态，在AArch64是通过exception level来实现的。AArch64最多支持EL0～EL3四个exception level，EL0的execution privilege最低，EL3的execution privilege最高。当发生异常的时候，系统的exception会迁移（route）到更高的exception level或者维持不变，但是绝不会降低。此外，不会有任何的异常会去到EL0。而AArch32，cpu没有异常等级，而是采用processor mode模式，例如User、FIQ、IRQ、Abort、Undefined、System，这些不同的mode对应privilege（其他mode）和no-privilege（User mode）。\n关于AArch64的exception level比较复杂，一般会有如下几种情况：\n 不支持security state，不支持虚拟化： AArch64有2个exception level，分别是：EL0（对应user mode的application），EL1（guest OS）。 不支持security state，支持虚拟化： AArch64有3个exception level，分别是：EL0（对应user mode的application），EL1（guest OS）和EL2（Hypervisor）。 支持security state，不支持虚拟化： AArch64有3个exception level，分别是：EL0（对应trusted service），EL1（trusted OS kernel）和EL3（Secure monitor）。 支持security state，支持虚拟化： AArch64有4个exception level，分别是：（对应trusted service），EL1（trusted OS kernel），EL2（Hypervisor）和EL3（Secure monitor）。  如下图：\n     异步异常和同步异常   异步异常（asynchronous exception）:\n 异步异常可以理解为中断，CPU是不可预知的。 异常和CPU执行的指令无关。 返回地址是硬件保存下来并提供给handler，以便进行异常返回现场的处理。（程序也有可能不返回，跟中断处理程序有关，比如正在发送邮件，突然点击取消发送，原发送程序不再执行【个人理解，不一定准确】） 根据这个定义IRQ、FIQ和SError interrupt属于asynchronous exception。    同步异常（synchronous exception）：\n 同步异常的产生是和cpu core执行的指令异常或试图改变执行权限引起的异常 返回地址是硬件保存下来并提供给handler，以便进行异常返回现场的处理。 同步异常分两种，一是abort类，例如未定义的指令、data abort、prefetch instruction abort、SP未对齐异常，debug exception等等。另一种是正常指令执行造成的，包括SVC/HVC/SMC指令，这些指令的使命就是产生异常，改变执行权限。    什么是精确异常 先来说说什么是非精确异常：在多发射乱序执行的流水线 CPU 上，从指令进入流水线到异常事件的发生，期间要经过若干流水级，此时 PC 的值已指向其后的某条指令，在实现非精确异常的 CPU 上就把此时的 PC 值作为引起异常指令的所在，也就是记录异常指令的PC并非真正的引起异常的指令所在，而是其后面的某条指令所在。\n精确异常（precise exception），也就是记录异常指令的PC并非真正的引起异常的指令所在，而是其后面的某条指令所在。实现精确异常的 CPU，在最后指令提交时 (commit) 按指令流的顺序提交，异常的抛出也在该指令提交时，这样就能精确计算出引起异常的指令相对于当前 PC 的偏移，从而保证精确异常。不管是何类异常，记录异常指令的PC之前的所有指令都会被执行完成 (commit)，之后的指令不会被执行。\n在AArch64中，除了SError interrupt这种exception，其他的exception都是precise exception。\n异常处理流程 AArch64 state异常处理流程：    流程 说明     1、保存PSTATE 数据到SPSR_ELx,(x = 1,2,3) 异常返回时需要从SPSR_ELx中恢复PSTATE   2、保存异常进入地址到ELR_ELx，同步异常（und/abt等）是当前地址，而异步异常（irq/fiq等）是下一条指令地址 64位架构LR和ELR是独立分开的，这点和32位架构有所差别   3、保存异常原因信息到ESR_ELx ESR_ELx.EC代表Exception Class，关注这个bit   4、PE根据目标EL的异常向量表中定义的异常地址强制跳转到异常处理程序 跳转到哪个EL使用哪个向量偏移地址又路由关系决定   5、堆栈指针SP的使用由目标EL决定 (SPSR_ELx.M[0] == 1) ？ h（ELx）: t（EL0）    AArch32 state异常处理流程    流程 说明     1、PE根据异常类型跳转到对应的异常模式x,x = {und/svc/abt/irq/fiq/hyp/mon} PE跳转到哪一种模式通常由路由关系决定   2、保存异常返回地址到LR_x，用于异常返回用 LR也是对应模式的R[14]_x寄存器，32位系统下LR和ELR是同一个寄存器，而64位是独立的   3、备份PSTATE 数据到SPSR_x 异常返回时需要从SPSR_x恢复PSTATE   4、PSTATE 操作：PSTATE.M[4:0]设置为异常模式x; PSTATE.{A,I,F} = 1; PSTATE.T = 1，强制进入A32模式; PSTATE.IT[7：2] = “00000” PSTATE.M[4]只是对32位系统有效，64为下是保留的，因为64位下没有各种mode的概念. 异常处理都要切换到ARM下进行；进入异常时需要暂时关闭A,I,F中断；   5、据异常模式x的向量偏移跳转到进入异常处理 各个mode有对应的Vector base addr + offset    AArch64异常向量表偏移量    exception level迁移情况 Synchronous exception的offset值 IRQ和vIRQ exception的offset值 FIQ和vFIQ exception的offset值 SError和vSError exception的offset值     同级exception level迁移，使用SP_EL0。例如EL1迁移到EL1 0x000 0x080 0x100 0x180   同级exception level迁移，使用SP_ELx。例如EL1迁移到EL1 0x200 0x280 0x300 0x380   ELx迁移到ELy，其中y\u0026gt;x并且ELx处于AArch64状态 0x400 0x480 0x500 0x580   ELx迁移到ELy，其中y\u0026gt;x并且ELx处于AArch32状态 0x600 0x680 0x700 0x780    注：每个异常等级都有一个关联的 Vector Base Address Register (VBAR),它定义了每个异常等级向量表的基址\nAArch64异常返回：  用ELR_ELx恢复PC值 SPSR_ELx恢复PSTATE值  AArch64异常相关寄存器 EL3异常层级系统寄存器控制：    SCR_EL3 SCTLR_EL3 MDCR_EL3     NS:决定了EL1和EL0的安全状态； {A, SA}:使能对齐检查，A-EL3访问数据时做对齐检查；SA-EL3对SP做对齐检查； {EPMAD, EDAD}：使能外部debugger访问；   RW:决定了低一级的异常等级运行状态； {M, C, I, WXN}：内存系统控制位； {SPME, SDD, SPD32}：安全debug控制；   {EA, FIQ, IRQ}：EA-SError和同步Aborts切换到EL3；FIQ-物理FIQ切换到EL3；IRQ-物理IRQ切换到EL3; EE:定义了端； {TDOSA, TDA, TPM}：陷阱控制   SMD:禁用SMC；     HCE:使能Hypervisor call异常；     ST:使能secure EL1访问secure timer;     SIF:安装指令获取，当secure state禁止从non secuer内存取指；     TWI:陷入WFI;     TWE:陷入WFE      EL2异常层级系统寄存器控制：    HCR_EL2 SCTLR_EL2 MDCR_EL2 HSTR_EL2     RW:决定了低一级的异常等级运行状态； {A, SA}:使能对齐检查 {TDRA, TDOSA, TDA} Tn, for values of n in the set {0-3, 5-13, 15}   {AMO, IMO, FMO}:路由物理中断到EL2 {M, C, I, WXN}：内存系统控制位； TDE:路由从非安全EL0 EL1 EL2来的debug异常    {VSE, VI, VF}:设置虚拟中断pending; EE:定义了端； {TPM, TPMCR}：陷阱控制；    VM:  HPMN:    {SWIO, PTW, FB, BSU, DC, CD, ID}:      HCD Hypervisor Call Disable      {TRVM, TDZ, TVM, TTLB, TPU, TPC, TSW, TACR, TIDCP, TSC, TID1, TID2, TID3, TWE, TWI}:      TGE: Trap General Exceptions       EL1异常层级系统寄存器控制：    TLR_EL1 MDSCR_EL1     {A, SA}:使能对齐检查 {MDE, SS}   {M, C, I, WXN}：内存系统控制位； KDE：   EE:定义了端；E0E:EL0端；UMA:非特权mask访问 TDCC：   {SED, ITD, CP15BEN}：     同步异常 同步异常类型    异常类型 描述     Undefined Instruction 未定义指令异常   Illegal Execution State 非法执行状态异常   System Call 系统调用指令异常（SVC/HVC/SMC）   Misaligned PC/SP PC/SP未对齐异常   Instruction Abort 指令终止异常   Data Abort 数据终止异常   Debug exception 软件断点指令/断点/观察点/向量捕获/软件单步 等Debug异常    同步异常迁移 如果HCR_EL2.TGE为1，None-secure EL0下的异常不会传递给None-secure EL1，而是直接传递给EL2\n异步异常 异步异常类型    类型 描述     SError or vSError 系统错误类型，包括外部数据终止   IRQ or vIRQ 外部中断 or 虚拟外部中断   FIQ or vFIQ 快速中断 or 虚拟快速中断    异步异常迁移 这里描述的是el2和el3都实现的情况：\n 若SCR_EL3.{EA, FIQ, IRQ} == 1，则所有相应的SError\\FIQ\\IRQ 中断都被路由到EL3; 若HCR_EL2.{AMO, IMO, FMO} == 1，则EL1/EL0所有对应的SError\\FIQ\\IRQ中断都被路由到EL2,同时使能对应的虚拟中断VSE,VI,VF; 若HCR_EL2.TGE == 1，那么会忽略HCR_EL2.{AMO, IMO, FMO}的具体值，直接当成1处理，则EL1/EL0所有对应的SError\\FIQ\\IRQ中断都被路由到EL2，同时禁止所有虚拟中断  注意： SCR_EL3.{EA, FIQ, IRQ}bit的优先级高于HCR_EL2.{AMO, IMO, FMO} bit优先级，路由优先考虑SCR_EL3\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":9,"section":"docs","tags":null,"title":"AArch64之异常处理","uri":"https://www.wenhui.space/docs/about_arm/aarch64/aarch64_execption/"},{"content":"本文 主要介绍为什么AArch64没有LDM和STM指令了，而是用LDP跟STP。\n   版本 说明     0.1 初版发布    写在前头 AArch32 指令集中包含多数据传输指令LDM、STM，也就是单条指令可以传输多个寄存器的值与内存交互，这对于发生异常时将当前寄存器压入栈很有用，通过单条指令STM可以实现此操作，出栈时同样使用LDM即可。但是到了AArch64里面就取消了多数据传输指令LDM、STM，而是使用LDP和STP，固定的一次最多只能取2个值。原因如何呢？请看下文。\n关于CPU内部微操作的拆分 对于复杂功能指令的实现，出于指令功能复杂以及读取和写回寄存器端口资源的限制，CPU内部会对指令进行微操作拆分。比如CPU内部流水线中单拍最多读取3个64bit寄存器和写回两个64bit寄存器，对于LDM和STM这种多数据传输操作，实际在CPU执行过程中会进行微操作的拆分。换句话说，LDM和STM只不过是对多个LD和ST的打包，在CPU里还是分多条微操作执行，LDM和STM指令除了方便软件工程师使用，而对CPU并没有提高执行效率。既然可以方便软件工程师使用，毕竟还是有利的，那为什么在AArch64还是取消了该指令呢？继续看下文。\nCPU对LD和ST的操作 当前CPU的LD和ST，大多分为两个独立的流水线，也就是说配合多发射就可能在一个cycle内同时执行两条（一个ldr、一个str）指令。这里如果执行一条LDM，会使LD Pipe处于持续工作状态，而ST Pipe是空闲状态，执行一条STM情况类似。所以为了最大化利用LD和ST独立流水线的特性，在软件使用层面上，应尽量减少这种突发的多LD和多ST事件，而使用间隔的LD和ST可以利用双pipeline实现该两条指令并发执行，提高执行效率。所以，也就没有LDM和STM指令的必要性了。\nLDP/STP  32bit模式下也是有LDRD跟STD指令的，但是在64bit模式下任意的两个整型寄存器都是可以读或者写的 数据的读写是内存里面的连续位置的 地址模式更严格：只能base + offset的模式进行访存，offset范围是正负127范围（7bit） 与32bit的LDRD跟STD指令不同的是：64bit模式下支持非对齐访问 LDP是支持SIMD 详细信息请看ARM手册。  LDNP/STNP  LDNP跟STNP是Armv8才有的机制，non-temporal代表读取的数据是不会存保存到cache。比如我只要2byte的数据，通常系统会加载1个cache line进来，但是使用LDNP指令，系统不会加载整个cache line进了，而是只加载2byte，从而减少总线流量，进而可能减少取数据的时间。因此LDNP这种指令只适合读取数据量少且不常访问的情况。 non-temporal加载和存储能够放松对访存顺序的要求，LDNP可能比LDR要提前执行（因为LDNP不需要进行cache line fill操作，而是流式读），但是这样顺序错了，因此要加barriar来保证执行顺序。（如果两个内存读之间存在地址依赖关系,第二个读指令是LDNP产生的，然后在没有任何其他屏障机制来保证顺序的情况下，这个可能就会乱序执行的！）   1 2 3 4 5 6 7 8  //错误的用法 LDR x0， [x3] LDNP x2, x1, [x0] //正确用法 LDR x0， [x3] DSB nshld LDNP x2, x1, [x0]    简单理解就是：LDNP指令会告诉memory子系统，我是流式访存，这个数据我暂时只用一次，因此不用读取至cache。  总结  在Arm v8-A架构里面因为有两个分别独立的ld、st pipeline，因此交叉使用LDP、STP指令可以并行使用pipeline，增大吞吐（因为armv7一般是单个加载存储单元，因此LDM、STM更有效） LDNP、STNP是流式处理数据的，不会进行cache line fill操作，因此适合少量数据处理的情形，减少总线流量，比如堆栈恢复的时候，堆栈就几个字节的数据，常规操作是要加载一个cache line，不仅占用cahche空间，还增大总线流量，因此用LDNP更有效，不过在与LDR存在依赖时，要使用数据隔离。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":10,"section":"docs","tags":null,"title":"为什么AArch64没有LDM和STM指令","uri":"https://www.wenhui.space/docs/about_arm/aarch64/aarch64_no_ldm_stm/"},{"content":"本文 主要主要对涉及CPU的一些基本知识和概念进行简单描述，作为科普知识。\n   版本 说明     0.1 初版发布    参考 各种网络资源。\nCPU和SOC的区别 SoC = System on Chip。芯片的发展方向：从CPU到SoC，现在已经没有纯粹的CPU了，都是SoC，ARM出卖的内核其实就是CPU（当然还需要总线），各种外设是半导体厂商自己添加的。\n外设就是外部设备。SoC中外设大部分都跑进去了，芯片设计的趋势是更大集成度，在SoC内做成单芯片解决方案。\nRISC和CISC  complex instruction set computer复杂指令集CPU。CISC体系的设计理念是用最少的指令来完成任务（譬如计算乘法只需要一条MUL指令即可），因此CISC的CPU本身设计复杂、工艺复杂，但好处是编译器好设计。CISC出现较早，至今Intel还一直采用CISC设计。 Reduced Instruction-Set Computer精简指令集CPU。RISC的设计理念是让软件来完成具体的任务，CPU本身仅提供基本功能指令集。因此RISC CPU的指令集中只有很少的指令，这种设计相对于CISC，CPU的设计和工艺简单了，但是编译器的设计变难了。 发展趋势：没有纯粹的RISC或CISC，发展方向是RISC与CISC结合，形成一种介于2者之间的CPU类型。  统一编址和独立编址？ 内存通过CPU的地址总线来寻址定位，然后通过CPU数据总线来读写。CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围是一定的，而内存是需要占用CPU的寻址空间的。内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。\nIO指的是与CPU连接的各种外设。CPU访问各种外设有2种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存相同的方式来操作外设，叫IO与内存统一编址方式；另一种是使用专用的CPU指令来访问某种特定外设，叫IO与内存独立编址。\nIO与内存统一编址方式，优势是IO当作内存来访问，编程简单；缺点是IO也需要占用一定的CPU地址空间，而CPU的地址空间是有限资源。IO与内存独立编织方式，优势是 不占用CPU地址空间，缺点是CPU设计变复杂了。\n冯诺依曼结构和哈佛结构  程序与数据：  程序是我们写好的源代码经过编译、汇编之后得到的机器码，这些机器码可以拿给CPU去解码执行，CPU不会也不应该去修改程序，所以程序是只读的。 数据是程序运行过程中定义和产生的变量的值，是可以读写的，程序运行实际就是为了改变数据的值。   冯诺依曼结构和哈佛结构：  程序和数据都放在内存中，且不彼此分离的结构称为冯诺依曼结构。冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。 程序和数据分开独立放在不同的内存块中，彼此完全分离的结构称为哈佛结构。哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）    外部存储和内部存储器 从冯诺依曼的存储程序工作原理以来，计算机就分为了运算器、控制器、存储器和输入输出设备，这里的存储器就是指内部存储器，简称内存。而外部存储器是作为辅助存储的，比如硬盘、U盘、光盘等，准确来说它们属于外设/输入输出设备。内存与地址空间直接映射，这里也就是物理地址，可以通过地址\u0026amp;数据总线与CPU直接相连，而外部存储器和CPU连接不是通过地址\u0026amp;数据总线直接相连，因为地址空间不够用，一般都是通过专门的接口来连接的。在CPU运行时，需要先将外存的程序和数据搬移到内存，才能正常执行。直观来说就是外存只能保证你能存更多东西，要想运行速度块，需要增加内存。\n外存和内存根据各自需要，使用不同的存储介质，内存一般使用DDR（Double Data Rate双倍速率同步动态随机存储器），容量小，断电后数据会丢失，单位容量价格较高，访问速度较快（为什么是较高较快，下文解释）；外存使用的种类就比较多了，动态硬盘、机械硬盘、光盘、U盘等等，容量大，单位容量价格低，访问速度慢，断电后数据不会丢失。\n之所以说内存的单位容量价格较高和访问速度较快，是因为还有缓存（cache），缓存一般使用SRAM（Static Random-Access Memory）静态随机存储器，之所以说静态与动态相比只要保持供电不需要刷电就能一直保存数据（与具体晶体管实现方式不同），SRAM访问速度最快，可以接近CPU的运行速度（内存和CPU运行速度相差近三个量级），但是单位容量价格最贵，单位容量占用芯片面积最多。\n虚拟地址和物理地址 地址空间 地址空间其实是一个比较抽象的概念，我们可以把它想象成一个长的数组，每个数组元素占一个字节。那么这个数组的长度就由地址空间长度来决定。例如：我们32位的系统的地址空间就是我们的2^32字节(4GB),而64位的地址空间大小就是2^64个字节。这也就解释了在我们32位的操作系统，为什么最大只能支持4GB的有效内存。\n物理地址 物理地址：物理地址空间是实在的存在于计算机中的一个实体，在每一台计算机中保持唯一独立性。我们可以称它为物理内存；如在32位的机器上，物理空间的大小理论上可以达到2^32字节(4GB)，但如果实际装了512的内存，那么其物理地址真正的有效部分只有512MB = 512 * 1024 KB = 512 * 1024 * 1024 B（0x00000000~0x1fffffff）。其他部分是无效的。\n虚拟地址 虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。\n为什么要设置虚拟地址 在早期的计算机中，程序是直接运行到物理内存（可以理解为内存条上的内存）上的。也就是说，程序运行的时候直接访问的就是物理地址。如果，我们的一个计算机只运行一个程序，那么只有这个程序所需要的内存空间不超过物理内存空间的大小，就不会有问题。但是，我们正在希望的是在某个时候同时运行多个程序。那么这个时候，就会有个一个问题，计算机如何把有限的物理内存分配给多个程序使用呢？\n某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。\n问题1：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。\n问题2：内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。\n问题3：程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。但是我们的某些硬件是需要在固定的地址上去开始运行的，但是如果这个地址后边被我们的程序占有，那么我们对这块内存的修改，就可能导致某些硬件不可用了。\n为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。\n虚拟地址和物理地址的映射 虚拟地址和物理地址之间的映射是通过MMU（内存管理单元）来完成的。具体映射机制，这里不进行描述了，本文作为科普，更深入的分析留在其他章节。\ncpu与核心  物理CPU：物理CPU是相对于虚拟CPU而言的概念，指实际存在的CPU处理器，安装在PC主板或服务器上。需要注意的是这个CPU可能有多个核心。 物理核：CPU中包含的物理内核（核心）个数，比如多核CPU，单核CPU（古老的CPU）。这个多核或者单核已经集成在CPU内部了。 逻辑核和虚拟核：所谓的4核8线程，4核指的是物理核心。用Intel的超线程技术(HT)将物理核虚拟而成的逻辑处理单元,现在大部分的主机的CPU都在使用HT技术，用一个物理核模拟两个虚拟核，即每个核两个线程，总数为8线程。这样在操作系统看来是8个核，但是实际上是1个物理CPU中的4个物理内核。通过超线程技术可以实现单个物理核实现线程级别的并行计算，但是性能比不上两个物理核，因为两个线程共享一套运算资源。  进程和线程 概念 进程是操作系统进行资源（包括cpu、内存、磁盘IO等）分配的最小单位。线程是cpu调度和分配的基本单位。\n举例说明： 我们打开的聊天工具，浏览器都是一个进程。进程可能有多个子任务，比如聊天工具要接受消息，发送消息，这些子任务就是线程。资源分配给进程，线程共享进程资源。\n对比    对比 进程 线程     定义 序运行的一个实体的运行过程，是系统进行资源分配和调配的一个独立单位 线程是进程运行和执行的最小调度单位   系统开销 创建撤销切换开销大，资源要重新分配和收回 仅保存少量寄存器的内容，开销小，在进程的地址空间执行代码   拥有资产 资源拥有的基本单位 基本上不占资源，仅有不可少的资源（程序计数器，一组寄存器和栈）   调度 的基本单位 独立调度分配的单位   安全性 互独立，互不影响 线程共享一个进程下面的资源，可以互相通信和影响   地址空间 系统赋予的独立的内存地址空间 由相关堆栈寄存器和和线程控制表TCB组成，寄存器可被用来存储线程内的局部变量    线程的切换 cpu给线程分配时间片(也就是分配给线程的时间)，执行完时间片后会切换都另一个线程。切换之前会保存线程的状态，下次时间片再给这个线程时才能知道当前状态。从保存线程A的状态再到切换到线程B时，重新加载线程B的状态的这个过程就叫上下文切换。而上下切换时会消耗大量的cpu时间。\n串行，并发与并行  串行：多个任务，执行时一个执行完再执行另一个。比如一边吃饭一边看视频。 并发：多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。比如一会跑去厨房吃饭，一会跑去客厅看视频。 并行：每个线程分配给独立的核心，线程同时运行。比如一边吃饭一边看视频。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":11,"section":"docs","tags":null,"title":"CPU相关的科普知识","uri":"https://www.wenhui.space/docs/polular_science/cpu_knowledge/"},{"content":"本文 主要介绍ARM体系结构与汇编指令，这里的体系结构指ARMv7及以前版本，ARMv8相对之前的版本区别较大，不过熟悉以前的体系结构对ARMv8的理解也有帮助，何况ARMv8本身也支持aarch32。\n   版本 说明     0.1 初版发布    参考 参考自《朱有鹏老师嵌入式linux核心课程》。\nARM的工作模式   7种工作模式：\n User : 非特权模式，大部分任务执行在这种模式 FIQ : 当一个高优先级（fast) 中断产生时将会进入这种模式 IRQ : 当一个低优先级（normal) 中断产生时将会进入这种模式 Supervisor :当复位或软中断指令执行时将会进入这种模式 Abort : 当存取异常时将会进入这种模式 Undef : 当执行未定义指令时会进入这种模式 System : 使用和User模式相同寄存器集的特权模式    注意：\n 除User（用户模式）是Normal（普通模式）外，其他6种都是Privilege（特权模式）。 Privilege中除Sys模式外，其余5种为异常模式。 各种模式的切换，可以是程序员通过代码主动切换（通过写CPSR寄存器）；也可以是CPU在某些情况下自动切换。 各种模式下权限和可以访问的寄存器不同。    CPU为什么设计这些模式？\n CPU是硬件，OS是软件，软件的设计要依赖硬件的特性，硬件的设计要考虑软件需要，便于实现软件特性。 操作系统有安全级别要求，因此CPU设计多种模式是为了方便操作系统的多种角色安全等级需要。    ARM的寄存器 37个寄存器  ARM共有37个寄存器，都是32位长度。 37个寄存器中30个为“通用”型，1个（r15）固定用作PC，一个固定用作CPSR，5个固定用作5种异常模式下的SPSR。 ARM寄存器编号为r0～r15，其中r13作为栈指针sp，r14作为链接寄存器lr，r15作为程序计数器pc。 ARM每个工作模式下都有自己独有的寄存器和共用的寄存器，而当前模式只见r0～r15。  举例如下：\n  当前模式为Usr      当前模式为Abort    所以，ARM（aarch32）的寄存器好比影子，每个模式都映射出当前模式下的r0～r15，注意System和User共有一套寄存器。由此可以发现，虽然ARM有37个寄存器，但对软件可见的只有r0~r15和cpsr。\n     CPSR当前状态寄存器        条件位：\n N = Negative result from ALU Z = Zero result from ALU C = ALU operation Carried out V = ALU operation oVerflowed    Q 位：\n 仅ARM 5TE/J架构支持 指示饱和状态    J 位\n 仅ARM 5TE/J架构支持 J = 1: 处理器处于Jazelle状态（对Jave的优化处理）    中断禁止位：\n I = 1: 禁止 IRQ. F = 1: 禁止 FIQ.    T Bit\n T = 0: 处理器处于 ARM 状态 T = 1: 处理器处于 Thumb 状态    Mode位：\n 处理器模式位    注意：\n CPSR中各个bit位表明了CPU的某些状态信息，这些信息非常重要，这与汇编指令息息相关。 CPSR中的I、F位和开中断、关中断有关。 CPSR中的mode位（bit4～bit0共5位）决定了CPU的工作模式，在uboot代码中会使用汇编进行设置。    PC（r15）程序控制寄存器  PC（Program control register）为程序指针，PC指向哪里，CPU就会执行哪条指令（所以程序跳转时就是把目标地址代码放到PC中）。 整个CPU中只有一个PC（CPSR也只有一个，但SPSR有5个）。  ARM的异常处理方式 什么是异常  正常工作之外的流程都叫异常。 异常会打断正在执行的工作，并且一般我们希望异常处理完成后继续回来执行原来的工作。 中断是异常的一种。  异常向量表  所有的CPU都有异常向量表，这是CPU设计时就设定好的，是硬件决定的。 当异常发生时，CPU会自动动作（PC跳转到异常向量处处理异常，有时伴有一些辅助动作） 异常向量表是硬件向软件提供的处理异常的支持。  ARM的异常处理机制  当异常产生时, ARM core完成以下操作：  拷贝 CPSR 到 SPSR_ 设置适当的 CPSR 位： 改变处理器状态进入 ARM 态（如果当前在Thumb状态下） 改变处理器模式进入相应的异常模式 设置中断禁止位禁止相应中断 (如果需要) 保存返回地址到 LR_ 设置 PC 为相应的异常向量   返回时, 异常处理需要:  从 SPSR_恢复CPSR 从LR_恢复PC   Note:这些操作只能在 ARM 态执行. 关于保存返回地址到 LR_，这时候分同步异常和异步异常，比如软中断指令引发的异常，属于同步异常，返回地址为该指令的下一条指令位置，而数据异常属于异步异常，返回地址为该指令位置。  总结  异常处理中有一些是硬件自动做的，有一些是程序员需要自己做的。需要搞清楚哪些是需要自己做的，才知道如何写代码。 以上说的是CPU设计时提供的异常向量表，一般成为一级向量表。有些CPU为了支持多个中断，还会提供二级中断向量表，处理思路类似于这里说的一级中断向量表。  指令集 两个概念：指令与伪指令  （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。 （汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。  两种不同风格的ARM指令  ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如： LDR R0, [R1] GNU风格的ARM汇编：指令一般用小写字母、linux中常用。如：ldr r0, [r1] 一般交叉编译都使用GNU风格的ARM汇编，编译器下载地址如下： https://releases.linaro.org/components/toolchain/binaries/。  ARM汇编的特点  ARM采用RISC架构，CPU本身不能直接处理内存数据，而需要先将内存数据加载入CPU中通用寄存器中才能被CPU处理。  ldr（load register）指令将内存内容加载入通用寄存器。 str（store register）指令将寄存器内容存入内存空间中。 ldr/str组合用来实现 ARM CPU和内存数据交换。   8种寻址方式：  寄存器寻址 mov r1, r2 立即寻址 mov r0, #0xFF00 寄存器移位寻址 mov r0, r1, lsl #3 寄存器间接寻址 ldr r1, [r2] 基址变址寻址 ldr r1, [r2, #4] 多寄存器寻址 ldmia r1!, {r2-r7, r12} 堆栈寻址 stmfd sp!, {r2-r7, lr} 相对寻址 beq flag   指令后缀:  B（byte）功能不变，操作长度变为8位 H（half word）功能不变，长度变为16位 S（signed）功能不变，操作数变为有符号 如 ldr ldrb ldrh ldrsb ldrsh S（S标志）功能不变，影响CPSR标志位 如 mov和movs\tmovs r0, #0   条件执行后缀:       数据传输和跳转指令  数据处理指令：  数据传输指令 mov mvn 算术指令 add sub rsb adc sbc rsc 逻辑指令 and orr eor bic 比较指令 cmp cmn tst teq 乘法指令 mvl mla umull umlal smull smlal 前导零计数 clz   cpsr访问指令：  mrs用来读psr，msr用来写psr CPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr   跳转(分支)指令：  b \u0026amp; bl \u0026amp; bx b 直接跳转（就没打开算返回） bl branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用 bx跳转同时切换到ARM模式，一般用于异常处理的跳转。   访存指令：  单个字/半字/字节访问 ldr/str 多字批量访问 ldm/stm （为什么设有多字批量访问指令，比如发生异常时需要将现场寄存器压入栈，而返回时出栈以回到异常前的现场，这里多字批量访问指令对多个寄存器压入和弹出栈很有用） 数据交换：swp r1, r2, [r0]   立即数：  合法立即数与非法立即数 ARM指令都是32位，除了指令标记和操作标记外，本身只能附带很少位数的立即数。因此立即数有合法和非法之分。 合法立即数：经过任意位数的移位后非零部分可以用8位表示的即为合法立即数 一般使用伪指令 ldr r0, 0x123456 可以不必关心立即数的合法性，编译器会自动完成   软中断指令：  swi（software interrupt） 软中断指令用来实现操作系统中系统调用    协处理器和协处理器指令  协处理器cp15操作指令：  mrc用于读取CP15中的寄存器 mcr用于写入CP15中的寄存器   什么是协处理器：  SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。 ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor） 协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。   MRC \u0026amp; MCR的使用方法：  mcr{} p15, \u0026lt;opcode_1\u0026gt;, , , , {\u0026lt;opcode_2\u0026gt;} mrc p15, 0, r0, c1, c0, 0 opcode_1：对于cp15永远为0 Rd：ARM的普通寄存器 Crn：cp15的寄存器，合法值是c0～c15 Crm：cp15的寄存器，一般均设为c0 opcode_2：一般省略或为0   关于协处理器的操作不必深究，一般通过协处理器访问系统寄存器，不过大多处理器已经取消了协处理器。  ldm/stm与栈的处理  为什么需要多寄存器访问指令：  ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm ldm(load register mutiple) stm（store register mutiple） 如：stmia sp, {r0 - r12} ，将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。一个访存周期同时完成13个寄存器的读写   8种后缀：  ia（increase after）先传输，再地址+4 ib（increase before）先地址+4，再传输 da（decrease after）先传输，再地址-4 db（decrease before）先地址-4，再传输 fd（full decrease）满递减堆栈 ed（empty decrease）空递减堆栈 fa（full ascending） 满递增堆栈 ea（empty ascending）空递增堆栈   四种栈：  空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出 满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针 增栈：栈指针移动时向地址增加的方向移动的栈 减栈：栈指针移动时向地址减小的方向移动的栈   ！的作用：  ldmia\tr0, {r2 - r3} ldmia\tr0！, {r2 - r3} 感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。   ^的作用：  ldmfd\tsp!, {r0 - r6, pc} ldmfd\tsp!, {r0 - r6, pc}^ ^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。   总结：  批量读取或写入内存时要用ldm/stm指令 各种后缀以理解为主，不需记忆，最常见的是stmia和stmfd 谨记：操作栈时使用相同的后缀就不会出错，不管是满栈还是空栈、增栈还是减栈 提供这么多种栈的模式，实际使用最多的是满减栈，而且编译器默认使用满减栈。    伪指令  伪指令的意义：  伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。 伪指令的意义在于指导编译过程。 伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令。   gnu汇编中的一些符号：  @, // , /* */用来做注释。（不同编译器可能不同，根据实际情况为准） ：以冒号结尾的是标号 . 点号在gnu汇编中表示当前指令的地址 # 立即数前面要加#，表示这是个立即数   常用gnu伪指令：  .global _start // 给_start外部链接属性 .section .text // 指定当前段为代码段 .ascii .byte .short .long .word .quad .float .string // 定义数据 .align 4 // 以16字节对齐 .balignl 16 0xabcdefgh // 16字节对齐填充   偶尔使用的gnu伪指令：  .end // 标识文件结束 .include // 头文件包含 .arm / .code32 // 声明以下为arm指令 .thumb / .code16 // 声明以下为thubm指令   最重要的几个伪指令:  ldr 大范围的地址加载指令 adr 小范围的地址加载指令 nop 空操作 ARM中有一个ldr指令，还有一个ldr伪指令，一般都使用ldr伪指令实现立即数赋值和长跳转   adr与ldr：  adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理 adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里，ldr加载的地址和链接时给定的地址有关，由链接脚本决定    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":12,"section":"docs","tags":null,"title":"ARM体系结构与汇编指令","uri":"https://www.wenhui.space/docs/about_arm/assembler/arm_architecture_and_assembly/"},{"content":"本文 主要内容向大家推荐一款hugo主题，是目前我见过的所有主题中最完美的一个，名字叫zdoc。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.63 extend  主题介绍 之所以说它完美，主要是支持了文档结构的多层目录，可实现博客文章的多级分类，并且支持了搜索功能和评论功能，简单易用，配置文件内容非常清楚，可以开箱即用。话不多说，github地址为： https://github.com/zzossig/hugo-theme-zdoc。\n使用效果和安装步骤readme中都有说明，这里不再说明。后面会对我操作过程中遇到的问题简单记录。\n注意事项  hugo版本需要0.60或以上版本，并且必须是extend版本。 实现多级分类： 只需要创建多级目录，在每一个层级目录下存放一个_index.md文件，代表该级页面。 需要先添加自己的语言环境，包括theme内的i18n目录。  我的配置 具体内容不再介绍了，这里提供一个我整体配置后的模板，可参考，如有具体问题可邮箱联系。另外，主题一直在保持更新，意味着会有不断的新功能添加进来，注意及时追踪。\n分享如下： 链接：https://pan.baidu.com/s/1s3BWpKNKi1QpgaXruvLx7w 密码：3ryh 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":13,"section":"docs","tags":["hugo"],"title":"推荐一款hugo主题","uri":"https://www.wenhui.space/docs/create_blog_site/hugo_theme_zdoc/"},{"content":"本文 主要介绍一款emacs插件\u0026ndash;epa(emacs-application-framework)。\n   版本 说明     0.1 初版发布    参考  github网址：https://github.com/manateelazycat/emacs-application-framework/blob/master/README.zh-CN.md  什么是epa？ EPA 是一个全新的图形应用框架，通过扩展Emacs的多媒体能力，最终达到 Live in Emacs 的终极目标。换句话说，也就是用emacs做一切。\n如何安装？ 安装过程请参考如上链接，这里只对安装时遇到的问题列出来，供大家参考。\n解决pip3安装网络慢问题 可以使用国内源，如 sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pack_name\n其他还有地址：\n 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/  安装dbus前先安装依赖 sudo apt-get install libdbus-glib-1-dev\nemacs不支持dbus 这是在编译安装时没有对dbus做支持，可能设置了without\u0026ndash;dbus，这时候需要重新编译安装emacs，使其支持dbus功能。\n为什么使用epa？ 暂时还没体会到epa的有利之处，初次安装，就是尝试使用，也许后面会发现更多好处吧，待使用后再对使用场景进行总结。\n这里罗列一下epa目前支持的功能：\n   应用名称 启动命令     浏览器 `M-x eaf-open-browser` 在浏览器中打开或搜索    `M-x eaf-open-browser-with-history` 搜索历史或者打开URL   HTML邮件渲染 `M-x eaf-open-mail-as-html` 在 `gnus`，`mu4e`，`notmuch` 等邮件客户端中执行   PDF阅读器 `M-x eaf-open` 输入PDF文件   视频播放器 `M-x eaf-open` 输入视频文件   图片浏览器 `M-x eaf-open` 输入图片文件   Markdown预览 `M-x eaf-open` 输入Markdown文件   Org预览 `M-x eaf-open` 输入Org文件   摄像头程序 `M-x eaf-open-camera`   终端模拟器 `M-x eaf-open-terminal`   二维码下载文件 `M-x eaf-file-sender-qrcode` or `eaf-file-sender-qrcode-in-dired`   二维码上传文件 `M-x eaf-file-receiver-qrcode`   无线分享 `M-x eaf-open-airshare` 输入要分享给手机的字符串   RSS新闻阅读器 `M-x eaf-open-rss-reader`   演示程序 `M-x eaf-open-demo`    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":14,"section":"docs","tags":["emacs"],"title":"emacs插件之多媒体应用","uri":"https://www.wenhui.space/docs/about_emacs/emacs_epa_package/"},{"content":"本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。\n   版本 说明     0.1 初版发布    参考 参考自文彬师兄的UVM培训资料。\n初识UVM 什么是UVM？  VMM(Verification Methodology Manual)，Synopsys在2006年推出的，VMM当中集成了寄存器解决方案RAL(Register Abstraction Layer)。 OVM(Open Verification Methodology)，Cadence和Mentor在2008年推出的，它引进了factory机制，功能非常强大，但是没有寄存器解决方案。 UVM(Universal Verification Methodology)，即通用验证方法学，其正式版本在2011年2月由Accellera推出的，UVM几乎完全继承了OVM，同时又采纳了VMM中的寄存器解决方案。  什么是UVM验证平台？  UVM是基于System Verilog的一种验证方法学，也可以看成是一个库，提供一系列的接口，可以利用UVM搭建验证平台，用于验证数字逻辑电路的正确性。 注意，UVM本身并不是一个验证平台，他只是一个库，而一个验证平台引入了UVM相关库，称为基于UVM的验证平台，或者简称为UVM验证平台。 支持UVM的EDA厂商：Cadence、Synopsys、Mentor\u0026hellip;  UVM基础 一个基于SV的简单验证平台 注：这里“基于SV”指平台仅仅使用SystemVerilog语言搭建。\n     一个基于UVM的简单验证平台      基于UVM验证平台原则  类： UVM中几乎所有的东西都是用类(class)来实现的，所以，搭建uvm平台第一条原则，所有的组件都用类来完成。 基于UVM类： 当要实现一个功能时，首先应该想到的是从UVM的某个类派生出一个新的类来实现期望功能，所以，搭建uvm平台第二条原则，所有的组件应该派生自uvm类。  UVM中两大最重要基类  uvm_object： 它是UVM最基本的类，几乎所有的类都派生自uvm_object，它的拓展性是最好的，当然能力也是最差的。它主要构成了环境的属性（例如配置）和数据传输。 uvm_component： 它派生自uvm_object ，却拥有自己独有的强大特性，它有两大独有特点，一是通过new形成树形结构，二是自动执行phase。它主要构成了环境的层次。  UVM中常用类的继承关系      什么是UVM Factory 所谓Factory就是工厂，是通过一个字符串（类名）创建一个此字符串所代表的的类的一个实例，并且能够自动调用其phase执行的机制，也就相当于加工工厂。理解上可能比较抽象，我们举例来说明。\n如下图，一个汽车工厂好比我们的验证平台，支持宝马和奔驰两条生产线，两位老板只需下令生产奔驰还是宝马，工厂按照生产线自动加工，最终产出汽车，这里指令（奔驰/宝马）就是上述中的字符串，生产线就是调用其phase执行的机制，整个验证平台也就相当于工厂，这就是UVM Factory。\n     我们的工厂可以支持生产哪些“汽车”，是由验证平台决定的，如果向验证平台输入不支持的指令，比如指定工厂生产“永久自行车”，会被视为错误指令。\n     如果就想生产“永久自行车”，我们需要添加永久自行车生产线:\n     然后我们就可以向工厂输入指令，生产“永久自行车”了。\n     总结 ：\n run_test()语句会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的phase，但是前提是你已经注册了这个类。 对于uvm_component类，注册是通过uvm_component_utils宏来进行的。所有派生自uvm_component以及其派生类都应使用uvm_component_utils来注册 对于uvm_object类，注册是通过uvm_object_utils宏来进行的。所有派生自uvm_object以及其派生类(除uvm_component外)都应使用uvm_object_utils来注册 由上述例子可以看出：run_test()是启动整个验证平台的UVM库函数。  UVM验证平台启动执行流程      搭建UVM验证平台 UVM验证平台基本组成      一个只有driver的测试平台 driver代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class my_driver extends uvm_driver; //继承uvm库中的uvm_driver类  `uvm_component_utils(my_driver) //将my_driver类注册到factory  virtual my_if vif; //声明driver的interface, interface my_if的定义这里不再介绍  extern virtual function void build_phase(uvm_phase phase); extern virtual task void main_phase(uvm_phase phase); endclass function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)) `uvm_fatal(“my_driver”, “virtual interface must be set for vif !!!”) endfunction task void my_driver:: main_phase(uvm_phase phase); //略去 endtask   top_tb代码示例： 1 2 3 4 5 6 7 8 9 10  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  run_test(“my_driver”); //实例化my_driver类，实例的名字是uvm_test_top，并执行类my_driver中的main_phase任务  end endmodule   注意: uvm_test_top是run_test产生的my_driver类的实例化对象名字，run_test(“my_driver”)可以简单的看成:\n1 2  my_driver uvm_test_top； uvm_test_top.main_phase();   这里，任何被run_test()实例化的类的对象的名字都会被UVM平台默认成uvm_test_top，这个被实例化的类也就是整个uvm平台的顶层，而且只允许有一个顶层，即一个验证平台只调用一个run_test()。\ntop_tb顶层与uvm树形结构的交互：  uvm_config_db   1 2 3 4 5  function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)) `uvm_fatal(“my_driver”, “virtual interface must be set for vif !!!”) endfunction   top_tb顶层与uvm树形结构的交互为什么要用这种看起来很怪的uvm_config_db方式获得top_tb的interface，不能直接调用得到吗？ 按道理来讲，是可以的，uvm本来就是基于sv的函数库，其底层肯定也是有sv去实现的，既然uvm将其封装为uvm_config_db，建议统一使用此方法，使用uvm提供的函数也是最好的避免出错的办法。\n top_tb顶层与uvm树形结构：        如果将top_tb中的第3点去掉，请回答以下问题：  top_tb如何获取dut内部信号？答：通过top_tb.my_dut.xxx可以获取。 top_tb如何获取右侧树形结构的内部信息？答：通过top_tb.uvm_test_top.xxx是不可行的，因为run_test实例化了一个脱离了top_tb层次结构的实例对象，建立了一个新的层次，所以不能通过top_tb.uvm_test_top.xxx直接访问。所以针对这种情况，UVM引入了config_db的机制，也就是前面分别在top_tb和my_driver类中build_phase提到的:     1 2  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if) uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)   这样我们通过uvm_config_db将top_tb顶层与uvm树形结构打通。\n top_tb与树形结构中driver的交互流：       注意：top\\_tb与树形结构之间的交互用虚线，是因为my\\_driver.interface.output\\_xxx不是直接给top\\_tb.interface.input\\_xxx传值，而是在采用了config\\_db机制后，类似于两边在操作同一个指针地址，即改变my\\_driver.interface.output\\_xxx的值，就等于直接改变了top\\_tb.interface.input\\_xxx中变量的值。另外：uvm\\_config\\_db将top\\_tb顶层与uvm树形结构打通，我们可以将top\\_tb与树形结构任意组件进行交互，而不仅限于driver和monitor。      树形结构构造 目前，一个只含有driver驱动的UVM验证平台已经形成，那么接下来要考虑树形结构的构造，即添加新部件并使其层次化。\ndriver、monitor、agent和env：      注意：此时树形结构的顶层变成了my\\_env, 所以在top\\_tb中run\\_test(“my\\_driver”)应改成run\\_test(“my\\_env”)，之前讲过,run\\_test(“my\\_driver”)实例化之后对象的名字是uvm\\_test\\_top, 那么run\\_test(“my\\_env”)实例化之后顶层对象的名字是什么？答案是仍然为uvm\\_test\\_top。树形结构发生了层次改变，此时top\\_tb怎么和my\\_driver交互？如下top\\_tb代码： 1 2 3 4 5 6 7 8 9 10 11 12  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin // uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if)  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.agt.drv”, “vif”, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  // run_test(“my_driver”)  run_test(“my_env”); //实例化my_env类，实例的名字是uvm_test_top，并执行类my_env中的phase  end endmodule   加入checker：      注意：这里的checker是将reference model和scoreboard统一看成一个整体。reference model和scoreboard的定义和其他component的方式一样，这里不再赘述。  树形结构通信通道       加入sequencer：      这里sequencer是一个固定组件，sequencer主要将激励承接给driver，my\\_transaction是一个数据包，也就是测试激励，这里还要有一个sequence概念，sequence里存放一组trans，提供给sequencer，可见sequencer属于component类，sequence和trans属于object类。关于sequencer、sequence和trans，还有这样一个比喻，trans好比子弹，sequence好比弹夹，而sequencer是枪。 加入transaction：       transaction使用`uvm_object_utils注册。 transaction可以看成是数据包，把数据打包传输，便于交互。 在组件之间(driver,checker,monitor等)的信息传递都是基于transaction。  加入transaction后driver的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class my_driver extends uvm_driver #(my_transaction); //uvm_driver是参数化类，参数类型为my_transaction  `uvm_component_utils(my_driver) virtual my_if vif; …… endclass task void my_driver:: main_phase(uvm_phase phase); 将： vif.data \u0026lt;= 8’b1; 改成： req = new(“req”); //等价于my_transaction tr; tr = new(“tr”);  req.data = 8’b1; //等价于tr.data = 8’b1;  vif.data \u0026lt;= req.data; //等价于vif.data \u0026lt;= tr.data; endtask    req是父类uvm_driver中变量，类型是传递给uvm_driver的参数，这里传递的参数是my_transaction，所以父类uvm_driver中的req类型就是my_transaction。 my_driver继承了uvm_driver类，所以可以直接使用uvm_driver中的req，而不需要在my_driver中声明定义req。  加入sequence： 前面所示代码中激励都是在driver产生的，正常情况driver只是传递激励，而不是产生激励，所以要将激励产生从driver中移除，从外界获得激励，那driver的激励应该从哪里产生呢？这就是sequencer要做的事情，也就是说sequencer要提供req(这里为my_transaction)给my_driver。那么sequencer的transaction从哪里来？\n     `uvm_do(my_trans)实现了以下操作:\n 创建一个my_transaction的实例my_trans 将其随机化 最终将其传送给my_sequencer(此宏不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer)  sequence工作机制：\n      对于1， my_sequencer等待。 对于2， my_sequencer等待。 对于3， my_sequencer将my_sequence中的my_trans发送给my_driver。  待解决问题：\n my_driver如何向my_sequencer发送transaction接收请求？ my_sequence如何向my_sequencer发送transaction？  my_driver向my_sequencer发送申请：      注意：  seq_item_port是uvm_driver中的成员变量。 seq_item_export是uvm_sequencer中的成员变量。  my_sequence向my_sequencer发送my_transaction： 前面提到， my_sequence中的`uvm_do不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer，所以需要额外启动连接，以在当前顶层my_env中手工启动为例(一般都是在顶层启动)：\n1 2 3 4 5  task void my_env:: main_phase(uvm_phase phase); my_sequence seq; seq = my_sequence::type_id::create(“seq”); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask        my_sequence自动启动机制default_sequence： 前面my_sequence是在my_env中手工启动的，default_sequence可以自动启动my_sequence 。\n1 2 3 4 5 6 7 8 9 10  task void my_env:: main_phase(uvm_phase phase); 将下列代码去掉： my_sequence seq; seq = my_sequence::type_id::create(“seq”); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask virtual function void my_env::build_phase(uvm_phase phase); uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endtask   树形结构通信通道变化： 原始：\n     现在：      注意：  蓝色部分: top_tb与树形结构的连接 紫色部分: transaction在my_checker和monitor之间的通信通道 红色部分: transaction在my_sequence,my_sequencer和my_driver之间的通信通道 单箭头虚线部分: 实际没有显性直接通道，均通过上一层connect实现 双箭头虚线部分: 代表同一模块  截至目前的树形结构：      目前，树形结构除my\\_case0顶层之后，均已构建完成，并全部打通。后面要添加my\\_case0。 加入base_test：      base_test.sv代码:\n1 2 3 4 5 6 7 8 9 10  class base_test extends uvm_test; `uvm_component_utils(base_test) my_env env; //my_env会在base_test中实例化,base_test取代env称为顶层。 endclass function void base_test::build_phase(uvm_phase phase); //my_sequence需要在顶层启动连接,因为base_test变成顶层,所以从my_env中移到此处  uvm_config_db# (uvm_object_wrapper)::set(this, “env.agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endfunction   top_tb.sv代码:\n1 2 3 4 5 6 7 8 9 10  module tob_tb initial begin // 将： // uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.agt.drv”, “vif”, input_if) // run_test(“my_env”); // 改成：  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.env.agt.drv”, “vif”, input_if) run_test(“base_test”); end endmodule   加入my_case0：      1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下重载了base_test中的my_sequence的启动，注意bast_test中的仍保留。  uvm_config_db# (uvm_object_wrapper)::set(this, “env.agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endfunction   注意：\n my_case0是继承了base_test的一个子类, 是base_test的一个更具体的实现，也就从这里形成了testcase的概念，这个testcase的名字就是my_case0。 my_case0没有改变激励产生的方式，即仍然是启动了my_sequence，并利用my_sequence中`uvm_do(my_trans)来全随机产生激励。  加入my_case0_sequence： my_case0_sequence.sv代码:\n1 2 3 4 5 6 7 8  class my_case0_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8’hff;}) endtask endclass   注意：\n my_case0_sequence是继承了my_sequence的一个子类, 是my_sequence的一个更具体的实现。 my_case0_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’hff的数据激励。  my_case0.sv代码:\n1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下将my_case0_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_case0_sequence::type_id::get()); endfunction   注：\n 这里制造了一个用例my_case0，此用例每个transaction产生8’hff数据的激励。 这里my_case0成为新的顶层。  将顶层base_test替换成my_case0： 1 2 3 4 5 6 7 8  module tob_tb initial begin // 将： // run_test(“base_test”); // 改成：  run_test(“my_case0”); end endmodule   run_test()作用：它会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的main_phase。\nrun_test给我们最初的印象是构建了一个脱离了top_tb的树形结构，并完成了所有内部需要交互部件的打通。现在我们需要改变一下思维，这里当调用run_test(“my_case0”)时，不再考虑树形结构，我们用一个更抽象的概念来描述run_test的行为，那就是：它执行一个用例my_case0，而且只有一个用例在执行，这条用例每个transaction都在产生数值为8’hff的数据。我们平时所谓的跑各种各样的用例，这些用例其实都是基于这个去构造和命名的(在uvm平台中)。\n用例构造 构造另一个用例my_case1:\n my_case1_sequence.sv:   1 2 3 4 5 6 7 8  class my_case1_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8’haa;}) endtask endclass   注意：my_case1_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’haa的数据激励。\n my_case1.sv:   1 2 3 4 5 6 7 8 9  class my_case1 extends base_test; `uvm_component_utils(my_case1) endclass function void my_case1::build_phase(uvm_phase phase); //以下将my_case1_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_case1_sequence::type_id::get()); endfunction   注意：这里制造了一个用例my_case1，此用例每个transaction产生8’haa数据的激励； 如果想要运行这个用例，那my_case1将成为新的顶层，也就是将top_tb中的 run_test(“my_case0”) 改为 run_test(“my_case1”)\nUVM测试用例启动 由于run_test在top_tb中只能调用一次，所以每次跑新的用例，都要手动改一下run_test()的参数名字，试想我们有10000个用例，如果都手动改，那肯定是不可行的，所以UVM提供了另外一种启动方式。\n1 2 3 4 5  module top_tb initial begin run_test(); end endmodule   此方式将run_test()中的参数去掉，并利用UVM_TESTNAME从命令行中获得测试用例的名字，例如:\n\u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case0 \u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case1 注：sim command为eda厂商提供的仿真命令，后面会有介绍。\nUVM验证平台启动和封装 非基于uvm验证平台仿真启动 注意：.f文件里分别是验证环境和设计的代码文件列表。\n sysnopsys:  编译：vcs –f env_vcs.f –f design_vcs.f –verdi_compile_option –coverage_compile_option …… 仿真：./simv –verdi_rrun_option –coverage_run_option ……   cadence:  编译：irun –f env_irun.f –f design_irun.f –verdi_compile_option –coverage_compile_option …… 仿真：irun –verdi_irun_option –coverage_run_option …… 编译：xrun –f env_xrun.f –f design_xrun.f –verdi_compile_option –coverage_compile_option …… 仿真：xrun –verdi_run_option –coverage_run_option ……    基于uvm验证平台仿真启动  sysnopsys:  编译：vcs –f env_vcs.vf –f design_vcs.f –verdi_compile_option –coverage_compile_option –ntb_opts uvm …… 仿真：./simv –verdi_rrun_option –coverage_run_option +UVM_TESTNAME=my_case0 ……   cadence:  编译：irun –f env_irun.vf –f design_irun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：irun –verdi_irun_option –coverage_run_option +UVM_TESTNAME=my_case0 …… 编译：xrun –f env_xrun.vf –f design_xrun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：xrun –verdi_run_option –coverage_run_option +UVM_TESTNAME=my_case0 ……    注意：需要在env.vf中包含uvm的库文件：\n$UVM_HOME/src/uvm_macros.svh $UVM_HOME/src/uvm.sv $UVM_HOME/src/uvm_pkg.sv $UVM_HOME/dpi/uvm_dpi.sv +incdir+$UVM_HOME/src 对于vcs和irun/xrun还有一点需要注意：\n 对于vcs,使用uvm库时需: include ”uvm_pkg.sv” 对于irun/xrun,使用uvm库时需: import uvm_pkg::*  基于uvm验证平台的封装 为什么要对验证平台封装？ 到目前为止，我们就可以利用基于uvm的验证平台跑用例进行验证了。经历了漫长痛苦的uvm环境开发之后，当我们在自己独立开发的uvm验证环境中，成功跑完第一条用例my_case0仿真用例的那一刻，发现之前的付出都是值得的，当我们利用自己制造的人生第一条用例my_case0找到人生第一个设计bug的那一刻，发现人生已经达到了巅峰。但是作为一名优秀的验证工程师，我们的成就不仅如此，因为我们的目的不仅仅是找到bug，而是快速高效的找到bug。\n当基本验证平台可以使用，进入初期验证阶段之后，你会发现，可能会有不同的验证工程师在此验证环境中开发新的功能，可能会有不同的设计人员在此验证环境中复现bug，也可能包括自己在内的工程师需要在此验证环境中运行各种各样配置的用例，如果每次都需要自己去改变底层仿真命令或者告诉其它人怎么改底层仿真命令，你会发现整个人都不好了。而且如果所有人都自己去手动改环境底层代码跑用例，到最后整个验证平台也会变得非常杂乱，非常不好维护，并且就实际情况，大部分设计工程师是不接受每次跑用例都需要自己手动改代码的。\n为了解决这些问题，使环境变得更加整洁高效，维护简单，便于扩展，我们将环境进行封装。\n封装的原则是什么？  对自己白盒： 所有的底层运行验证环境的编译选项和仿真选项都要自己维护开发；所有的新的开发需求需要自己来指定结构和位置；所有的内部uvm固有部件骨架都要自己维护开发。 对验证工程师灰盒： 熟悉整体环境运行原理；熟悉各编译和仿真选项含义，验证过程中知道如何增减选项；在指定的结构和位置开发新的功能；不需要对此uvm环境固有骨架进行全面掌握。 对设计工程师黑盒： 不需要知道任何环境内部构造，只需要按照验证工程师提供的脚本命令运行用例即可。  如何对验证平台封装？ 环境采用脚本封装，一般只需提供命令和接口选项，脚本可以使用Makefile，python，perl，shell等。以python脚本封装为例。\n 仿真命令： ./runtest.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim  seed : 提供仿真种子号 -dump : 产生波形 -cov : 打开code coverage收集 -funcov : 打开function coverage收集 -debug : 仿真结束后自动弹出波形 -covermerge : 仿真结束后自动merge coverage数据 simpath : 指定生成log的文件夹    上述接口选项最终都会呈现在底层编译和仿真命令中，使用者可以根据需求打开关闭提供选项，而不必需要知道环境内部的细节。如果有新的需求，开发完毕后提供对应的接口即可，大大减少了使用的低效性。\n封装脚本的构造 封装脚本一般分为两部分： 单条用例运行脚本 和 回归用例运行脚本。\n  单条用例运行脚本：\n 用户提供testcase list。 根据脚本提供用例名字在tclist找到对应的用例属性，包括uvm中提供的test名字(如my_case0),用例所在路径等。 在sim下创建以用例名字+种子号命名的文件夹，后面生成的这条用例的所有相关信息，包括log和波形等都会存放在这里。 根据脚本提供选项进行整个环境的编译工作。 根据脚本提供选项进行整个环境的仿真运行。 用例运行结束后，根据仿真产生的log，得到并打印出pass还是fail的信息，方便使用者进行快速判断。 使用者到对应的sim/testcase_name_seed/下查找所有相关log和波形，进行相关debug。 添加其它功能，例如coverage的merge，但是一般只有回归才会涉及到merge的工作，所以这部分功能可以放到回归脚本中。    回归用例运行脚本：\n 识别脚本提供的tclist中提供的回归组名，将所有指定组的用例进行仿真回归。 内部调用单条用例脚本，并将回归用例脚本输入参数全部转换为单条用例脚本输入参数需要的格式。 监测每条用例的仿真结果，并累加计数得到总的tc数，总pass tc数，总fail tc数，和总的没有产生仿真log的tc数。 判断是否所有用例运行结束，并打印最终回归报告。 如果打开coverge merge选项，会自动merge所有回归用例的coverage数据。 回归结束后在sim下生成pass，fail的tclist, 同样每条用例的结果也都存在以用例名字+种子号命名的文件夹中，可以实时查看。    跑单条用例命令： ./rt.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim\n  跑回归用例命令： ./rt.py –regress –rgr_group=my_regression -seedrand –dump –cov –funcov –covmerge simpath=./sim\n  UVM验证平台的优化 优化目的是什么？  针对平台结构优化： 使环境结构简洁，清晰明了，重用性好，移植性强，拓展性高，让新的用户和开发者能够快速切入。 针对平台性能优化： 使环境运行速度提升，提高验证效率  如何优化验证平台？   针对平台结构优化：\n 加入readme，包含运行方法等必要信息。 加入setup脚本，所需一切配置均在此一键完成。 环境中用到所有路径宏均统一管理，方便更改和移植。 运行中间文件统一管理，方便查看和删除。 目录结构清晰，文件夹命名需简洁易懂。 删除开发过程中的无效代码和目录。 加入必要信息打印开关，方便读取层次结构。 撰写平台使用手册，进行环境详细说明。    针对平台性能优化：\n 检查变量定义，减少存储空间占用，如需要超大容量数组时，需使用关联数组。 检查哪些任务可以并行执行，改成fork_join*多线程机制。 检查是否transaction约束过多，如过多速度会明显变慢。 检查dut文件列表，去掉不必要文件，减少环境编译时间。 检查是否有不必要打印，关掉以减少log输出占用的时间。 检查model，checker，driver中是否有过多占用时间的函数，重新考虑是否有高效替代方案。 利用第三方工具得到平台各个部件的时间占用分布，分析占用最多的几个部件原因，寻找解决方案。    uvm验证平台目录组织结构 verif/my_ut/env下文件：\n agents/ ： agent文件目录，内含一个或多个agent，agent包含driver、sequencer、monitor组件，agent从行为上可以理解为与dut交互的模块或组织。 coverage/ ： coverage文件目录，内含一个或多个模块的覆盖率文件，也就是covergroup。 checker/ ： checker文件目录，也就是reference model和scoreboard文件，不过有时候会将两者融合成一个checker文件。 include/ ： include文件，一些环境路径的宏定义以及其他include文件存放在这里。 interface/ ： interface文件目录，内含一个或多个接口文件。 script/ ： script文件目录，一些验证平台封装的脚本文件存放在这里。 setup/ ： setup文件目录，一些平台初始化文件存放在这里，如环境变量的初始化和工具的配置。 tests/ ： tests文件目录，所有测试用例存放在这里。 readme ： readme文件，对环境和使用的说明文件。 tb.v ： tb文件，顶层testbench。 env_vcs.f ： env_vcs.f文件，针对vcs工具的filelist文件，包含设计和验证平台的文件列表。 env_xrun.f ： env_xrun.f文件，针对xrun工具的filelist文件，包含设计和验证平台的文件列表。 tc.list ： tc.list文件，包含所有测试用例信息，可为测试用例设定分组，方便回归测试。 my_env_cfg.sv ： my_env_cfg.sv文件，整个验证平台的配置文件，内含静态变量，可传递至平台任意模块，完成验证平台的配置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":15,"section":"docs","tags":["UVM"],"title":"UVM与验证平台","uri":"https://www.wenhui.space/docs/digital_verifer/creation/uvm_and_verification_platforms/"},{"content":"本文 主要介绍一种有效解决RTL编译时依赖关系问题的方法。\n   版本 说明     0.1 初版发布    关于include 一般在文件中会用include来加载依赖的文件，其效果就好比将依赖文件的内容复制粘贴至此。当然你可以将所有依赖文件都进行include，也就是不仅仅是宏定义文件和函数文件，还包含子模块的文件，这样层层include，自然形成一个完整的编译顺序，而只需要给工具指定最顶层的文件和提供include路径即可。但是并不建议这样实现，因为除了影响代码整洁性（可能某模块子模块众多），还会使代码难以维护。所以我们一般只include宏定义文件和函数文件，这样指定的include路径也会很清楚。\n有时候一个文件可能会被多个文件include，为了防止被重复编译，往往会加上ifdef判断条件。虽然重复编译不一定带来问题，但毕竟也影响了编译效率，所以还是要尽量消除重复编译。方法如下：\n1 2 3 4 5 6 7 8  `ifndef __file_name `define __file_name  //....... //File content...... //.......  `endif   在文件的开头和结尾添加如上内容后，当第一次编译该文件时，不会有“__file_name”的宏定义，所以编译文件内容，当再次编译该文件时，已经定义“__file_name”，ifndef的判断会使该文件不被重复编译。这样的方法是被推荐的，建议所有文件的头尾都添加如上内容。\n关于filelist 一般工程中都会用filelist文件来进行维护，这也是最方便的。filelist文件描述的顺序，就是编译顺序，所以这里要小心，要将最底层模块定义到前列，优先编译，否则编译其他模块时找不到其依赖模块，会报编译错误。这里提供两个技巧：\n 较大设计中，分割子模块，定义各个子模块的的filelist，在上层filelist中采用“-f path/xxx_subfilelist”的形式引入子模块filelist（注意要指明路径），这样由子模块的设计师维护子模块的filelist，待合并系统时，再合并filelist。 加载某一目录下的文件，可以使用“-y”，而不必关心编译顺序，工具会自动识别顺序，使用方法为：  “+libext+.v+.sv”（指明加载后缀为.v和.sv的文件） “-y file_path”（加载该路径下所有后缀为.v和.sv的文件）   “-y” 的使用其实是加载库文件的方法，为了不将设计扁平化，需要在verdi打开时添加“-ssy”，这样可以保持设计的层次化。 include路径必须添加在filelist前部。  示例：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/other_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 “+define+”是传入define参数。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":16,"section":"docs","tags":["Verilog"],"title":"如何更好的解决RTL编译时依赖关系问题","uri":"https://www.wenhui.space/docs/digital_designer/other_tips/resolve_dependencies_rtl_compile/"},{"content":"本文 主要介绍一款自动插入英文翻译的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  Emacs: 自动插入翻译后的字符串 Github：insert-translated-name  补充说明： 这个英文补全的emacs插件是基于google翻译的，可能需要先安装google翻译才可以使用，由于安装此自动插入英文翻译的插件时已经安装google翻译，所以并未考证。如果需要安装google翻译，请参考我的另一篇帖子 GoldenDict的安装 中 添加google翻译这一节。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":17,"section":"docs","tags":["emacs"],"title":"emacs插件之自动插入英文翻译","uri":"https://www.wenhui.space/docs/about_emacs/emacs_insert_english_translate/"},{"content":"本文 主要介绍debug工具Verdi的使用，并对自己使用过程中的经验进行总结。\n   版本 说明     0.1 初版发布    参考  Verdi and Siloti Command Reference Verdi (Premier) Training  百度网盘分享资源 链接：https://pan.baidu.com/s/1h5xm8-poxOwjL14MzBH4pw 密码：4kb6\n专业术语与缩略语    缩略语 全称 含义     RMB Right Mouse Button 鼠标右键   MMB Middle Mouse Button 鼠标中键   LMB Left Mouse Button 鼠标左键   DC Double-click 双击   D\u0026amp;D Drag and Drop 拖拽   KDB Knowledge Database 知识数据库   FSDB Fast Signal Database 快速信号数据库   TFV Temporal Flow View 时序界面   BA Behavior Analysis 行为分析    Set Up the Environment 指定路径和环境变量  Binary File：   1 2  setenv NOVAS_INST_DIR \u0026lt;Path to Novas installation\u0026gt; set path = ($NOVAS_INST_DIR/bin $path)    License File：   1 2  setenv NOVAS_LICENSE_FILE \u0026lt;license_file\u0026gt;:$NOVAS_LICENSE_FILE   添加符号库  为什么使用符号库：  符号库提供了源代码到逻辑单元的映射，没有符号库，原理图将仅显示正方形而不是逻辑单元。\n 创建符号库：  syn2SymDB:适用于 ASCII格式的Synopsys logic library(.lib) map2SymDB:适用于已有的map file 参考\u0026lt;verdi_install\u0026gt;/doc/Symbol_Library.pdf   设置符号库环境变量：   1 2  setenv NOVAS_LIBS\u0026#34;LIB ROOT#1\u0026gt;\u0026lt;LIB ROOT#\u0026gt;…\u0026#34; setenv NOVAS_LIBPATHS\u0026#34;\u0026lt;Directory#1\u0026gt;\u0026lt;Directory#2\u0026gt;…\u0026#34;    通过GUI设置符号库：  菜单栏点击Tools–\u0026gt;Preferences 在打开的子窗口中 Find一栏 查找 Schematic \u0026ndash;\u0026gt;Symbol Library 填写Symbol Library Name 填写Symbol Library Path 保存，然后设置将被保存到novas.rc 源文件中。    使用Setup文件 novas.rc  指定路径：  setenv NOVAS_RC /novas.rc 直接通过命令行命令 -rcFile 来进行设置   搜索顺序：  -rcFile 命令行选项 NOVAS_RC环境变量 ./novas.rc $HOME/novas.rc /etc/novas.rc    首选项 通过Tools–\u0026gt;Preferences打开窗口，所有设置将被保存在novas.rc文件中，在Find窗口栏中根据关键字搜索。比如设置字体大小和颜色，在find栏搜索font，找到相关项，设置完毕后保存为novas.rc，可添加为Verdi的Setup文件，一劳永逸。\nFSDB   什么是FSDB文件：\n 压缩的二进制文件格式，包含仿真信号数据。 开放文件格式，其他的供应商工具可以dump波形，比如Verisity，Vera，Ikos，etc. 利用System Task来帮助dump。    常用的系统任务：\n fsdbDumpfile： 指定FSDB文件名和限制文件大小(单位MB，若超出限制只保留最新，也可不限制大小)，如 “$fsdbDumpfile(\u0026ldquo;top.fsdb, 500\u0026rdquo;);” 。 fsdbDumpvars： Dump指定变量，可以指定dump特定的实例和层次深度，可以指定FSDB文件名，以及指定其他option参数，如 “$fsdbDumpvars(0, top.dut1.u1, \u0026ldquo;+fsdbfile+u1.fsdb\u0026rdquo;, \u0026ldquo;+all\u0026rdquo;);”，也可以使用“$fsdbDumpvarsToFile(\u0026ldquo;dump.list\u0026rdquo;);”。 fsdbDumpon/fsdbDumpoff： 打开和关闭fsdb Dumping，如 “#0; #50000 $fsdbDumpvars; #50000 $fsdbDumpoff; #50000 $fsdbDumpon; #50000 $finish;”，指保存50000~100000和150000~200000时间段波形。 提示：更多信息请查看文档linking_dumping.pdf。    为FSDB dumping 链接Novas Object文件  创建环境变量：   1 2 3 4 5 6 7 8  #Setup license file for simulator setenv LM_LICENSE_FILE \u0026lt;simulator_license_file\u0026gt; #Setup path for simulator setenv \u0026lt;Simulator\u0026gt;_INST_DIR \u0026lt;simulator_tool_install\u0026gt; #Setup path for Novas tool setenv NOVAS_INST_DIR \u0026lt;Novas_install_path\u0026gt; #Setup LD_LIBRARY_PATH to specify the appropriate shared object files setenv LD_LIBRARY_PATH ${NOVAS_INST_DIR}/share/PLI/\u0026lt;simulator\u0026gt;/\u0026lt;platform\u0026gt;   FSDB文件处理  vfast： 将VCD文件转化为FSDB文件。 fsdb2vcd： 将FSDB文件转化为VCD文件。 fsdbextract： 在已经存在的fsdb文件中提取信号，范围，时间周期，而不用重新进行仿真。 fsdbmerge： 将多个文件进行合并。 fsdbreport： 针对一个特定的信号，将值得变化情况生成report。 提示： 使用 “ -h” 查找帮助，或参阅《 Verdi Command Reference》。  Import Design 命令行导入设计 1 2 3 4  verdi -f \u0026lt;file_list\u0026gt; +define+GETTHEMOSTOUTOFYOURTIME verdi -f \u0026lt;file_list\u0026gt; -top TopBlock verdi \u0026lt;source_file1.v\u0026gt; -sv \u0026lt;source_file2.sv\u0026gt;… verdi system.v ... alu.v -v lib.v -y ../special -ssv -ssy   推荐使用命令： “verdi -f run.f -ssv -ssy” ，其中run.f内容如下：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/other_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -ssv和-ssy是对-v导入的库文件和-y指定的路径中的模块被视为普通模块，而不是库单元，如果库单元的话会无法显示Hierarchy。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 +define+是传入define参数。  图形化界面上导入设计  命令行输入verdi ，打开verdi 图形化界面。 菜单栏File-\u0026gt;Import Design 或 菜单栏上的Import Design符号 导入设计。 选择language、run file或源文件，不建议使用VHDL。  Debug in Source Code View Open nTrace Window  导入设计后，Verdi会自动打开nTrace窗口。 nTrace窗口包含三个可调整大小的子窗口：左侧Hierarchy Browser Pane，右侧Source Code Pane，下方Message Pane。  Search and Collapse Hierarchy Browser  折叠全部区域： 在hierarchy browser pane，点击鼠标右键选择Collapse All Scopes 折叠和展开选中项： 在hierarchy browser pane，点击所选项的“+”即展开，“-”即折叠。 搜索： 在hierarchy browser pane，点击鼠标右键选择Show Navigation TextField（快捷键Ctrl+s）。  在搜索框输入通配符字符串并回车即可，如CH*，可匹配CHILD1、CHILD2、CHILD3\u0026hellip; 搜索框右侧提供了prev和next操作，并且可以选择搜索记录。 在Filter搜索框输入通配符字符串，选择匹配项（模块、函数、任务、类\u0026hellip;），回车显示所有匹配结果   所选项（一般指module）鼠标双击，即可显示Source Code 所选项鼠标右键可选择Copy Full Path（或快捷键Ctrl-H），这对验证环境中需要引用信号需要全路径时非常有用。 所选项鼠标右键可选择Set/Unset Bookmark，可设置和取消书签，在在hierarchy browser pane右键选择Manage Bookmarks可快速回到书签标记项。 Instance显示层级关系，也可以选择Declaration，将所有模块平铺显示，搜索功能与上文描述相同。 快捷键Shift-S打开Find Scope窗口，可以查找模块、任务、函数等，列出模块名和例化列表（全路径）， 查找模块推荐使用此方法 。  Traverse Source Code  快速搜索信号、实例或实例端口： 使用快捷键Shift-A打开Find窗口，编辑框内显示当前打开的Source Code模块全路径，如果此模块内查找则保留全路径，在最后编辑通配符字符串，如果全设计中搜索，则删除全路径，直接编辑通配符字符串， 查找信号推荐使用此方法 。 查找字符串： Source Code窗口上方工具栏有搜索框，编辑通配符字符串即可全文搜索，支持Prev和Next，以及历史记录（注：通配符为*，可代表任意字符串）。 使用书签： Source Code窗口上方工具栏有书签图形，点击可将当前Source Code的当前行设置/取消书签（也可使用快捷键Ctrl-F2），在菜单栏Source选中Manage Bookmarks打开Source书签管理窗口，可快速跳转至某书签位置。 多文件调试时推荐使用此方法 。 模块的层次跳转： Source Code窗口上方工具栏有向上直角箭头和向下直角箭头两个图标，向上箭头代表跳转到当前模块的例化语句，向下箭头代表进入此例化模块（选中例化名）/双击亦可。 双击模块名： 双击Source Code窗口打开的模块名，跳转到上层模块例化当前模块的语句，并且在message窗口列出例化此模块的文件全路径、文件名以及行号，双击message信息可跳转至该模块被例化语句。 撤销操作： Source Code窗口上方工具栏有向左箭头和向右箭头两个图标，代表操作的回退和前进。  Operate on Signals  信号的Driver and Loads： Source Code窗口上方工具栏有“D”和“L”图标和向上箭头和向下箭头图标，选中信号，D代表查看driver，L代表查看load，箭头代表Prev和Next，双击信号也可以达到查看Driver效果。 选中信号并右键可选择Copy Signal\u0026rsquo;s Full Path，这对验证环境中需要引用信号需要全路径时非常有用。 Load Simulation Results： 菜单栏File -\u0026gt; Load Simulation Results 加载FSDB文件，也可以在打开verdi时命令行添加参数-ssf nova.fsdb。 Source Code窗口显示信号值： 当加载FSDB文件后，光标停留在Source Code窗口，使用快捷键x，可以在代码中显示信号值，当前仿真时间在上方工具栏显示，且可调整，可选择信号下/上一个值变化（沿）来跳转模拟时间，注意信号值与波形窗口光标所在模拟时间保持一致，建议通过波形窗口来控制模拟时间的跳转。 将信号添加到波形窗口： 选中信号（按住Ctrl可选择多个信号），鼠标右键选择Add Signal(s) to Waveform， 建议使用快捷键Ctrl+w 。 选中信号鼠标右键选择Signal，可以设置Radix，默认十六进制。  Debug in Waveform View Open nWave Window  选择Tools -\u0026gt; New Waveform 或者 点击菜单栏波形窗口图标。 加载FSDB文件后，选中信号，使用快捷键Ctrl+w，将信号添加到波形窗口，工具会自动打开波形窗口。 使用命令行如“verdi –f run.f –ssf nova.fsdb”启动verdi时，会自动打开波形窗口。 在波形窗口也可以加载FSDB文件，波形窗口菜单栏File -\u0026gt; Open 或 使用工具栏打开文件图标。  Add Signals  Source Code窗口选中信号使用快捷键Ctrl+w可以添加信号到波形窗口。 波形窗口菜单栏Signal选择Get Signals 或 使用工具栏信号图标，将打开添加信号窗口，可以选择当前模块的输入、输出、寄存器、线网等信号，或搜索信号，添加至波形窗口。 提示： debug时往往边分析代码边查看波形，使用场景更多是一个个添加追踪，所以大多使用Ctrl+w； 而波形窗口菜单栏添加信号，往往在查看输入输出信号x态时使用，统一添加所有输入输出端口信号，而无需一一添加。  Organize Signals  创建信号组： RMB -\u0026gt; Group Operations -\u0026gt; Add Group to add groups； RMB -\u0026gt; Group Operations -\u0026gt; Insert Subgroup。 修改组名： 选中组，RMB -\u0026gt; Rename。 跳转至信号组： RMB -\u0026gt; Go To， 菜单栏也可操作。 折叠与展开组： 双击\u0026quot;+\u0026rdquo;/\u0026quot;-\u0026quot;。 添加空白分隔行： RMB -\u0026gt; Add Blank。  Operate on Signals  信号移动： 信号列表中金色标线代表移动至此，可通过鼠标中键调整金色标线位置，选中对应信号后，使用快捷键m，即可将信号移动至金色标线位置，并且金色标线移动至添加信号的下方（按住Ctrl或下拉可选择多个信号，按选择顺序添加）。 信号复制： RMB -\u0026gt; Copy， 快捷键Ctrl+P。 信号粘贴： RMB -\u0026gt; Paste， 快捷键Insert（粘贴至金色标线位置）。 删除信号： 选中信号按delet键（选中可以使用按住Ctrl或下拉选中多个信号）。 右键可复制信号全路径。 bus总线可以双击展开单bit信号显示，也可双击折叠。 bus总线可以分组显示，RMB -\u0026gt; Bus Operation -\u0026gt; Expand as Sub-bus， 可以设置每组bit数。 可将多个单比特信号组合为bus显示： RMB -\u0026gt; Bus Operation -\u0026gt; Create Bus。 可以添加注释： RMB -\u0026gt; Add Comment，添加注释行，在波形注释行右键可选择添加注释文本框，且文本框箭头可拖拽指向位置（个人觉得debug时使用不多，在做PPT展示讲解时很有必要）。 信号沿追踪和搜索信号值： 菜单栏有沿选择（任何变化、上升沿、下降沿、总线值等），左右操作图标（可向前跳转和向后跳转），当选择总线值时，左即向前搜索，右即向后搜索。 保存信号列表： 菜单栏File -\u0026gt; Save Signal，或快捷键Shift+s，打开Save Signal窗口，在默认路径后输入文件名（路径可修改），无需写文件后缀，默认后缀为“.rc”。注意：如果信号中有使用参数化表示范围，请在Options选项取消Events的选择，这样当参数变化时波形信号保持一致。 加载信号列表： 菜单栏File -\u0026gt; Restore Signal，如果在命令行则使用“–sswr .rc”。  Manipulate Waveform Display  设置标记： 菜单栏Waveform -\u0026gt; Marker 或 快捷键Shift+m，打开Marker窗口，可设置名称、时间、颜色、线的形状等，可对标记进行添加、删除、修改（标记也会保存至Signal文件），在debug时对信号的追踪使用标记很有用，可标记关键节点。 修改信号值显示进制： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Radix，可更改显示进制。 设置信号值显示别名： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Edit Alias，打开Alias Editor窗口，可为数值设置别名，以及颜色（这对状态机State信号显示特别有用）， 使用apply可应用已设置的alias。 显示毛刺： View -\u0026gt; Display Glitch。 event报告： 选中信号，View -\u0026gt; Signal Event Report，可以显示信号信息，包括上升沿数量、下降沿数量、翻转频率，可选择统计起始和结束时间，这对统计某时间段clk（或其他信号）翻转数很有用，好像只能统计单比特信号。 添加网格： View -\u0026gt; Grid Options 打开Grid Options窗口，可以根据所选信号的上升/下降沿添加网格，也可以自定义周期在特定时间范围内添加网格，当波形窗口信号较多时添加参考网格非常有用。 选择一段时间： 鼠标中间设置起始位置， 鼠标左键设置终止位置。 选择无翻转信号： 首先选择一段时间，然后快捷键Ctrl+s，快速选择选择时间内无翻转信号。 波形显示窗口： Ctrl+鼠标滚轮，缩放窗口；鼠标拖拽选中区域填充整个窗口；Shift+鼠标滚轮，波形左右移动（时间前后）。  Debug in Schematic View 待补充\nDebug in FSM View 待补充\nDebug in Temporal Flow View 待补充\nFrequently Used Preferences 打开TCL命令窗口  Preferences -\u0026gt; General -\u0026gt; Enable TCL Command Entry Form(将其切换为选中状态)。 可以在TCL Command窗口输入TCL命令来执行，同时在Verdi中执行的任何操作，其对应TCL命令都将记录在此处（换句话说，你可以通过图形化操作来找到对应的TCL命令）。  Source Code 相关  关于Source Code窗口，最常用的设置无非是字体的大小，可以在这里找到，或直接搜索Font，找到Source Code的Font设置选项。  Waveform 相关  General： 可以设置以不同的颜色显示输入/输出信号。、 View Options： 可以设置进制、信号值与别名等。 Color / Font / Pattern： 可以设置外观和字体颜色大小等。  其他 关于首选项，可设置参数挺多的，不过一般不会使用到，也不建议做太多更改，我使用最多的就是对字符大小的更改，方便浏览代码。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":18,"section":"docs","tags":["EDA工具"],"title":"Verdi使用总结","uri":"https://www.wenhui.space/docs/digital_verifer/tools/verdi_userguide/"},{"content":"本文 主要分享我摘自微博的关于美食系列漫画，作者为 心壹绘画 。\n展示   1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19      20      21      22      23      24      25      26      27      28      29      30      31      32      33      34      35      36      37      38      39      40      41      42      43      44      45      46      47      48      49      50      51      52      53      54      55      56      57      58      59      60      61      62    分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1elUURr8CgDQ4c91EEpZX3w 密码：1cz1\n","description":"","id":19,"section":"docs","tags":["美食"],"title":"我的收藏-美食漫画","uri":"https://www.wenhui.space/docs/about_life/food-comics/"},{"content":"本文 主要分享我收藏的中国烹饪古籍丛刊，文件为电子扫描版PDF格式。\n介绍 中国烹饪古籍丛刊是由中国商业出版社出版的，好像最早是1984年9月出版第一种《易牙遗意》，最晚是1993年出版的《太平御览·饮食部》，但始终不知总目，不知出版了多少种，我这里收藏的有33种。这些烹饪古籍，都是古代人智慧的结晶，也许对现在物质如此丰富且与时俱进的社会，不会有太多借鉴之道，但是由此可以了解到古人文人对吃文化的追求，以及关于吃的闲文趣事。\n我收藏的中国烹饪古籍丛刊共计33本，名录如下：\n 中国烹饪古籍丛刊 01 云林堂饮食制度集_11199761 中国烹饪古籍丛刊 02 易牙遗意_11404103 中国烹饪古籍丛刊 03 中馈录_11414100 中国烹饪古籍丛刊 04 醒园录_11131465 中国烹饪古籍丛刊 05 随园食单_11132930 中国烹饪古籍丛刊 06 素食说略_11132919 中国烹饪古籍丛刊 07 吕氏春秋本味篇_10508261 中国烹饪古籍丛刊 08 养小录_11404102 中国烹饪古籍丛刊 09 千金食治 食疗方_10807464 中国烹饪古籍丛刊 10 清异录（饮食部分）_10826528 中国烹饪古籍丛刊 11 闲情偶寄_10122795 中国烹饪古籍丛刊 12 齐民要术（饮食部分）_11122013 中国烹饪古籍丛刊 13 食宪鸿秘_11138805 中国烹饪古籍丛刊 14 随息居饮食谱_10093750 中国烹饪古籍丛刊 15 饮馔服食笺_11404150 中国烹饪古籍丛刊 16 饮食须知_10094041 中国烹饪古籍丛刊 17 能改斋漫录（饮食部分）_11476167 中国烹饪古籍丛刊 18 先秦烹饪史料选注_11476279 中国烹饪古籍丛刊 19 吴氏中馈录 本心斋疏食谱 （外四种）_11404172 中国烹饪古籍丛刊 20 居家必用事类全集（饮食类）_10508260 中国烹饪古籍丛刊 21 造洋饭书_11404173 中国烹饪古籍丛刊 22 菽园杂记（饮食部分）、升庵外集（饮食部分） 、 饮食绅言（饮食部分）_11404158 中国烹饪古籍丛刊 23 粥谱（二种）_10762172 中国烹饪古籍丛刊 24 山家清供_11046668 中国烹饪古籍丛刊 25 调鼎集_11550671 中国烹饪古籍丛刊 26 筵款丰馐依祥调鼎新录_11476281 中国烹饪古籍丛刊 27 饮膳正要_11500655 中国烹饪古籍丛刊 28 浪迹丛谈四种（饮食部分）_11622664 中国烹饪古籍丛刊 29 陆游饮食诗选注_11419091 中国烹饪古籍丛刊 30 随园食单补证_11473106 中国烹饪古籍丛刊 31 清嘉录_11622981 中国烹饪古籍丛刊 32 食疗本草_10444356 中国烹饪古籍丛刊 33 东京梦华录 都城纪胜 西湖老人繁胜录 梦粱录 武林旧事_10162520  分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1ald33jJK8y91vS7wwMNWYw 密码：srgf\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":20,"section":"docs","tags":["美食","读书"],"title":"我的收藏-中国烹饪古籍丛刊","uri":"https://www.wenhui.space/docs/about_life/ancient_chinese_cooking_books/"},{"content":"本文 主要介绍了一些verilog的编码风格准则。\n   版本 说明     0.1 初版发布    参考  RTL Coding Styles That Yield Simulation and Synthesis Mismatches（链接：https://pan.baidu.com/s/16fD72mrvHfSIA531h33J2A 密码：vzrl） VERILOG CODING STYLES FOR IMPROVED SIMULATIONEFFICIENCY (链接：https://pan.baidu.com/s/1r8RETSe3ehe2T%5FK5brZbjQ 密码：t2hp)  写在前头 本文主要从三个角度来对verilog编码风格进行说明：\n 利于模拟的编码风格：可以加快模拟速度或减少模拟占用内存。 利于综合的编码风格：可以减少综合前后模拟不一致问题。 利于维护的编码风格：有利于设计的维护、交互与修改，提高设计效率。  利于模拟的编码风格  多条件下尽量使用 case 语句，不使用嵌套 if-else if-else 语句，两者占用内存差不多，但模拟速度 case 比 if 要快。 不使用多余的 begin-end， always 或 if 语句中只有一条语句，是不需要使用 begin-end 的，多余的 begin-end 会占用更多内存和减缓模拟速度。 时钟信号产生，使用 always 语句描述模拟速度更快，如下代码：   1 2 3  reg clk； initial clk = 0； always #(`CYCLE/2) clk = ~clk;    尽量避免将赋值语句分散到多个 always 块，如寄存器的赋值，建议尽量将多个寄存器描述在一个 always 块语句，而不是将每个寄存器都用一个 always 块语句来描述，这样可以减少内存和提高模拟速度。 尽量减少模块的端口数，模块端口数越多，模拟速度越慢，因此需要对设计合理划分模块。 加载测试向量时，避免在时钟的上下沿变化，而是在延时一个时间单位后，这样更能够模拟真实电路的行为，为了便于维护，可以定义CYCLE数值，延时单位采用 “0.1*`CYCLE” 形式。 显示非阻塞赋值语句的变量值，使用 $strobe ，而不是 $display 和 $write 。下面介绍一下两者的区别，举例如下：   1 2 3 4 5 6 7  initial begin a = 0; $display(a); // displays 0 $strobe(a); // displays 1 ... a = 1; // ... 因为这条语句 end   可见 $strobe 是在整个块语句结束后执行的，而 $display 是在程序位置执行的。这里是一个顺序执行的块语句，而对于非阻塞赋值语句不是顺序执行的，所以在需要显示非阻塞赋值语句的变量值时，使用 $strobe ，确保能够取到稳定的赋值后的值。\n以上是公认的编码原则，强烈建议遵循，而下面内容，仅供参考：\n 尽量减少设计层次，层次越多模拟速度越慢。 parameter 比 define 更占用内存，但模拟速度相当。 `timescale 精度越高，模拟速度越慢。 $time 等系统调用程序非常影响模拟速度，可以使用但不要滥用。 不建议设计文件中写 `timescale ，建议写在单独文件，统一进行 `include ，或在仿真工具中参数化输入。  利于综合的编码风格  顶层模块不要有粘连逻辑，顶层模块甚至次顶层模块只用来例化和连接子模块，这样不仅可以节省顶层的编译时间，还有利于布局布线的实施。 减少不必要的设计层次，更多的层次会降低综合性能，当然也可以先使用工具将设计层次铺平，如 dc 的 ungroup 。 组合逻辑与时序逻辑尽量分开描述，换句话说，寄存器always语句描述中应该只有赋值，而无其他运算。 将不同类的逻辑分散到不同模块，这样综合工具可以针对不同的逻辑类型采用适当的优化技术。 相关的组合逻辑不要拆散到不同模块，否则会限制综合工具的优化力度，好的设计就是所有输出都是寄存器输出，对于组合逻辑分散到不同模块，虽然通过工具在综合前将设计铺平的方法可以缓解问题，但作为设计师还是尽量遵循此原则。 所有输出都是寄存器，这样所有组合逻辑都在前端，最后寄存输出，这也是所说的 “cloud-register原则” ，这样既可以得到更好的综合结果，而且简化了综合的约束设计。 敏感列表要完整，当然现在可以使用*代替，或者使用 SystemVerilog 的 always_comb 。 注意阻塞赋值的语句顺序。 避免 if/case 条件不完整，否则会产生 latch，可以使用 Systemverilog 中的 always_comb、always_latch、always_ff 语句，编译时会严格检查，也可以在块描述语句 if/case 前对信号赋初值。 用 always 语句描述组合逻辑使用阻塞赋值 = 。 描述 latch 时使用阻塞赋值 = 。 描述时序逻辑使用非阻塞赋值 \u0026lt;= 。 在同一个块语句中不要混用两种赋值方式。 不要使用 #0 延迟赋值。 FSM 中的状态名应该使用 parameter。 FSM 计算下一状态的组合逻辑应该放在一个单独的 always 块。 FSM 计算下一状态的组合逻辑应该使用 case 语句。 每个 FSM 使用单独的 module 描述。  利于维护的编码风格  每个项目都使用相同的目录结构，相同的目录结构有利于脚本移植，以及增加复用性和可维护性，同时利于工作交接。 项目中每个设计都保持类似的目录结构，理由同上。 项目内脚本尽量使用相对路径，需要全路径名称则使用环境变量。 对 `include 加载的文件尽量使用完整相对路径，方便设计的集成和移植，或者对所有设计的 include 文件规范命名规则。 每个文件只包含一个 module 。 文件名和模块名保持一致。 测试文件名与被测试模块名相对应，添加 _tb 后缀。 每个文件都添加头信息：版权声明、文件描述、创建时间、修改时间、原始作者信息、当前作者信息。 注释描述代码功能，而不是行为。 每个 parameter 声明后要注释。 function 要加注释。 每个主要逻辑段落要加注释。 信号名要有实际意义，并且输入输出信号名信息中要包含输入输出模块。 废代码删掉，而不是注释。 每个模块逻辑代码尽量不要超过400行，可读性可调试性强。 每级缩进建议四个空格，并且不建议使用TAB缩进，不同编辑器对TAB支持不同，可能会导致代码显示乱掉。 每行最多72个字符，在恰当的地方换行，并保持对齐。 控制流嵌套不超过三级。 每行只写一条语句。 连续声明语句对齐，并且每行只声明一个。 句尾的注释尽量对齐。 多次使用的逻辑使用 function 。 操作符周围使用一个空格与其他项隔开。 所有信号名尽量使用小写字母，并且用下划线将单词分隔开。 常数定义和宏定义使用大写字母。 模块的名字要体现层次结构。 模块的例化名与模块名基本保持一致，不过例化名可不体现层次结构，加 “i_” 或 “inst_” 前缀。 信号名要有意义，至少5个字符。 模块根据功能命名，不要依据类型或作者命名。 项目内命名要规范，避免模块重名。 根据功能或逻辑顺序声明端口，而不是方向。 低电平有效信号加后缀 “_n” ，如复位信号 “rst_n” 。 建议时钟信号统一加前置 “clk_” 。 建议复位信号统一加前缀 “rst_” 。 建议寄存器信号统一加后缀 “_ff” ，下一拍寄存器加载的值信号添加后缀 “_nxt” 。 总线范围定义为 “N-1:0” 。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":21,"section":"docs","tags":["Verilog"],"title":"verilog的编码风格","uri":"https://www.wenhui.space/docs/digital_designer/rtl_coding/verilog_coding_styleguide/"},{"content":"本文 主要介绍Verilog语法中case，casex，casez的区别，以及建议使用方法。\n   版本 说明     0.1 初版发布    关于case  代码：   1 2 3 4 5 6 7 8 9  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 g default   xx g default   x0 c x0   1z f 1?   z1 g default    可见，case语法对四值0 1 X Z是严格匹配的，并且语义中“？”代表Z值。\n关于casez  代码   1 2 3 4 5 6 7 8 9  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 f 1?   xx g default   x0 c x0 (would have matched with z0(item 5) if item 3 is not present.)   1z d 1x (would have matched with z0(item 5) \u0026amp; 1?(item 6) also.)   z1 b 01 (would have matched with 1?(item 6) also.)    首先，casez的匹配顺序是从上到下。根据上面casez的匹配列表，可见casez语法将表达式的“z/?”与输入的任意值（0 1 X Z）匹配，而表达式的“x 0 1”和输入的“x 0 1”还是严格匹配。所以，一般我们对于不关心的信号位使用casez语句，并在选项中将该位设为\u0026quot;z/？\u0026quot;。这也是最推荐的写法。\n关于casex  代码   1 2 3 4 5 6 7 8 9  casex (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 d 1x (would have matched with 1? also)   xx a 00 (would have matched with all)   x0 a 00 (would have matched with all items except 01)   1z c x0 (would have matched with all items except 00,01)   z1 b 01 (would have matched with 1x, 1? also)    同样，casex的匹配顺序也是从上到下。根据上面casex的匹配列表，可见casex语法将将表达式中“z/?/x”与输入的任意值（0 1 X Z）匹配，而表达式中的“0 1”与输入的“0 1”严格匹配。\n总结      总结如下：\n case、casex、casez的匹配顺序都是从上到下。 case严格匹配，casez中表达式z/?代表不关心该位的状态值(最好使用？)，casex中表达式x/z/?代表不关心该位的状态值。 case、casex、casez都是可综合的，不过在case中综合电路无法解析x/z/?，会将其认为不关心，这样会使RTL语义和综合电路间产生偏差，所以case语句表达式中不建议使用x/z/?。 尽量不使用casex，因为在初始条件下，控制信号可能存在大量x，使用casex会对电路的选择功能造成混乱，隐藏选择信号x值对电路功能的影响。  推荐使用casez，代码格式如下：\n1 2 3 4 5 6  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b1?: y = c; default : y = d; endcase   代码功能等同于：\n1 2 3 4 5 6  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b10,2\u0026#39;b11: y = c; default : y = d; endcase   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":22,"section":"docs","tags":["Verilog"],"title":"关于Verilog中的case、casex、casez","uri":"https://www.wenhui.space/docs/digital_designer/rtl_coding/about_verilog_cases/"},{"content":"本文 主要介绍一些我生活中做的小菜，以及做菜的小心得，为自己的美好生活做个记录，同时与有兴趣的人一起分享。\n背景 为什么喜欢做菜呢？ 还不是为了嘴嘛！ 做自己喜欢吃的菜是一件多么愉悦的事，为自己爱的人做喜欢吃的菜又是一件多么幸福的事。\n西红柿炒鸡蛋 西红柿炒鸡蛋可以说是我的第一个菜。西红柿炒鸡蛋是最家常的菜了，也正是因为家常，所以每家的西红柿炒鸡蛋都有其独特的味道。\n材料 材料需要两个西红柿、两个鸡蛋、少许葱白、少许香葱末/青椒末、少许番茄沙司、盐、糖、油。其实我自己炒一人份的话，要败家一点，一个西红柿两个鸡蛋，咱这收入水平做不到财富自由，总能做到鸡蛋自由吧，想吃就吃。\n对于材料，这里要强调两点：\n 必须是葱白，用葱叶爆香是不好吃的，西红柿鸡蛋吃的是葱白的香甜味。 是番茄沙司不是番茄酱，番茄沙司是用水和糖调过味的，而番茄酱只是番茄酱，加入番茄沙司会使西红柿的味道更浓郁。  制作  西红柿顶部用刀轻划十字，开水锅里滚两下，然后冲凉，用手剥去外皮。 西红柿切块，不要太小，葱白切末，香葱/青椒切末。 打两个鸡蛋，如果想要颜色好看，可以使用柴鸡蛋或者多加一个蛋黄，用筷子朝一个方向打散。 坐锅烧油，油可以略多点，油热煎鸡蛋，待鸡蛋成熟打碎成块，同样不要太小，鸡蛋熟后取出待用。 不用刷锅，继续使用煎鸡蛋留下的底油，低油温放入葱白末，煸炒爆香。 葱白煸香后放入西红柿，快速翻炒，适当加一点点水，防止葱白炒糊，同时放入适量番茄沙司翻炒。 调味，放入盐和糖，糖多放一点，中和西红柿的酸味。 西红柿炒透出汁后，放入鸡蛋，继续慢慢翻炒，使鸡蛋吸满之水。 最后放入青椒末，翻炒两三下，如果是香葱末则在出锅后撒入即可。  心得  西红柿最好去皮，一是为了口感，二是去皮的西红柿更容易出汁水，更容易炒透，三是西红柿皮在炒熟过程中会打卷，影响美观。 如果西红柿成熟度不好，可以在切之前轻揉几下，这样更容易炒透。 鸡蛋一定要打散，使蛋清蛋黄充分融合，打散的蛋液炒起来更容易蓬松。 鸡蛋可以放一点点盐或不放，放盐会使炒出的鸡蛋稍稍发黑不黄亮。 炒鸡蛋油温一定要够，大概六七成，这样会使鸡蛋迅速蓬松起来，并且不要急于搅动，否则鸡蛋易碎而不成块状，待定型成熟至饼状时将其打散成块状。 鸡蛋炒的稍老会更香，蓬松的鸡蛋才能更好的吸收汁水。 鸡蛋打散成块状的时机也很重要，早了鸡蛋易碎不成块状，晚了容易产生焦边，影响颜色，最好的时候就是鸡蛋成熟至饼状时打散，然后快速翻炒几下，不至于边缘受热过度。 取出鸡蛋时要取干净，尤其边缘部分，否则煸炒葱白时残留鸡蛋容易糊，或者清洗锅后重新烧热，将鸡蛋滤出部分油淋入锅中，也可以避免此问题。 葱白要在低油温时下锅煸炒，大概三成油温时即可，并且尽量在锅底处煸炒，否则容易糊，出葱香味后放入西红柿，这时可以将火调小一点或者稍加一点点水，防止葱白在翻炒时烧糊。 西红柿出水后大火翻炒，一定要将西红柿炒熟炒透，但也切忌过度翻动，否则会将西红柿翻碎不成型。 西红柿炒透后进行调味，然后加入鸡蛋，加入鸡蛋后一定要大火快速翻炒，这样可以快速收汁，小火慢炖的话会是西红柿出太多汁水。 青椒末一定要在锅中翻炒几下，熟的青椒末才有香气，香葱末不要翻炒，成菜时撒入即可，否则会影响美观，其实香菜梗末也可以，或者黄瓜根部切圈，可以多尝试，找到自己最喜欢的味道，搭配点绿色成菜也更漂亮。 如何保证味道呢，一个诀窍就是尝一尝，缺啥加啥。 个人觉得，西红柿炒鸡蛋拌米饭才是最佳。  成品 成品效果主要有以下几个特点：\n 成菜红黄搭配，绿色点缀，颜色鲜亮。 鸡蛋黄亮，块大，吸足汁水。 西红柿炒透，无硬心，并且成块有口感。 成菜略有汁水，但不太多。 味道甜酸咸适中，先甜后咸。  图片待补充：\n声明 以上仅代表个人口味和心得，仅供参考。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":23,"section":"docs","tags":["美食"],"title":"我的美食拙作","uri":"https://www.wenhui.space/docs/about_life/my_food_works/"},{"content":"本文 主要介绍WPS如何使用文档模板。编辑文档时使用模板是一个好习惯，不仅能够使工作中的文档格式统一，还节省排版时间。Windows word创建模板操作应该类似。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 deppin版本： Deepin GNU/Linux 15.11 WPS版本：WPS Office 2019  写在前面 由于本人的办公系统基本已经从Windows转向了Linux，而且文档编写已经转向emacs org格式，但是与同事间交互时还是避免不了使用传统文档文件。典型的文档编辑器就是Windows Office word，但是Linux环境并不支持word，幸好WPS有Linux版本。有人说WPS不如word好用，两个工具来对比，其实功能基本完全对等，只是操作不同，可能大部分人习惯了word吧，还有就是彼此兼容略有问题，建议WPS完成的文档转为PDF格式再交付，这样可以避免兼容的问题。\n创建我的模板 由于网上并没有找到合适的模板，所以就根据自己的工作习惯，创建一个自己的模板，我对文档格式的需求主要有如下几点：\n 标题页面，需要有标题名称，作者信息，时间和版本信息。 目录页面，包括文档目录、图目录和表目录。 页码，前文页码为罗马数字，正文页码为阿拉伯数字。 正文第一项，文档介绍，需要介绍文档目的和参考文献。 水印为可选项，可加可不加。  根据以上需求，我完成了我的文档模板，分享给大家，仅供参考。网盘资源分享链接： 链接：https://pan.baidu.com/s/19C-LCnAOpcN0RBXoCGocPg 密码：27ys 。\n简单描述一下文档模板如何创建，其实和编写文档一样，设置完以上内容，通过 另存为 可选择输出为模板文件。\n如何使用模板文件 新建文档时选择 本机上的模板 ，一般这里只会显示空白模板，选中导入模板，在本地找到模板文件，即可使用模板创建新的文档。如果想在 本机上的模板 中显示自己的模板，请将模板文件移动到WPS的模板文件夹内，这里给出Linux下的路径： ~/.local/share/Kingsoft/office6/templates/wps/zh_CN 。\n其他使用技巧 关于水印 选择 插入-*水印*，可以选择去除水印或右键编辑水印。\n关于图表 文档中免不了会使用图表，选中插入的图表，选择 引用-题注-图 或 表 ，这里一般有几个重要参数，编号格式和是否包含章节编号，我一般选择默认的数字和包含章节编号，一般包含一级标题编号即可，另外一个参数是 位置 ，一般习惯上表格的题注在上方，图的题注在下方。\n关于目录 文档目录模板中已经添加好，可双击选择更新；图表目录需要删除后，将光标置于合适位置，选择 引用-插入表目录 ，选择图或表，即可自动插入目录。（如果需要添加公式目录，操作类似）\n关于操作符 这里操作符是指换行符等在文档中不可见的符号，在模板中添加了若干换行符、分页符和分节符等，若想显示它们，点击左上角的 文件-选项-视图-段落标记 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":24,"section":"docs","tags":["Office"],"title":"WPS如何使用文档模板","uri":"https://www.wenhui.space/docs/about_windows/create_wps_tepmlate/"},{"content":"本文 主要介绍一款关于英文自动补全的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  基于 Company 的英文助手 Github：company-english-helper  补充说明： 这个英文补全的emacs插件是基于Company插件的，可能需要先安装Company插件才可以使用，由于安装此英文补全插件时已经安装Company插件，所以并未考证。如果需要安装Company插件，请参考我的另一篇帖子 emacs如何安装插件。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":25,"section":"docs","tags":["emacs"],"title":"emacs插件之英文自动补全","uri":"https://www.wenhui.space/docs/about_emacs/emacs_company_english/"},{"content":"本文 主要介绍数字电路设计中X-Propagation问题以及其解决方案。\n   版本 说明     0.1 初版发布   0.2 添加EDA工具的使用   0.3 添加verilog X-Prop插件VRQ介绍   0.4 添加综合后代码以及仿真结果    参考  文献1：《X-Propagation Woes: Masking Bugs at RTL and Unnecessary Debug at the Netlist》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YV%5FuOM1ech1zVkPMcqQ51w 密码：09wu 文献2：《X-propagation能在RTL仿真中发现X态问题》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YP3ZfIDgmX%5FmWFaOzkFKeQ 密码：3hq3  什么是 X-Propagation 问题? 什么是 X 状态？ SystemVerilog 标准中定义了四种逻辑状态，即“0”、“1”、“X”、“Z”，“0”代表低电平，“1”代表高电平，“X”代表不定态，“Z”代表高阻态。低电平和高电平很容易理解，而不定态和高阻态只有在模拟仿真时才会出现，真实电路中是不存在“X”和“Z”的。“X”和“Z”都代表不确定是“0”还是“1”的情况，比如未复位前的寄存器，在模拟仿真时是“X”状态，未赋值的悬空信号，在模拟仿真时是“Z”状态。\nX 状态的来源有哪些？ 数字电路中 X 状态的来源主要有以下几种：\n 未复位的寄存器和锁存器。 输入信号为 X 状态。 总线竞争。 地址越界。 跨时钟域逻辑（虽然在模拟仿真中不会直观看到X状态，但实际电路中由于跨时钟域是有采样到非理想值的风险，需要关注）。 多驱动（虽然在RTL编码中多驱动认为是一种错误，但实际电路中是有多驱动的技术的）。  总的来说，模拟仿真中 X 的状态更多来自未复位的寄存器和锁存器，尽管可以通过复位信号进行初始化解决这一问题，但是复位信号由于空间和延迟等布线的限制，也并非能够完全做到这一点。尤其现在低功耗设计，电路的睡眠和唤醒机制，对寄存器的初始化设计又带来了复杂性，同时也增加了隐藏 bug 的风险。但是需要注意的是，X 状态在真实电路中是不存在的，要么是“0”，要么是“1”。\n什么是 X-Optimism？ RTL 仿真中，对 X 状态是乐观处理的，什么是乐观处理呢？直观来说就是会将一个未知值在电路逻辑中传递为已知值。举例说明：\n if-else语句   1 2 3 4 5  always@(*) if (sel) out = a; else out = b;   结果如下：\n   sel out     1 a   0 b   x b    在if-else 的选择电路中，当选择信号为 X 时，判断 if 条件不满足，则会执行 else语句，所以 out 值为 b（如果没有 else 语句，则会产生锁存器，保持先前值）。这里补充一下，Z 状态同样会产生相同问题，只不过设计中很少存在 Z 状态，不再讨论。\n case语句   1 2 3 4 5  always@(*) case (sel) 1: out = a; 0: out = b; endcase   结果如下：\n   sel out     1 a   0 b   x prev    当选择信号为 X 时，非 0 非 1，不符合 case 语句中任何选项，则保持先前值，这也是将未知状态传递为已知状态的乐观处理。\n可见模拟仿真中对 X 状态的乐观处理，与实际电路是有差异的，这样比较容易隐藏功能bug。不过在门级网表仿真中是可以发现这些问题的，门级仿真对 X 状态是悲观处理的，会引入更多无效X状态，而且门级编译和仿真速度很慢，调试也是极其麻烦，将X-Propagation问题放到门级仿真来解决并不是一个好的选择。\n什么是 X-Pessimism？ 门级网表仿真中，对 X 状态是悲观处理的，什么是悲观处理呢？直观来说就是会将一个已知值在电路逻辑中传递为未知值。举例说明（这里只以assign语句为例，其实所有逻辑综合后都等效为门级电路，换句话说所有逻辑语句在门级电路仿真时都是悲观处理的）：\n1  assign out = (a \u0026amp;\u0026amp; selector) || (b \u0026amp;\u0026amp; ~selector);   结果如下：\n   selector a b out     X 0 0 X   X 0 1 X   X 1 0 X   X 1 1 X    以上是一个选择器逻辑，当 a 和 b 为相同值时，out结果应该与选择信号无关，也就是当 a和 b 都为“1”时，无论 selector 值为何，其结果值都应该为“1”。而实际门级仿真的悲观处理，在selector为X时，会将结果输出为“X”。\n可见门级仿真中对 X 状态的处理是悲观的，这样就会出现不必要的 X 值，与实际电路是有差异的，虽然不会隐藏功能 bug（因为 X 都会暴露出来），但是由此带来的门级仿真和RTL 仿真的差异，必须解决，带来了额外的工作量。\n关于clk的X-Prop 以上对选择逻辑的X-Prop问题进行了描述，而对于寄存器来说，clk的X态同样会带来问题，举例如下：\n 源代码：   1 2  always@(posedge clk) q \u0026lt;= d;    RTL仿真结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 0   0-\u0026gt;X or X-\u0026gt;1 1 0 1   0-\u0026gt;X or X-\u0026gt;1 1 1 1     真实电路结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 1     门级仿真结果：  （注意：猜测结果如下，未进行证实）\n   clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 x   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 x     总结：  可见对于寄存器关于clk的x态处理，也存在乐观和悲观问题。\n结论 通过上面内容，已经知道 X 状态的含义和来源，以及 RTL 仿真对 X 状态的乐观处理和门级仿真对 X 状态的悲观处理，总之由于 X 状态的存在，不同的处理方式，在 RTL 仿真、门级仿真和真实电路之间产生了差异，RTL 仿真的乐观处理，带来了隐藏功能 bug 的风险，门级仿真的悲观处理，当发现 X 状态时首先要确认是真实的 X 状态还是由悲观处理产生的，这带来了额外的工作量，尤其网表调试是极其麻烦的。综上，这就是关于 X-Propagation 问题。\n我的测试程序 RTL测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  module xprop_tb; reg clk; reg sel; reg a0,a1; reg b0,b1; reg din; /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire out1; // From i_xprop of xprop.v wire out2; // From i_xprop of xprop.v wire out3; // From i_xprop of xprop.v wire out4; // From i_xprop of xprop.v // End of automatics  initial begin //Two options have the same value  #0 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //Two options have the different value  #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //test clk  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;bx; #1 $display(out4); #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;bx; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;b1; #1 $display(out4); #10 $finish; end xprop i_xprop(/*AUTOINST*/ // Outputs  .out1 (out1), .out2 (out2), .out3 (out3), .out4 (out4), // Inputs  .clk (clk), .sel (sel), .a0 (a0), .a1 (a1), .b0 (b0), .b1 (b1), .din (din)); endmodule // xprop_tb  module xprop (/*AUTOARG*/ // Outputs out1, out2, out3, out4, // Inputs clk, sel, a0, a1, b0, b1, din ); input clk; input sel; input a0; input a1; input b0; input b1; input din; output out1; output out2; output out3; output out4; wire out1; reg out2; reg out3; reg out4; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule // xprop   综合后代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  ///////////////////////////////////////////////////////////// // Created by: Synopsys DC Expert(TM) in wire load mode // Version : O-2018.06-SP5 // Date : Mon Feb 24 10:57:14 2020 /////////////////////////////////////////////////////////////  module xprop ( out1, out2, out3, out4, clk, sel, a0, a1, b0, b1, din ); input clk, sel, a0, a1, b0, b1, din; output out1, out2, out3, out4; wire out3, n4, n5; assign out2 = out3; assign out1 = out3; DFFX1_LVT out4_reg ( .D(din), .CLK(clk), .Q(out4), .QN() ); MUX21X1_LVT U7 ( .A1(n4), .A2(n5), .S0(sel), .Y(out3) ); AND2X1_LVT U8 ( .A1(a1), .A2(a0), .Y(n5) ); OR2X1_LVT U9 ( .A1(b0), .A2(b1), .Y(n4) ); endmodule   RTL测试结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:03 2020 x00 x00 000 111 111 111 111 111 0 1 0 1 $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180 V C S S i m u l a t i o n R e p o r t Time: 180 CPU Time: 0.370 seconds; Data structure size: 0.0Mb Mon Feb 24 17:03:52 2020 门级仿真结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:02 2020 xxx xxx 000 111 xxx xxx 111 111 0 x 0 x $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180000 V C S S i m u l a t i o n R e p o r t Time: 180000 ps CPU Time: 0.360 seconds; Data structure size: 0.0Mb Mon Feb 24 17:02:33 2020 总结  使用工具为VCS。 对于综合，无论是三目运算符还是if-else还是case，综合工具都将其转为相同的选择逻辑电路，也就是无论选择RTL何种表达方式，都不影响门级仿真悲观处理的问题，与综合工具也无关，而是仿真工具解析电路的悲观处理导致的。 对于模拟仿真，RTL仿真中if-else和case语句确实存在逻辑乐观处理的问题，而关于三目运算符的结果更符合真实的电路行为； 门级仿真是悲观处理的。  我们的需求是什么？ 验证工程师 对于验证工程师，需求是在 RTL 综合之前尽早消除设计中所有 X 传播问题，使其不会隐藏功能 bug，并且不至于在门级仿真中花费大量时间调试 X 传播问题。\n这里说明一下为什么在门级仿真中调试 X 传播问题需要消耗大量时间和精力。\n 综合后的网表不同于 RTL，难以调试定位问题。 由于门级仿真的悲观处理，增加了更多的 X 状态，而且大多是无害的，难以甄别。 门级仿真中发现 X 问题通常体现在输出的功能错误，而抓到错误与实际的 X 产生节点相隔可能多个周期，对调试增加了难度。 门级仿真速度慢.  设计工程师 对于设计工程师，更关心 X 源在设计中的位置，以及 X 在逻辑中的传播，更早的避免、发现和解决 X 传播问题，减少设计代码的迭代，并且最好不需要重新编码以及其他辅助性代码，这样可以依靠工具对代码结构进行静态检查，准确报告有可能存在 X 传播问题的代码信息。当然，对于复杂的低功耗设计，可能会带来更多的 X 传播问题，更有可能隐藏 bug，保证电路功能的正确性是他们最关心的，但对于验证难度也是非常大的。\n以往的解决方法 模拟仿真  波形调试工具：波形调试工具会显示 X 状态，在 RTL 仿真和门级仿真不一致时，可以通过波形工具进行调试分析 X 传播问题，当然这是最基础的手动调试方法，除了要排除悲观处理产生的不必要的 X 状态外，在表现为错误的节点和实际产生 X 乐观处理的电路间可能存在多个时钟节拍和复杂的电路层级，这对手动调试都带来了不小的工作，更别说大量的 X 传播问题的存在情况。 RTL X 乐观处理的检测：有些仿真工具可以对 X 乐观处理进行检测，当选择条件为 X 状态时，它将驱动 X 状态为 1’b1 和 1’b0，并在两种情况下输出结果不同时报错。这也同  样存在问题，首先是消耗更多的仿真时间，其次是很难保证所有组合状态都已覆盖。\n 随机初始化值：有些仿真工具支持设置寄存器的初始化值，这样通过初始化值随机化，可以减少大部分的 X 状态，这对于检测悲观处理是个好方法，但对于乐观处理，以及电路正确的初始化，不是一个好方法，首先会掩盖正确初始化的功能验证，其次是如果并未产生导致问题的初始值组合，依然无法发现功能 bug，通过多次随机仿真，不仅消耗了大量的仿真时间，但仍不能保证无隐藏的功能 bug。  代码结构分析 代码检查工具如 Lint，会对代码结构进行分析，以识别潜在的问题，并提醒设计人员可能导致 X 传播问题的危险信息。从代码结构分析来讲，工具会检测逻辑中是否使用了未驱动的信号，诸如这些可能导致 X 传播问题情况。但是代码检查工具并不能确定是否存在真正的问题，这样就需要设计人员去逐个分析。不过好在通过代码检查工具可以定位可能的X源以及与其敏感的电路信号，在发现功能bug时，根据代码检查报告快速定位问题。\n形式化验证  等价性检查：很多人都误以为等价性检查会捕获 X 传播问题，而实际并非如此。等价性检查是用于将设计的两个版本（或 RTL 和网表）验证为功能等效。其原理是基于端口信号、黑盒边界以及寄存器初始值的二进制状态空间的遍历。 注：对于此结论并没有完全理解，疑问是形式化验证工具是否对门级网表进行了悲观处理。 模型检查：设计或验证人员使用 SVA 语言编写设计属性，通过形式化验证是状态空间遍历，支持四态的验证工具会验证所有 X 值上无论是“0”还是“1”，都符合设计属性，从而解决 X 乐观和 X 悲观问题。但是需要设计或验证人员编写设计属性，工作量是一方面，还有设计属性描述的完备性以及大规模设计的状态空间爆炸问题难以解决。 符号模型仿真：符号模型仿真可以通过检查输出是否保持一致（无论是否存在 X）来彻底验证设计，并且可以提供反例，显示导致错误的信号状态。但是符号模型仿真也具有局限性，对于大规模的设计会导致内存迅速消耗。同时，设计中可能存在非法输入，可能提供假的反例。 注：对于什么是符号模型仿真本人暂时还不清楚，个人理解为支持X精确的抽象模型。  准确的代码编写 解决 X 传播问题最直接的方法就是准确代码编写，比如双目运算符（？：）是不会被仿真器乐观处理的，可以代替 if-else 和 case，但是它的可读性不强，并且没有避免 X 的悲观处理。那么什么是严格的代码编写呢？举例如下：\n X-optimistic Coding：当 sel 为 X 时，输出 g 为 2’b01。   1 2 3 4 5  always @(*) if (sel==1’b0) g = 2’b00; else g = 2’b01;    X-pessimistic Coding：当 sel 为 X 时，输出 g 为 2’bxx。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’bxx; else g = 2’b01;    X-accurate Coding：当 sel 为 X 时，输出 g 为 2’b0x（准确处理的话应该同时包含 Z 的处理，这里没有体现）。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’b0x; else g = 2’b01;   通过上面的描述感觉问题迎刃而解，仅仅是在编码时追求准确代码编写而已，但是对于赋值语句，很少是常量值，而是复杂的表达式。虽然通过悲观的编码方式可以解决 RTL 仿真的乐观处理问题，但对于门级仿真的悲观处理还是没有解决。\nverilog X-Prop插件VRQ 什么是VRQ？ Vrq是一个Verilog工具框架，带有用于处理源代码的各种插件。支持但不完全支持verilog 2005 语法规则。\n如何安装？  官网下载地址：https://altlinux.pkgs.org/sisyphus/autoimports-i586/vrq-1.0.130-alt1%5F4.i586.rpm.html 百度网盘分享资源： 链接：https://pan.baidu.com/s/11PXGNyhhFk3n9H5CtNQh9g 密码：3j40 ，其中包含安装包和可执行程序，可以直接使用可执行程序，也可以自行安装，安装方法参考readme文件。  如何使用？ Vrq支持的插件功能很多，这里仅以X-Prop为例，使用命令为： “vrq -tool xprop source.v -o target.v” 。这里也就是将source.v源代码进行X-Prop处理，处理完毕后的代码输出至target.v。效果如下：\nvrq xprop处理前：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module top_module (); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0,a1; reg b0,b1; reg out4; reg din; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule   vrq xprop处理后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //**************************************** // Warning! This file is machine generated //****************************************  module top_module(); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0; reg a1; reg b0; reg b1; reg out4; reg din; assign out1=sel ? a0\u0026amp;a1 : ~sel ? b0|b1 : 1\u0026#39;hx; always @* if(sel==1\u0026#39;b1) begin out2 = a0\u0026amp;a1; end else if(~(sel==1\u0026#39;b1)) begin out2 = b0|b1; end else begin out2 = 1\u0026#39;hx; end always @* case(sel) 1\u0026#39;b1: begin out3 = a0\u0026amp;a1; end default: begin case(sel) 1\u0026#39;b0, 1\u0026#39;b1: begin out3 = b0|b1; end default: begin out3 = 1\u0026#39;hx; end endcase end endcase always @(posedge clk) out4 \u0026lt;= din; endmodule //**************************************** // Warning! This file is machine generated //****************************************   可见vrq xprop插件自动完成了将常规逻辑语句准确的xprop语句，简化了工程师的编码工作。关于vrq的xprop的详细功能，可通过“vrq \u0026ndash;help”或“man vrq” 查看。\n其他功能 vrq支持的verilog源代码处理插件很多，可通过“vrq \u0026ndash;help”或“man vrq” 查看。由于其他功能没有亲自实践，这里不再描述，待后续补充。\n最新EDA工具的支持 VCS 的 X-Propagation 功能 VCS X-Prop 的介绍 X-Propagation 是 VCS 开发的用于 RTL 阶段发现 X 态问题的新增特性。该特性主要有两种使用模式：T-merge 和 X-merge。T-merge 采用的算法是：当所有可能值不同时，结果为 X；X-merge采用的算法是：无条件的结果为 X（门级仿真的悲观处理）。下面对 T-merge 和 X-merge 举例说明：\n1 2 3 4 5  always@(*) if (select) out \u0026lt;= a; else out \u0026lt;= b;   看一下 T-merge 和 X-merge 的对比：\n   select a b T-Merge X-Merge     X 0 0 0 X   X 0 1 X X   X 1 0 X X   X 1 1 1 X    使用方法 只需在 VCS 仿真中添加-xprop 或者-xprop=xmerge 选项，默认是 T-merge 模式。也可以通过配置文件指定哪些模块使用 X-propagation 功能，以及指定使用哪种模式，其使用方法为： vcs -xprop=xp_config_file\u0026hellip; 配置文件内容格式如下：\ntree {bridge} {xpropOff}; instance{top.bridge.cpu}{xpropOn}; module {sram,cache}{xpropOff}; merge = tmerge; 另外boundscheck 的使用可以抓到数组下标不合法问题，不合法的下标分两类，下标越界和下标为 X。使用方法是在编译时添加-boundscheck 选项，运行仿真时会检查下标问题，输出报告。\n结论  X-Propagation 简单易用。 使用 T-merge 可以让各种语法结构中的 X 态问题有效传播，其效果可以代替门级仿真，但仿真速率要优于门级仿真。 建议使用方法为：先使用 T-merge 模式，当回归 pass 后再使用 X-merge 模式，如果 pass 则 OK，如果 fail 需要检查是否无效 fail。 使用 X-Propagation 对仿真性能影响可接受，T-merge 模式影响更小（注：与Cadence相反，待考证）。 对于低功耗设计由于其电源控制的复杂性，更有必要使用 X-Propagation。  INCISIVE 的 X-Propagation 功能 INCISIVE X-Prop 的介绍 INCISIVE13.1及更高版本，开始支持X-prop的功能，该功能通过命令行上的\u0026rsquo;-xprop \u0026lt;F / C\u0026gt;'选项启用。\nX-Prop工具目的是在RTL仿真中尽早的发现并解决X问题，其特点如下：\n 两种X-Prop模式  FOX模式 (“Forward only X”) CAT模式 (“Compute as Ternary”)   这两种模式可以区别LRM（Language Reference Manual）的行为 不需要更改现有的设计 减少门级调试  测试代码：\n1 2  if( sel) out = a; else out = b;   两种模式结果对比：\n   sel a b out(verilog LRM) out(FOX model) out(CAT model)     x 0 0 0 x 0   x 0 1 1 x x   x 1 0 0 x x   x 1 1 1 x 1    使用方法 只需要在 INCISIVE 仿真中添加-xprop选项，该选项包含在xrun中，命令为“xrun –xprop F|C”，这里F代表FOX模式，C代表CAT模式。而且可以提供配置文件以在选定的层次结构/实例上启用X-Prop，这也是最推荐的方式，命令为“xrun –xfile \u0026lt;file_name\u0026gt;”，Xfile格式如下：\n//在CAT模式下，在testbench以及其子模块中启用xprop SCOPE testbench… C //在FOX模式下，在testbench.dut以及其子模块中启用xprop SCOPE testbench.dut… F 为了降低调试的难度，在较大设计中，可以为少量模块添加X-Prop，这可以在Xfile中实现：\nSCOPE TB.DUT_TOP.AHB_MOD1…C SCOPE TB.DUT_TOP.CPU… C SCOPE TB.DUT_TOP.APB_MOD2… C SCOPE TB.DUT_TOP.AHB3… C 运行仿真时可以使用tcl命令控制开启和关闭X-Prop：\nxrun\u0026gt; xprop -off // Disable X-Propagation xrun\u0026gt; run 10ns xrun\u0026gt; xprop -on // Enable X-Propagation 结论  FOX模式比CAT模式仿真速度更快，因为FOX模式对x强制传播，无额外判断。 关于发现X bug，使用CAT模式更依赖于输入激励的质量，有可能由于判断逻辑选择值相同而继续被掩盖。 FOX模式更近似于门级仿真的行为。 建议从单元级模块运行X-Prop，待单元级模块清除X-Prop问题，然后在系统级运行X-Prop。 建议先使用CAT模式，将真实的X-Prop问题处理完毕后，再使用FOX模式。  JasperGold 的 X-Propagation 功能 JasperGold X-Prop APP 的功能  检查时钟和复位，以确保无Xs。 检查赋值逻辑，以确保无Xs 检查控制逻辑，以查看Xs可以传播到哪些区域。 检查输出信号，以查看Xs是否可以传播到设计之外。 检查黑盒输入，以查看Xs是否可以传播到黑盒上层模块。 可使用 assume-guarantee 的方法，使对X-Prop问题的证明尽可能收敛。  启动命令 jg -xprop\n待补充 以目前的了解，JasperGold X-Prop是需要工程师选定X源，然后工具为其进行0 1状态遍历，检查输出是否一致，若不一致则证明X传播至设计外部，可能存在设计bug，需要工程师去调试分析。形式化验证工具的好处就是工具自动采用状态空间全遍历的引擎，这对一个设计的完整验证似乎更有保证，防止模拟仿真中测试激励质量的问题而隐藏bug，但是形式化验证更适合单元级模块，较大模块会带来状态空间爆炸的问题，无法证明完全。这里另外说明一下可能的X源，其中最主要的就是输入信号和未复位状态的寄存器，如果选择输入信号作为可能的X源，我想不应该必然会影响设计输出吗？\n至于JasperGold X-Prop对X源的设定和分析，工具如何使用和调试，以及其工作原理，本人并未实际使用过，待通过工程实践后再补充。\n总结 X-Prop问题一直存在，由于现在设计规模越来越大，功耗控制技术越来越复杂，X-Prop问题显得更为重要，从以往的解决办法中，认为准确的代码编写最为有效，而且有工程师为其开发的脚本工具，但是个人认为不能很好的解决悲观问题，不过好在模拟工具都对X-Prop做了很好的支持，我们只要用好工具就能做到事半功倍。\n另外，如有兴趣欢迎详细交流和分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":26,"section":"docs","tags":["Verilog"],"title":"关于X-Propagation问题","uri":"https://www.wenhui.space/docs/digital_verifer/creation/x-propagation/"},{"content":"本文 主要介绍了我的美食地图，大部分是旅行中亲自品尝并值得推荐的美食，还有部分列为TODO的美食清单。写本帖子的目的是对自己生活的一个美好记录，再有就是为志同道合之人（美食爱好者）提供参考。\n吃的信仰 这里借用一句黑面大叔陈晓卿的名言，那就是“ 最好吃的是人 ”。我十分认可这句话，这就是我关于吃的信仰。这句话的理解要从两方面去理解：\n 所谓美食，并不仅仅是入口那一瞬间带来的精神快感，背后的人文，更耐人寻味。 所谓美食，和谁吃远远比吃什么重要的多。  一个真正的美食爱好者，绝不仅仅是满足于入口的这一瞬间。比如我长沙出差经常去的一个牛肉粉馆，虽然吃的是一碗粉，但是会想到材料是什么，做法是什么，当地人喜欢吃扁粉还是圆粉，这个大叔又是做了多少年的粉，一辈子靠粉承担起全家的经济，也许还供养了两个大学生\u0026hellip;\u0026hellip; 如此，从一碗粉，想到材料，想到做法，想到做粉人的生活，耐人寻味，这就是吃背后的人文，这就是所谓最好吃的是人。\n西安 定家小酥肉 定家小酥肉在大皮院街口，接近广济北街的位置，也就是从鼓楼走向回民街正街，过了西羊市继续直走，到北院门左转进入大皮院路，直行大概五百米（接近北广济街）右手边。这家小酥肉是清真的，牛肉裹面糊，再上锅蒸制，入口绵缠酥软。大概30元左右，满满的一小盆都是牛肉，建议两个人一份肉一个凉菜两碗或一碗米饭就够了。小酥肉肉质很嫩，虽然卖相不太好，但是个人觉得十分美味。不过，写在前头，小酥肉调料味偏重，多胡椒，略偏麻，稍微油腻，如果你是南方人或口味偏轻的女生请慎重尝试，并且服务态度实在不敢恭维。整体来说，褒贬不一吧，不过个人觉得口碑还算不错。贴图如下：\n     老米家羊肉泡馍 来到西安，不得不吃的就是羊肉泡馍。西安卖羊肉泡馍的地儿很多很多，不过西安毕竟是旅游城市，如果随意找个地儿吃羊肉泡，又是很容易踩坑的，所以还是建议去回坊。回坊的羊肉泡最出名的是两家，老米家和老孙家，都是不错的。但是回民街无论春夏秋冬，都是摩肩擦踵、人山人海的火热场面，这里推荐一个案板街的老米家羊肉泡馍，清净很多，但是味道也很正宗。案板街离回民街也不远，在钟楼往东，沿着东大街走一二百米路左就是案板街了，走进案板街不远就能看到老米家羊肉泡馍。这里提醒一下，清真场所一定要避免展现非清真的东西。羊肉泡馍的馍是死面馍，半夹生，这样很耐煮，没错，羊肉泡馍就是煮的。一般馍要自己掰，这里不是店家偷懒，而是有意义的。自己掰馍可以掰成喜欢的大小，有人说馍掰的越碎煮着越入味，越好吃，不过个人觉得玉米粒大小刚好，而且，掰馍是一个乐趣，三五好友，放下手机，掰馍聊天，反现代科技的社交方式。听说掰馍时留一口放在碗里，是回民的标志，后厨师傅会给多加片肉，当然这个只是个传说，无从考证，不过有兴趣的可以试一试。羊肉泡一般会配糖蒜和辣椒酱，注意，辣椒酱很咸的，酌量加，糖蒜可以解腻，感觉是最佳搭配。其实一碗羊肉泡还是挺贵的，别听说西安人早上都吃羊肉泡，一碗羊肉泡40元左右，天天吃那得是大户，牛肉泡稍便宜些，但也要30多元，贵虽然贵了点，但味道香的很。回民街深处大皮院路，也有一些泡馍馆，味道也很好，还有小炒泡馍，这里的价格相对外面旅游区就便宜不少，有时间有兴趣的话也可以尝试。下面是贴图：\n     文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":27,"section":"docs","tags":["美食"],"title":"我的美食地图","uri":"https://www.wenhui.space/docs/about_life/my_food_map/"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第五篇，主要介绍验证的方法、UVM简介、UVM组件、UVM环境。\n   版本 说明     0.1 初版发布    参考  《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      验证的方法 概述  一方面是目前验证方法的分支和其他工具种类繁多，另一方面是希望大家可以在系统了解验证方法和工具后，可以展开验证时有一整套工具箱，根据设计的特点选用合适的验证方法。 目前的芯片设计，已经无法依赖单一的工具、语言或方法来达到验证的完备性。 实际的验证工作中，我们需要通过各种语言、方法、工具实现此目的。这些不同的语言、方法、工具以及脚本没有绝对的优劣区分，比如仿真验证协同形式化验证工具一同完善功能覆盖率，也可能通过语言和脚本之间的整合来最终完成一项验证流程。 作为一名有经验的验证工程师，他需要在掌握现有的各种方法和工具的前提下，通过合理的选择，最后“保质高效低耗”地完成验证任务。  主要方法分类  动态仿真（dynamic simulation） 静态检查（formal check）（包含形式化验证也包含代码静态检查） 虚拟模型（virtual prototype） 硬件加速（hardware acceleration） 电源功耗（power consumption） 性能评估（performance evaluation）  动态仿真  该方式是通过测试序列和激励生成器给入待验证设计适当的激励，伴随着仿真时间，进而判断输出是否符合预期。 我们需要仿真器来配合这一项工作，验证人员也需要查看比较结果和仿真波形，最终判断测试用例是否通过。 如果按照激励生成方式和检查方式，我们可以将动态仿真进一步分为：定向测试、随机测试、参考模型检查、断言检查。  静态检查  与动态仿真相对的是静态检查，它本身不需要仿真、波形激励，通过工具的辅助，验证人员即可以发现设计中存在的问题。 静态检查可以细分出更多种类，它们关注的领域也不相同，我们将这些方法概括为：  语法检查（syntax check） 语义检查（linting check） 跨时钟域检查（CDC Cross-clock Domain Check） 形式化验证（formal verification）    语法检查  与编译器自带的功能一样，验证工具一旦需要建立模型，都需要编译器对目标语言提供语法检查。 仿真编译器会帮助检查语法错误，例如拼写、声明、引用、例化、连接、定义等常见语法错误。 同时，不同仿真工具对语言标准的解释也可能存在少量偏差，以及严格度略有不同。  语义检查  语义检查和语法检查相比，是在设计的可行性上做深度检查。 语义检查使用过专用的工具来协助完成的，例如spyglass，语义检查的范围包括：常见的设计错误、影响覆盖率收敛的问题、可能会产生x值以及受其影响的设计部分。 这些静态检查最大的便捷之处在于，可以早期发现一些功能实现以外的设计问题，而且也有助于完善设计代码，以便提高有效覆盖率以及RTL与网表的逻辑一致性。  跨时钟域检查  大多数复杂的设计都拥有不止一个时钟，多个时钟之间也常表现为异步的关系。对于设计中的不同模块如果被不同的时钟驱动，那么就会形成不同的时钟域。 对于单一时钟域的模块而言，它的设计方式和验证环境都较为简单，拥有多时钟域的硬件，它的跨时钟域的逻辑通讯就需要考虑同步问题了。用来验证这些设计要求的过程被称为跨时钟域检查。 之所以需要同步是考虑到不同时钟域的信号采样问题，当时钟域A的信号进入时钟域B被采样时，每个周期都会有相对时钟B不同的延迟，这种随机性可能导致建立时间或者保持时间无法满足，进而导致不可预期的功能失败。 这种跨时钟域问题无法通过常规验证方法分析，例如动态仿真，也不能被静态时序分析判断出来，通过静态的跨时钟域检查就可以分析这一问题。 通过该方法可以在设计早期来识别出跨时钟域的问题，CDC就是为了保证所有CDC信号都能够正确的同步，目前支持CDC检查的商业工具有Spyglass等。  形式验证 形式验证分两种方式：\n 等价性检查（EC， Equivalence Check）：用来保证两个电路行为是等价的，可以用来检查不同抽象级的电路是否一致，例如RTL和网表。 属性检查（PC， Property Check）：又称为模型检查（MC，Model Check），电路的行为通过验证语言来描述其属性，随后通过静态方式来证明所有状态空间下都满足该条件，否则举出反例（counter example）来证明设计行为不符合属性描述。  虚拟模型  虚拟模型即高抽象级的硬件模型，软件模型可依赖虚拟模型（SystemC）在早期开发，并且将反馈交给设计。这种反馈在以往的瀑布模式开发周期中是无法实现的，因为软件往往需要等到硬件设计制造完成后才能展开。 通过虚拟模型，硬件可以更早的获取软件反馈而对设计进行修改。这种硬件和软件更紧密的协作方式，可以体现更多的优势，比如利用虚拟模型获取性能数据可以对硬件早期结构提供参考意见，或者判断硬件和软件的协同任务是否可以满足功耗目标。 在目前多核的手机移动平台上，一个增长的需求就是将不同的任务合理分配到多核上面来取得更好的性能，而这种软件层面的评估就可以在虚拟建模阶段完成。 目前我们通过多项虚拟建模的技术，如协同设计、协同仿真和验证，试图在早期就发现设计缺陷，使得修改这些缺陷可以相对容易实施的阶段完成。 虚拟模型在实际项目中还有一种用途，SystemC本身也能做到可综合，并且定义端口，当某模块设计称为依赖时，虚拟模型可以替代模块的功能集成到设计中去，先行完成某些验证任务，待后续将其替换为RTL。     阶段 任务     建模准备 芯片定义、高级别结构、用户用例、RTL模块   虚拟模型 建模策略、将功能描述转换为SystemC模型、将RTL转换为SystemC模型、结构和性能分析   平台开发 虚拟平台、结构性能及功耗报告、驱动和固件开发、OS和应用层开发、反馈给硬件设计    硬件加速  动态仿真和静态检查方法具有各自的优势，然而他们的不具备一个优势就是速度。尤其是在SoC的设计体量越来越大的时候，仿真速度成为了制约验证进度的重要障碍。 由于仿真速度的限制，一些真实的用例也无法在RTL级仿真很快地呈现结果，这种困难在硅后测试发现问题反馈给硬件团队时更加明显，因为通常这意味着硬件团队需要消耗很长的仿真时间进行分析，找到可能的问题点，拆分软件场景，进而在硬件仿真上尝试重现问题。 仿真速度的限制使得无法通过仿真在早期测试软件，而这一任务一般交给虚拟模型平台或硬件加速仿真平台。 一般需要等到硬件设计初步稳定，进而将其映射到可配置的硬件加速平台上面，这种方式相比于RTL仿真速度已经有了质的提升。 目前业界主要的硬件加速方式分为两种，即FPGA和专用的模拟器。 FPGA主要是为软件开发提供平台，而模拟器则是为了硬件和软件协同验证和整个系统的测试。FPGA不可以设置断点，也无法看到大量的内部信号，而模拟器可以做到，同时速度优于RTL的动态仿真。  效能验证  在移动时代，硬件提升性能的方式主要体现在以下几种：  提升原有处理器性能、存储空间、数据总线带宽或者采取多核处理方式。 增加额外的协处理单元，或者新的功能模块。 在后端允许的情况下提高工作时钟频率。   随着性能的提升，能耗也会逐步提高，这在过去的PC时代还不是一个显著问题，但是到了移动时代，就越发要求硬件在性能有提升的基础上，同时要考虑能耗是否也可以接受。 硅前设计阶段进行能效验证，涉及的流程可分为两个部分：  功能验证：主要采样PA（Power Aware），（主要包括有UPF（Unified Power Format）或者CPF（Comment Power Format））方式，通过与仿真器结合，模拟电源域的开关进行设计检查。 功耗预测与优化：通过第三方功耗分析工具，结合仿真数据（FSDB/VCD/SAIF），进行功耗预测，并且给出分析结果。   移动芯片节能技术是一项全方位的改进流程，从工艺制程、电路、封装到模块设计、Soc设计、系统和应用软件开发等等，整个环节都需要有效利用能量。下面这个表格是从芯片硬件和软件采用的节能技术（省去工艺制程）。     域 节能技术     硬件 多核与聚合结构、多电压域、电源门控时钟门控、保持寄存器   电源管理 稳压调节、提升屏显功耗方案、智能电源管理   软件 开发工具、动态电源时钟调节、算法程序优化    性能验证  在性能验证中离不开大量的运算或者数据传输。硅前RTL验证的瓶颈之一在于仿真速度，而且一旦到了芯片级仿真，这一因素就更进一步放大了。 在产品定义过程，对于系统的运算和数据传输都有要求，如果可以在产品实现阶段尽早地得出性能有关的数据，这不但可以帮助提前验证硬件性能是否满足要求，在进度允许的情况下还可以修改硬件设计完善其性能。 这种将性能测试提前的方式也可以使得硅前验证与硅后测试采用一致的测试用例，从而得出可对比的性能数据。 性能验证是用来衡量一个系统在特定的工作负载下它的响应能力和稳定性，同时性能报告也可以用来分析和优化系统的质量标准，例如可靠性和资源使用能力。 性能验证是一门实用的计算机科学工程方法，在软件功能测试中分类较多：负载测试、压力测试、浸泡测试、尖峰冲击测试、配置测试、隔断测试等。 目前硅前验证阶段，性能验证还是一个新颖的概念，一方面由于业界对这一测试还没有形成统一标准，另外也是由于性能验证更多的是在衡量指标，而验证本身关注更多的是功能正确性。 但同时，对一些性能要求严格的硬件设计，我们确实希望能够更早期就得出一些数据，而且最好能够赶上给设计做出反馈并加以完善，以此来降低开发成本。  UVM简介 概述  SystemVerilog从2002年的3.0标准逐步发展到IEEE-1800 SystemVerilog 2012标准，是目前IC验证的霸主。 高级的验证方法学在2011年后逐步融合，也就是VMM、OVM等逐步统一为UVM（Universal Verification Methodology），此时UVM 1.0发布。 SV的核心特性是面向对象、随机约束、线程通信等，这些特性使建立验证环境十分便利。 所谓验证方法学，并不是必须与某种语言绑定，而体现在验证的方法上，其目的是提供一些可以复用的类，通过复用来减轻项目中工作量，同时为验证新人提供一套可靠地框架，这就是验证方法学。 UVM中的Universal（通用），也就是适用大多数验证项目，包括模块级到系统级，ASIC到FPGA，以及控制逻辑、数据通路到处理器验证的全部场景。 UVM的框架构建类和测试类能够帮助验证工程师减轻环境构建的负担，从而将更多精力集中在如何指定验证计划和创建测试场景。 认识UVM由浅入深：  认识UVM的类库和核心机制。 学习核心的UVM组件和层次结构。 了解常见的UVM组件间的通信方式。 深入UVM测试场景。 UVM的寄存器模型应用。    UVM类库      UVM的类库大致分为以下几类：\n 核心基类 工厂类（factory） 事务类（transaction）和序列类（sequence） 结构创建类（structure creation） 环境组件类（environment component） 通信管道类（channel） 信息报告类（message report） 寄存器模型类（register model） 线程同步类（thread synchronization） 事务接口类（transaction interface）  UVM组件  验证组件按照功能划分，可以分为激励器（stimulator/driver）、监测器（monitor）和检查器（checker）。 这三个核心组件与验证环境的三个关键特性相对应，也就是激励、监测和检查。 从UVM基类继承的一个核心分支，即uvm_component类，它们是UVM类库中的重要成员，是构成整个验证环境框架的基础，uvm_component类依据不同功能，又分为以下几个子类：  uvm_driver uvm_monitor uvm_sequencer uvm_agent uvm_scoreboard uvm_env uvm_test    UVM环境 uvm环境中很重要的一点是phase机制。\n 传统的硬件设计模型在仿真开始前，已经完成例化和连接了。 而SV的软件部分对象例化是在仿真开始后执行的。虽然对象例化时只是通过调用构建函数new()，但是单单通过new()函数无法实现验证环境的层次化，也就是保证例化的先后关系和各个组件之间的连接。 如果需要实现高级功能，比如在顶层到底层的配置时，SV也无法在底层组件例化之前完成对底层的配置逻辑。 因此，UVM验证环境构建时，引入phase机制，通过该机制可以很清晰的将UVM仿真阶段层次化。这里层次化，不仅仅是各个phase的执行顺序，还有同一个phase中的层次化组件之间的【phase也有先后关系。     phase 函数/任务 执行顺序 功能 典型应用     build 函数 自顶向下 创建和配置测试平台的结构 创建组件和寄存器模型，设置或者获取设置   connect 函数 自底向上 建立组件之间的连接 连接TLM的接口，连接寄存器模型和adapter   end_of_elaboration 函数 自底向上 测试环境的微调 显示环境结构、打开文件，为组件添加额外配置   start_of_simulation 函数 自底向上 准备测试环境的仿真 显示环境结构、设置断点，设置初始运行时的配置值   run 任务 自底向上 激励设计 提供激励、采集数据、数据比较   extract 函数 自底向上 从测试环境中收集数据 从测试平台提取剩余数据，从设计观察最终状态   check 函数 自底向上 检查任何不期望的行为 检查不期望的数据   report 函数 自底向上 报告测试数据 报告测试结果，并将其写入文件中   final 函数 自顶向下 完成测试活动、结束仿真 关闭文件，结束联合仿真引擎      phase执行顺序      创建测试平台    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":28,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（五）","uri":"https://www.wenhui.space/docs/digital_verifer/beginner_verification/beginner_verification_five/"},{"content":"本文 主要介绍emacs org-model 的使用方法。\n   版本 说明     0.1 初版发布   0.2 添加Org-Mode导出如何禁用下划线转下标    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  什么是org-mode？ org-mode 是文本编辑器Emacs中一种支持内容分级显示的编辑模式。这种模式支持写 To-Do 列表，日志管理，做笔记，做工程计划或者写网页。\n安装 emacs 23以后默认自动安装 org-mode ，如果想安装最新版，可以手动下载安装包或通过emacs包管理器进行安装。手动下载和安装请参考org-mode下载页面。\n大纲 org-mode强大的操作能力源于它对大纲的支持。\n标题 文章中的标题可以通过 #+TITTLE: 来设置标题； 正文中的标题可以通过*，一个*表示一级，两个*表示二级标题。如：\n1 2 3 4  #+TITLE: emacs org-mode 的使用 *这是一个一级标题 ** 这是一个二级标题 *** 以此类推（最多10个*）   注意： ‘*’要位于行首；‘*’后面要有一个空格。\n大纲相关的快捷键 折叠    快捷键 说明     S-TAB 循环切换 整个文档 的大纲状态（三种状态：折叠，打开下一级，打开全部）   TAB 循环切换光标 所在大纲 的状态 （三种状态：折叠，打开下一级，打开全部）    大纲间移动    快捷键 说明     C-c C-n/p 下/上一标题   C-c C-f/b 下/上一标题（仅限同级标题）   C-c C-u 跳到上一级标题   C-c C-j 切换到大纲浏览状态    基于大纲的编辑    快捷键 说明     M-RET 插入一个同级标题   M-S-RET 插入一个同级TODO标题   M-LEFT/RIGHT 将当前标题升/降级   M-S-LEFT/RIGHT 将子树升/降级   M-S-UP/DOWN 将子树上/下移   C-c * 将本行设为标题/正文   C-c C-w 将子树或区域移动到另一标题处（跨缓冲区）   C-x n s/w 只显示当前子树/返回   C-c C-x b 在新缓冲区显示当前分支（类似C-x n s)   C-c / 只列出包含搜索结果的大纲，并高亮，支持多种搜索方式   C-c C-c 取消高亮    关于大纲显示 org的大纲显示模式会对不同级标题采用不同颜色显示，但是默认的大纲显示没有缩进，如果想添加缩进显示，可以用M-x，输入org-indent-mode。如果想让某个文件默认用这种方式打开，可以在文件头部增加：\n1  #+STARTUP: indent   如果希望打开所有org文件都默认用这种方式，可以在.emacs或.emacs.d/init.el中添加如下配置：\n1  (setq org-startup-indented t)   轻量级标记语言 Org现在已经成为一种专门的轻量级标记语言，与Markdown、reStructedText、Textile、RDoc、MediaWiki等并列。\n段落 可能我们习惯了回车下一行开启新的段落，而在org-mode中，需要回车两次，也就是段落间需要用空行隔开。\n字体 *粗体* /斜体/ +删除线+ _下划线_ 下标： H_2 O 上标： E=mc^2 等宽字： =git= 或者 ～git～ （ox-hugo并未将org中上下标的语法转为markdown，暂时没有解决方案）\n列表 列表语法  无序列表以\u0026rsquo;-'、\u0026lsquo;+'或者\u0026rsquo;*\u0026lsquo;开头 有序列表以\u0026rsquo;1.\u0026lsquo;或者\u0026rsquo;1)\u0026lsquo;开头 描述列表用\u0026rsquo;::\u0026rsquo; 列表层级用缩进体现  注意事项： 列表符号后面都要有空格；同级别的列表缩进要相同；空两行之后列表结束；\n举例如下：\n1 2 3 4 5 6  + treeroot + branch1 + branch2 + treeroot 1) branch1 2) branch2   列表快捷键    快捷键 说明     TAB 折叠列表项   M-RET 插入项   M-S-RET 插入带复选框的项   M-S-UP/DOWN 移动列表项   M-LEFT/RIGHT 升/降级列表项，不包括子项   M-S-LEFT/RIGTH 升/降级列表项，包括子项   C-c C-c 改变复选框状态   C-c - 更换列表标记（循环切换）    表格 表格语法 任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。一个表格是下面的样子：\n1 2 3  | Name | Height | Weight | Age | |----------+--------+--------+-----| | Abcdefgh | 178 | 123 | 18 |   创建表格时，首先输入表头（如下），然后在第二行按Tab键，会自动补全表格框架。表格的标题声明可有可无，看个人需求。\n1 2 3  #+CAPTION: 表格的标题 | Name | Height | Weight | Age| |-   有时候，表格的某一项特别的长，你可以在任意一个表格的空白项内输入数字来限制其所在列的长度，可以可以通过l、c、r来设置左中右对齐（默认左对齐）。比如(=\u0026gt;代表内容隐藏内容，实际为Abcedfgh)：\n1 2 3 4  | \u0026lt;5\u0026gt; | \u0026lt;l5\u0026gt; | \u0026lt;r5\u0026gt; | \u0026lt;c5\u0026gt; | | Name | Hei=\u0026gt; | Wei=\u0026gt; | Age | |-------+-------+-------+-------| | Ab=\u0026gt; | | | |   列表快捷键    快捷键 说明     C-c 竖线 创建或转换成表格   快捷键 说明   C-c C-c 调整表格，不移动光标   TAB 移动到下一区域，必要时新建一行   S-TAB 移动到上一区域   RET 移动到下一行，必要时新建一行   M-LEFT/RIGHT 移动列   M-UP/DOWN 移动行   M-S-LEFT/RIGHT 删除/插入列   M-S-UP/DOWN 删除/插入行   C-c - 添加水平分割线   C-c RET 添加水平分割线并跳到下一行   C-c ^ 根据当前列排序，可以选择排序方式    缺陷 目前表格不支持拆分和合并，只能使用如下格式替代。\n| 一级部门 | 二级部门 | 人数 | |----------+----------+------| | A | A.1 | 5 | | | A.2 | 6 | |----------+----------+------| | B | B.1 | 7 | | | B.2 | 3 | 分隔线 三条短线或以上显示为分隔线。‘\u0026mdash;’\n链接 链接语法 链接用于链接一些资源地址，如图片、文件、URL等。如下（可省略链接描述）：\n1 2 3  [[http://orgmode.org/orgguide.pdf][grgguid.pdf]]] [[file:/home/maple/图片/test.jpg][a picture]] [[file:/home/maple/图片/test.jpg]]   直接显示的图片在Emacs里默认不显示，需按C-c C-x C-v才能显示，在输出成其他格式（html、pdf……）后也能看到。\n链接快捷键    快捷键 说明     C-c C-l 插入链接和说明   C-c C-x C-v 显示链接图片    标签 Tag的作用 对于信息的管理，有分类(category)和标签(tag)两种方式。这两种方式各有特点：通常分类是固定的，很少变化，而tag随时可以增加。分类通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。所以，这两种方式通常结合起来使用。\n标记Tag 在Org-mode中，可以对标题增加tag标记。标记的格式如下：\n1  标题 :标记1标记2:标记3:   而且Org-mode的标签自动按照大纲树的结构继承。即子标题自动继承父标题的标签。比如：\n1 2 3  *Meeting with the French group :work: ** Summary by Frank :boss:notes: ***TODO Prepare slides for him :action:   则最后一行标题具有 work, boss, notes, action 四个标签。如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：\n1  #+FILETAGS: :Peter:Boss:Secret:   如果手工输入标签，在标题后设置标签，键入\u0026rsquo;:\u0026lsquo;后，M-Tab自动提供标签的补齐。更方便的做法是在正文部分用C-c C-q 或直接在标题上用C-c C-c创建标签，这种方式可以列出所有预定义的标签以便选取。\n预定义Tag 预定义的方式有两种：\n 在当前文件头部定义，这种方式预定义的标签只能在当前文件中使用，每项之间必须用空格分隔，可以在括号中定义一个快捷键；花括号里的为标签组，只能选择一个，对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效：   1  #+TAGS: { 桌面(d) 服务器(s) } 编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)    在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：   1 2 3 4 5 6 7 8 9  (setq org-tag-alist \u0026#39;( (:startgroup . nil) (\u0026#34;桌面\u0026#34; . ?d) (\u0026#34;服务器\u0026#34; . ?s) (:endgroup . nil) (\u0026#34;编辑器\u0026#34; . ?e) (\u0026#34;浏览器\u0026#34; . ?f) (\u0026#34;多媒体\u0026#34; . ?m) ))   Tag搜索 Tag搜索快捷键    快捷键 说明     C-c \\ 按tag搜索标题   C-c / m 搜索并按树状结构显示   C-c a m 按标签搜索多个文件（需要将文件加入全局agenda)    逻辑表达式限制条件 + 和 a+b 同时有这两个标签 - 排除 a-b 有 a 但没有 b | 或 a|b 有 a 或者有 b \u0026amp; 和 a\u0026amp;b 同时有 a 和 b，可以用“+”替代 在查询视图中 C-c C-c 退出。\nGTD（时间任务管理） 请参考org-mode，最强的任务管理利器，没有之一。我暂时并未使用org-mode进行时间任务管理，待使用后将总结进行补充。其实时间任务管理工具有很多，包括手机移动端，不一定非要使用emacs，不过emacs精神就是用emacs做一切。我用org-mode主要是做笔记和写博客，通过ox-hugo转为hugo识别的markdown文档，再通过hugo生成站点文件。\nOrg-Mode导出如何禁用下划线转下标 更多时候我们需要将org文件导出为pdf或html文件，这就会遇到一个问题，emacs org mode会将下划线转为下标格式，对导出的文件浏览很有影响。解决这个问题可参考如下两个方法：\n 在org文件添加OPTIONS：   1  #+OPTIONS: ^:nil    在配置文件（.emacs/init.el）添加如下设置：   1  (setq org-export-with-sub-superscripts nil)   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":29,"section":"docs","tags":["emacs"],"title":"emacs org-mode 的使用","uri":"https://www.wenhui.space/docs/about_emacs/emacs_org_mode/"},{"content":"本文 主要介绍有关python的一些基础知识。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 python： Python 2.7.13  参考  菜鸟教程：Python基础教程  写在前头 什么是Python？ Python语言是少有的一种可以称得上即简单又功能强大的编程语言。它具有以下特点：\n 简单易学： 读Python程序就像是读英语，语法极其简单。 免费开源： Python是FLOSS（自由/开放源码软件）之一。 可移植： 多平台支持Python环境，方便程序移植。 面向过程和面向对象： Python既支持面向过程，也支持面向对象。面向过程，由过程或仅仅是可重用代码的函数构建起来；面向对象，由数据和功能组合而成的对象构建起来。（个人理解，在当做脚本语言时，主要是面向过程编程） 可扩展和可嵌入： Python程序可以使用其他语言，也可以被其他语言使用。 丰富的函数库： Python标准库很大，功能很强。  安装Python  如果你是Linux用户，系统应该已经自带Python，可以使用 python \u0026ndash;version 查看版本号。如果没有安装（可能性很小），可以使用系统的包管理器安装 sudo apt install python ，或者去Python官网下载页面下载最新Linux版本，也可以从别人那里copy可执行二进制文件。 如果你是windows用户，去Python官网下载页面下载最新Windows版本，手动安装，安装过程与其他软件类似，具体请自行百度。  运行方法  可以在python解释器直接运行python命令，打开终端，在命令行键入python，启动解释器，现在输入print \u0026lsquo;Hello World\u0026rsquo;，然后按回车，会看到屏幕输出Hello World。 使用源文件形式运行python程序： source HelloWorld.py 可执行的Python程序： 将程序源文件更改为可执行属性 chmod 755 HelloWorld.py ，在终端命令行直接运行 ./HelloWorld.py 。  获取帮助 help() 函数用于查看函数或模块用途的详细说明，按q退出。(注意：查看模块前，需要先import模块)\n\u0026gt;\u0026gt;\u0026gt;help('sys') # 查看 sys 模块的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help('str') # 查看 str 数据类型的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;a = [1,2,3] \u0026gt;\u0026gt;\u0026gt;help(a) # 查看列表 list 帮助信息 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help(re.findall) # 显示re模块的findall方法的帮助 ……显示帮助信息…… 基本概念 数  整数： 1、 2、 3、 -1、 -2、 -3（默认十进制，也可以采用其他进制表示： 0b 二进制，0o 八进制，0x 十六进制） 浮点数： 3.14、 3.14E-4（也就是0.000314） 复数： (-1+2j)、 (1-2j)， 也可以complex(a,b)表示， 复数的实部 a 和虚部 b 都是浮点型  字符串  单引号： ‘Hello \\\u0026lsquo;World！\\'’，输出 Hello \u0026lsquo;World！\u0026rsquo; （也就是单引号中使用单引号，需要转义，使用其他符号无需转义） 双引号： \u0026ldquo;Hello \\\u0026ldquo;World！\\\u0026quot;\u0026quot;，输出 Hello \u0026ldquo;World！\u0026rdquo; （也就是双引号中使用双引号，需要转义，使用其他符号无需转义） 三引号（三个连续单引号）： \u0026lsquo;\u0026lsquo;\u0026lsquo;\u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026quot;'''，输出 \u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026rdquo; （三引号中使用双引号和单引号，无需转义） 转义符： 转义符是反斜杠 \u0026ldquo;\\\u0026rdquo; ，如\\\\代表\\符号，如‘Hello \\\u0026lsquo;World！\\'’，\\\u0026lsquo;代表\u0026rsquo;（注意：行末的\\，代表下一行继续，也就是不换行，而非转义符） 自然字符串： 引号表示的一般字符串时是支持转义的，如果不需要转义，可以使用自然字符串（字符串前加r或R）。举例：一般字符串\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \u0026lsquo;world\u0026rsquo;；自然字符串r\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \\\u0026lsquo;world\\\u0026rsquo; 。 自动拼接： print \u0026lsquo;Hello\u0026rsquo; \u0026lsquo;World\u0026rsquo; ，会输出 HelloWorld 。  变量 用标识符命名的存储单元的地址称为变量，变量是用来存储数据的，通过标识符可以获取变量的值，也可以对变量进行赋值。对变量赋值的意思是将值赋给变量，赋值完成后，变量所指向的存储单元存储了被赋的值，在Pyhton语言中赋值操作符为“=、+=、-=、*=、/=、%=、**=、//=”。声明变量的语法如： name=”Peter”\n标识符 标识符用于Python语言的变量、关键字、函数、对象等数据的命名。标识符的命名需要遵循下面的规则。\n 可以由字母（大写A—Z或小写a—z）、数字（0—9）和_（下划线）组合而成，但不能由数字开头； 不能包含除_以外的任何特殊字符，如：%、#、\u0026amp;、逗号、空格等； 不能包含空白字符（换行符、空格和制表符称为空白字符）； 标识符不能是Python语言的关键字和保留字； 标识符区分大小写，num1和Num2是两个不同的标识符。 标识符的命名要有意义，做到见名知意。  数据类型 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。由于Python变量无需声明，所以它没有类型，我们所说的\u0026quot;类型\u0026quot;是变量所指的内存中对象的类型。标准的数据类型由如下几个：\n Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典）  对象 python中一切皆为对象，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method） Python中的对象包含三要素：id、type、value 其中id用来唯一标识一个对象， type标识对象的类型， value是对象的值 is判断的是a对象是否就是b对象，是通过id来判断的 ==判断的是a对象的值是否和b对象的值相等，是通过value来判断的。\n物理行和逻辑行 物理行是你在编写程序时所看见的。逻辑行是Python看见的单个语句。\n 如果你想要在一个物理行中描述多个逻辑行，那么你需要在逻辑语句末尾添加\u0026rdquo;;\u0026quot;，表示一个逻辑语句的结束（物理行末尾分号可写可不写）。 如果你想要在多个物理行中描述一个逻辑行，那么你需要在物理行末添加\u0026rdquo;/\u0026quot;，表示一个逻辑语句未结束，接下一行。  缩进 空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。也就是说，同一层次的语句必须有相同的缩进。\n运算符 运算符 特别说明：运算符左右可以存在空格，也可以不存在空格，不同于shell中赋值符'=\u0026rsquo;，左右是不能有空格的。\n 算数运算符：     运算符 名称 说明 例子     \u0026lsquo;+\u0026rsquo; 加 相加 3+5输出8; \u0026lsquo;a'+'b'输出\u0026rsquo;ab\u0026rsquo;   \u0026lsquo;-\u0026rsquo; 减 负数或相减 -5.2输出一个负数; 50-24输出26   \u0026lsquo;*\u0026rsquo; 乘 相乘或字符串重复 2*3输出6; \u0026lsquo;la\u0026rsquo;*3输出\u0026rsquo;lalala\u0026rsquo;   \u0026lsquo;**\u0026rsquo; 幂 x的y次幂 3**4输出81（即3 * 3 * 3 * 3）   \u0026lsquo;/\u0026rsquo; 除 x除以y 4/3输出1; 4.0/3或4/3.0输出1.3333333333333333;   ’%‘ 取模 返回除法的余数 8%3输出2; -25.5%2.25输出1.5   \u0026lsquo;//\u0026rsquo; 取整 返回商的整数部分（向下取整） 5.9//2输出2.0     比较运算符：     运算符 名称 说明 例子     \u0026lsquo;\u0026lt;\u0026rsquo; 小于 x是否小于y 是返回True，否返回False（首字母大写），5\u0026lt;3返回False； 3\u0026lt;5\u0026lt;7返回True   \u0026lsquo;\u0026gt;\u0026rsquo; 大于 x是否大于y 是返回True，否返回False（首字母大写），3\u0026gt;5返回False； 7\u0026gt;5\u0026gt;3返回True   \u0026lsquo;\u0026lt;=\u0026rsquo; 小于等于 x是否小于等于y x=3; y=6; x\u0026lt;=y返回True   \u0026lsquo;\u0026gt;=\u0026rsquo; 大于等于 x是否大于等于y x=4; y=3; x\u0026gt;=y返回True   \u0026lsquo;==\u0026rsquo; 等于 比较对象是否相等 x=2; y=2; x==y返回True; x='str\u0026rsquo;; y='stR\u0026rsquo;; x==y返回False   \u0026lsquo;!='或'\u0026lt;\u0026gt;\u0026rsquo; 不等于 比较两个对象是否不相等 x=2; y=3; x!=y返回True     赋值运算符：     运算符 名称 说明     \u0026lsquo;=\u0026rsquo; 简单的赋值运算符 a=2+3, a结果为5   \u0026lsquo;+=\u0026rsquo; 加法赋值运算符 a=7, a+=2, a结果为9   \u0026lsquo;-=\u0026rsquo; 减法赋值运算符 a=7, a-=2, a结果为5   \u0026lsquo;*=\u0026rsquo; 乘法赋值运算符 a=7, a*=2, a结果为14   \u0026lsquo;/=\u0026rsquo; 除法赋值运算符 a=7, a/=2.0, a结果为3.5   \u0026lsquo;%=\u0026rsquo; 取模赋值运算符 a=7, a%=2, a结果为1   \u0026lsquo;**=\u0026rsquo; 幂赋值运算符 a=7, a**=2, a结果为49   \u0026lsquo;//=\u0026rsquo; 取整除赋值运算符 a=7, a//=2, a结果为3     位运算符（避免表格中 或符号'|\u0026rsquo; 被转义，这里使用 \u0026lsquo;竖线\u0026rsquo; 代替）：     运算符 名称 说明 例子     ’\u0026laquo;’ 左移 一个数的比特形式进行左移 2\u0026laquo;2输出8，也就是0b10 \u0026laquo;2 结果为0b1000   ’\u0026raquo;‘ 右移 一个数的比特形式进行右移 11\u0026raquo;1输出5，也就是0b1011 \u0026raquo;1 结果为ob101   ’\u0026amp;’ 按位与 数的按位与 5\u0026amp;3输出1，也就是0b101 \u0026amp; 0b001 结果为0b001   ‘竖线’ 按位或 数的按位或 5'竖线\u0026rsquo;3输出7，也就是0b101 \u0026lsquo;竖线\u0026rsquo; 0b001 结果为0b111   \u0026lsquo;^\u0026rsquo; 按位异或 数的按位异或 5^1输出4，也就是0b101 ^ 0b001 结果为0b100   \u0026lsquo;~\u0026rsquo; 按位取反 x的按位取反，其值为-(x+1) ~5输出-6，也就是~0b0101 结果为0b1010(待补充)     逻辑运算（符布尔与和或，建议表达式为判断表达式，而非计算表达式，除非你明确知道返回结果的形式是什么）：     运算符 名称 说明 例子     \u0026lsquo;not\u0026rsquo; 布尔“非” not True 返回False x=2; y=3; not x!=y返回False   \u0026lsquo;and\u0026rsquo; 布尔“与” True and True 返回True 1\u0026lt;2 and 2\u0026lt;3 返回True； 1\u0026lt;2 and 2+3 返回2+3结果5   \u0026lsquo;or\u0026rsquo; 布尔“或” True or False 返回True 1\u0026lt;2 or 2\u0026gt;3 返回True； 1\u0026gt;2 or 2+3 返回2+3结果5     成员运算符     运算符 说明     \u0026lsquo;in\u0026rsquo; 如果在指定的序列中找到值返回 True，否则返回 False。   \u0026lsquo;not in\u0026rsquo; 如果在指定的序列中没有找到值返回 True，否则返回 False。     身份运算符     运算符 说明     \u0026lsquo;is\u0026rsquo; is 是判断两个标识符是不是引用自一个对象   \u0026lsquo;is not\u0026rsquo; is not 是判断两个标识符是不是引用自不同对象    是不是觉得is和==功能相同呢？那就理解错了，下面对is和==进一步说明。==是比较判断两个对象的value(值)是否相等；is比较判断两个对象id是否相同。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026gt;\u0026gt;\u0026gt; a = 1 #a和b为数值类型 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 14318944 \u0026gt;\u0026gt;\u0026gt; id(b) 14318944 \u0026gt;\u0026gt;\u0026gt; a = \u0026#39;cheesezh\u0026#39; #a和b为字符串类型 \u0026gt;\u0026gt;\u0026gt; b = \u0026#39;cheesezh\u0026#39; \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 42111872 \u0026gt;\u0026gt;\u0026gt; id(b) 42111872 \u0026gt;\u0026gt;\u0026gt; a = (1,2,3) #a和b为元组类型 \u0026gt;\u0026gt;\u0026gt; b = (1,2,3) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 15001280 \u0026gt;\u0026gt;\u0026gt; id(b) 14790408 \u0026gt;\u0026gt;\u0026gt; a = [1,2,3] #a和b为list类型 \u0026gt;\u0026gt;\u0026gt; b = [1,2,3] \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42091624 \u0026gt;\u0026gt;\u0026gt; id(b) 42082016 \u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} #a和b为dict类型 \u0026gt;\u0026gt;\u0026gt; b = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42101616 \u0026gt;\u0026gt;\u0026gt; id(b) 42098736 \u0026gt;\u0026gt;\u0026gt; a = set([1,2,3])#a和b为set类型 \u0026gt;\u0026gt;\u0026gt; b = set([1,2,3]) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 14819976 \u0026gt;\u0026gt;\u0026gt; id(b) 14822256   总结：只有数值型和字符串型的情况下，a is b才为True，当a和b是tuple，list，dict或set型时，a is b为False。\n运算符优先级 优先级从高到低。\n   运算符 说明     ** 指数 (最高优先级)   ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)   * / % // 乘，除，求余数和取整除   + - 加法减法   \u0026raquo; \u0026laquo; 右移，左移运算符   \u0026amp; 位 \u0026lsquo;AND\u0026rsquo;   ^ \u0026lsquo;竖线\u0026rsquo; 位运算符   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   == 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not and or 逻辑运算符        虽然python解释器对运算符号优先级指明了顺序，但还是建议使用圆括号来更明确地指出运算的先后顺序，使程序尽可能地易读。例如，2+(3*4)显然比2+3*4清晰。\n控制流 if判断 Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。条件判断语句中，\u0026ldquo;判断条件\u0026quot;成立时（非零），则执行后面的语句，执行内容可以多行，以缩进来区分表示同一范围。其中else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  num = 5 if num == 3: # 判断num的值 print \u0026#39;boss1\u0026#39; print \u0026#39;boss2\u0026#39; print \u0026#39;boss3\u0026#39; elif num \u0026lt; 0: # 值小于零时输出 print \u0026#39;worker1\u0026#39; print \u0026#39;worker2\u0026#39; print \u0026#39;worker3\u0026#39; else: # 条件均不成立时输出 print \u0026#39;roadman1\u0026#39; print \u0026#39;roadman2\u0026#39; print \u0026#39;roadman3\u0026#39;   输出结果为：\nroadman1 roadman2 roadman3 while循环 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。while语句有一个可选的else从句，在不满足while条件时执行。举例如下：\n1 2 3 4 5 6 7 8  count = 0 while (count \u0026lt; 3): print \u0026#39;The count is:\u0026#39;, count count = count + 1 else: print \u0026#34;end while at count:\u0026#34;, count print \u0026#34;Good bye!\u0026#34;   结果如下：\nThe count is: 0 The count is: 1 The count is: 2 end while at count: 3 Good bye! for循环 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。for语句有一个可选的else从句，在执行完for内容时执行一次（除非遇到break）。举例如下：\n1 2 3 4 5 6 7 8  for i in [1,2,3]: print i else: print \u0026#39;end for i=\u0026#39;, i #------------------------ for letter in \u0026#39;ABC\u0026#39;: print \u0026#39;letter:\u0026#39;, letter   结果如下：\n1 2 3 end for i= 3 letter: A letter: B letter: C break语句 break语句可以强制终止循环语句，即使while循环条件仍为True或for循环序列还没有被完全递归。注意：break终止for或while循环 ，对应的循环else块将不执行。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: break print \u0026#39;there is break\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除break语句，将结果进行比较）：\n1 2 3 continue语句 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: continue print \u0026#39;there is continue\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除continue语句，将结果进行比较）：\n1 2 3 4 end while, i= 5 函数 函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。\n函数形参 函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为实参。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  def printMax(a, b): if a \u0026gt; b: print a, \u0026#39;is maximum\u0026#39; else: print b, \u0026#39;is maximum\u0026#39; #---------------------------------------------- printMax(3, 4) # directly give literal values x = 5 y = 7 printMax(x, y) # give variables as arguments   结果如下：\n4 is maximum 7 is maximum 局部变量 在函数内声明的变量，与函数外具有相同名称的其他变量没有任何关系，也就是变量的作用域仅限于函数内容，是局部的，这样的变量被称作局部变量。举例如下（注意，函数要先定义，才可以使用）：\n1 2 3 4 5 6 7  def local_test(num): num += num print \u0026#39;local_test\\\u0026#39;s num is\u0026#39;, num num = 10 local_test(num) print \u0026#39;main_program\\\u0026#39;s num is\u0026#39;, num   结果如下：\nlocal_test's num is 20 main_program's num is 10 默认参数 对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。注意：不能先声明有默认值的形参而后声明没有默认值的形参。如 def func(a, b=5, c=3) 是有效的， def func(a=5, b) 是无效的。举例如下：\n1 2 3 4 5  def say(message, times = 1): print message * times say(\u0026#39;Hello\u0026#39;) say(\u0026#39;World\u0026#39;, 3)   结果如下：\nHello WorldWorldWorld 关键字参数 如果某个函数有许多参数，只想指定其中某些参数的值，可以通过命名来为这些参数赋值，这种方法就是关键字参数。换句话说，关键字参数就是调用参数时使用名字（关键字）而不是位置来给函数指定实参。举例如下：\n1 2 3 4 5 6  def func(a, b=5, c=10): print \u0026#39;a =\u0026#39;, a print \u0026#39;b =\u0026#39;, b print \u0026#39;c =\u0026#39;, c func(c=1, b=2, a=3)   结果如下：\na = 3 b = 2 c = 1 return语句 return 语句就是讲结果返回到调用的地方，并把程序的控制权一起返回程序运行到所遇到的第一个return即返回（退出def块），不会再运行第二个return。举例如下：\n1 2 3 4 5 6 7 8 9 10 11  def add_sub (a, b): c = a + b d = a - b return c, d x = 3 y = 2 m, n = add_sub(x,y) print x, \u0026#39;+\u0026#39;, y, \u0026#39;=\u0026#39;, m print x, \u0026#39;-\u0026#39;, y, \u0026#39;=\u0026#39;, n   结果如下：\n3 + 2 = 5 3 - 2 = 1 文档字符串 DocStrings 文档字符串是一个重要工具，用于解释文档程序，帮助你的程序文档更加简单易懂。我们可以在函数体的第一行使用一对三个单引号 '\u0026rsquo;\u0026rsquo; 或者一对三个双引号 \u0026quot;\u0026rdquo;\u0026rdquo; 来定义文档字符串。你可以使用 __doc__（注意双下划线）调用函数中的文档字符串属性。举例如下：\n1 2 3 4 5 6  def function(): \u0026#39;\u0026#39;\u0026#39; The introduction to function. \u0026#39;\u0026#39;\u0026#39; pass print (function.__doc__)   输出结果如下：\nThe introduction to function. 特别说明：在函数的第一个逻辑行的字符串是这个函数的文档字符串（也适用于模块和类）。文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾，一般概括介绍函数的功能。第二行是空行，从第三行开始是详细介绍函数功能和使用方法。强烈建议，函数中使用文档字符串时遵循这个惯例。\n模块 什么是模块？ 在python中，一个文件（以“.py”为后缀名的文件）就叫做一个模块，每一个模块在python里都被看做是一个独立的文件。模块可以被其他程序引用，从而使用该模块里的函数等功能，使用Python中的标准库也是采用这种方法。\nPython中模块分为以下三类：\n 系统内置模块：如：sys、time、json模块等等； 自定义模块：自定义模块是自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用； 第三方的开源模块：这部分模块可以通过pip install进行安装，有开源的代码；  import模块 首先模块要先使用import语句导入到程序，如“import sys”导入sys模块，import的使用遵循以下规则：\n 使用关键词“import”，后面跟具体的模块名称，则可以导入某一个模块； 同一个模块不管你执行了多少次“import”，只会被导入一次，以防止模块一遍又一遍的被执行； “import”应该被放在代码的顶端；  再来你说一说import的搜索路径和顺序，如下：\n 当前目录 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。  如果我们自定义一个模块（不能与系统模块重名），如何让python成功import呢？第一，我们可以将模块文件与引用模块的程序放在同一目录，可自动搜索到；第二，修改系统环境变量PYTHONPATH，比如自定义模板文件放在~/my_lib，可以将以下内容添加到~/.bashrc，并重启终端。\n1  export PYTHONPATH=~/my_lib/:$PYTHONPATH   from\u0026hellip;import 语句 Python 的 from 语句可以从模块中导入一个指定的部分到当前命名空间中。举例如下：\n1  from fib import fibonacci   也可以使用import modname from *语句，将模块中所有函数导入到当前命名空间中，但不建议这样做。举例如下：\n1  from fib import *   import和import\u0026hellip;from的区别 import和import\u0026hellip;from的区别，从函数引用来看就理解了，如下(support是自定义的模块，只为解释模块使用)：\n import   1 2  import support support.print_func(\u0026#34;Runoob\u0026#34;)    import\u0026hellip;from   1 2  from support import * print_func(\u0026#34;Runoob\u0026#34;)   从以上内容也看出，import和import\u0026hellip;from的区别，也知道为什么不建议使用import\u0026hellip;from * ，因为这样有可能带来函数命名上的冲突。总之，建议还是直接使用import。\npython中的包 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在__init__.py 文件, 该文件的内容可以为空。__init__.py 用于标识当前文件夹是一个包。\n如定义一个包，文件目录如下：\npackage_runoob |-- __init__.py |-- runoob1.py |-- runoob2.py 使用程序：\n1 2  from package_runoob.runoob1 import runoob1 from package_runoob.runoob2 import runoob2   python的标准库 python的标准库内容很多，这也是Python强大之处，在这里不进行描述，后续会根据自己使用情况，对某些內建函数进行介绍。分享一个Python标准库介绍文档，可供查阅，百度网盘分享资源： 链接：https://pan.baidu.com/s/1o7G32%5FilSHhflfYTHuJq3g 密码：h2vv 。\n数据结构 在Python中有三种内建的数据结构——列表、元组和字典。我们将会学习如何使用它们，以及它们如何使编程变得简单。\n列表 列表中的元素应该包括在方括号中，并用逗号隔开。列表中，可以添加、删除或是搜索列表中的元素。由于可以增加或删除元素，所以列表是可变的数据类型。列表中的每个元素都分配一个数字（用来索引它的位置），第一个索引是0，第二个索引是1，依此类推。创建列表的方法如下：\n1 2 3  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5 ] list3 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]   访问列表中的值（列表索引时，默认从左到右，负号‘-’可代表从右到左，冒号‘:’可定义区间，省略则代表起始或末尾）：\n1 2 3 4 5 6 7  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5, 6, 7 ] print \u0026#34;list1[0]: \u0026#34;, list1[0] print \u0026#34;list1[-2]: \u0026#34;, list1[-2] print \u0026#34;list2[1:5]: \u0026#34;, list2[1:5] print \u0026#34;list2[1:]: \u0026#34;, list2[1:]   添加、修改和删除列表中的元素：\n1 2 3 4  list = [] ## 创建空列表 list.append(\u0026#39;Google\u0026#39;) ## 在列表末尾添加元素 list[0] = \u0026#39;Baidu\u0026#39; ## 修改列表第一个元素 del list[0] ## 删除列表中第一个元素   列表的操作符：\n   表达式 结果 说明     len([1, 2, 3]) 3 长度   [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合   [\u0026lsquo;Hi!'] * 4 [\u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!'] 重复   3 in [1, 2, 3] True 元素是否存在于列表中   for x in [1, 2, 3]: print x 1 2 3 迭代    Python列表函数：\n   函数 说明     len(list) 列表元素个数   max(list) 返回列表元素最大值   min(list) 返回列表元素最小值   list(seq) 将元组转换为列表    Python列表方法：\n   方法 说明     list.append(obj) 在列表末尾添加新的对象   list.count(obj) 统计某个元素在列表中出现的次数   list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）   list.index(obj) 从列表中找出某个值第一个匹配项的索引位置   list.insert(index, obj) 将对象插入列表   list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值   list.remove(obj) 移除列表中某个值的第一个匹配项   list.reverse() 反向列表中元素   list.sort([func]) 对原列表进行排序    元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可(元组中只包含一个元素时，需要在元素后面添加逗号)。如下：\n1 2 3 4 5  tup1 = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34; tup4 = () tup5 = (33,)   元组的运算和索引与列表相同，可参考列表。唯一不同的是元组不可修改，不可删除，不可添加。\n元组的函数：\n   方法 说明     cmp(tuple1, tuple2) 比较两个元组元素   len(tuple) 计算元组元素个数   max(tuple) 返回元组中元素最大值   min(tuple) 返回元组中元素最小值   tuple(seq) 将列表转换为元组    字典 字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中，举例如下：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; }   多级字典嵌套：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} }   访问字典数据（如果key不存在，则会报告异常）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; } print \u0026#34;dict[\u0026#39;Alice\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;] #------------------------------------------ dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} } print \u0026#34;dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]   修改、删除和添加字典元素：\n1 2 3 4 5 6 7 8 9 10 11  dict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} dict[\u0026#39;Age\u0026#39;] = 8 # update dict[\u0026#39;School\u0026#39;] = \u0026#34;RUNOOB\u0026#34; #add print \u0026#34;dict[\u0026#39;Age\u0026#39;]: \u0026#34;, dict[\u0026#39;Age\u0026#39;] print \u0026#34;dict[\u0026#39;School\u0026#39;]: \u0026#34;, dict[\u0026#39;School\u0026#39;] del dict[\u0026#39;Name\u0026#39;] # delete Name dict.clear() # clear dict del dict # delete dict   字典的特性：\n 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个会覆盖前一个。 key必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。  字典内置函数：\n   序号 说明     cmp(dict1, dict2) 比较两个字典元素   len(dict) 计算字典元素个数，即key的总数   str(dict) 输出字典可打印的字符串表示   type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型    字典内置方法：\n   序号 说明     dict.clear() 删除字典内所有元   dict.copy() 返回一个字典的浅复   dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始   dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default   dict.has_key(key) 如果键在字典dict里返回true，否则返回fals   dict.items() 以列表返回可遍历的(键, 值) 元组数   dict.keys() 以列表返回一个字典所有的   dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaul   dict.update(dict2) 把字典dict2的键/值对更新到dict   dict.values() 以列表返回字典中的所有   pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值   popitem() 返回并删除字典中的最后一对键和值    序列 列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。索引和切片的使用方法在列表和元组中已经有介绍，这里不再赘述。\n引用 创建一个对象并给它赋一个变量的时候，这个变量仅仅 引用 那个对象，而不是表示这个对象本身！j简单来说，创建的对象指向的是计算机中存储赋值对象的内存，而并非重新开辟一块内存对应被赋值对象。一般说来，使用者不需要关心，但是如果你想要复制一个列表或者类似的序列，必须使用切片操作符来取得拷贝，如果只是想要使用另一个变量名，可以直接赋值，不过两个名称都引用同一个对象，一不小心就可能会引来各种麻烦。特别给Perl程序员提示：python中序列的赋值语句不创建拷贝，需要使用切片操作符来建立序列的拷贝。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  print \u0026#39;Simple Assignment\u0026#39; shoplist = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;carrot\u0026#39;, \u0026#39;banana\u0026#39;] mylist = shoplist # mylist is just another name pointing to the same object! del shoplist[0] print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that both shoplist and mylist both print the same list without # the \u0026#39;apple\u0026#39; confirming that they point to the same object #--------------------------------------------------------------------- print \u0026#39;Copy by making a full slice\u0026#39; mylist = shoplist[:] # make a copy by doing a full slice del mylist[0] # remove first item print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that now the two lists are different   中文 Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入 # -- coding: UTF-8 -- 或者 # coding=utf-8 就行了。注意： # coding=utf-8 的 = 号两边不要空格。如果以上教程中出现中文注释或其他中文内容，运行时报错，请添加中文支持。\n输入输出 打印的屏幕 最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式（显示时，Python会在逗号分隔处自动插入一个空格）。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：\n1  print \u0026#34;Python\u0026#34;,\u0026#34;是一个非常棒的语言，不是吗？\u0026#34;   读取键盘输入 raw_input函数，raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：\n1 2  str = raw_input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   input函数，input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。\n1 2  str = input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   举例如下（input）：\n请输入：[x*5 for x in range(2,10,2)] 你输入的内容是: [10, 20, 30, 40] 文件操作 打开文件 语法规则如下：\n1  file object = open(file_name [, access_mode][, buffering])   参数说明：\n file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。  模式说明：\n   模式 说明     t 文本模式 (默认)   b 二进制模式   x 写模式，新建一个文件，如果该文件已存在则会报错   + 打开一个文件进行更新可读可写   r 以只读方式打开文件（默认模式）   r+ 打开一个文件用于读写   w 打开一个文件只用于写入（文件存在则覆盖，不存在则新建）   w+ 打开一个文件只用于读写（文件存在则覆盖，不存在则新建）   a 打开一个文件用于追加（文件存在则末尾添加内容，不存在则新建））   a+ 打开一个文件用于读写（文件存在则末尾添加内容，不存在则新建））    对r+、w+、a+进一步说明：\n   描述 r+ w+ a+     当前文件不存在时文件 抛出异常 创建文件 创建文件   打开后原文件内容 保留 清空 保留   初始位置 0 0 文件尾   写入位置 标记位置 标记位置 写入时默认跳至文件尾    文件对象属性    属性 描述     file.closed 返回true如果文件已被关闭，否则返回false   file.mode 返回被打开文件的访问模式   file.name 返回文件的名称   file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true    关闭文件 File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：\n1  fileObject.close()   write和read write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符('\\n\u0026rsquo;)，举例如下，创建foo.txt文件，并将内容写入该文件，并最终关闭文件：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;w\u0026#34;) fo.write( \u0026#34;www.runoob.com!\\nVery good site!\\n\u0026#34;) # 关闭打开的文件 fo.close()   read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 read需要传入一个参数，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。举例如下（读取上面创建的文件前10个字符）：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 关闭打开的文件 fo.close()   文件定位 tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 查找当前位置 position = fo.tell() print \u0026#34;当前文件位置 : \u0026#34;, position # 把指针再次重新定位到文件开头 position = fo.seek(0, 0) str = fo.read(10) print \u0026#34;重新读取字符串 : \u0026#34;, str # 关闭打开的文件 fo.close()   os模块 Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能，通过import导入模块可参考上文模块章节。\n rename：   1 2  # 重命名文件test1.txt到test2.txt。 os.rename( \u0026#34;test1.txt\u0026#34;, \u0026#34;test2.txt\u0026#34; )    remove：   1 2  # 删除一个已经存在的文件test2.txt os.remove(\u0026#34;test2.txt\u0026#34;)    mkdir：   1 2  # 创建目录test os.mkdir(\u0026#34;test\u0026#34;)    chdir：   1 2  # 将当前目录改为\u0026#34;/home/newdir\u0026#34; os.chdir(\u0026#34;/home/newdir\u0026#34;)    getcwd：   1 2  # 给出当前的目录 print os.getcwd()    其他，可参考os模块提供的内建函数手册。  异常处理 什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在python无法正常处理程序时就会发生一个异常（异常是python对象，表示一个错误）。错误分两种：\n 语法错误： 这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正。 逻辑错误： 程序执行时遇到的错误，比如0做除数。  异常种类有哪些？ 常见的异常种类：\n   异常类型 说明     AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x   IOError 输入/输出异常；基本上是无法打开文件   ImportError 无法引入模块或包；基本上是路径问题或名称错误   IndentationError 语法错误（的子类） ；代码没有正确对齐   IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]   KeyError 试图访问字典里不存在的键   KeyboardInterrupt Ctrl+C被按下   NameError 使用一个还未被赋予对象的变量   SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）   TypeError 传入对象类型与要求的不符合   UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它   ValueError 传入一个调用者不期望的值，即使值的类型是正确的    所有标准异常    异常类型 说明     BaseException 所有异常的基类   SystemExit 解释器请求退出   KeyboardInterrupt 用户中断执行(通常是输入^C)   Exception 常规错误的基类   StopIteration 迭代器没有更多的值   GeneratorExit 生成器(generator)发生异常来通知退出   SystemExit Python 解释器请求退出   StandardError 所有的内建标准异常的基类   ArithmeticError 所有数值计算错误的基类   FloatingPointError 浮点计算错误   OverflowError 数值运算超出最大限制   ZeroDivisionError 除(或取模)零 (所有数据类型)   AssertionError 断言语句失败   AttributeError 对象没有这个属性   EOFError 没有内建输入,到达EOF 标记   EnvironmentError 操作系统错误的基类   IOError 输入/输出操作失败   OSError 操作系统错误   WindowsError 系统调用失败   ImportError 导入模块/对象失败   KeyboardInterrupt 用户中断执行(通常是输入^C)   LookupError 无效数据查询的基类   IndexError 序列中没有没有此索引(index)   KeyError 映射中没有这个键   MemoryError 内存溢出错误(对于Python 解释器不是致命的)   NameError 未声明/初始化对象 (没有属性)   UnboundLocalError 访问未初始化的本地变量   ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象   RuntimeError 一般的运行时错误   NotImplementedError 尚未实现的方法   SyntaxError Python 语法错误   IndentationError 缩进错误   TabError Tab 和空格混用   SystemError 一般的解释器系统错误   TypeError 对类型无效的操作   ValueError 传入无效的参数   UnicodeError Unicode 相关的错误   UnicodeDecodeError Unicode 解码时的错误   UnicodeEncodeError Unicode 编码时错误   UnicodeTranslateError Unicode 转换时错误   Warning 警告的基类   DeprecationWarning 关于被弃用的特征的警告   FutureWarning 关于构造将来语义会有改变的警告   OverflowWarning 旧的关于自动提升为长整型(long)的警告   PendingDeprecationWarning 关于特性将会被废弃的警告   RuntimeWarning 可疑的运行时行为(runtime behavior)的警告   SyntaxWarning 可疑的语法的警告   UserWarning 用户代码生成的警告    异常处理的方法  如果错误发生的条件是可预知的，我们需要用if进行处理，在错误发生之前进行预防。   1 2 3 4 5 6 7 8  AGE=10 while True: age=input(\u0026#39;\u0026gt;\u0026gt;: \u0026#39;).strip() if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age=int(age) if age == AGE: print(\u0026#39;you got it\u0026#39;) break    如果错误发生的条件是不可预知的，则需要用到try..except：在错误发生之后进行处理。   1 2 3 4 5 6 7 8 9 10  try: f=open(\u0026#39;a.txt\u0026#39;) g=(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g)) except StopIteration: f.close()   try\u0026hellip;except\u0026hellip;的详细用法 我们把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，也可以处理一组圆括号中的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except。\n 异常类只能来处理指定的异常情况，如果非指定异常则无法处理：   1 2 3 4 5  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: # 未捕获到异常，程序直接报错 print e    多分支：   1 2 3 4 5 6 7 8 9  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e)    多分支＋Exception：   1 2 3 4 5 6 7 8 9 10 11  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) except Exception as e: print(e)    异常的其他机构（try\u0026hellip;finally语法）：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) #except Exception as e: # print(e) else: print(\u0026#39;try内代码块没有异常则执行我\u0026#39;) finally: print(\u0026#39;无论异常与否,都会执行该模块,通常是进行清理工作\u0026#39;)    主动触发异常（raise语句）：   1 2 3 4  def functionName( level ): if level \u0026lt; 1: raise Exception(\u0026#34;Invalid level!\u0026#34;, level) # 触发异常后，后面的代码就不会再执行    自定义异常：   1 2 3 4 5 6 7 8 9 10  class Networkerror(BaseException): def __init__(self,msg): self.msg=msg def __str__(self): return self.msg try: raise Networkerror(\u0026#39;类型错误\u0026#39;) except Networkerror as e: print(e)    断言：assert条件：   1 2  assert 1 == 1 assert 1 == 2   总结： 使用异常处理方法，可以时代码程序拥有以下几个优点， 1）把错误处理和真正的工作分开来； 2）代码更易组织，更清晰，复杂的工作任务更容易实现； 3）代码更成熟，不至于由于一些小的疏忽而使程序意外崩溃了。 既然异常处理有这么多好处，是不是要为每一段程序都加上try\u0026hellip;except呢？首先try\u0026hellip;except是附加的一种异常处理逻辑，与主要的工作是没有关系的，这种东西加的多了，会导致代码可读性变差，其次只有在错误发生的条件无法预知的情况下，才应该做异常处理，而不是为自己不成熟的代码擦屁股。\n","description":"","id":30,"section":"docs","tags":["Python"],"title":"Python简明教程","uri":"https://www.wenhui.space/docs/about_linux/language_notes/python_tutorial/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第四篇，主要介绍类随机约束和分布、约束块控制、随机函数、数组约束、随机控制。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      随机约束和分布 为什么需要随机？  芯片复杂度越来越高，在20年前定向测试已经无法满足验证的需求，而随机测试的比例逐渐提高。 定向测试能找到你认为可能存在的缺陷，而随机测试可以找到连你都没有想到的缺陷。 随机测试的环境要求比定向测试复杂，它需要激励、参考模型和在线比较。上百次的仿真不再需要人为参与，以此来提高验证效率。 随机测试相对于定向测试可以减少相当多的代码量，而产生的激励较定向测试也更多样。  为什么需要约束？  如果随机没有约束，产生有效激励的同时，还会产生大量的无效激励。 通过为随机添加约束，这种随机自由是一种合法的随机，产生有效的测试激励。 约束不是一成不变的，为了获取期望的测试范围或期待的数值范围，约束需要“变形”。 随机的对象不只是一个数据，而是有联系的变量集合。通常这些变量集合会被封装在一个数据类里，同时需要类中声明数据之间的约束关系。因此，约束之后要产生一个随机数据的“求解器”，即在满足数据本身和数据之间约束关系的随机数值解。 约束不但可以指定数据的取值范围，还可以指定各个数值的随机权重分布。  我们需要随机什么？  器件配置： 通过寄存器和系统信号。 环境配置： 随机化环境，例如合理的时钟和外部反馈信号。 原始输入数据： 例如MCDF数据包的长度、带宽，数据间的顺序。 延时： 握手信号之间的时序关系，例如valid和ready，req和ack之间的时序关系。 协议异常： 如果反馈信号给出异常，那么设计是否可以保持后续数据处理的稳定性。  声明随机变量的类  随机化是为了产生更多可能的驱动，我们倾向于将相关数据有机整理在一个类的同时，也用“rand”关键词来表明它的随机属性。 “randc”关键词表示周期性随机，即所有可能的值都赋过值后随机才可能重复，也就好比54张扑克牌抽牌游戏，rand代表每抽完一张放回去才可以下次抽牌，randc代表没抽完一张不需要放回就抽取下一张，如果抽完了，那就全部放回再次同样规则抽取。 rand和randc，只能声明类的变量，硬件域以及软件域的局部变量都不可以。 随机属性需要配合SV预定义的随机函数std::randomize()使用。即通过声明rand变量，并且在后期调用randomize()函数才可以随机化变量。 约束constraint也同随机变量一起在class中声明。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class packet; rand bit [31:0] src, dst, data[8]; randc bit [7:0] kind; constraint c { src \u0026gt;10; src \u0026lt;15; } endclass //----------------------------------  Packet p; initial begin p = new(); //assert语句保证randomize成功，否则会报fatal（如果约束冲突，如src\u0026gt;15 and src\u0026lt;10则会随机失败）  assert (p.randomize()) else $fatal(0, \u0026#34;Packet::randomize failed\u0026#34;); transmit(p); end   什么是约束  约束表达式的求解是有SV的约束求解器自动完成的。 求解器能够选择满足约束的值，这个值是由SV的PRNG（伪随机数发生器）从一个初始值（seed）产生。只要改变种子的值，就可以改变CRT的行为。 SV标准定义了表达式的含义以及产生的合法值，但没有规定求解器计算约束的准确顺序。也就是，不同仿真器对于同一个约束类和种子求解出的数值可能不同。 什么可以被约束？SV只能随机化二值数据类型，但数据位可以是二值或四值的，所以无法随机出x值和z值，也无法随机出字符串。   1 2 3 4 5 6 7 8 9 10 11  class date; rand bit [2:0] month; //note:  rand bit [4:0] day; rand int year; constraint c_data { month inside {[1:12]}; day inside {[1:31]}; year inside {[2010:2030]};} } endclass   请问：month=10，day=31，year=2020此组随机值可以产生吗？ 答案：不能，因为month的声明是3位，所以不可能出现数值10，这也是经常会犯的错误，当你约束数据时，一定要与声明数据的位数相匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class stim; const bit [31:0] CONGEST_ADDR = 42; //声明常数  typedef enum {READ, WRITE, CONTROL} stim_e; randc stime_e kind; rand bit [31:0] len, src, dst; bit congestion_test; constraint c_stim { len \u0026lt; 1000; len \u0026gt; 0; if(congestion_test) ( dst inside {[CONGEST_ADDR-100:CONGEST_ADDR+100]}; src == CONGEST_ADDR; ) else ( src inside {0, [10:20], [100:200]}; ) } endclass   权重分布  关键词dist可以在约束中用来产生随机数值的权重分布，这样某些值的选取机会要大于其他值。 dist操作符带有一个值的列表以及相应的权重，中间用 := 或 :/ 分开。值和权重可以是常数，也可以是变量。 权重不要百分比表示，权重的和也不必是100。 := 操作符表示值的范围内的每一个值的权重是相同的， :/ 操作符表示权重要平均分到范围内的每一个值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  rand int src, dst; constraint c_dist { src dist {0:=40, [1:3]:=60);} // src=1, weight=40/220  // src=2, weight=60/220  // src=3, weight=60/220  // src=4, weight=60/220  dst dist {0:/40, [1:3]:/60);} // dst=1, weight=40/100  // dst=2, weight=20/100  // dst=3, weight=20/100  // dst=4, weight=20/100 }   集合成员和inside  inside是常见的约束运算符，表示变量属于某个值的集合，除非还存在其他约束 ，否则随机变量在集合里取值的概率是相等的（集合里也可以是变量）。 可以使用 $ 符指定最大或最小值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  rand int c; int lo, hi; constraint c_range{ c inside {[lo:hi]}; } //-------------------------------  rand bit [6:0] b; rand bit [5:0] e; constraint c_range { b inside {[$:4], [20:$]}; e inside {[$:4], [20:$]}; }   条件约束  可以通过 -\u0026gt; 或者 if-else来让一个约束表达式在特定条件有效。   1 2 3 4 5 6 7 8 9 10 11  constraint c_io { (i_space_mode) -\u0026gt; addr[31] == 1\u0026#39;b1; //i_space_mode!=0 } //--------------------------------------  constraint c_io { if(i_space_mode) //i_space_mode!=0  addr[31] == 1\u0026#39;b1; else; }   双向约束  约束块不是自上而下的程序代码，它们是声明性代码，是并行的，所有的约束同时有效。 约束是双向的，这表示它会同时计算所有的随机变量的约束，增加或删除任何一个变量的约束都会直接或间接的影响所有相关的值的选取。 约束块可以声明多个，但是它们仍旧是并行的，如果对同一变量进行约束，取两者约束的交集，也就是两个约束都会生效，与写在一个约束块效果相同。 子类会继承父类的约束。  约束块控制 打开或关闭约束  一个类可以包含多个约束块，可以把不同约束块用于不同测试。 一般情况下，各个约束块之间的约束内容是相互协调不违背的，因此通过随机函数产生的随机数可以找到合适的解。 对于其他情况，例如跟胡不同需求，来选择使能哪些约束块，禁止哪些约束块，可以使用内建函数constraint_mode()打开或者关闭约束。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class packet; rand int length; constraint c_short {length inside {[1:32];}} constraint c_long {length inside {[1000:1032];}} endclass //------------------------  packet p; initial begin p =new (); //create a long packet by disabling c_short  p.c_short.constraint_mode(0); assert(p.randomize()); transmit(p); //create a short packet by disabling all constraint and then enable only c_short  p.constraint_mode(0); p.c_short.constraint_mode(1); assert(p.randomize()); transmit(p); end   内嵌约束  伴随着复杂的约束，它们之间会相互作用，最终产生难以预测的结果。用来使能和禁止这些约束的代码也会增加测试的复杂性。 经常增加或修改类的约束也可能会影响整个团队的工作，这需要考虑类的OCP原则（开放封闭原则，也就是哪些对外部开放，哪些不对外开放）。 SV允许使用 randomize() with来增加额外的约束，这和在类里增加约束是等效的，但同时要注意类内部约束和外部约束之间应该是协调的，如果出现违背，随机数会求解失败（求解失败，不同的工具报告形式不同，有的是error，有的是warning）。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class packet; rand int length; constraint c_short {soft length inside {[1:32];}} endclass //------------------------  packet p; initial begin p =new (); assert(p.randomize() with { length inside {[36:46];}; length != 40; } ); transmit(p); end   上述例子中randomize() with{}约束与c_short产生可冲突，那会不会报错呢？答案是不会，因为c_short约束前加了soft（软约束）关键字，意义就在于当外部或子类的约束发生冲突时，其优先级降低，不会影响外部或子类的约束。\n随机函数 pre_randomize 和 post_randomize  有时需要在调用randomize()之前或之后立即执行一些操作，例如在随机前设置一些非随机变量（上下限、条件值、权重）,或者在随机化后需要计算数据的误差、分析和记录随机数据等。 SV提供两个预定义的void类型函数pre_randomize和post_randomize，用户可以类中定义这两个函数，分别在其中定义随机化前的行为和随机化后的行为。 如果某个类中定义了pre_randomize或post_randomize，那么对象在执行randomize()之前或之后会分别执行这两个函数，所以pre_randomize和post_randomize可以看做是randomize函数的回调函数（callback function）。  系统随机数函数 SV提供了一些常用的系统随机函数，这些系统随机函数可以直接调用来返回随机数值：\n $random()平均分布，返回32位有符号随机数。 $urandom()平均分布，返回32位无符号随机数。 $urandom_range()在指定范围内的平均分布。  随机化个别变量  在调用randomize()时可以传递变量的一个子集，这样只会随机化类里的几个变量。 只有参数列表里的变量才会被随机化，其他变量会被当做状态量而不会被随机化。 所有的约束仍然保持有效。 注意：类里所有没有被指定rand的变量也可以作为randomize()的参数而被随机化。 注意：未进行随机化的变量默认初始值为0。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class rising; byte low; rand byte med, hi; constraint up { low\u0026lt;med; med\u0026lt;hi; } endclass //----------------------------------  initial begin rising r; r =new(); r.randomize(); //随机化hi和med，不改变low  r.randomize(med); //只随机化med  r.randomize(low); //只随机化low end   数组约束 约束数组的大小  在约束随机标量的同时，我们也可以对随机化数组进行约束。 多数情况下，数组的大小应该给定范围，防止生成过大体积的数组或空数组。 此外，还可以在约束中结合数组的其他方法sum(), product(), and(), or(), 和xor()。   1 2 3 4 5 6  class dyn_size; rand logic [31:0] d[]; constraint d_size { d,size() inside {[1:10];}; } endclass   约束数组的元素  SV可以利用foreach对数组每一个元素进行约束，和直接写出对固定大小数组的每一个元素相比，foreach更简洁。 针对动态数组，foreach更适合于对非固定大小数组中每个元素的约束。   1 2 3 4 5 6 7 8  class good_sum5; rand uint len[]; constraint c_len{ foreach (len[i]) len[i] inside {[1:255]}; len.sum() \u0026lt; 1024; len.size() inside {[1:8]}; } endclass   产生唯一元素值的数组  如果想要产生一个随机数组，它的每一个元素值都是唯一的，如果使用randc数组，嘛呢数组中的每一个元素只会独立的随机化，并不会按照我们期望的使得数组中的元素值是唯一的。 解决方案1：   1 2 3 4 5 6  rand bit [7:0] data; constraint c_data{ foreach(data[i]) foreach(data[j]) if(i != j) data[i] != data[j]; }    解决方案2：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class randc_data; randc bit [7:0] data[64]; endclass class data_array; bit [7:0] data_array [64]; function void pre_randomize(); randc_data rcd; rcd = new(); foreach (data_array[i]) begin assert(rcd.randomize()); data_array[i] = rcd.val; end endfunction endclass    特别示例如下，首先“\u0026lt;=”代表小于等于，其次限定da.size为（3/4/5），实际不可能取到5，原因是da.size的约束体现在“da[i] \u0026lt;= da[i+1]”时，约束的是i和i+1为为（3/4/5）。   1 2 3 4 5  rand bit [7:0] da[]; constraint c_da { da.size() inside {[3:5]}; foreach(da[i]) da[i] \u0026lt;= da[i+1]; }   随机化句柄数组  随机句柄数组的功能是在调用其所在类的随机函数时，随机函数会随机化数组中的每一个句柄所指向的对象。因此随机句柄数组的声明一定要添加rand来表示其随机化的属性，同时在调用随机函数前要保证句柄数组中的每一个句柄元素都是非悬空的，这需要早随机化之前为每一个元素句柄构建对象。 如果要产生多个随机对象，那么你可能需要建立随机句柄数组。和整数数组不同，你需要在随机化前分配所有的元素，因为在随机求解器不会创建对象。使用动态数组可以按照需要分配最大数量的元素，然后再使用约束减小数组的大小。在随机化时，动态句柄数组的大小可以保持不变或减小，但不能增加。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  parameter MAX_SIZE = 10; class RandStuff; bit[1:0] value = 1; endclass class RandArray; rand RandStuff array[]; constraint c_array { array.size() inside {[1:MAX_SIZE]}; } function new(); //分配最大容量  array = new[MAX_SIZE]; foreach (array[i]) array[i] = new(); endfunction endclass //---------------------------  RandArray ra; initial begin // 构造数组和所有对象  ra = new(); // 随机化数组，但可能会减小数组  assert(ra.randomize()); foreach(ra.array[i]) $display(ra.array[i].value); end    问题1：执行ra.randomize() with {array.size=2}时，array[0].value 和 array[0].value分别是多少？ 答案都是1，首先value没有加rand，所以randomize不会随机value，仍然保持为1。 问题2：为什么要分配最大容量？ 答案是只有创建对象，并且分配最大容量，才能保证随机化时可能会碰到句柄数组悬空，无指向对象，随机会报错。 总结：句柄数组的随机，首先查看句柄指向的对象内有没有rand变量，其次对句柄数组按最大容量进行例化。  随机控制  产生事务序列的另一个方法是使用SV的randsequence结构。这对于随机安排组织原子（atomic）测试序列很有帮助。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin for (int i=0; i\u0026lt;15; i++) begin randsequence (stream) stream: cfg_read := 1 | //权重不一样  io_read := 2 | //权重不一样  mem_read := 5; //权重不一样  cfg_read: (cfg_read_task;) | (cfg_read_task;) cfg_read; mem_read: (mem_read_task;) | (mem_read_task;) mem_read; io_read: (io_read_task;) | (io_read_task;) io_read; endsequence end end    我们也可以使用randcase来建立随机决策树，但它带来的问题是没有变量可供追踪调试。   1 2 3 4 5 6 7 8 9  initial begin int len; randcase: 1: len = $urandom_range(0,2); //10%  8: len = $urandom_range(3,5); //80%  1: len = $urandom_range(6,7); //10%  endcase $display(\u0026#34;len=%0d\u0026#34;, len); end    总结：  randsequence和randcase是针对轻量级的随机控制的应用。而我们可以通过定义随机类取代上述随机控制的功能，并且由于类的继承性使得后期维护代码时更加方便。 randsequence的相关功能我们在协调激励组件和测试用例时，可能会用到。 randcase则对应着随机约束中的dist权重约束 + if-else条件约束的组合。    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":31,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（四）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_four/"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第四篇，主要介绍验证周期、验证管理三要素、验证的收敛、问题追踪、团队建设、验证的专业化。\n   版本 说明     0.1 初版发布    参考  《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      验证的周期 验证菜鸟的成长  确定验证的模块，与设计人员交流，熟悉模块，进行模块验证，所有的精力专注在这个模块。 考虑验证时间，尽可能又快又多的发现bug，在项目节点前完成验证。 在模块验证完后不知做什么，被动安排工作。 不清楚每个节点应该做什么、上一个节点和下一个节点的联系、不同节点对整个项目周期的意义，这些需要有一个宏观的认识。 随着经验增长，被赋予更多的责任，从模块到子系统，再到系统。 接到富有挑战性的任务会感受到压力，但是学到的东西也更多。 每一个验证人员能够充分了解各个验证环节，那么就可以更好的贯彻验证任务，保持信息通畅，整体的风险就会降低。  验证的里程碑 RTL0 -\u0026gt; RTL1 -\u0026gt; RTL2 -\u0026gt; RTL3 -\u0026gt; GLS -\u0026gt; TO -\u0026gt;流片\n RTL0： 芯片框架和模块功能定义完成，制定验证策略。 RTL1： 模块和子系统的功能信号定义完成，定制需要的存储模型。 RTL2： 完成所有模块的设计，以及80%以上的模块和子系统的验证，核心功能全部完成验证。 RTL3： 完成芯片系统的连线集成和验证，覆盖所有的功能验证点。 GLS： 完成门级网表的验证。 TO： 回顾验证的各项检查清单，最终流片。  RTL0    任务 内容     团队验证环境准备 项目的工作目录、采取的验证进度跟踪方法   验证人力和进度安排 模块、子系统、系统需要的人力和进度安排   验证工具和方法选择 仿真工具和形式化验证工具的版本、验证方法学   验证文档 记录验证策略、验证平台环境、方法学    RTL1    任务 内容     搭建模块验证环境 按照设计接口搭建验证环境   生成寄存器模型 由设计XML文件生成UVM寄存器模型   验证文档 模块验证环境、寄存器模型 、环境编译   验证计划回顾 模块级验证计划的回顾    RTL2    任务 内容     语义检查（linting） 检查常见的设计规范问题   跨时钟域检查（CDC） 模块、子系统级的CDC检查   仿真验证、形式化验证 选择合适的方法学完成模块/子系统80%以上的验证   创建测试用例 将测试用例同功能验证点完成匹配   回归测试 创建和更新模块级/子系统级的回归测试表   bug修复和跟踪 记录发现的bug，完成修复后的回归测试    RTL3    任务 内容     跨时钟域检查（CDC） 完成系统级的CDC检查   能效仿真（PA） 完成系统级的PA仿真   仿真验证和形式化验证 完成系统级的验证   创建测试用例 创建系统级测试用例   回顾测试用例 系统级测试用例和功能点回顾   bug修复和跟踪 修复系统级测试的bug，并跟踪和回归测试   回归测试 集中提交所有模块的测试用例，评估整体进度   代码/功能覆盖率收集 合并模块/芯片覆盖率，创建新的用例完备覆盖率    GLS    任务 内容     门级验证环境准备 需要从RTL芯片验证环境做更新，使用门级仿真   网表仿真验证 从RTL级选择测试用例，在网表环境测试逻辑一致性   网表+SDF仿真验证 伴随门级延迟仿真，完成时序验证   bug修复和验证 伴随设计ECO流程，完成RTL和门级验证    TO    任务 内容     验证功能点回顾 确保所有待验的功能点全部被测试用例覆盖   测试用例回顾 检查最终回归测试表结果，检查用例是否全部通过   覆盖率回顾 检查最终合并的覆盖率，功能覆盖率100%，代码覆盖率在90%以上   门级仿真用例回顾 所有的时序违例均被修正和过滤，功能全部通过    验证管理的三要素 时间管理  早行动：  各个模块和系统验证人员早参与到项目的前期定义环节，可以尽早知道设计的改动，从而考虑如何对原有的环境做出更新。同时，在选用IP和定义新模块的过程中，验证人员也可以更早的考虑选用什么验证IP、验证方法以及相应的工具。 有经验的验证团队，在项目开始之前就考虑更新的验证环境、流程、工具选择、方法学、技能训练、自主工具脚本开发等。 将验证环境搭建工作和测试用例创建工作分开，也就是少数人搭建维护验证环境，剩下的绝大部分人专心创建测试用例，通过这种让验证人员更专注的进行功能验证的模式来提高产出率。   少依赖：  一旦有了充分的意识，懂得验证过程并非是在设计完备后开始，那么验证人员就应该想出各种办法来减轻或者消除对于设计进度的依赖性。 尤其对于验证经理而言，让团队因为依赖一些未完成的事情而白白浪费时间，这对于项目进行来讲是大忌。 同时，验证团队往往需要在多个项目中一边开展新项目一边维护老项目，这更需要做好人力协调安排，避免出现项目之间人力冲突的情况。   大局观：  验证人员不但要专注于自己的“一亩三分地”，还要清楚共同的关键节点，以及各个模块之间的依赖性， 面临选择验证方法和工具时，需要考虑的不单单是该方法或该工具可以提高多少仿真速度或覆盖率，同时也要考虑人员的技能培训投入、学习曲线、新工具整合、新环境维护等与项目进度密切相关的因素。    人力安排  团队建设：  由于验证技术的趋势变化加快，新的方法、工具层出不穷，验证团队成员组成往往需要不同的技术背景。 招聘或培养人员时，要考虑所要具备的基本技能，和在某些技术领域拥有着丰富经验。比如软件编程、验证环境建设、形式化验证、硬件加速等。 一个经验丰富的验证团队，成员之间的技能一般会有重叠和差异部分。这种方式可以保证在人员任务分派时会有多种选择，同时团队共同工作时可以实现技能互补。 不同经验层次的梯队可以保持技术的传承，梯队培养，同时在任务分派的时候，也可以考虑将新的任务交给老员工，将老的任务交给新员工，满足老员工新技能培养、接受新的挑战，也使得新员工快速使用项目环境。   技术和管理：  技术功底深厚的人少有管理同样出色的，而善于在不同部门、技术组之间沟通的人善于协调、计划和监督却又无法很好的兼顾技术层面。 往往技术优秀的人才会被委以团队和项目管理的职责，但是这种选择不一定是最合适的。 伴随着验证项目的要求越来越复杂，芯片公司也越来越需要有经验的项目管理者，因为这样一位管理者会对整个项目起到组织和推动的作用。 好的验证组织既需要有技术良好的梯队，也应该具备贯彻执行验证计划的执行力，一个验证团队需要不同技术专长的验证人员，也需要可以统管全局的验证经理。    任务拆分和重组  项目启动初期，由于系统结构和设计功能描述尚未确定，相邻模块间的接口上不稳定，这时候在这些不确定中找到确定因素，来安排验证进度、估算所需的验证资源，对于验证经理的经验有很高的要求。 任务拆分指的是可以将一件用时较长或较复杂的任务拆分为相对独立的小任务。拆分任务的好处：  更容易清楚要做的任务和技术难易度、时间长短。 帮助分辨不同小的任务间的依赖性。 发现哪些部分是核心，哪些部分存在风险。 在有多人参与情况下，可以合理的分配任务，并发执行。 细化的任务有助于进度的跟踪和工作的量化。   任务重组指的是验证经理在统筹各个模块、不同验证节点之间的任务时，可以合理的对不同任务进行合并、转接、排序等，它的目的是更有效利用整体的验证资源。常见的任务重组场景包括：  发现各个验证模块中共同的可利用资源，指派专人维护（验证IP、回归工具、环境、脚本、仿真工具）。 模块A和模块B都需要创建一个类似的环境或组件时，考虑两个组件间共同规划同一个环境或参数化组件，以便减少整体工作量，提高模块复用性。 在发现不同模块之间有依赖性的时候，就需要安排优先级，消除依赖路径，尽可能使全员都行动起来。    验证的收敛 概述 随机验证的方式使得回归测试更加有意义。一般来讲，我们基于两种目的来提交回归测试表：\n 由于随机环境每次产生激励序列不同，这样每次回归测试均会对覆盖率收集做出贡献。 当设计bug修复后，回归测试保证bug的修复且不会引入新的bug。  回归测试具体指的是每次直接将所有测试用例提交到服务器运行，并且检查测试结果，对于模块级的回归测试，这种方法在时间和计算资源上也许是可行的，但对于系统级回归测试，这种方式每次要消耗的时间和资源需要重新考虑，一般考虑的因素是：回归流程、回归质量、回归效率。\n回归流程   流程阶段：\n RTL1：模块级基本功能验证、模块级高级功能验证。 RTL2：模块级回归测试和收集覆盖率、系统级基本连接验证、系统级模块交互功能验证。 RTL3：系统级回归测试和收集覆盖率、模块级和系统级副覆盖率合并。    流程细节：\n 模块设计阶段，除了准备验证环境，在验证的基本功能完成之时就应该创建一些基本的测试用例，并逐渐形成回归列表，在RTL2时要全部测试通过。 保证基本功能回归列表时，一些高级功能或附件功能，以及corner场景尽可能的在RTL2前完成验证。但是这些功能可能有部分需要在RTL2和RTL3之间完成验证，所以按照优先级划分功能回归列表也需要作为模块验证完成的检查项。 由于RTL2节点可以保证基本功能的正常工作，这份回归测试表单也是的RTL3开始时进行系统验证得到保障。 RTL2和RTL3之间，需要完成模块级的高级功能验证，之后反复进行回归测试，通过大规模的随机测试来验证设计的稳定性，并且完成覆盖率的收集。 模块级验证必须在RTL3之前完成，而系统级验证必须在门级仿真之前完成，并且尽可能减小落后于节点的差距。    备注： 这里提到的基本功能回归表，能够初步保证设计代码的正确性，在代码提交前设计师先通过代码编译检查和基本功能回归测试，通过后再提交到git库，交验证人员进行更多的高级功能回归测试，可以减少因提交代码质量导致时间的浪费，也可以将其集成到git提交管理。\n  回归质量  芯片设计在每次完成后，我们可以通过回归测试工具将设计、验证环境的编译、仿真、结果检查集成为一体，也可以通过一些简单的命令由设计者先查看基本功能是否正常工作。 只有保证基本功能回归列表测试通过，代码版本管理工具才可以允许提交，同时通知验证人员更新设计代码，展开高级功能的回归测试。 如果验证人员发现了bug，设计人员在bug修复后，先通过基本功能测试，再递交给验证人员检查之前的bug场景，确定修复后再进行高级功能或更高层次的验证工作。     回归测试列表 任务     基本功能测试表 设计提交检查项、设计基本功能覆盖   高级功能测试表 设计稳定后开展高级功能测试   覆盖率收集测试表 高级功能测试之后，随机测试收集覆盖率     总结：  前期设计不稳定时，主要定期提交基本功能测试来快速检查功能是否通过。 设计比较稳定后，规划用时较短、测试场景简单的用例，检查核心功能是否正确。 设计后期，应该一方面实现复杂场景测试，一方面大量提交回归测试表类完善功能覆盖率。    回归效率  影响回归效率的几个方面：  模块验证阶段，随机测试方式倾向于反复提交测试表来产生各种可能场景，而到了后期覆盖率难以得到更多提升，那么如何 精细控制随机约束 使得每次回归测试总有新增覆盖率的收获就显得额外关键。 在设计bug修复后，如何快速检查设计基本功能，保证设计版本提交的质量，这对提高回归测试效率也很关键，一个低质量的设计代码会降低回归测试的收益。 系统级验证阶段，由于测试用例时间明显加长，每次回归整个测试表需要消耗很长时间，但是越到后期反复回归的收益就越低，但是验证管理需要这样的数据，这种矛盾也需要化解。   提升回归效率：  切分测试场景，将较长的测试用例切分为多个序列，这样做的好处是避免过于冗长复杂的测试用例，划分多个用例可以方便并行提交，用计算资源来节省时间。 对于较难切分场景的测试用例，比如系统级仿真时需要先完成上电、复位、时钟使能等一系列初始化操作之后才能进行有效测试场景，可以考虑快速跳转到特定状态来实现缩短测试时间。 针对第二条所描述的特定状态，也就是需要长时间的运行来到达某一测试状态，建议分为两个阶段，第一阶段来检查跳转该状态的条件以及跳转功能是否正常，第二阶段在第一阶段测试通过的前提下，可以直接初始化到测试状态，例如强行置位寄存器、状态信号等方式，使得设计快速到达测试状态，缩短测试时间。 尽可能给予充分的计算资源，目前用于仿真的普遍方式是，中心化服务器集群来提供计算和数据存储资源，通过资源分配管理办法来实现充足的并行运算资源，缩短回归测试的运行时间。 后期回归测试，使用定向用例或精确控制随机约束，提高覆盖率收集的效率。    问题追踪 问题类型  系统功能定义问题。 硬件设计问题。 芯片验证环境问题。 综合时序问题。 硅前工具问题。 引用库和IP问题。  追踪工具  关于bug追踪需要的功能：分类、派发、查找、追溯、报告等。 标准化的问题追踪工具可以加速芯片开发的进度：  商业工具：Team Foundation Server(Microsoft), JIRA, Rational cLEARqUEST(IBM) 开源工具：Bugzilla(Mozilla), Redmine, Trace    工具的功能  记录：记录问题标题、内容、出错场景、背景描述、发布版本、测试用例、复现命令以及其他相关文件。 分类：归属哪个项目、哪一层次、哪个模块、哪一类型以及问题的严重性。 派发：问题提交即代表追踪的开始，管理者或提交人员可以指定谁来修复。 查找：查找功能可以方便bug追踪的查看，也可以在新bug发生时查找是否之前出现过此bug或有其他同事已经提交相同bug。 追溯：追溯是跟踪bug的状态迁移，从提交、派发、解决、完成等一系列状态的迁移。 报告：将整个数据库中的bug统计，从不同的维度形成报告，方便管理者查看。  团队建设 7个好习惯之从全局入手  同一个问题，专家的考虑角度总会比新手更高，更广、更丰富，解决问题的方案也会有高低的区别，所以无论处于哪个专业水平，总会有更高更全面的视角等待挖掘。 对于一个团队而言，在项目启动的时候，如果团队负责人能够对项目的周期、难点、人力估计、环境建设做出响应，与团队分享他的视野，保证团队清楚接下来大家如何作战、清晰每个阶段的作战目标，对于整个项目的推进很有意义。 团队中每一个成员在思考问题时都保持一种全局观，往往对于项目的中长期运行，可以更少资源、更高效率的去实现目标，另外对个人成长也很有意义。  7个好习惯之追求百分百  如果一个问题从硅前隐藏到门级仿真，那么代价是数倍的，如果隐藏到硅后测试，代价是数十倍的，这就需要每个人的严谨工作态度，百分百的工作努力。 如果遇见了问题就要及时解决它，以往的经验来看，凡是没有验证过的场景就一定存在bug，在发现问题或预测到问题的存在时，就尽早的去解决它，否则隐藏的风险会在后期不对放大，如果你认为没问题，那么问题很快就会来找你。 如果发现一个会影响大家的问题，主动去修复它，避免问题的延续导致影响更多的人，以及更长的影响时间。 维护好自己的TODO list，确保有序高效的完成它们，切记不能遗忘否则可能会带来灾难，并且当自己不确定时及时请高层次的人员或负责人来帮助自己确认。  7个好习惯之保持面向对象的开发习惯  对于设计人员，面向对象的开发方式不一定要熟悉，但对于验证人员，它的重要性尤为显著。 无论使用SV、SC、C++还是Python，如果需要开发一个长期维护的环境或工具，请先考虑面向对象的方式。  7个好习惯之合理复用  复用是高效验证的核心理念，无论是方法学的推陈出新还是验证环境的搭建维护，都需要考虑复用。 复用所涉及的范围很广，除了设计模块复用。验证环境复用、测试用例复用之外，也包括项目环境复用、脚本复用等。 验证目前占到整个芯片开发60%以上的工作量，提高复用性可以加快验证速度和减少维护成本。 为了提高复用性，在构建验证环境时，尽可能考虑验证环境参数化、脚本自动化、提交文档等方式，使得验证环境的维护和使用。  7个好习惯之保持创新  从新手逐渐变为“老司机”之后，往往会有一段倦怠期或自满期，因为验证人员觉得：他对所属的模块已经足够掌握，验证环境也熟悉，似乎没有那么多再需要深挖的地方了。 这个时候，不放争取新的模块和任务，往往“老司机”和新任务的搭配，能够发现更多的问题和改善措施。 我们相信验证总会有需要不断完善的地方，在新的空余你的思想还会保持一段活跃的时间，从而提出一些新的改善方法。 如何让大脑保持不断创新？除了不断学习。不断交流外，那就是永远追求验证效率的提高。实际工作中的创新，一旦被证明它对整个团队的价值，那么不单单是它的作用会逐渐放大，而且你也可以感染和吸引更多的人，一同加入到你们的创新队伍中去。  7个好习惯之高效的沟通  首先，多人团队可以进一步拆分为5人以内的小组，平行执行任务，保持各组之间的独立。 其次，在可行的情况下优先考虑面对面谈话，次者打电话，再次者写邮件，我们相信口头表达是最高效的方式。 再者，尽量少开会、开短会，只邀请必要的人参加，节省他人时间，也节省自己的时间（最害怕白图标开会，晚上加班coding）。 最后，如果有条件，可以将团队在一些关键项目节点前，聚集在一起办公进行团队作战，减少沟通成本。  7个好习惯之突破责任边界  在设计的边界划分上，我们可以通过定义模块层次和结构来实现，而在验证工作中，我们无法很清晰的划分出边界，因为模块间有互动功能。 一般情况下，我们会遵循主从端、上下行数据传输和功能实现工作量大小的方式来确定，互动功能由哪一方来验证。 尽管我们希望以一种合理的方式来划分验证边界，但仍然难免有一些边界不清晰的功能交互部分。 如果有关联的模块A、B双方可以突破责任边界，积极承担各自的部分，或者从项目整体出发，去定义验证的完整方案，在考虑工作的承担问题，毫无疑问这对于整体验证质量是有益的。 主动突破责任边界，会对自己的成长很有帮助，学到更多东西。  验证的专业化 对于验证的偏见  A公司目前的设计复杂度低，而且有面向市场的进度压力，所以他们更愿意将设计做完后经过简单的测试直接将原型验证通过FPGA来实现和测试，至于RTL验证的投入则少的可怜。 B公司的验证平台已经很多年没有更新，尽管设计越来越复杂，但是因为一直缺少经验丰富的验证师来更换升级公司的验证平台，所以在项目开始，尽管能听到越来越多对于验证平台老旧不方便的抱怨，项目管理者还是以缺少合适的人力为理由，让大家通过加班来弥补验证平台的效率缺失。 C公司没有专门的验证团队，而验证的工作几乎是公司内部的设计人员之间相互合作验收的，在缺少验证标准、计划、环境和文档的情况下，设计师同时也兼任了验证师的角色。如果询问设计师，实施验证是否困难？他们会回答，这不就是添加激励，看看行为是否异常吗？在他们眼里，设计工作才是应该受到公司最多关注的。 D公司验证团队整体实力与设计团队有不小差距，通过分析我们可以发现，该公司的验证团队是由公司不合格或暂时没经验的设计师和新进公司的新手拼凑组成的。公司的管理层认为，验证的好处不单单是可以发现一些漏洞，还可以让那些不合格或暂时没经验的设计师先到验证环境去熟悉，至少不会因为一些简单的错误给设计种下一些严重的漏洞。看起来D公司的验证团队接收到的，是一种隐形的“二等公民”。不过通过验证工作，debug过程可以熟悉设计，进而在对设计有一定理解之后，逐渐承担设计任务，也是很多公司目前采用的培养方式。 E公司的设计团队和验证团队比较健全，然而他们之间的沟通经常不顺。当验证人员在项目前期发现bug时，还可以和设计人员探讨修复bug的问题，而到了项目的后期，如果再发现什么严重的漏洞，设计人员就显得不那么愉快了。因为漏洞越到了后期才被发现，修复漏洞的难度和代价越大，同时由于项目进度的压力，有时候设计人员不得不加班加点去完成，这就是为什么不愉快的原因。  验证的专业化认识  A公司虽然看起来在用FPGA可以快速得到测试结果，但是更多地是将设计作为黑盒验证，缺少内部信号的检查调试，同时缺少随机激励的场景来达到验证的完备性，缺少边缘场景错误场景保证设计的稳定性。 B公司为什么缺少合适的人？深层次的原因恐怕与公司对验证不重视有很大关系。如果一开始从验证人员招聘和对验证贡献的充分肯定上入手，那么验证人员的培养不会滞后于设计人员太多。 C公司除了对与设计师的验证能力充分“信任”之外，也没有觉得验证是一项单独需要培养的技能，或者说缺乏对一个专业验证团队的认识。事实上，验证确实不是一项技能，而是需要很多知识综合起来的技能。 D公司看起来倒是通过这种小聪明，使得烫手的员工没有做出什么可能让公司无法挽回的损失。但除了让员工被感到不信任之外，公司又如何能够保证他们的验证工作做的足够好？要知道验证和设计一样重要，设计种下了漏洞，验证没有发现，同样是致命的。 E公司的设计人员越到后期越不情愿听到自己的设计被发现漏洞，而且和验证人员沟通起来也颇为困难。除了对于设计和验证的关系需要理清之外，该公司还需要多鼓励验证团队，让他们在关键时刻顶住压力，该报告的设计漏洞需要义无反顾的提交，并且到后期每报出一个漏洞都应该值得庆幸，因为幸好它没在流片后回来才被发现。  验证面临的现状  芯片业对验证的偏见不单单来源于公司和业界的成见，就连教育行业也是如此。高校的教育与芯片行业的脱节十分严重，基本很少看到有高校开设关于芯片验证的课程，哪怕是导论。 国内芯片验证领域可参考的书目也不多，而国外优秀的图书又没有得到及时的翻译和引进。 对于从事验证的工程师，业界优秀的图书本身也是实际工作联系不够紧密，而大多数人缺少时间和资源来查阅每年最新的验证领域的相关论文。 国内缺少验证行业广泛交流大会，使得验证工程师在经验积累和技术交流上，缺少途径。 就公司而言，对于验证工程师的培养以及职业发展路径上，应该给出明确的信息，从公司层面给出对验证工程师的认可，让验证工程师对于自己的职业发展感受到动力。  验证的标准化  如果想让验证技术呈现出更清晰的理念，首先要将验证的流程标准化和量化，就像软件测试的环节一样。无论对于团队还是个人，只有趋于标准化、量化的验证才能更稳固地推进项目，从而做到心里清楚，手中不慌。 验证团队除了需要优秀的验证工程师，也需要经验丰富的验证经理，这一要求的着眼点不只在于日常管理，也包括针对芯片整体验证去规划验证框架、环境、流程、制定验证计划、评估人力、时间节点等。 验证经理会就所有项目、之前的项目和未来的项目之间验证环境的复用和优化两方面考虑，要求模块、子系统和系统级验证环境可以保持垂直复用和水平迁移的要求。同时验证经理也需要考虑采样哪一种验证方法、选派合适的人进行验证等。  验证经验的积累和突破  经验分享是需要长期贯彻的事情，包括公司的内部分享和公司的外部分享两方面。验证的事务做久了容易让人产生倦怠，原因主要在于验证工程师对于验证环境逐渐掌握，趋向于按照现有的环境框架去思考问题，也容易对现有环境的效率感到满足，很难做到主动突破现有框架、做出改善甚至验证环境换代的举措。 公司内部的交流值得推荐，除了沟通成本小，不同验证团队、不同事业部或者分公司之间都可以就验证技术展开交流。 请EDA技术支持工程师，为大家培训，或咨询。 通过总结自己的验证经验，完成体系的验证思想，发表到行业技术大会以及其他技术交流会议，同其他公司分享，也查看和听取其他公司的技术分享和探讨。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":32,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（四）","uri":"https://www.wenhui.space/docs/digital_verifer/beginner_verification/beginner_verification_four/"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第三篇，主要介绍计划的概述、计划的内容、计划的实现、计划的进程评估。\n   版本 说明     0.1 初版发布    参考  《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      计划的概述 验证计划是什么  选择验证方法和构建验证环境前，首先需要知道验证计划是什么。 展开设计之前，设计人员和验证人员都会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现和验证它。 实际项目执行中，功能描述文档和设计会不断更新，验证工程师要做好相应验证计划的更新。 验证计划在设计启动之前就已经诞生，且伴随着整个设计周期。  计划的步骤  创建验证计划 选择验证方法 人力资源调配 构建验证平台和环境组件 开发测试用例  收集的材料  结构功能描述 设计的各种操作使用模式 正常输入和错误输入场景下设计的行为 设计的接口 边界场景下设计的行为 设计在实际使用中的场景描述  计划的好处  使得设计和验证人员对于功能描述文档的理解保持一致。 将自然语言描述的功能通过可测试性语言来描述。 可以更合理的评估出工作量、人力安排和进度节点。 为验证人员提供明确的验证目标、任务和进度安排。 为功能文档提供反馈，修改文档中不明确、有歧义的描述。  影响计划的因素  验证计划是团队协作的产物，需要系统、设计、验证共同参与制定。 需要更新成百上千的测试用例，并且与计划中待测试功能一一对应。 考虑选中不同的验证方法，针对不同的设计，需要考虑使用模拟仿真、形式化验证或硬件加速验证，如需使用多平台验证，还要考虑如何实现技术平台上的兼容和跨越式复用。 添加新的设计需求，需要更新验证计划。新添加功能，要考虑额外的人力和进度影响。 多组参与验证，需要团队合作协调，以及测试用例的复用。  计划的内容 概述  技术角度考虑，需要有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求。 项目角度考虑，需要有使用工具、人力安排、进度安排和风险评估。  验证的功能  基本功能： 时钟、电源、复位、寄存器访问和基本功能特性，这些可以仿真模块级完成验证。 交互功能： 需要与其他模块交互的特性，需要在更高层次的子系统级或系统级完成验证。 次要功能： 这些会在项目后期完成验证，比如性能验证，即便没有达到要求不会存在致命影响，所以风险较低，放在最好验证。  验证的层次  结合验证功能点，需要清楚该功能点在何层次验证。 从验证效率和激励自由度来看，应该尽量在较低层次验证更多功能点。 在较高层次，应该侧重于系统集成测试。  验证的方法  方法： 模拟仿真 or 形式化验证 or 硬件加速验证。 透明度： 黑盒 or 白盒 or 灰盒（建议尽可能使用黑盒）。 激励： 定向激励 or 随机约束激励。  验证的用例 选择：\n 更随机的测试方法，尽可能遍历可能的状态空间？ 适中的随机约束，倾向于更贴近实际场景的随机激励？ 采用定向测试，针对一些边界情况可以更有效的收集覆盖率？  建议：\n 验证初期，应该只发送一些基本的测试数据，约束范围尽可能窄。 验证中期，由于设计基本稳定，可扩大约束范围，以此更有效地完成验证。 验证后期，有一些边界场景通过随机约束激励无法有效收集覆盖率，需要采用定向用例。  覆盖率的要求  覆盖率是衡量激励生成质量和功能点验证的量化指标。 无论何种验证，都需要采用覆盖率来确保给出了足够的激励，遍历设计可能的状态。 覆盖率可以分为代码覆盖率、功能覆盖率和断言覆盖率。 除了给出合法的激励之外，也要考虑给出错误的激励，来测试设计的稳定性和纠错能力。  工具的选择  模拟仿真工具 形式化验证工具 验证IP（如商用接口协议的验证IP） 断言IP 调试工具 硬件加速器 高层次验证语言  人力安排  不同验证方法对人力安排存在明显差别，除了考虑个人的实际经验外，也需要考虑他们是否熟悉该模块，也就是验证人员的知识和技术背景越贴合，越倾向于选择这样的验证人员，对于人力成本和验证风险都可以降低。 推荐一个完整的项目周期内，固定人员跟踪同一个设计模块，从搭建环境、用例编写、覆盖率收集，以及模块级、子系统级、系统级整个验证过程，这样安排项目风险较低，人员成长较快。  进度安排  首先进度往往是从上向下传达的，项目有时间进度，验证工程师会有一个大概的进度要求。 工作量 = 人力 X 时间。 验证经理经常会处于人力不够充分或时间不够宽松的境地。时间往往是固定的，做好任务的安排和动态的人力分配，实现高效的资源配置是关键。 时间进度可修改吗？ 这无法回答，如果能更细致的量化和评估时间和人力安排，delay的风险会较低。  风险评估  芯片结构不稳定： 添加或修改新的功能，会增加新的工作量。 工具的不稳定： 新的版本工具会增加新的特性，有可能提高工作效率，但是也会存在适应期。新的工具面临环境流程更新、技术培训等问题。 人力不稳定： 处于各种原因导致验证人员被临时替换，会加大验证风险。 设计交付时间的不稳定： 设计的delay会直接影响到验证。  计划的实现 概述  一份细致的验证计划也包括项目动向、更新内容和工程进度，清晰的计划更能保证时间和人力的平衡。 验证计划需要时常保持更新，给出合理的安排，从计划到实践的反馈，再到计划修改。  如何制定验证计划  邀请相关人员参加会议（设计、验证、系统等）。 开会讨论验证方案。 确定测试场景。 创建验证环境。  邀请人员    项目角色 关注角度 期望验证点     设计人员 设计实践 设计内部时序、状态机、内部逻辑   硅后测试人员 硅后模块功能测试 硅前测试用例移植到硅后测试   软件人员 模块在系统中的应用 软件正确的配置序列被测试   系统人员 结构和性能要求 设计框架符合要求，性能和效能可以早期测试   验证经理 进度、人力和优先级 给出合理安排，定期更新计划   验证人员 验证方法和环境 综合衡量其他角色意见，给出统一的解决方案    开会讨论 作为会议组织者，首先明确开会的目的和议题：\n 报告验证计划的内容。 确定验证功能点。 确定验证方案和时间节点。  一份验证计划的模板应该包含以下内容：\n 设计功能简要概述。 硬件实现结构框图。 待验证的功能点。 验证环境结构。 测试用例构成。 编译脚本和回归测试。 覆盖率分析。 风险评估。  确定测试场景  电源开关。 复位测试。 常规场景。 边缘场景。 错误场景。 性能压力测试。 选择验证层次和验证方法。  创建验证环境  搭建环境时，创建不同的接口信号和激励组件来构建场景。 是否可复用验证资源，以及可用的vip。 监测组件收集数据，确定采样时序和事件，捕捉有效信号。 构建参考模型，模拟DUT行为。 检查组件比对结果，输出报告信息。  计划的进程评估 概述 在验证过程中，需要不断更新验证进度，从各项参数综合评估验证的完备性。\n 回归测试pass率。 代码覆盖率。 断言覆盖率。 功能覆盖率。 bug曲线。  回归测试pass率  一份回归测试表是将测试设计的所有功能点的用例合并为一个测试集。 回归测试表的主要功能是用来在设计bug修复后或性能优化后，对原有的功能仍然正常工作。 回归测试不仅确保设计修改不影响原功能，且不影响其他模块功能。 回归测试表中的测试用例，需要确保可以重现激励场景。这对于定向测试是容易实现的，而对于随机约束测试，需要保存随机种子，方便重新激励场景。 如果某层次回归测试通过，可向上迁移到新的验证层次，展开新的回归测试流程。 同一测试用例，不同层次回归测试，仿真时间不同，不同层次、不同设计规模、不同测试场景的复杂度，都会影响测试用例的仿真时间。 回归测试中，对验证平台的优化（运算资源和运算效率）的要求更高。 如果系统级回归测试发现bug，修复后需要从模块级回归测试开始运行。  代码覆盖率  代码覆盖率是用来衡量RTL代码是否被充分运行的指标。 通过工具开关可自动收集代码覆盖率，且可以将不同批次回归测试覆盖率数据进行合并。  常见的代码覆盖率：\n 语句覆盖率（statement coverage）： 程序每一行代码是否执行过。 条件覆盖率（condition coverage）： 每个判断条件中的操作数被覆盖情况。 分支覆盖率（branch coverage）： if、case、while、repeat、for等语句中各个分支执行情况。 事件覆盖率（event coverage）： 记录某个事件被触发的次数。 翻转覆盖率（toggle coverage）： 记录信号数据位 0-\u0026gt;1 和 1-\u0026gt;0 的翻转情况。 状态机覆盖率（FSM coverage）： 记录状态机各个状态的进入次数，以及状态间的跳转情况。  断言覆盖率  断言描述本身也支持覆盖率收集，一般可以模拟仿真、形式化验证和硬件加速仿真都可以收集。 仿真过程中，会判断断言的先决条件是否被触发，以及判断语句的成功与否。 依据仿真工具不同，断言覆盖率可分为动态仿真和形式化验证两种。  功能覆盖率 功能覆盖率衡量设计的各项功能是否实现。功能覆盖率会关注设计的输入、输出和内部状态。\n 输入： 检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。 输出： 检测是否有完整的数据传输类别，以及各种场景的反馈时序。 设计内部： 检查信号与功能点相对应，通过单一覆盖、交叉覆盖或时序覆盖来检查功能场景是否被触发。  注意： 功能覆盖率的收集需要依据功能点文档编写covergroup，且fail用例的覆盖率数据不能合并到回归测试的覆盖率数据中。\nbug曲线  验证过程中要记录和统计bug，bug管理工具一般具有提交、修改、完成、挂起四个状态。 每周统计新增bug数量和修复bug数量，绘制bug曲线。 依据bug曲线，如果能尽早的收敛，意味着后期发现bug的数量和可能性就越小，是设计稳定性的有效指标。 注意： 如果验证后期发现一个基本功能的严重bug，意味着我们很可能在之前验证过程中遗漏了一些重要场景的测试。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":33,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（三）","uri":"https://www.wenhui.space/docs/digital_verifer/beginner_verification/beginner_verification_three/"},{"content":"本文 主要介绍一种verilog语言中获取随机数的方法。\n   版本 说明     0.1 初版发布    代码展示  设计代码   1 2 3 4 5  function [31:0] get_random; input signed [31:0] min_num; input signed [31:0] max_num; get_random = min_num + {$random}%(max_num-min_num+1); endfunction // get_random    验证代码（如果范围包括负数，请将random_num声明为有符号类型）   1 2 3 4 5 6 7 8 9 10 11 12  reg signed random_num initial begin #0 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #10 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #20 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end end   应用场景 实际设计中并不会使用随机数的生成逻辑，因为本身逻辑也是非可综合的。使用随机数生成逻辑往往用于测试逻辑。典型的应用如，为时钟添加时钟偏移（多用于跨时钟域设计的验证，如异步fifo验证）。\n1 2 3 4 5 6 7 8 9 10  parameter CLK_PERIOD = 50; reg clk; reg signed [31:0] random_num; reg [31:0] clk_shift_period; initial clk = 0; always begin random_num = get_random(-CLK_PERIOD/5,+CLK_PERIOD/5);//skewing 20%  clk_shift_period = CLK_PERIOD + random_num; #clk_shift_period/2 clk = ~clk; end   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":34,"section":"docs","tags":["Verilog"],"title":"Verilog中获取随机数","uri":"https://www.wenhui.space/docs/digital_designer/typical_demo/random_in_verilog/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要介绍类和对象的概述、类的成员、类的继承、句柄的使用、包的使用。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      类和对象的概述 类和对象  面向对象的编程语言更符号人对自然语言的理解（属性property和功能function）。 这个世界由无数的类（class）和对象（object）构成的。 类 是将相同的个体抽象出来的描述方式， 对象 是实体，其具备有独立行为能力。 具有相同属性和功能的对象属于同一类，而不同的类之间可能有联系（继承关系）或没有关系。 在C语言中，编程基于过程方法（function）；在verilog中，提供了笨拙的“类对象编程”可能性，也就是在module中定义方法（function/task/always/initial），而后调用module实例中的方法。 verilog中module+method的方式与sv中class定义有本质的区别，即面向对象的三要素：封装（encapsulation）、继承（inheritance）、多态（polymorphism）。本节只阐述类的封装和继承，多态在后续高级章节介绍。 类的定义核心是属性声明和方法定义，所以类既可以保存数据，也可以处理数据。这与struct结构体的重要区别就是，结构体只是数据的集合，而类不仅保存数据，还可以进行数据处理。  为了直观说明类的属性和方法，举例如下：\n 类名： 鸟 属性： 翅膀：有，羽毛：有 方法： 飞  例化一个类的过程，就是创建类的一个实例，类的实例就是对象。比如家里养了一只喜鹊，这就是对象，它属于鸟类，满足鸟类的属性，具有鸟类的方法，同时也可以拥有自己的属性，如下：\n 实例名： 喜鹊1 属性： 翅膀：有，羽毛：有，颜色：黑白，体重：700g \u0026hellip;\u0026hellip; 方法： 飞  验证为什么需要OOP（面向对象编程） 验证环境的各个组件具有以下特点：\n 验证环境中不同组件其功能和所需处理的数据内容是不同的。 验证环境中同一类组件其所具备的功能和数据内容相似。  所以，基于以上两点，验证环境中各个组件角色明确、功能独立，使用面向对象编程与验证环境的构建原则十分吻合。\n第一个transaction事务类：\n1 2 3 4 5 6 7  class transaction; bit [31:0] addr, crc, data[8]; function void display; $display(\u0026#34;transaction: %h\u0026#34;, addr); endfunction endclass   可见class的定义和module的定义类似，不过module和class完全不同：\n module属于硬件域，class属于软件域。 module内的变量是静态的，代表硬件电路，class内的变量是动态的，代表软件行为。 class内可以并且建议定义软件变量（bit等），而module只能定义硬件变量（reg、wire等）（其实也可以定义bit，只不过最后工具还是默认为reg类型）。 class例化后称为对象，module例化后称为实例。 class内不能出现initial和always。  OOP的概念要素  class类： 基本模块包含成员变量（属性）和方法。module也可以存在变量和方法，不过属于硬件域。 object对象： 类的实例。module也可以例化，属于硬件域。 Handle句柄（指针）： 用来指向对象的指针。module通过层级索引找到设计的实例。 property属性（变量）： 在类中声明的存储数据的变量。在module中就是reg和wire。 method方法： 在类中可以使用function/task来定义方法，在module中定义function/task，也可以定义always/initial。  创建对象  再次强调v module和sv class的区别：  两者共同点在于均使用“模板”来创建内存实例。 不同点在于v module例化是静态的，编译时完成，而sv class例化是动态的，可以任意时间点发生，这也使得类的例化方式更加灵活和节省空间。 v module中没有句柄概念，而是通过层级索引方式找到实例（A.B.C.sig1），而sv class通过句柄使操作更加灵活。   创建对象时，需要清楚什么是声明，什么是创建（例化）：  声明： transaction trans; 创建： trans = new();   创建对象时创建了什么？ 开辟了新的内存空间，用来存放对象的成员变量和方法。 创建对象时可以通过自定义构建函数来完成变量的初识化和其他操作。   1 2 3 4 5 6 7 8  class transaction； bit [31:0] addr, crc, data[8]; function new(); addr = 3; foreach(data[i]) data[i] = 5; endfunction endclass    构建函数new()系统预定义的函数，不需要指定返回值，函数会隐式的返回例化后的对象指针，所以并不是没有返回值，不能加void。 new函数也可以定义多个参数作为初始化时外部传入数值的手段。   1 2 3 4 5 6 7 8 9 10 11 12 13  class transaction； bit [31:0] addr, crc, data[8]; function new(bit[31:0] a=3, d=5); addr = a; foreach(data[i]) data[i] = d; endfunction endclass initial begin transaction trans; //声明  trans = new(10, 20); //带初始化数据的创建 end   句柄的传递 区分了类（抽象）和对象（具体）之后，还需要区分对象（存储空间）和句柄（对象指针）。也就是说，在创建了对象之后，该对象的存储空间位置不会变，而指向该空间的句柄可以有多个。\n1 2 3 4  transaction trans1, trans2; //声明句柄 trans1和trans2（此时句柄悬空，无指向对象） trans1 = new(); //例化对象，将其句柄赋予trans1 trans2 = trans1; //将trans1的值赋予trans2，也就是句柄trans1和trans2指向同一对象 trans1 =new(); //例化第二个对象，并将其句柄赋予trans1   首先两个new就代表创建了两个对象，最终trans1指向第二个对象，trans2指向了第一个对象。\n对象的销毁  软件编程的灵活在于动态的分配内存空间，在资源闲置时可以回收空间。 C++语言中的类除了有构建函数，还有析构函数，析构函数的作用就是手动释放空间，这对编程人员的细心和经验提出了要求；而Java和Python等后续的OOP语言不再需要手动定义析构函数，而是自动回收释放空间。 sv也采用自动回收空间的处理方式。回收原则：当一个对象在整个程序中没有任何地方再需要它时，便会被销毁，也即是回收空间。不需要的意思就是没有句柄指向该对象。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class word; byte nb[]; //声明动态数组  function new(int n); nb = new[n]; //创建动态数组（创建类的对象是使用\u0026#34;new()\u0026#34;）  endfunction endclass initial begin : initial_1 word wd; for(int i=1; i\u0026lt;=4; i++) wd = new(i); end initial begin : initial_2 #1p3 $display(\u0026#34;How many Bytes are allocated for word instances??\u0026#34;); end   根据以上代码，假设wd=new(1)需要分配1Byte空间，那么在initial_2中当打印语句时，需要为例化开辟多少空间呢？答案是4Byte，原因是wd是静态的；如果将wd声明改为“automatic word wd;”，答案就是0Byte，原因是wd是动态的，且#0ps时刻被创建，而#1ps打印时，wd变量已经消失，空间被回收了。\n句柄的使用  句柄可以用来创建多个对象，也可以前后指向不同对象。 可以使用句柄来使用对象中的成员变量或者成员方法，如下：   1 2 3 4  transaction trans; //声明句柄 trans = new(); //例化对象 trans.addr = 32\u0026#39;d10; // 为对象的成员变量赋值 trans.display(); //调用对象的成员方法   静态变量  与硬件域不同的是，class中声明的变量默认是动态的，其生命周期在仿真中的某一时间点，也就是对象的创建到对象的销毁。 如果使用关键字static来声明class内的变量，则其为静态变量。静态变量的生命周期贯穿整个仿真阶段。 如果类中声明了静态变量，那么可以直接引用该变量class::var，或者通过例化对象引用object.var。类中静态变量声明后，无论例化多少个对象，只可以共享一个同名的静态变量，因此类的静态变量的使用可以打通各个对象，但是要注意共享资源的保护，换句话说，任何地方修改静态变量，大家都会看到它的修改。  静态方法  类似与静态变量，在class中定义的方法默认为动态的，我们可以通过static关键字将其声明为静态方法。 静态方法内可以声明并使用动态变量，但是不能使用类的动态变量。原因是咋调用静态方法时，可能还没有创建具体的对象，对应的动态变量也就没有被创建，这时候是无法使用类的动态变量，编译时就会报错；静态方法中可以使用类的静态变量，因为静态变量和静态方法一样，编译时就创建了。  类的成员 概述  类是成员变量和成员方法的载体，这些成员可以完成保存数据和处理数据的功能，并且类的变量和方法应该遵循“聚拢”原则，也就是一个类的功能要尽可能单一，做好专职工作。 类作为载体，天生具备了闭合属性，也就是将其属性（变量）和方法封装在类的内部，不会直接暴露给外部，并且可以通过protected和local的关键词，设置变量和方法的外部访问权限。 如果没有指明访问类型，成员默认为public（public并不是关键字），意味着子类和外部都可以访问。 如果指明访问类型为protecd，那么只有该类及其子类可以访问，外部无法访问。 如果指明访问类型为local，那么只有该类可以访问，子类和外部无法访问。 访问类型的设定是为了更好的封装类，尤其是发布供他人使用的软件包，如果验证环境应用范围较窄，可以使用默认的public访问类型，方便类的外部更好的使用变量和方法。  定义和调用成员方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class transaction1； bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction1\u0026#34;); endfunction endclass class transaction2； bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction2\u0026#34;); endfunction endclass   1 2 3 4 5 6 7 8 9  transaction1 t1; //声明句柄t1 transaction2 t2; //声明句柄t2 initial begin t1 = new(); //创建对象  t1.display(); //调用transaction1::display()  t2 = new(); //创建对象  t2.display(); //调用transaction2::display() end   类的封装  类和结构体的异同：  二者本身都可以定义数据成员。 类变量在声明后，需要构造才会创建对象实体，而struct在变量声明时已经开辟内存。（有时候类没有new函数，也并不会出错，并不是不需要new，而是系统自动调用了new函数） 类除了可以声明数据变量，还可以声明方法，而struct不能。换句话说，struct就是个数据结构，而class包含了数据成员以及对数据成员处理的方法。   类与module的异同：  从数据和方法来看，两者都可以作为封闭容器来定义和存储。 从例化来看，module必须在仿真开始时就确定是否要例化，而类可以在仿真的任意时刻被例化。换句话说，module是硬件域，静态的，class是软件域，动态的。 从封装性来看，module内的变量和方法是对外部公共开发的，而类可以定义为公共的、受保护的和私有的。 从继承性来看，module没有继承性可言，也就是无法在原有的module的基础上进行module的功能扩展，而继承性是类的一大特点。    思考  可以在哪里定义类？ 答案：module、interface、program和package，也就是所有“盒子”。 可以在类中再声明类成员吗？ 答案：可以，类也是一种数据载体。 What is this ？ 答案：如果在类中使用 this ，即表明this.X所调用的成员是当前类的成员，而非同名的局部变量或者形式参数等。   1 2 3  function new(string name); this.name = name; //将参数传递的name赋值给当前类的name变量 endfunction    类有编译顺序吗？ 答案：有，建议的编译顺序是先编译基类，再编译高级类，或者说先编译将被引用的类，再编译引用 之前已经编译过的类 的类，其实就是个依赖关系。  类的继承 概述  继承也符合我们的认识世界的观点，我们对世界的认识无外乎归纳法和演绎法。 归纳法就是从个别特别到一般属性的方法，从具体对象中抽象出类的属性和方法，这就是定义类的思维方式。 “白猫黑猫都是猫，抓住老鼠就是好猫”，这里白猫黑猫都继承于猫类，他们有一个属性是颜色，另一个属性是好坏。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class cat; protected color_t color; local bit is_good; function set_good(bit s); this.is_good = s; endfunction endclass class black_cat extends cat; function new(); this.color = \u0026#34;BLACK\u0026#34;; endfunction endclass class white_cat extends cat; function new(); this.color = \u0026#34;WHITE\u0026#34;; endfunction endclass black_cat bk; white_cat wt; initial begin bk = new(); wt = new(); bk.set_good(1); wt.set_good(0); end   由上面代码得出结论：\n 不可以通过外部修改黑/白猫的颜色，因为声明的是受保护的变量。 黑/白猫不可以自己初始化时设置is_good夸自己是好猫，因为cat类定义的is_good是local类型。 外部不可以通过访问黑/白猫的is_good属性来得知是不是好猫，因为cat类定义的is_good是local类型，无法访问。 黑/白猫是不是大脸猫，无从得知，因为没有这个属性。  案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class basic_test; int def = 100; //成员变量赋予默认值  int fin; task test(sim_ini ini); $display(\u0026#34;basic_test::test\u0026#34;); endtask function new(int var); //......  endfunction endclass class test_wr extends basic_test; function new(); super.new(def); $display(\u0026#34;test_wr::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_wr::test\u0026#34;); //......  endtask endclass class test_rd extends basic_test; function new(); super.new(def); $display(\u0026#34;test_rd::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_rd::test\u0026#34;); //......  endtask endclass    类test_wr和test_rd是子类，其父类为basic_test，也叫基类。 子类在定义new函数时，应该首先调用父类的new函数，即super.new()。如果父类的new无任何参数，也可以省略super.new()，因为系统会自动调用。 要想继承父类的属性和方法，必须调用（显式或隐式）super.new()。 从创建对象的初始化来看，用户应该注意如下的规则：  子类的实例对象在初始化时首先会调用父类的构造函数。 当父类构造函数完成时，会将子类实例对象中各个成员变量按照他们定义时的默认值初始化，如果没有默认值则不初始化。 在成员的变量默认值赋予后（声明的同时即赋值），才会最后进入用户定义的new函数中执行剩余的初始化代码。    成员的覆盖 在父类和子类里，可以定义相同名称的成员变量和方法（形式参数和返回值也应该相同），而在引用时，也将按照句柄类型来确定作用域。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class basic_test; int def = 100; //成员变量赋予默认值  function new(int var); //......  endfunction endclass class test_wr extends basic_test; int def = 200; //成员变量赋予默认值  function new(); super.new(def); $dispaly(\u0026#34;test_wr::super.def =%0d\u0026#34;, super.def); //super.def为100  $dispaly(\u0026#34;test_wr::this.def =%0d\u0026#34;, this.def); //this.def为200  endfunction //...... endclass module tb; //...... basic_test t; test_wr wr; initial begin wr = new(); t = wr; //将子类对象句柄赋值给父类句柄（实际上父类句柄t仍旧只能访问父类变量，而并没有扩大作用域至子类，如果想扩大作用域，只能使用$cast，而不是等号）  $display(\u0026#34;wr.def = %0d\u0026#34;, wr.def ); $display(\u0026#34;t.def = %0d\u0026#34;, t.def ); end endmodule   最后打印的wr.def和t.def的值分别为多少？答案是200和100。首先声明了父类的句柄t和子类句柄wr，创建了子类的实例wr，又将子类的句柄wr赋给了父类句柄t。此时句柄t和wr都指向了这个对象，这里就有区分了，虽然都指向同一对象，但是子类句柄wr可以访问这个对象中的全部变量，也就是def默认值为200，而父类句柄t只能访问子类继承自父类的变量，也就是def默认值为100。这里有两个关键点，一是父类和子类都声明了相同名字的变量，二是子类句柄赋值给了父类句柄，在此场景下需要特别注意。\n总结：\n test_wr类新定义的变量test_wr::def和basic_test::有冲突（同名），但是在类的定义里， 父类和子类拥有同名的变量和方法也是允许的 。当子类作用域中出现父类同名的变量和方法，则 以子类作用域为准 。同时也可以使用this/super来指明使用子类/父类的变量/方法。 父类和子类拥有同名或非同名的变量或方法时，子类使用变量和方法，如果不指明super/this，则依照由近及远的原则来引用变量。  首先看变量是否是在函数内部定义的局部变量。 其次看变量是否是当前类定义的成员变量。 最好再看变量是否是父类或更底层类的变量。    句柄的使用 句柄的传递  句柄可以作为形式参数通过方法来完成对象指针的传递，从外部传入方法内部（注意：传递的参数是句柄，而不是对象，并且对象是创建在一块内存里的，永远不可能作为参数传递）。   1 2 3 4 5 6 7 8 9  task generator; tranctions t; t = new(); transmit(t); endtask task transmit(transaction t); //...... endtask    句柄也可以在在方法内部首先完成修改，而后再由外部完成使用。   1 2 3 4 5 6 7 8 9 10 11 12 13  function void create(tranction tr); //Bug, miss ref  tr =new(); tr.addr = 100; //initialize other fields  //...... endfunction transaction t; initial begin create(t); t.addr = 10; $display(t.addr); end   问题：最后显示的t.addr的数值是多少？ 答案：报错。分析：create函数的参数默认为input，没有返回值，也就是create函数内所做的操作都是局部的，而在外部看来，句柄t还是个null，没有实例，所以在引用t.addr时会报错。改进方法是：参数声明为inout 或 添加ref关键字。\n句柄的动态修改 程序执行时，可以在任何时候为句柄创建新的对象，并将新的指针赋值给句柄。\n1 2 3 4 5 6 7 8 9 10 11 12  task generate trans(); transaction t; //声明句柄  tranction fifo[$]; //声明存放句柄的队列  t =new(); //创建对象  for(int=0; i\u0026lt;3; i++) begin t.addr = i\u0026lt;\u0026lt;2; fifo.push_back(t); end t = fifo.pop_front(); endtask   问题：最后t.addr数值多少？ 答案：8。分析：首先循环对t.addr的赋值依次为0 4 8，队列依次存入三个t，最后弹出第一个赋给t，仿佛最后t.addr的值应该是第一个数字0，为什么会是8，原因就一个，队列里存放的是句柄，不是对象，三次存入的句柄t的内容不变，都指向对象t，而对象t的addr变量是8。所以牢记： *传递和传递的是句柄，而不是对象*。\n包的使用 包的意义  sv语言提供了一种在多个module、interface和program中共享parameter、data、type、task、function、class等的方法，即利用package（包）的方式来实现。如果装修一个大房子（完整的验证环境）来看的话，我们喜欢将不同的模块的类定义归整到不同的package中。 这么做的好处在于将一簇相关的类组织在单一的命名空间下，使得分属于不同模块验证环境的类来自于不同package，这样便于通过package来解决类的归属问题。  包的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package regs_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage package arb_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage //导入包 module tb; import regs_pkg::*; import arb_pkg::*; regs_mon mon1 = new(); arb_mon mon2 = new(); endmodule    两个package regs_pkg和arb_pkg中都定义了4个与模块验证相关的类，即stimulator、monitor、checker、env。两个不同的package内存在同名的类，但是它们的内容是不同的。 如果我们将这些重名的类归属到不同的package中去编译，不需要担心命名冲突的问题，因为package会将命名空间分隔开率，在使用同名类时，注明要使用哪个package的即可。   1 2  regs_pkg::monitor mon1 = new(); arb_pkg::monitor mon2 = new();   包与库的区分  package可以对类名做一个隔离的作用，使用不同的package管理同名的类，可以解决命名冲突问题。（使用域名索引符“::”） package更多的意义是将软件封装在不同的命名空间中，以此来与全局的命名空间进行隔离。 library是编译的产物，硬件都会被编译到库中，如果不指明编译库，会被编译到默认的库中（worklibrary），同样可以解决命名冲突的问题（不过设计中我认为都会依靠一套完整的命名规则来命名，这样不仅解决同名冲突问题，还可以从名字上了解到模块的更多信息）。 库既可以容纳硬件、也可以容纳软件，包括package。  包的命名规则  在创建package的时候，已经在指定包名称的时候隐含地指定了包的默认路径，即包文件所在的路径，如果在package中要include该路径之外的文件，需要额外指定搜索路径“+incdir+PATH”。 如果遵循package的命名习惯，不但要求定义的package名称独一无二，其内部定义的类也应该尽可能独一无二。 如果不同package中定义的类名也不相同，在顶层的引用可以通过“import pkg_name::*”的形式，来表示在tb中引用的类如果在当前域中没有定义，会搜寻regs_pkg和arb_pkg中定义的类（前提是所有类不同名）。 类的命名上，建议加上指明特定身份的前缀，比如package名。  包的使用建议  在包中可以定义类、静态方法和静态变量。 如果将类封装在某一个包中，那么它就不应该在其他地方编译，这样可以方便后面对类的引用。 类和包是好朋友，包是类的归宿，类是包的子民。 一个完整模块的验证环境组件类，应该由一个对应的模块包来封装。 使用`include关键词完成类在包中的封装，要注意编译的前后顺序。 编译一个包的背后实际是将各类文件平铺在包中，按照顺序完成包和包内各类的有序编译。 使用类的可以通过`import完成包中所有类或者某个类的导入，使得新环境可以识别出来，否则类会躺在包外不被外部识别。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":35,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（三）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_three/"},{"content":"本文 主要介绍辅助verilog编码的三款工具，简化编码工作。\n   版本 说明     0.1 初版发布    三大利器  Emacs verilog-mode 的使用 代码预处理工具ep3的使用 verilog中reg和wire的自动声明  verilog编码我们需要写什么？ 如下代码，我们实际要写的，也就是真正的逻辑部分，而其他部分基本全部由以上三大利器完成。注意，正常使用顺序为：先ep3进行代码预处理，再verilog-mode进行AUTO处理，最后自动声明reg和wire。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  module demo(/*AUTOARG*/); input clk; input din1; input [3:0] din2; @for i=0 to 5 output dout@i; @endfor /*AUTOWIRE*/ /*AUTOREG*/ /*AUTO DECLARE*/ assign sig1 = \u0026amp;din_b[3:0]; //.........other logic  sub_mod i_sub_mod(/*AUTOINST*/); endmodule   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":36,"section":"docs","tags":["Verilog"],"title":"简化verilog编码的全套解决方案","uri":"https://www.wenhui.space/docs/digital_designer/rtl_coding/verilog_coding_three_tools/"},{"content":"本文 主要介绍一款代码预处理工具：ep3（基于Perl语言开发）。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Perl： v5.24.1  参考  https://metacpan.org/search?q=ep3 http://www.lujun.org.cn/?p=2099  什么是ep3？ ep3是一款基于Perl语言开发的脚本工具，主要对代码中一些重复代码，通过脚本处理自动生成，以节省编码工作。\n下载与安装 下载  github（安装包）：https://github.com/weiqi7777/ep3 百度网盘分享资源（安装包）： 链接：https://pan.baidu.com/s/1VU3%5FbI0HXdhopquccYHo2Q 密码：co5s 百度网盘分享资源（可执行程序）： 链接：https://pan.baidu.com/s/1GKROlch5GDqglpbbUs09mw 密码：andt  安装  下载可执行程序的话，将其放到/usr/local/bin/目录（也可以是其他PATH变量下目录）下即可使用，无需安装。 下载安装包的话（详情可见readme），安装到/usr/local/bin/（需要root权限）：   1 2 3 4 5  su perl Makefile.PL make make test make install    下载安装包的话（详情可见readme），安装到~/tool/bin/：   1 2 3 4  perl Makefile.PL PREFIX=~/tools/usr make make test make install   使用命令 1  ep3 [option] source_file \u0026gt;result_file   option选项：\n1 2 3 4 5 6 7 8 9  Usage:\t/usr/local/bin/ep3 [-include dir] [-define key [value]] [-delimeter string] [-module modulename] [-[no]comments] [-[no]protect] [-[no]depend] file1 [file2 .. filen]    -include： 指明include路径 -define： 定义参数， 如 -define TYPE=1（参数赋值等号左右无空格） -nocomments: 去除文件中的注释 -noprotect: 注释保护，默认是不对注释内容进行处理的，如果设为-noprotect，会处理注释内容 -delimeter string: 默认是@，可以指定其他字符 其他参数：待学习，暂不清楚  使用场景 删除注释 使用命令 ep3 -nocomments filename.v \u0026gt;filename.v ，即可删除代码中所有注释内容。\n循环  原代码   1 2 3  @for i =2 to 5 reg mem@i; @endfor    ep3 filename.v \u0026gt;filename.v 处理后   1 2 3 4  reg mem2; reg mem3; reg mem4; reg mem5;   传递参数和条件判断 注意：ep3传递参数和带参数值的条件判断（@if和@elif和 @else 和@endif关键字），只能使用命令行传参使用。\n 原代码   1 2 3 4 5 6 7 8 9  @if TYPE == 0 reg TYPE_0; @elif TYPE == 1 reg TYPE_1; @elif TYPE == 2 reg TYPE_2; @else reg TYPE_3; @endif    ep3 -define TYPE=2 filename.v \u0026gt;filename.v 处理后（注意，TYPE=2，等号左右无空格；如果多个参数，每一个参数前都要有-define）：   1  reg TYPE_2;   定义宏  原代码（也可以将宏定义内容放到某文件，在使用宏前进行include，效果相同，关于include的使用请参考下文)：   1 2 3  @macro `A_WIDTH 8 reg [`A_WIDTH-1:0] sig1;    处理后：   1  reg [8-1:0] sig1;   def判断 关键字：@ifdef和@ifndef和@else和@endif。\n 原代码（也可以将define定义内容放到某文件，在def判断前进行include，效果相同，关于include的使用请参考下文）：   1 2 3 4 5 6 7  @define TYPE0_ON @ifdef TYPE0_ON reg TYPE_0; @else reg TYPE_1; @endif    处理后：   1  reg TYPE_0;    还可以使用@enum定义宏，一行定义多个，与@define效果相同   1  @enum a,b,c,d   include  原代码：   1 2  //include @include \u0026#34;inc1.v\u0026#34;    创建inc1.v文件，其内容如下（如果是@define或@macro，换成对应内容即可）：   1 2  reg mem1; reg mem2;    ep3关于include的查找默认是当前目录，使用 ep3 filename.v \u0026gt;filename.v 命令即可 ，如果非同一目录，可以在命令行指定目录 ep3 -include ./include/ filename.v \u0026gt;filename.v ，也可以在@include语句中指明文件目录，处理后如下：   1 2 3  //include reg mem1; reg mem2;   replace  原代码  replace以空格为分隔符，第一个参数作为被替换对象，其余作为替换内容。\n1 2 3  @replace AA BB MM CC This is AA;    处理后   1  This is BB MM CC;   perl_begin和perl_end ep3支持在代码中使用perl语言生成代码，关键字是@perl_begin和@perl_end。\n 原代码：   1 2 3 4 5  @perl_begin for($i=0;$i\u0026lt;3;$i++) { print \u0026#34;reg mem${i};\\n\u0026#34;; } @perl_end    处理后：   1 2 3  reg mem0; reg mem1; reg mem2;   也可以使用perl语言定义子函数，辅助生成代码：\n 原代码（定义了@hello函数）：   1 2 3 4 5 6 7 8 9 10  1 Text to be printed ... @perl_begin sub hello { my $self = shift; print \u0026#34;Hello there\\n\u0026#34;; } @perl_end 2 Text to be printed ... @hello 3 Text to be printed ...    处理后（在“2 Text”后引入@hello）：   1 2 3 4  1 Text to be printed ... 2 Text to be printed ... Hello there 3 Text to be printed ...   更多无耻要求 以上是常用场景，基本满足日常需求了，如有更多无耻要求，请查看相关资料，并且有解决方案的话，欢迎分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":37,"section":"docs","tags":["Verilog"],"title":"代码预处理工具ep3的使用","uri":"https://www.wenhui.space/docs/about_linux/script_notes/ep3_tool/"},{"content":"本文 主要介绍一款自己开发的Python脚本： verilog中reg和wire的自动声明 。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Python： Python 2.7.13  功能  该脚本会统计always块和assign语句中的赋值对象，并且自动识别wire类型和reg类型，以及信号位宽，完成自动声明。 会滤除已声明的wire和reg信号，以及output信号，不会对已声明的信号重复声明。 支持位宽使用宏定义，建议使用 [`XXX_WIDTH-1 : 0] 方式定义（对于使用宏定义的信号，需要对自动生成的声明结果再次确认，如有修改，可将修改后的信号声明置于/*AUTO DECLARE*/之前，脚本不会对已声明的信号重复声明）。 自动滤出注释内容。 其他功能，待添加（如begin end匹配检查）  脚本源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304  #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import operator import re import os import os.path #Ignore comments Begin #-------------------------------------------------------- def ignore_comments(line_val, nextline_is_comment): line_nocomment=re.sub(\u0026#39;//[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_val) #Ignore comments(//) line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments(/* */) line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) #Ignore comments(/* */ Cross-line_nocomment) currentline_is_comment=nextline_is_comment if \u0026#34;/*\u0026#34; in line_nocomment: nextline_is_comment=True line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if \u0026#34;*/\u0026#34; in line_nocomment: nextline_is_comment=False currentline_is_comment=False line_nocomment=re.sub(\u0026#39;[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if currentline_is_comment: line_nocomment=re.sub(\u0026#39;[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) if line_nocomment == \u0026#39;\u0026#39;: line_nocomment=\u0026#34;/*LINE_IS_COMMENT*/\u0026#34; return line_nocomment, nextline_is_comment #-------------------------------------------------------- #Ignore comments End #Fetch Keywords Add To Dict Begin #-------------------------------------------------------- def fetch_keywords(line_val): line_val=re.sub(\u0026#39;input \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;output \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;wire \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;reg \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;assign \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;[\u0026lt;]?=[\\S\\s]*\u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=line_val.strip() signal_width=re.findall(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, line_val) if len(signal_width) != 0 : signal_name=re.sub(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, \u0026#39;\u0026#39;, line_val) signal_name=signal_name.strip() signal_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;\\[[\\s]*([`a-zA-Z0-9_\\-]+)\u0026#39;, line_val)) signal_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;([`a-zA-Z0-9_\\-]+)[\\s]*\\]\u0026#39;, line_val)) else: signal_name=line_val.strip() signal_width_max=\u0026#39;0\u0026#39; signal_width_min=\u0026#39;0\u0026#39; return signal_name, signal_width_max, signal_width_min #-------------------------------------------------------- #Fetch Keywords Add To Dict End #Add Keys To Dict Begin #-------------------------------------------------------- def add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, key_val, key_width_max, key_width_min): if type_val == \u0026#39;output_type\u0026#39;: output_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;input_type\u0026#39;: input_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;wire_type\u0026#39;: wire_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;reg_type\u0026#39;: reg_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return input_check=input_dict.has_key(key_val) output_check=output_dict.has_key(key_val) reg_check=reg_dict.has_key(key_val) wire_check=wire_dict.has_key(key_val) addwire0_check=addwire_dict0.has_key(key_val) addreg0_check=addreg_dict0.has_key(key_val) addwire1_check=addwire_dict1.has_key(key_val) addreg1_check=addreg_dict1.has_key(key_val) if key_width_max.isdigit() and key_width_min.isdigit(): if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: signal_width_max=addwire_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addwire_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addwire_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addwire_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif output_check or addwire1_check or wire_check: pass else: addwire_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: signal_width_max=addreg_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addreg_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addreg_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addreg_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif addreg1_check or reg_check: pass else: addreg_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) else: update_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;`[a-zA-Z0-9]+[\\s]*\\-[\\s]*1\u0026#39;, key_width_max)) update_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;0\u0026#39;, key_width_min)) if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: addwire_dict0.pop(\u0026#39;key_val\u0026#39;) if addwire1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif output_check or wire_check: pass else: addwire_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: addreg_dict0.pop(\u0026#39;key_val\u0026#39;) if addreg1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif reg_check: pass else: addreg_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return #-------------------------------------------------------- #Add Keys To Dict End #Print Declare Begin #-------------------------------------------------------- def print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1): addwire_dict0_keys=addwire_dict0.keys() addwire_dict1_keys=addwire_dict1.keys() addreg_dict0_keys=addreg_dict0.keys() addreg_dict1_keys=addreg_dict1.keys() print \u0026#34; // Begin auto declaration\u0026#34; print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict1_keys: if addwire_dict1[key][\u0026#39;width_max\u0026#39;] == addwire_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addwire_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict1_keys: if addreg_dict1[key][\u0026#39;width_max\u0026#39;] == addreg_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addreg_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict0_keys: if addwire_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; wire \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addwire_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict0_keys: if addreg_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; reg \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addreg_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // End auto declaration\u0026#34; #-------------------------------------------------------- #Print Declare End #Main Program Begin #-------------------------------------------------------- #open verilog file #================= try: vfile=open(sys.argv[1], \u0026#39;r\u0026#39;) alllines=vfile.readlines() except (IOError,OSError) as reason: print(\u0026#39;文件出错了！错误原因是：\\n\u0026#39; + str(reason)) finally: vfile.close() #================= #line process #================= input_dict={} output_dict={} wire_dict={} reg_dict={} addwire_dict0={} addreg_dict0={} addwire_dict1={} addreg_dict1={} nextline_is_comment=False currentline_is_comment=False line_num=0 for line in alllines: line_num+=1 line_nocomment, nextline_is_comment=ignore_comments(line, nextline_is_comment) if line_nocomment == \u0026#34;/*LINE_IS_COMMENT*/\u0026#34;: continue #print \u0026#34;Line Nocomment:\u0026#34;, line_nocomment output_regex=re.compile(\u0026#39;(output[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) input_regex=re.compile(\u0026#39;(input[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) wire_regex=re.compile(\u0026#39;(wire[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) reg_regex=re.compile(\u0026#39;(reg[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) addwire_regex=re.compile(\u0026#39;(assign[\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) addreg_regex=re.compile(\u0026#39;([\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) output_line=output_regex.findall(line_nocomment) input_line=input_regex.findall(line_nocomment) wire_line=wire_regex.findall(line_nocomment) reg_line=reg_regex.findall(line_nocomment) addreg_line=addreg_regex.findall(line_nocomment) addwire_line=addwire_regex.findall(line_nocomment) if len(output_line) != 0: type_val=\u0026#34;output_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(output_line)) elif len(input_line) != 0: type_val=\u0026#34;input_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(input_line)) elif len(wire_line) != 0: type_val=\u0026#34;wire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(wire_line)) elif len(reg_line) != 0: type_val=\u0026#34;reg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(reg_line)) elif len(addwire_line) != 0: #Note: wire should be judged before reg type_val=\u0026#34;addwire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addwire_line)) elif len(addreg_line) != 0: type_val=\u0026#34;addreg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addreg_line)) else: continue # print \u0026#34;##Type Vale :\u0026#34;, type_val # print \u0026#34;##Signal_Name :\u0026#34;, signal_name # print \u0026#34;##Signal_Width_Max:\u0026#34;, signal_width_max # print \u0026#34;##Signal_Width_Min:\u0026#34;, signal_width_min # print \u0026#34;\\n\u0026#34; add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, signal_name, signal_width_max, signal_width_min) #================= #print declare #================= #print addwire_dict0 #print \u0026#34;\u0026#34; #print addwire_dict1 #print \u0026#34;\u0026#34; #print addreg_dict0 #print \u0026#34;\u0026#34; #print addreg_dict1 print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1) #================= #-------------------------------------------------------- #Main Program End   使用方法 写在前头  此脚本要求所有自声明的wire和reg要在/*AUTO DECLARE*/之前 要添加自动声明的位置，严格使用/*AUTO DECLARE*/关键字。 本脚本不支持以下赋值语句，请不要使用同时给多个信号赋值的语句：   1  assign {sig_a, sig_b} = 2\u0026#39;b11;    此脚本只自动声明被赋值信号，如有例化模块的输出信号，请使用emacs verilog-model 的AUTOWIRE。  手动添加 可以使用脚本将自动声明结果打印的屏幕或重定向到文件，手动赋值粘贴，使用命令如下(脚本文件名为verilog_auto_declare.py)：\n1 2  python verilog_auto_declare.py verilog_filename.v python verilog_auto_declare.py verilog_filename.v \u0026gt;autodeclare.log   shell封装 如果想将声明结果自动添加到文件，需要用shell将脚本进行封装。\n print_declare.sh（请更改为自己的verilog_auto_declare.py路径）   1 2 3 4 5 6  #!/bin/bash  python ~/Treasury/tools_and_drives/verilog_auto_declare/verilog_auto_declare.py $1 \u0026gt;autodeclare.log sed \u0026#39;/\\/*AUTO DECLARE/r autodeclare.log\u0026#39; $1 \u0026gt; print_declare.v mv print_declare.v $1 rm -rf autodeclare.log    delete_declare.sh   1 2 3 4  #!/bin/bash  sed \u0026#39;/\\/\\/ Begin auto declaration/,/End auto declaration/c \\\u0026#39; $1 \u0026gt;delete_declare.v mv delete_declare.v $1   使用时 source print_declare.sh verilog_filename.v 和 source delete_declare.sh verilog_filename.v 即可。也可以将shell脚本文件属性改为可执行，通过设置alias或将其放到linux的PATH变量路径，可以在终端直接使用。如下：\n 更改文件属性   1 2  chmod 755 print_declare.sh chmod 755 print_declare.sh    设置alias（将下面内容添加到~/.bashrc文件）   1 2 3  #verilog_auto_declare alias print_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/print_declare.sh\u0026#39; alias delete_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/delete_declare.sh\u0026#39;   效果 verilog源码 以下代码无实际意义，仅作为测试使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   print_declare后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ // Begin auto declaration  // Please double check the declaration with macro  wire [`YYYYWIDTH] marco_yyyy; wire [`XXXXWIDTH-1:0] marco_xxxx; reg [`AAAAWIDTH-1:0] marco_aaaa; reg [`BBBBWIDTH-1:0] marco_bbbb; // Please double check the declaration with macro  wire w_yyyy; wire w_xxxx; wire [ 1: 1] wccy; wire [ 2: 2] wccx; reg r_yyyy; reg r_zzzz; reg r_xxxx; // End auto declaration  //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   下载  百度网盘分享资源 链接：https://pan.baidu.com/s/1WEzfSkeZsgYp8gITMsWtqQ 密码：7ui9  其他说明 此版本为初步完成，可能存在部分bug，如有发现bug或有新的需求，欢迎交流。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":38,"section":"docs","tags":["Python","Verilog"],"title":"verilog中reg和wire的自动声明","uri":"https://www.wenhui.space/docs/about_linux/script_notes/verilog_auto_declare/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第二篇，主要介绍接口、采样和数据驱动、测试的开始和结束、调试方法。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      接口 什么是接口？  接口主要用作验证，国外有些团队使用sv设计，接口会用作设计。 验证环境中，接口可以使连接变得简洁而不易出错。 interface和module的使用性质很像，可以定义端口，也可以定义双向信号，可以使用initial和always，也可以定义function和task。 interface可以在硬件域和软件域间传递信息，也就是可以作为module的端口列表，也可以作为软件方法的形式参数。 对于interface的初步认识，可以看作“插排”，DUT与TB之间的数据驱动就是靠这个“插排”来完成的。  接口的定义与使用  interface的定义结构与module类似。 interface的端口列表只需定义时钟、复位等公共信号，或者不定义任何端口信号，而在变量列表中定义DUT与TB连接的各个变量，建议用logic来定义。 interface也可以依靠参数化方式提高复用性。 interface在例化时，与module例化方式相同。 对于有对应interface的DUT和TB组件，在例化时，传递匹配的interface变量名也就完成了interface内变量的传递，换句话说就是两者打通，对应interface的不同组件之间变量信号实时传递。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  interface arb_interface(input bit clk); logic [1:0] grant, request; logic reset_n; endinterface module arb(arb_interface arb_if); //......  always@(posedge arb_if.clk or negedge arb_if.reset_n)begin if(!arb_if.reset_n) arb_if.grant \u0026lt;= 2\u0026#39;b00; else arb_if.grant \u0026lt;= next_grant; end //...... endmodule module test(arb_interface arb_if); //......  initial begin @(posedge arb_if.clk) arb_if.request \u0026lt;= 2\u0026#39;b01; $display(\u0026#34;@%0t: Drove req=01\u0026#34;, $time); repeat(2) @(posedge arb_if.clk); if(arb_if.grant != 2\u0026#39;b01) $display(\u0026#34;@%0t: a1: grant != 2\u0026#39;b01\u0026#34;, $time); $finish; end endmodule module tb_top; bit clk; initial clk = 1\u0026#39;b0; always #5 clk = ~clk; arb_interface arb_if(clk); arb a1(arb_if); test t1(arb_if); endmodule   接口的优势  将有关信号封装在接口，对于设计和验证环境都便于维护，如需修改、添加、删除信号，只需修改interface文件即可。 接口在硬件域（module）和软件域（class）都可以使用，是硬件域和软件域交互的唯一媒介。 接口可例化，对于多组相同总线，通过例化可灵活使用，简化代码且便于维护。 每一个agent使用对应的interface，简化验证平台结构，便于维护。 tb顶层例化时，无需定义信号连线，只需例化interface。  采样和数据驱动 竞争问题  为了避免RTL仿真行为中发生信号竞争问题，建议使用非阻塞赋值(\u0026lt;=)。（简单来说阻塞赋值是顺序执行，非阻塞赋值是并发执行，硬件电路行为是并发执行） 在仿真行为中，为了避免时序电路中时钟和驱动信号的时序竞争，我们需要尽量明确的驱动时序和采样时序。 默认情况下，时钟对于组合电路的驱动会添加一个无线最小时间（delta-cycle）的延迟，而该延迟无法用绝对时间单位衡量，它要比最小时间单位精度还要小。这是仿真工具为了符合硬件电路真实行为（建立时间保持时间以及线延迟）而做出的处理。（注意： #0并不代表0延迟，而是指延迟delta-cycle）  为了说明delta-cycle的概念，举例如下：\n 源代码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  `timescale 1ns/1ps module top_module (); bit clk1,clk2; bit rstn; logic [7:0] d1; initial begin clk1 = 0; forever #5 clk1 \u0026lt;= ~clk1; end always@(clk1) clk2\u0026lt;=clk1; initial begin #0 rstn \u0026lt;= 0; #10 rstn \u0026lt;= 1; #20 $finish; end always@(posedge clk1 or negedge rstn) if(!rstn) d1 \u0026lt;= 0; else d1 \u0026lt;= d1+1; always@(posedge clk1) $display(\u0026#34;clk1: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); always@(posedge clk2) $display(\u0026#34;clk2: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); endmodule    仿真结果：   Running Icarus Verilog simulator... VCD info: dumping is suppressed. clk1: 5000 ps d1 value is 0xxx clk2: 5000 ps d1 value is 0x0 clk1: 15000 ps d1 value is 0x0 clk2: 15000 ps d1 value is 0x1 clk1: 25000 ps d1 value is 0x1 clk2: 25000 ps d1 value is 0x2 Hint: Total mismatched samples is 0 out of 0 samples Simulation finished at 30000 ps Mismatches: 0 in 0 samples 为什么同样在25000ps时刻，d1在clk1和clk2下的采样值不同？首先clk2是在clk1下驱动的，也就是clk2比clk1延迟一个delta-cycle时间，clk1驱动了d1，d1也比clk1延迟一个delta-cycle时间。25000ps，当在clk1下采样时，d1的值还未更新，所以采到的是0x1；而在clk2下采用时，d1已有clk1驱动更新，所以采到的是0x2。如果还未完全理解，可以打开波形窗口，不过要打开delta-cycle的开关，可以看到delta-cycle的存在，对电路的数据驱动和采样时序会有更直观的理解。\n 总结：  如果处于各种原因，clk与被采样数据之间存在若干个delta-cycle的延迟，那么对数据的采样会存在问题。 采样数据的竞争问题会成为潜在困扰仿真采样准确性的问题。 避免采样的竞争问题： 1）在驱动时，添加相应的人为延迟，使clk与驱动变量之间的延迟加大，提高DUT使用驱动信号时的准确度；2）在采样时，依靠采样前某段时刻进行采样，来模拟建立时间的采样要求，确保采样的可靠性。    接口中的clocking  在接口中声明clocking（时序块）和采样的时钟信号，可以用来实现信号的同步和采样。 clocking块基于时钟周期对信号进行驱动或采样的方式，使testbench不再苦恼于如何准确及时地对信号驱动或采样,消除了信号竞争的问题。   1 2 3 4 5 6  clocking bus @(posedge clk1); default input #5ns output #2ns; input data, ready, enable; output negedge ack; input #1step addr; endclocking   对上述clocking描述代码进行说明：\n 第一行定义clocking块bus，使用上升沿来驱动和采样。 第二行指出输入信号在clk1上升沿之前5ns采样，输出信号在clk1上升沿之后2ns采样（输入为采样，输出为驱动）。 第三行声明输入信号，采用默认的输入事件（clk1上升沿5ns前采样）。 第四行声明输出信号，并且指明为clk1下降沿驱动，覆盖了原有的clk1上升沿后2ns驱动。 第五行定义了输入信号addr，采用了自定义的采样事件，clk1上升沿后的1 step，覆盖了原有的clk1上升沿前5ns采样，这里1 step使得采样发生在clk1上升沿的上一个时钟片采样区域，即可以保证采样到的数据是上一个时钟周期数据。  clocking块的总结：\n clocking块不仅可以定义在interface中，也可以定义在module和program中。 clocking中列举的信号不是自己定义的，而是interface或其他声明clocking的模块定义的。 clocking在声明完名字后，应该伴随着定义默认的采样事件，也就是“default input/output event”，如果没有定义，会默认使用时钟上升/下降沿前1step进行采样，时钟上升/下降沿后#0进行驱动。 除了定义默认的采样和驱动事件，定义信号方向时同样可以用新的采样/驱动事件对默认事件进行覆盖。  结论  为了避免采样竞争问题，验证工程师应该在验证环境的驱动环节添加固定延迟，使得在仿真波形中更容易体现出时钟与被驱动信号之间的时序前后关系，同时这样也便于对DUT的准确处理和TB的准确采样。 如果TB在采样从DUT送出的数据，在时钟与被驱动信号之间存在delta-cycle时，应该考虑在时钟采样沿的更早时间端段去模拟建立时间要求，这种方法也可以避免由于delta-cycle问题带来的采样竞争问题。 当我们把clocking运用到interface中，用来声明各个接口与时钟的采样和驱动关系后，可以大大提高数据驱动和采样的准确性，从根本上消除采样竞争的可能性。  测试的开始和结束 写在前头  各个设计自身可以作为一个大的线程，内部有包含多个并行的线程，而模块之间即线程的通信，主要依靠信号的变化。 可以想象，对于一个设计，如果在仿真开始没有任何激励，那么仿真不具备执行条件，也可以认为已经结束，因为在设计内部没有产生任何新的事件，也不会触发组合逻辑和时序逻辑。 如果仿真开始后仅提供时钟和复位信号，验证会持续下去，而对设计不会产生实质的功能影响。从设计角度来看，复位信号是为了让设计进入一个确定的初识状态，而时钟就是脉搏跳动。 verilog测试中，可以通过系统函数“$finish()”来结束仿真，也可以通过“$stop()”来暂停仿真。  program  program是作为验证而提出的，可以有效控制仿真的进程，但是目前验证平台更多基于UVM，UVM有独特的控制机制，所以program在实际项目中使用并不多。 program的提出，将验证部分和设计部分进行有效隔离，每一个program作为一个独立测试，当testbench中所有program中最后一个initial块完成后，结束仿真。这是program的隐式结束。 有些program内的initial块无法正常结束，这时候需要使用显示结束，使用“$exit()”来结束program。 program被看做软件域，所以不可以出现always、module、interface等硬件相关语句，并且不可以例化其他program。 program被看做软件域，可以在program内部定义变量和发起多个initial块，并且建议使用阻塞赋值（软件方式的顺序执行）。 program对于数据采样也可以消除delta-cycle竞争问题，详细内容可见红宝书“SV环境构建篇之程序和模块”。（待了解）  总结  硬件域（module）、软件域（program）、中间域（interface）。 不仅可以使用interface clocking来消除采样竞争问题，可以使用program（建议使用clocking）。 program可以控制仿真的结束。 使用“$stop()”和“$finish()”可以结束仿真。  调试方法 调试工具 大多工程师选择使用verdi作为调试工具，主要有三个窗口：层级列表窗口、源代码窗口、波形窗口。verdi的具体使用方法，请参考我的另一篇帖子 Verdi使用总结。\n打印消息 打印消息是调试循环语句、顺序执行语句等查看路径和当前变量值的简便方式，除此之外，由于验证平台更多变量是动态的，无法在调试工具查看动态变量值，所以对与验证环境的调试，更多使用打印消息。\n打印消息命令“$display()”：\n $time代表仿真时间变量。 显示格式： %x（十六进制）、%d（十进制）、%b（二进制）、%s（字符串）、%t（时间）。 $display（消息级别）、$warning（警告级别）、$error（错误级别）、$fatal（严重错误级别） 字符串变量格式化：string s = $sformatf(\u0026ldquo;Hello, %s!\u0026quot;, name_s);  设置断点  可以通过调试工具为程序设置断点。 通过设置断点（breakpoint）可以查看程序执行到断点处（程序暂停）的变量数值，而设置断点要求验证工程师对程序执行顺序足够了解。 设置断点可以便于查看软件程序（function、task、object）中局部变量的数值。注意：动态变量是无法添加到波形查看的。 设置断点还可以方便调试程序执行的顺序，例如在顺序执行语句执行的多个位置设置断点，通过仿真执行，查看程序是否在断点处暂停，如果没有，那么程序的挂起（hang-on）原因就在上一个断点和此断点之间。通过此方法可定位可疑程序的范围。 如果查看局部变量，需要使用局部变量窗口（Local Windows），继而通过断点查看变量（暂时不知verdi是否支持，待学习）。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":39,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（二）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_two/"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第二篇，主要介绍测试平台、硬件设计描述、激励产生器、监测器、比较器。\n   版本 说明     0.1 初版发布    参考  《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      测试平台 什么是测试平台？  测试平台是整个验证系统的总称，包括验证结构中的各个组件、组件之间的连接关系、测试平台的配置和控制。 广义来讲，测试平台还包括编译仿真流程、结果分析报告和覆盖率检查等。 狭义来讲，测试平台主要关注结构和组件，如何产生所需输入，以及设计的功能检查。  经典的测试平台 经典的测试平台包含Clock/Reset组件、Driver组件、Monitor组件、Checker组件，其特性如下：\n 各个组件相互独立。 验证组件与设计之间需要连接。 验证组件之间也需要相互通信。 验证环境也需要时钟和复位信号的驱动。  验证语言趋势  SystemVerilog使用比例为主导地位。 SystemC和C/C++在验证部分也有应用空间。 验证方法学UVM的统一已经形成。  硬件设计描述  硬件设计描述要介绍它的结构、功能、寄存器和时序。 熟悉硬件设计描述的方式，是验证工程师的一项基本技能。 这里对硬件设计描述不具体举例说明。  Clock/Reset组件 Clock/Reset组件就是指在testbench中产生时钟和复位信号，驱动DUT和Driver。严格来讲，算不得组件，此功能在testbench完成。\nDriver组件  Driver主要职责是模拟与DUT交互模块的接口协议，模拟真实的接口信号驱动DUT。 Driver的激励驱动要符合接口协议，但不局限于真实的硬件行为，可使用抽象的语言方法产生丰富的测试激励。 对于接口协议，如果是成熟的商业协议，建议使用第三方的商用接口ip/vip，这很大程度上节省时间和人力。 如果接口协议为非标准，应该查看功能描述文档，明确接口协议。 Driver主要是与DUT相连接，也应该有时钟和复位的输入，确保driver的驱动激励与DUT接口保持时序同步。 Driver与DUT的连接包含两部分：initiator（发起器）和responder（响应器）。发起器是指主动发起DUT接口驱动，响应器是指接收DUT接口信号，做出响应。  Monitor组件 监测DUT的信号 Monitor主要功能是监测DUT的边界或者内部信号，并且经过打包处理传送到其他组件：\n DUT边界信号：对于系统信号如时钟，可以监测频率变化；对于总线信号，可以监测传输类型和数据内容，以及总线时序是否符合协议。 DUT内部信号：从灰盒验证的手段来看，往往需要监测内部关键信号，来反馈给Driver控制激励产生，或者完成覆盖率收集，以及其他内部功能检查。  Monitor的结构建议  独立性： 建议不同接口信号采用独立的Monitor。 复用性： 尽可能将组件做成验证IP，方便复用到其他环境。 可维护性： 保持代码和验证环境的可维护性，对后期设计修改导致验证环境维护更新很有帮助。 封装性： 将Monitor和Driver一一对应，封装为一个小的单元，这样的小单元可以按照统一的方法实现，但又各自独立。  监测内部信号的建议  如没有特殊需求，采取灰盒验证，而非白盒。 监测内部信号应该尽量少（收集覆盖率除外），且应当为状态信号，不建议监测中间变量信号，因为其本身手受时序的原因信号留存不稳定，这种不稳定有可能影响到验证环境。 可以通过接口信息计算的，尽量少监测内部信号，这样有悖于假定设计有bug的验证思想，如需采用内部信号，也要以动态检查或断言形式确保其逻辑正确性。  Checker组件 checker主要功能 checker主要承担模拟设计和功能检查的任务，主要包含以下功能：\n 接收缓存各个monitor收集的数据。 将DUT接口数据驱动给Reference Model（参考模型），参考模型扮演了模拟DUT功能的角色。 通过数据比较，检查DUT输出接口是否与Reference Model产生的期望数据一致。 检查过程中保存整理验证信息，纳入检查报告中，便于仿真后的追溯。  总结来讲，Checker主要负责数据接收缓存、参考模型和检查报告。\nchecker比较方式 对于checker的数据比较，又可以分为两类：\n 线上比较（Online Check）： 仿真时收集数据与参考模型实时比较，实时报告。 线下比较（Offline Checker）： 将仿真时的数据结果保存到文件中，仿真结束后通过脚本或其他手段，进行数据比较。  checker实现结构建议  对于复杂的系统，建议集中管理checker，将不同monitor信息汇集于此，检查各个模块的功能，统一输出报告。 monitor和driver相对独立且一一对应，建议封装在agent单元组件，而checker在验证环境中心化位置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":40,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（二）","uri":"https://www.wenhui.space/docs/digital_verifer/beginner_verification/beginner_verification_two/"},{"content":"本文 主要对linux系统中对系统的一些设置操作进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  VNC使用笔记  开启VNC：第一步在终端通过ssh登录用户，win系统也可以使用putty；第二步开启VNC服务，会显示开通的端口号，根据此端口可以使用ip加端口号进行VNC登录；第三步设置VNC登录密码。（每个用户可以开启多个端口，另外，VNCSERVER的大部分配置文件及日志文件都在用户home目录下.vnc目录下）   1 2 3  ssh username@ip_addr vncserver vncpasswd    开启指定端口的vnc（注意冒号前有空格，若该端口已占用，VNC会自动创建新的端口）   1  vncserver :2    开启指定分辨率的vnc   1  vncserver -geometry 1920x1080    查看自己已开启的VNC端口   1  vncserver -list    杀死已开启的VNC端口（冒号前有空格）   1  vncserver -kill :2   修改分辨率 选择系统提供的分辨率选项： 菜单栏系统 -\u0026gt; 首选项 -\u0026gt; 硬件 -\u0026gt; 显示器 -\u0026gt; 选择分辨率\n选择自定义分辨率：  生成自定义的分辨率modeline   1 2 3 4  cvt 1600 850 60 #宽 高 刷新频率 #显示如下 # 1600x850 59.92 Hz (CVT) hsync: 52.91 kHz; pclk: 111.75 MHz Modeline \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    xrandr创建新的mode   1  xrandr --newmode \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    查看xrandr输出设备（也包含可使用的分辨率）   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  xrandr #显示如下，×代表当前使用的分辨率 Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192 eDP-1 connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 277mm x 156mm 1366x768 60.00*+ 48.00 1360x768 59.80 59.96 1024x768 60.04 60.00 960x720 60.00 928x696 60.05 896x672 60.01 960x600 60.00 960x540 59.99 800x600 60.00 60.32 56.25 840x525 60.01 59.88 800x512 60.17 700x525 59.98 640x512 60.02 720x450 59.89 640x480 60.00 59.94 680x384 59.80 59.96 576x432 60.06 512x384 60.00 400x300 60.32 56.34 320x240 60.05 DP-1 disconnected (normal left inverted right x axis y axis) HDMI-1 disconnected (normal left inverted right x axis y axis) DP-2 disconnected (normal left inverted right x axis y axis) HDMI-2 disconnected (normal left inverted right x axis y axis)    选择输出设备添加自定义分辨率mode   1  xrandr --addmode DP-1 1600x850_60.00    自定义的分辨率已经添加到系统可选项，可以回到上文的选择系统提供的分辨率选项进行设置 其他说明：首先系统提供的分辨率可选项已经很多，并且多数设备系统可以自适应，以上的添加自定义分辨率的操作不常用到  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":41,"section":"docs","tags":null,"title":"Linux系统设置记录","uri":"https://www.wenhui.space/docs/about_linux/use_notes/linux_syscfg_notes/"},{"content":"本文 主要介绍emacs folding-mode的使用。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  什么是folding-mode? emacs 的folding-mode是一种emacs的副模式，提供代码折叠功能，方便代码阅读和编辑。emacs用户肯定知道org-mode的大纲模式，但是只能在阅读或编辑org文档时才可以使用，而folding-mode可以对任何模式实现类似于org-mode大纲模式的功能。\n安装folding-mode 最简捷的安装方式，是通过emacs的包管理器安装，安装方法请参考我的另一篇帖子 emacs如何安装插件 。\nfolding-mode的使用 修改emacs配置文件 安装folding-mode后，需要修改emacs配置文件，.emacs或.emacs.d/init.el，开启folding-mode功能，请将下面代码添加到emacs配置文件。注意：如需为新的格式添加folding-mode功能，请参照folding-add-to-marks-list完成添加。\n1 2 3 4 5 6 7 8  (if (load \u0026#34;folding\u0026#34; \u0026#39;nomessage \u0026#39;noerror) (folding-mode-add-find-file-hook)) (folding-add-to-marks-list \u0026#39;verilog-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;c-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;latex-mode \u0026#34;%%{{{\u0026#34; \u0026#34;%%}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;lisp-mode \u0026#34;;;{{{\u0026#34; \u0026#34;;;}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;shell-script-mode \u0026#34;##{{{\u0026#34; \u0026#34;##}}}\u0026#34;)   个人配置 为了使用方便，我对folding-mode的常用命令设置了别名，如下：\n1 2 3 4 5 6 7 8  (defalias \u0026#39;me-folding-mode \u0026#39;folding-mode) (defalias \u0026#39;me-folding-reg \u0026#39;folding-fold-region) (defalias \u0026#39;me-folding-in \u0026#39;folding-shift-in) (defalias \u0026#39;me-folding-out \u0026#39;folding-shift-out) (defalias \u0026#39;me-folding-hide-all \u0026#39;folding-whole-buffer) (defalias \u0026#39;me-folding-show-all \u0026#39;folding-open-buffer) (defalias \u0026#39;me-folding-hide \u0026#39;folding-hide-current-entry) (defalias \u0026#39;me-folding-show \u0026#39;folding-show-current-entry)   使用 folding-mode，我主要是以命令的形式使用，其实也支持快捷键，快捷键比较复杂且难以记住，如folding-shift-in，快捷键是 C-c @ \u0026gt;，所以我还是以快捷键使用为主，其他快捷键可以查看folding-mode文档或使用emacs help。\n 打开文件（支持folding-mode的类型）， M-x folding-mode ，打开folding-mode。 选中一块区域，输入 M-x me-folding-reg，此时会在buffer中仅显示选中的内容，且上下插入了folding的注释符，输入标题（也就是第一行注释符后的内容），添加标题后 M-x me-folding-out 可以显示所有内容；或者可以手动添加folding的注释符，通过 M-x me-folding-hide/show 打开或关闭折叠区。 其他命令可自行尝试，不再说明。  效果  hide：   1  # {{{ Title1...    show:   1 2 3 4 5 6 7  # {{{ Title1 aaabbbccc=123456 aaabbbccc=123456 aaabbbccc=123456 # }}}   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":42,"section":"docs","tags":["emacs"],"title":"emacs使用folding-mode","uri":"https://www.wenhui.space/docs/about_emacs/emacs_folding_mode/"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第一篇，主要介绍数据类型、过程块和方法、设计例化和连接。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书。 《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      数据类型 写在前面：SystemVerilog完全兼容Verilog语言\n內建数据类型 verilog中数据类型区分寄存器型（register）和线网型（net），分别用reg和wire去声明，而sv中并不区分reg和wire，而是引用新的数据类型logic（sv中也可以使用reg和wire，不过并不建议这样做）。\n除了logic，还有bit数据类型，它们默认都代表一位数据，也就是它们都可以构建矢量类型（logic/bit [7:0] signal_name）。其区别之处为：\n logic为四值逻辑： 0 1 X Z，四值逻辑类型还包括 integer、 reg、 wire。 bit为二值逻辑： 0 1（引入二值逻辑其目的是将验证软件化），二值逻辑类型还包括 byte、 shortint、int、longint。  数据类型除了二值四值之分，还存在有符号无符号之分：\n 有符号：byte、shortint、int、longint、integer 无符号：bit、logic、reg、wire  关于数据类型的几个注意点：\n 尽量避免两种不同数据类型变量进行操作，包括有无符号，四值二值，不同位宽，如必须进行操作，请先转换为同一类型。 四值变量的x和z态转换为二值变量的0（不过尽量避免四值和二值变量的转换） 多位数据赋值给少位数据，高位被截取忽略；少位数据赋值给多位数据，二值类型的话高位赋值为0，四值类型的话高位赋值为x（如果是有符号类型，高位赋符号位，不过尽量避免不同位宽数据赋值）。 有符号变量转无符号变量，直接赋值的话会将原始比特数据赋给无符号变量，但其原符号位失去含义；使用转换语句转换的话，会将有符号变量取模赋值给无符号变量（不过尽量避免有无符号数据之间转换）  数据类型转换（待补充）：\n 静态转换（不对转换值进行检查）：   1 2 3  unsigned_data = unsigned\u0026#39;(signed_data); int_data = int\u0026#39;(real_data); real_data = real\u0026#39;(int_data);    动态转换（仿真时对转换值进行检查，并输出检查和转换结果）：   1 2  //$cast(tgt,src); $cast(unsigned_data,signed_data);   定宽数组 数组声明（变量左侧为矢量宽度，右侧为维度，且从左至右代表维度从高到低）： 1 2 3 4 5 6 7 8  //二维数组（习惯上左右顺序是从低到高，这对初始化很重要） int data_a[0:15]; // 16个整数[0]...[15] int data_a[16]; // 紧凑型声明  //多维数组（左边为高维度） int data_a[0:7] [0:3]; int data_a[7] [3]; // 紧凑的多维数组声明 int data_a[7][3] = 1; // 为最后一个元素赋值   数组的初始化和赋值： 1 2 3 4  int data_a[4] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[0:3] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[4] = \u0026#39;{4{1}}; //全赋值为1 int data_a[4] = \u0026#39;{5,default:-1}; //data_a[0]为5，其他为-1   存储空间考量： 1 2 3 4  bit [3][7:0] b_pack; bit [7:0] b_unpack [3]; logic [3][7:0] b_pack; logic [7:0] b_unpack [3];   一般变量左侧的宽度代表矢量宽度，右侧代表数组维度，也可以称为数组的合并与非合并，以上都可以代表24bit数据容量。二值逻辑bit声明，每bit位占用1bit空间，第一种声明占用1WORD空间，3x8bit，第二种声明占用3个WORD空间，3WORD x 1x8bit；四值逻辑logic声明，每bit位占用2bit空间，第一种声明占用2WORD空间，3x16bit，第二种声明占用3WORD空间，3WORD x 1x16bit。所以，在合适的时候选用合并数组，能够节省存储空间。（软件仿真时计算机空间占用都是以word为单位的）\n数组操作之for和foreach循环： 1 2 3 4 5 6 7 8  bit [31:0] src[5]; bit [31:0] dst[5]; for(int i=0; i\u0026lt;$size(src); i++) src[i] = i; foreach (dst[j]) dst[j] = src[j] * 2;   $size(src)是获取最高维度变量个数，也可以指定维度$size(src，1)，其中1代表最高，2次之\u0026hellip; foreach语句会遍历数组变量，这也是最推荐的使用方法，多维度遍历可以使用foreach(dst[i,j])。\n 数组操作之复制和比较：  赋值可以直接使用赋值符号“=”，直接进行数组的复制；对于比较，也可以使用“==”或“！=”来比较，不过结果仅限于内容相同或不相同。\n1 2 3 4 5 6 7  bit [31:0] src[5] = \u0026#39;{0,1,2,3,4}; bit [31:0] dst[5] = \u0026#39;{4,3,2,1,0}; if(src == dst) $display(\u0026#34;src == dst\u0026#34;); //比较数组  dst = src; //数组复制  src[0] = 5; //修改数组中某元素   动态数组  定宽数组类型宽度编译时已经确定，若在程序运行时在确定数组宽度就要使用 动态数组 。 动态数组特点就是仿真运行时灵活调节数组的大小，也就是存储量。 动态数组开始时使用“[]”来声明，此时数组为空，其后使用“new[]”来分配空间，方括号中传递数组宽度。 调用“new[]”时也可以将数组名一并传递，将已有数组的值复制到新的数组中。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int dyn[]; int d2[]; //声明动态数组  initial begin dyn = new[5]; //分配5个元素  foreach(dyn[j]) dyn[j] = j; //对元素初始化  d2 = dyn; //复制动态数组，d2初始元素个数为零，复制后元素个数为5，且dyn和d2各自独立  d2[0] = 5; //修改元素值，此时dyn[0]仍为0，d2[0]为5  dyn = new[20](dyn); //分配20个数值并进行复制，也就是dyn初始值5个元素复制给了新的dyn低5个元素，高15个元素为0.  dyn = new[100]; //重新分配100个数值，而旧值不复存在  dyn.delete(); //删除所有元素 end   队列  队列结合了链表和数组的优点，可以在任何地方添加和删除元素，并且通过索引实现对任一元素的访问。 队列的声明是使用美元符号的下标：[$]，队列元素标号从0到$。 队列不需要new[]去创建空间，只需要使用队列的方法为其增减元素，队列初始空间为为零。 队列的简单使用是通过push_back()和pop_front()的结合来实现FIFIO的用法。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int j = 1; int q2[$] = {3,4}; int q[$] = {0,2,5}; //队列的赋值不需要单引号  initial begin q.insert(1, j); //{0,1,2,5} 在1位置插入1  q.insert(3, q2); //{0,1,2,3,4,5} 在队列q 3位置中插入队列q2  q.delete(1); //{0,2,3,4,5} 删除队列中1位置元素  //下列操作才是队列中最常用方法  q.push_front(6); //{6,0,2,3,4,5} 在队列头部插入  j = q.pop_back(); //{6,0,2,3,4} 在队列尾部弹出  q.push_back(8); //{6,0,2,3,4,8} 在队列尾部插入  j = q.pop_front(); //{0,2,3,4,8} 在队列头部弹出  foreach(q[j]) $display(q[j]); //打印整个队列  q.delete(); //删除整个队列 end   关联数组  如果需要一个超大容量存储空间，而有相当部分数据不会被存储和访问，不管使用定宽数组还是动态数组，都会造成存储的浪费，这时候需要使用关联数组。 关联数组可以保存稀疏矩阵元素，当你对一个非常大的地址空间进行寻址时，该数组只为写入的元素分配空间，所以关联数组需要的空间远小于定宽或动态数组。 此外关联数组的灵活应用，在其他高级语言中都有类似的存储结构，比如Perl语言中称为哈希(Hash)，Python中称为词典(Dictionary)，可以灵活赋予key和value。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  bit [63:0] assoc[int]; //声明关联数组，关联数组中[]内声明数据类型，也就是index类型 int idx = 1; repeat(64) begin //对稀疏分布的元素初始化  assoc[idx] = idx; idx = idx \u0026lt;\u0026lt;1; //1 2 4 8 16 ...... end foreach(assoc[i]) //使用foreach变量关联数组，注意：并不一定按index大小顺序依次执行（可以使用sort排序）  $display(\u0026#34;assoc[%d] = %h\u0026#34;, i, assoc[i]); //找到并删除第一个元素，使用if(assoc.first(idx)) 可以判断数组是否为空 assoc.first(idx); assoc.delete(idx);   结构体  sv中可以使用struct语句创建结构，与c语言类似。 sv中struct功能较少，只可以定义一个数据的集合，也就是将若干相关变量组合到一个struct结构定义中。 通过使用typedef和struct，可以定义新的数据类型，并利于新的数据类型声明变量。   1 2 3 4 5 6 7 8 9  typedef struct { bit[7:0] r; bit[7:0] g; bit[7:0] b; } pixel_str; //使用typedef和struct创建新的数据类型 pixel_str  pixel_str my_pixel; //使用新的数据类型声明变量 my_pixel = \u0026#39;{8\u0026#39;h10, 8\u0026#39;h20, 8\u0026#39;h30}; //结构体赋值，此时赋值与声明时一一对应 my_pixel = \u0026#39;{b: 8\u0026#39;h30, g: 8\u0026#39;h20, r: 8\u0026#39;h10}; //结构体赋值，也可以指明结构体内赋值变量   枚举类型  规范的操作码和指令有利于代码的编写和维护，如ADD、WRITE、IDEL等。 枚举类型enum经常和typedef搭配使用，由此便于用户自定义枚举类型的共享使用。 枚举类型保证一些非期望值的出现，增加代码可维护性和降低设计风险。   1 2 3 4 5 6 7 8 9 10  typedef enum {INIT, DECODE, IDLE} fsmstate_e; //声明枚举类型和自定义数据类型 fsmstate_e pstate, nstate; //通过自定义枚举数据类型 声明变量  case(pstate) //枚举类型主要应用于状态机  IDEL: nstate = INIT; INIT: nstate = DECODE; default: nstate = IDLE; endcase $display(\u0026#34;Next state is %s\u0026#34;, nstate.name()); //显示状态名   字符串  verilog语言中是不存在字符串的，而sv中添加了字符串string类型。 所有相关的字符串处理，都使用string来保存和处理。 字符串处理相关的格式化函数可以使用$sformatf()，如果只是打印输出，可以直接使用$display()。   1 2 3 4 5 6 7 8 9 10  string s; //声明字符串，此时为空。  initial begin s = \u0026#34;IEEE\u0026#34;; $display(s.tolower()); //显示 ieee (转小写)  s = (s, \u0026#34;-P1800\u0026#34;); //字符串拼接， \u0026#34;IEEE-P1800\u0026#34;  $display(\u0026#34;@%t: %s\u0026#34;, $time, $sformatf(\u0026#34;%s %d\u0026#34;, s, 42)); //$sformatf返回字符串 end   过程块和方法 initial和always  initial是不可综合的，为验证而生，always是可综合的，代表硬件电路。 module、interface可视为硬件域，program、class可视为软件域，区分硬件域和软件域对理解initial和always很有帮助。 always是为了描述硬件行为，可综合，使用时需要区分时序电路描述和组合电路描述。 initial是软件行为，只执行一次。 initial块和always块之间，以及不同initial块，不同always块，在仿真一开始都是同时执行的。 initial块内语句顺序执行的。 在verilog时代，所有的测试都放在initial块中，并且为了便于统一管理，建议放在同一个initial块中。 initial块可以放在module、interface和program中。 对于过程块，使用begin\u0026hellip;end将其作用域包住，对于控制语句和循环语句，同样适用。  函数function  可以在参数列表指定输入参数(input)、输出参数(output)、输入输出参数(inout)或者引用参数(ref)。 可以有返回值，也可以无返回值(void)。   1 2 3 4 5 6 7  function int double(input a); return 2*a; endfunction initial begin $display(\u0026#34;double of %0d is %0d\u0026#34;, 10, double(10)); end   函数其他属性：\n 默认数据类型为logic。 数组可以作为形式参数传递。 function可以返回或不返回结果，返回结果需要使用关键字return，不返回需要声明为void function。 只有数据变量可以在形式参数列表被声明为ref类型，而线网类型则不能声明为ref类型。 使用ref时，有时为了保护参数对象只被读取不被修改，可以通过const的方式限定ref声明的参数。 在声明参数使，可以设置默认值（input a=10），同时如果在调用时省略参数的传递，则函数中使用默认值。  任务task 任务相比函数更加灵活，且有以下不同点：\n task无法通过return返回结果，因此只能通过output、inout或ref的参数来返回。 task内可以使用耗时语句，而function不能。常见的耗时语句如：@event、wait event、#delay等。   1 2 3  task double(output [31:0] b, input [31:0] a); //不指明方向则默认为input  b = 2*a; endtask   function和task的使用建议：\n 初学者傻瓜式用法，可以全部采用task来定义方法，因为它可以内置耗时语句，也可不以内置耗时语句。 经验者要区分两种方法，非耗时方法使用function，耗时方法使用task，也就是function中完成纯粹的逻辑运算，而task更多完成需要耗时的信号采样或者驱动等场景。 调用function，在function和task内均可以调用其他function，而调用task，如果被调用task内使用了耗时语句，只能在task调用。  变量的生命周期  sv中数据的生命周期分为动态(automatic)和静态(static)。 局部变量的生命周期与其所在域共存亡，也就是在function/task中的临时变量，在其被调用结束后，临时变量的生命周期也将终结。 全局变量在程序执行开始到结束一直存在。 如果数据变量被声明为automatic，那么在进入该进程/方法后，automatic变量会被创建，离开该进程/方法后，automatic变量被销毁。而static在仿真开始时被创建，而在进程/方法执行过程中，不会被销毁，且可以被多个进程和方法所共享。 module内全部是静态变量，代表真实的电路结构。 对于automatic方法，其内部所有变量默认也是automatic。 对于static方法，其内部所有变量默认也是static。 对于static变量，声明时应该对齐做初始化，而初始化只会伴随它的生命周期执行一次，不会随着方法调用而多次初始化。 在module、program、interface声明的变量，以及其他在task/function之外声明的变量，默认是静态变量，存在于是整个仿真阶段。 也就是说，只要用户不注明automatic变量或方法，其变量就是static变量。  设计例化和连接 模块定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  module xprop ( // Outputs out1, // Inputs clk, sel, din0 ); input clk; input sel; input [7:0] din0; output out1; //...... //......  endmodule   模块例化 1 2 3 4 5 6 7 8 9 10 11 12  module testbench; //...... //......  xprop dut( // Outputs  .out1 (out1), // Inputs  .clk (clk), .sel (sel), .din0 (din0)); endmodule   模块连接 模块连接就是将硬件电路在测试平台进行例化，传统的verilog验证方法，在initial过程块产生激励，驱动硬件电路完成仿真。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":43,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（一）","uri":"https://www.wenhui.space/docs/digital_verifer/study_sv/study_sv_one/"},{"content":"本文 主要介绍芯片相关公司的组织架构，和职级与职位及对应的英文缩写。\n   版本 说明     0.1 初版发布   0.2 增加常见职级职位英文缩写    写在前头 本文主要属于科普，目的是避免像我一样，在与别人聊天中对关于职级职位的英文，自己一脸懵逼。\n一般芯片公司的组织架构      公司一级部门由董事长/总经理和副董事长/副总经理负责（也可以称为总裁、副总裁）：\n 董事长/总经理： 向董事会负责。 董事长/总经理助理： 负责协助完成董事长的行程安排、计划实施和会议总结等其他事项。 副董事长/副总经理助理： 负责分管的具体事项，如财政、人力、市场、研发。  公司二级部门由各部门总监负责（芯片公司研发是重中之重，往往研发属于一级部门，研发下设二级部门）：\n 人事部： 负责薪酬、考核、招聘、培训等。 财务部： 负责报销、发票、进帐、出账、税务等。 行政部： 负责会议记录、办公室、后勤、车辆的调度使用等。 市场部： 负责市场、销售、客服等。 运营部： 负责生产管理和运营管理等。 品控部： 负责供应商品质、设计品质、流程体系、可靠性品质等。 研发部： 下设项目部 、验证部、IP部、SOC部、软件测试部、固件开发部、后端设计部等。  项目部： 负责项目立项调研，牵头项目规划和执行。 验证部： 负责项目中验证任务（此验证部与IP部和SOC部的验证团队功能有交叉，不同公司分设不同）。 IP部： 负责IP的开发，其中下设验证团队和设计团队，以及可能还有算法模型设计团队。 SOC部： 负责芯片的集成，包括存储、互连、总线等。 软件测试部： 完成芯片的软件测试。 固件开发部： 完成芯片的固件驱动开发。 后端设计部： 完成芯片的后端版图设计，包括行布局布线和物理验证。    公司三级部门由各部门经理或项目经理负责：\n 设计团队： 负责芯片的前端RTL设计。 验证团队： 负责芯片的验证。  公司职位与职级，以及对应的英文 公司规模和企业性质不同，都会有不同的组织架构，以下只是列举出常见的职位名称，以及其职能，仅供参考：\n GM： 是英文 General Manager 的缩写，指总经理，总经理（General manager）传统意义上是一个公司的最高领导人或该公司的创始人。但实际上，总经理所在的层级，还是会因公司的规模而有所不同。 CEO： 是英文 Chief Executive Officer 的缩写，指首席执行官，是在一个企业中负责日常事务的最高行政官员，又称作行政总裁、总经理或最高执行长 COO： 是英文 Chief Operating Officer 的缩写，指首席运营官，主要是负责公司的日常营运，辅助CEO的工作。对CEO负责，负责企业的运营管理。COO在某些公司中同时任职 总裁 ，但他们通常是常务或资深的副总裁。 CFO： 是英文 Chief Finance Officer 的缩写，指首席财务官，CFO是绝对的二号人物，对公司上市全权负责，对公司长远发展的了解，和对公司整体战略的把握，都要远超其他C级人物。再者，很多时候CFO是董事会直接委派的，有间接地监督CEO和管理团队的职责，所以CFO地位绝对超然。 VP： 是英文 Vice President 的缩写，指副总裁，副总裁是总裁的助手，受总裁委托分管公司日常经营管理工作，对总裁负责，并在副总裁职责范围内签发有关业务文件，总裁因故不能履行职务时，副总裁受总裁委托代行总裁的职权。 HRD： 是英文 Human Resource Director 的缩写，指人力资源总监，人力资源总监要从战略高度努力构建高效实用的人力资源管理系统，成功进行人才选拔，建立科学的考核与激励机制，最大限度地激发人才潜能，创建优秀团队，塑造卓越的企业文化，推动组织变革与创新，最终实现组织的持续发展。 HRM： 是英文 Human Resource Manager 的缩写，指人力资源经理，分管组织管理、人事信息管理、招聘管理、培训管理、绩效管理、福利管理、工资管理等全部或部分职责。 HRBP：是英文 Human Resource BUSINESS PARTNER 的缩写，指人力资源业务合作伙伴，实际上就是企业派驻到各个业务部门或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。 MD： 是英文 Marketing Director 的缩写，指市场总监，企业中负责市场运营工作的高级管理人员，主要负责在企业中对营销思想进行定位；把握市场机会，制定市场营销战略和实施计划，完成企业的营销目标；协调企业内外部关系，对企业市场营销战略计划的执行进行监督和控制；负责企业营销组织建设与激励工作。  以上列出的是公司各大部门的管理层职位（可能不全），下面我们来看一下职级：\n   职级名称 英文 职级名称 英文       总裁 CEO/GM   首席科学家 Chief Scientific Officer 副总裁 VP   研究员 Researcher Engineer 总监 Director   专家 Proficient Engineer 经理 Manager   高级工程师 Senior Engineer 主管 Header/Leader   中级工程师 Middle Engineer     初级工程师 Junior Engineer      以上信息仅是自己简单的个人理解，实际公司中职级分的可能更细，并且会设有类似于Senior Management Engineer这样的研发管理职位，总之，本篇文章仅为科普，如有幸更专业的人士看到此帖子，欢迎指正。\n常见职级职位英文缩写    缩写 英文 中文     PL Project Leader 项目负责人   FAE Field Application Engineer 现场技术支持工程师/售前售后服务工程师    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":44,"section":"docs","tags":["职级与英文缩写"],"title":"你应该知道的职级与英文缩写","uri":"https://www.wenhui.space/docs/polular_science/rank_and_abbreviation/"},{"content":"本文 主要介绍本人使用形式化验证的一些经验总结。\n   版本 说明     0.1 初版发布    背景  验证工具： Cadence 公司的 JasperGold  写在前头 形式化验证是一种验证方法，而实际应用方向主要有两方面，一是综合前后的等价性检查，二是RTL设计的功能验证。本文所讲的是形式化验证方法在RTL设计功能验证方向的应用。\n模拟仿真验证和形式化验证 芯片验证的两个方法，一个是模拟仿真验证，另一个是形式化验证。\n模拟仿真验证是目前最主流的验证方法，主要是以 UVM 为代表的验证方法学，特点就是搭建模拟仿真环境，通过随机化激励进行模拟仿真，reference module作为验证标准进行结果数据的check，以收集覆盖率的方式作为验证进度的参考，当代码覆盖率和功能点覆盖率达到100%时，做到sign off。由此看来，模拟仿真的优点就是基本不受设计复杂度的影响，而缺点就是验证环境搭建较复杂，测试激励手动添加，收集覆盖率周期较长，尤其是Corner场景的覆盖很让人头疼。\n形式化验证从某层面看似乎让人省心。形式化方法简单的说就是用数学工具进行定义、开发和验证，它会对设计电路进行数学建模，然后穷举系统运行过程中电路所能达到的所有状态，以断言的形式完成设计电路的功能验证和规则检查（也可以通过reference model的形式，做结果数据的check）。听起来似乎完美，但是这要依赖强大的运算系统和EDA工具，否则会发生状态爆炸问题，长时间无法得出证明结果。以目前的形式化验证工具来看，还不足以吃进一个超复杂的设计电路，来完全替代模拟仿真的验证方法。\n所以，在芯片的验证中，随机仿真验证和形式化验证往往是相辅相成，一个更适合系统级功能验证，一个更适合模块级的功能验证。除此之外，还有FPGA的硬件加速测试，这三种验证手段可谓是三位一体，相辅相成。\n什么是形式化验证 个人认为，形式化验证是基于严格的数学算法和模型，根据设计功能提取电路规则的属性描述，并穷举系统运行过程中电路所能达到的所有状态，自动进行数学分析和证明。验证过程如下：\n  形式化验证示例    以上的形式化验证过程就像做一道数学证明题，用数学方法证明该命题是否成立，而这个证明过程是验证工具完成的，工程师不需要关心。目前，业界主流的形式化验证工具主要有Cadence的 JasperGold 和 Synposys 的 VC-Formal。\nSVA语法 形式化验证使用的是 SVA (SystemVerilog Assertion) 语言，属于SV的一部分，下面对SVA基本的使用语法进行说明。\nSVA的语法主要分为三种使用类型：assume、assert、cover。使用的基本规则为，先描述一个property，然后为property设置为assume或assert或cover，命名时习惯性将property名字添加“P_”前缀，将assume名字添加“ASM_”前缀，将assert名字添加“AST_”前缀，将cover名字添加“COV_”前缀。注：建议所有属性带时钟沿触发条件。\nAssume Assum即假定之意，也就是假定某些信号符合某规则特性，最常见的就是给输入信号添加约束，下面对assume语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty ASM_property_name: assume property (P_property_name);    精简写法   1  ASM_property_name: assume property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   Assert Assert即断言之意，也就是认为某些信号符合某规则特性，出现反例则报错，最常见的就是给关键信号依据特定属性设置断言，来进行特性检查，下面对assert语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty AST_property_name: assert property (P_property_name);    精简写法   1  AST_property_name: assert property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   Cover cover即覆盖之意，也就是对某些信号的某规则特性进行采样，反馈是否覆盖该特性，下面对cover语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty COV_property_name: cover property (P_property_name);    精简写法   1  COV_property_name: cov property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   JasperGold的使用 本文使用的形式化验证工具是JasperGold，其常用的使用方法有两种类型，一个是SEC，对模块功能做对等性检查，另一个是FPV，基于规则特性的功能验证。这里只对FPV进行介绍，也就是 Formal Property Verifycation。\n验证环境       FPV_project_name：整个FPV的验证环境。 Report：用来存放验证报告。 Source：整个FPV环境的文件源。 FPV_project_name.tcl：FPV验证环境的启动脚本。 Design：文件源中的设计文件，也可以不存放设计文件，而由design.flist指定设计文件。 Property：文件源中的验证文件（SVA），提取设计文件的属性。 Refer_model：此文件为参考模型文件，根据需求创建，非必须。  启动脚本  设置环境变量   1 2 3  set FPV_ROOT /FPV_project_path set DES_PATH $FPV_ROOT/source/design set PRO_PATH $FPV_ROOT/source/property    设置功能点收集选项   1 2  set_capture_elaborated_design on check_cov –init –exclude_bind_hierarchies –enable_prove_based_proff_core    编译设计文件 (注：v2k指IEEE 2001 标准)   1  analyze -v2k –f $DES_PATH/design.flist    编译验证文件   1  analyze –sva –f $PRO_PATH/property.flist    设置顶层   1  elaborate –top top_module_name    设置时钟和复位 (注：如果复位是低位有效，则为 ~reset_signal_name)   1 2  clock clock_signal_name reset reset_signal_name    设置最长验证时间   1  set_prove_time_limit 24h    启动验证   1  prove -all    生成报告   1  report –summary –force –result –file “report/FPV_project_name.rpt”    其他  以上只说明了基本设置，其他详细设置可参考手册或JasperGold的Tcl Command Help。\n启动命令 启动验证环境很简单，验证流程主要依靠启动脚本的设置，而验证环境的启动只需在终端敲下启动命令即可，如下：\n1  jg FPV_project_name.tcl   关于形式化验证的个人总结 什么样的设计适合用形式化验证  规模较小：设计模块太大对应验证复杂度较高，导致验证时间过长。 功能独立：功能独立的设计更容易提取规则属性。 时序较短：时序较长会导致验证复杂度增大，验证时间指数增长。 接口清晰：接口清晰便于对输入添加约束，避免非法输入影响验证结果。  形式化验证中影响验证时间的因素  设计复杂度：设计复杂度高，肯定验证时间长，这也是为什么形式化验证不适合大的设计模块。 时序较长：形式化验证是所有状态的全遍历，时序每增加一个cycle，所增加的遍历空间并非只是此cycle，还包括此cycle与前几个cycle的状态组合，换句话说，时序增加，遍历空间指数增长。 设计中存在时序控制：比如advance_pipeline对pipeline进行使能控制的此类信号，以及所有影响流水线不能依次脉动流出的控制信号。 设置的特性检查：设置的特性检查越多越复杂，对应的验证时间越长，如果以reference model形式进行数据结果check，所需验证时间最长，但是若只提取设计特性又很难做到signoff标准。  形式化验证不能验证完全是不是就无任何作用 当然不是！\n 形式化验证工具进行了语法检查，可确定设计逻辑语法无误。 形式化验证工具进行了部分特性检查，可确定已验证的特性符合设计规则。  换句话说，形式化验证不能验证完全，虽然不能做到sign off，但是可以将前期暴露的语法bug和设计bug进行修复，最终验证不完全，无非表明我不一定是对的，但也没找到我的错误，说明设计代码已经达到一定成熟度。\n形式化验证工具的其他用途  完成设计不加任何特性检查，直接启动形式化验证工具，可将暴露的语法错误和警告修复，提高设计代码质量。当然反过来，验证人员可先启动形式化验证工具，将暴露的语法错误和警告提单给设计人员。 设计时对于显而易见的规则特性边设计边记录，待设计交付验证人员时，可先启动形式化验证，修复前期bug，提高设计代码质量。 模拟仿真中收集覆盖率，对于较难收到的功能点可利用形式化验证工具去设置cover，辅助模拟仿真创建定向用例。这里提两点，一是需要确定输入的场景作为输入约束，二是无需保证形式化验证的正确性，因为只是提取测试激励，正确性由模拟仿真保证。  复杂设计如何完成验证 复杂的设计验证时间通常较长，不容易完成验证，但是，依据设计的特性，也是可以通过一些手段完成验证，下面以典型设计举例。\n设计结构      此设计有以下几个特点：  设计中stage1输入，stage5输出，中间需寄存四拍。 设计中分为流水线控制信号、数据信号和控制信号、组合逻辑三个部分，流水线控制信号带复位。 设计中为单向流动，无bypass，也就是流水线前后独立，无反馈。 设计中带advance_pipeline，流水线的使能控制，也就是流水线可能锁定n拍后重新启动。 设计中模块支持多功能类型，也就是op_type。  复杂设计的形式化验证方案  依据功能类型，分类验证，各个功能依次验证。 约束输入，单功能验证仅提交一次，运算数据由工具遍历，验证功能正确性。 除流水线控制寄存器之外，其他寄存器不加复位，工具会将其初始值进行遍历，可等效为激励输入前模块的任何状态。 凡是影响流水线行进的输入，全部添加约束，可以约束停顿周期为1~2，或直接约束为无停顿，暂不验证流水线控制功能。 数据check语法采用单比特，如“data_a[3:0]==data_b[3:0]”改为“data_a[3]==data_b[3], data_a[2]==data_b[2] ……”，前者遍历空间是2^4，后者遍历空间2*4。 对流水线控制功能的验证，在其算法功能验证的正确基础上，将数据进行适当约束，减少遍历空间，主要验证流水线控制功能。 其他手段有待后续补充。  其他减少状态空间的方法  抽象模型：如fifo或其他存储类模块，设计本身主要验证的是控制逻辑，从而可以减少存储单元来针对设计完成抽象模型，可以有效的减少状态空间。 黑盒化：将不关心的设计设置黑盒，可以有效的减少状态空间 断点：待了解  以上方法还未在实际工程中使用过，待后续总结\n推荐书籍  《SystemVerilog Assertion应用指南》 《Formal Verification: An ESSential Toolkit For Modern VLSI Design》 以及其他EDA厂商提供的使用手册和培训资料（如哪位读者有此类资料，感谢分享）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":45,"section":"docs","tags":["Formal"],"title":"Formal验证技术总结","uri":"https://www.wenhui.space/docs/digital_verifer/creation/formal_verify/"},{"content":"本文 主要对日常linux系统中一些工具的安装过程进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  安装tree命令 tree命令在deepin系统中没有自带，需要手动安装，此命令可以通过代码显示方式列出文件结构，在有些编写文档需对文件结构进行描述时很有用（如何使用可以通过man tree查看），安装命令如下：\n1  sudo apt install tree   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":46,"section":"docs","tags":null,"title":"Linux安装工具记录","uri":"https://www.wenhui.space/docs/about_linux/use_notes/linux_tools_notes/"},{"content":"本文 主要介绍一个破解版的谷歌访问助手工具。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 google版本： 78.0.3904.97（正式版本） （64 位）  谷歌访问助手能做什么  解决chrome扩展程序无法自动更新的问题 可以访问google搜索、gmail邮箱和google+  下载  进入github网址进行下载 我的百度网盘分享资源 链接：https://pan.baidu.com/s/1nVTXRinSBhOz17C23ytM7w 密码：j0lt  使用  打开google浏览器（Windows和Linux均支持） 点击功能栏右侧三个点，选择设置，打开设置页面 选择扩展程序，进入扩展程序页面 打开 开发者模式 ，选择 加载已解压的扩展程序包 ，选择刚刚下载的压缩包解压后的文件夹 可以开始访问了（该插件通过代理服务器访问Google，代理服务器的地址和密码以及PAC脚本均由插件动态获取。研究发现，即使将PAC脚本替换掉，依然只能访问Google和GMail，其余网站无法打开，表明服务器端已进行了限制。）    谷歌访问助手页面    注意 该插件是在使用网络代理访问外网，建议仅在安装扩展程序以及google查资料时使用，尽量不要长时间访问外网。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":47,"section":"docs","tags":["google"],"title":"最简单易用的谷歌访问助手","uri":"https://www.wenhui.space/docs/install_software/google_assistant/"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第一篇，主要介绍芯片开发概述、验证任务和目标、验证职业前景、验证周期。\n   版本 说明     0.1 初版发布    参考  《芯片验证漫游指南》，也就是所谓的红宝书。 路科验证。  概览      芯片开发概述 芯片开发流程  市场调研和客户需求。 项目立项。 架构师按照芯片功能划分子系统。 子系统划分为功能模块，设计工程师完成逻辑设计。 验证工程师对设计功能进行验证，发现bug并提交给设计工程师修正，如此迭代，直至无bug。 验证收敛无bug后，后端工程师综合、布局、布线。 后端工程师将核心数据交FAB厂商进行流片。  验证和设计的关系  设计如果没有经过充分验证、量化验证，无法保证流片的成功。 验证工程师要懂设计，否则无法更好的发现和定位bug，更无法与设计工程师好好沟通。 设计工程师要懂验证，否则无法体会验证逐渐趋向于软件化。 设计工程师要验证尽早尽快尽量的发现设计bug，越到后期修正设计bug的代价越大，首先设计的修改可能牵一发而动全身，修正后需要完整的回归测试，甚至后端重新综合布局布线。 设计工程师和验证工程师围绕功能描述文档展开工作。 设计初步完成时验证就要启动，甚至更早启动。 发现验证结果与预期不符，明显bug可提交给设计工程师，若无法判定，需要与设计工程师依据功能描述文档进行沟通，统一对功能的理解。 设计从底层模块向系统集成过程中，验证与设计要各自开展工作，验证要保证每一个层次验证的充分性和完备性。  验证的三个方向  设计功能是否符合功能描述文档？ 设计工程师是否有遗漏的边界场景？ 设计是否足够稳定来处理错误场景？  验证的挑战  如何穷尽所有场景为设计产生激励？  划分有效的测试空间。 给出随机约束激励。   如何发现和判断设计的bug？  根据不同类型设计提供相应的测试激励，选择相应的比对方法。 根据不同类型设计选择相应的验证工具，仿真验证和形式验证。 根据复杂度不同，选择黑盒验证、白盒验证以及灰盒验证。    验证职业前景  目前工作中设计与验证同等重要。 验证需求量大，与设计的比例接近2:1。 学习和掌握验证知识，对后期从事设计或验证都有帮助。 公司研发团队越正规化，对验证的规范性越重视。 验证工作越来越趋向软件化，知识迭代比设计快，更富有挑战性。 验证的充分性和完备性，才能保证高质量流片。  验证的目标 按时：  验证工程师需要按照项目的预期进度来考虑验证节点。 协调安排各模块验证工作进度，任何一个模块验证的延迟都会影响整体验证进度。 团队协作，所有验证工程师都要有时间节点观念。  保质：  尽可能保证验证的充分性和完备性，减少硅后bug的出现。 bug出现的阶段越到后期，代价越大。 提前做好验证计划，设计与验证定期沟通，保证验证计划的充分性和完备性。  低耗：  人力和时间成本低耗，保证工作的高效率。 资金成本低耗，尽早保证验证的充分性，防止bug出现在硅后甚至客户端，就是在保证资金成本低耗。  验证的周期 验证流程  创建验证计划：参照设计人员提供的设计功能描述文档创建验证计划，并且与设计工程师完成多次review，确保验证计划无明显缺陷。 搭建验证环境：验证工程师搭建验证环境平台，准备测试激励。 模拟仿真和debug：开始跑测试激励，进行验证环境和设计电路的debug（如果是环境问题择优化环境，设计问题定位具体bug，提交给设计人员）。 回归测试：当设计电路通过了一定量的测试激励，验证人员需要准备回归测试，也就是将已有的所有测试通过的用例重新测试一遍。 验证代码检查：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等。 收集覆盖率：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标。 完备性检查：此项任务由验证项目经理完成，主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押。 硅后测试：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训。  review节点  验证计划review： 设计工程师与验证工程师依据功能描述文档沟通，检查验证计划，确保无明显遗漏和功能偏差。 验证代码review： 回归测试前，设计工程师与验证工程师对验证代码进行review，检查是否有遗漏的测试用例、不恰当的随机约束等。 覆盖率review： 回归测试后，对当前覆盖率进行review，确保验证的完备性。 验证总结review： 其一是分析bug逃逸，总结经验，吸取教训；其二是验证流程、工具使用、团队协作等经验总结。  功能描述文档  接口信息： 描述接口信号的时序信息和数据传输信息等。 结构信息： 描述模块的逻辑结构，包含各个功能组件，以及各个功能组件的逻辑关系。 交互信息： 描述模块与其他模块的交互信息，包括逻辑示意图和时序信息，确保集成后模块间按照预期功能完成交互。  验证计划  验证方法： 定向验证、随机约束验证、形式化验证等。 验证工具： 选择需要的验证工具来支持验证方法，如VCS、XRUN、JasperGold等。 验证完备性： 量化一些参数（功能点覆盖率、代码覆盖率、断言覆盖率）可以衡量验证任务是否完成。 验证资源和进度： 人力、时间、硬件、软件等预算。 验证功能点： 流出验证功能点，以及明确在什么层次去验证它，甚至选择何种激励去验证它。  开发验证环境  搭建环境，实现激励产生、参考模型和数据比较。 不同的验证方法，验证环境的结构和使用软件不同。 随着bug的发现和修正，设计趋于稳定，验证环境保持更新，补充测试用例。 添加covergroup或assert，使环境支持覆盖率收集。  debug  环境是否存在bug。 测试激励是否合理。 参考模型是否遵循设计功能描述文档。 硬件设计是否存在bug。  回归测试  确保改动没有引入新的bug。 随机种子不同，测试激励不同，有利于收集覆盖率，往复的回归测试和补充的定向测试，可逐步提供验证的完备性。  芯片流片  经过回归测试（RTL回归和门级网表回归），项目负责人、设计负责人、验证负责人、后端负责人一同回顾整个checklist，确保通过各项指标，交给FAB厂商进行流片。 特别提示： 即便已经交给FAB厂商进行流片，继续保持回归测试，并尽可能创造新的测试激励，覆盖更多状态空间，进一步保证验证的完备性。 如果交给FAB厂商进行流片后发现设计bug，一考虑是否有软件补救办法，二提交设计修改意见，下次流片前准备好设计和验证方案。  硅后测试  流片后系统测试工程师会将芯片植入测试系统或依靠测试开发板，进行硅后测试。 硅前工程师（设计、验证）和硅后工程师保持沟通，出现测试问题，第一时间判断测试问题还是设计bug，以及如何修补。  逃逸分析  验证无法保证设计没有任何bug，而是尽可能发现所有bug。 硅后测试发现bug，设计工程师和验证工程师要和系统测试工程师沟通，尝试在硅前的仿真环境中复现。 逃逸分析后，对下一个芯片周期，设计工程师如何规避设计bug、完善设计经验，验证工程师如何完善验证方案、如何产生更多有效测试激励都是很有意义的。也就是总结经验、吸取教训  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":48,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（一）","uri":"https://www.wenhui.space/docs/digital_verifer/beginner_verification/beginner_verification_one/"},{"content":"本文 主要介绍芯片验证工程师的成长之路，包括职位概述、技术入门、能力提升和角色转换。\n写在前头，本文内容是根据自己的工作经验和行业了解，以及师兄的经验传授和网络资源，集合而成。并且我还在不断继续努力中。\n   版本 说明     0.1 初版发布   0.2 添加验证流程    背景 本人工作IC设计和IC验证同时涉及，工作领域为CPU相关，经验三年。\n参考  路科验证  芯片验证职位概述  以往设计地位高于验证，随着芯片复杂度越来越高，流片成本越来越大，目前芯片验证地位与设计同样重要 验证的岗位需求量大，与设计的比例接近2:1 了解验证知识对于将来从事芯片设计也有很大帮助 公司越规模化，团队越正规化，对芯片验证的规范性和重要性就越突出 芯片验证相对设计，更讲究团队协作 芯片验证软件化，工具和语言等知识迭代快（目前相对稳定，统一使用sv语言和UVM方法学），需要不断学习 芯片验证也要懂设计代码，否则无法更好的完成芯片验证 芯片验证不仅限于发现设计bug，还包括对设计的理解以及提出修改意见  芯片验证的技术入门 芯片验证相对于芯片设计，技术门槛较低，但要学习的知识宽度要大于芯片设计。所谓技术门槛低，换句话说也就是即便你对项目领域（如射频、通信、CPU等）完全不通，但并不妨碍你做基础的验证工作。以下是个人认为芯片验证工程师入门需具备的基础：\n 基本的数字电路知识 systemverilog语言和UVM验证方法学 RTL硬件描述语言，如verilog 芯片设计项目的了解（对于前期入门阶段并不是硬性要求） 基础的脚本语言，如Makefile、shell  芯片验证工程师与FPGA验证工程师、芯片设计工程师、软件测试工程师的比较 芯片验证工程师与FPGA验证工程师  FPGA验证是更高层次的黑盒验证 FPAG验证相对于模拟仿真，缺点是难以调试IC设计的内部信号，难以深入debug FPGA验证相对于模拟仿真，优点是仿真速度快，可模拟芯片真实环境，发现隐藏bug FPGA验证工程师的技能更多是工具的使用，看到的IC设计更上层（一般IC设计完整度较高时才会上FPGA平台）  芯片验证工程师与芯片设计工程师  芯片设计工程师更加硬件化，只需verilog语言，但重点在于对设计领域的深刻理解和项目经验 芯片设计工程师对芯片验证领域无需了解太多，而验证工程师也需要对设计有一定了解 芯片验证工程师往往有机会转型到设计，debug过程对设计逐步了解，并且有时候需要给出修改意见 芯片验证工程师不仅与设计工程师协作紧密，与后端和软件工程师有时也有交互 芯片设计工程师关注的是功能结构如何转换为电路实现，芯片验证工程师关注的是电路层次是否符合功能场景 芯片设计工程师学习深度更深，芯片验证工程师学习广度更广，换句话说，验证工程师相对于设计工程师更容易转行（指项目领域，如射频、通信、CPU） 芯片设计门槛高于芯片验证，需要更强的项目领域相关背景知识（一般要求重点学校硕士学历）  芯片验证工程师与软件测试工程师 芯片验证与软件测试，对于非芯片领域或刚毕业的学生，是很容易产生误会的。\n 所处芯片开发阶段不同，芯片验证在流片前，软件测试在流片后（不仅限于流片后） 软件测试纯软件化，看不到或不关心电路结构 软件测试与软件设计的薪资差异，远远大于芯片验证和芯片设计的薪资差异，普遍来讲（排除技术大牛），芯片验证薪资往往高于软件测试（这也是为什么产生误会的原因）  芯片验证工程师的能力提升  深入学习设计领域知识和IC设计架构（对于IP验证及其重要） 深刻学习理解SV语言，可以学习与SV类似的面向对象编程语言，帮助对SV语言特性的理解 深刻学习理解UVM验证方法学，可以从软件的设计模式深入理解 优化代码结构和项目层次，增强可复用性，增强集成度和自动化 多平台验证工具的使用，如formal、FPGA等，对于覆盖率收敛很重要 脚本语言，如shell、Makefile、Python、Tcl、Perl等，掌握脚本语言是使验证平台自动化的基础 虚拟建模和VIP的开发，可增加验证效率，并且可复用性强 制定和优化验证流程，验证计划的制定和实现，验证进程评估 验证管理，包括时间和人力，以及任务安排  芯片验证工程师的角色转换 一个芯片验证工程师经历五到七年的技术积累，此时工作任务得心应手（或者说固化），往往会产生工作倦怠的态度，对于新工具和新知识的学习也不再渴望，这时候需要考虑角色的转换。\n 承担全新设计模块的验证，比如对于CPU项目，可以从DPU模块验证转为LSU模块验证 转为芯片设计，从事不同的工作内容 专职做验证平台优化，学习或自研更好的验证工具和验证方法，提高验证效率（前提是公司同意） 做技术培训者 做验证技术专家或验证管理（前提是能力出众，一般工作十年经验） 离职（需慎重，芯片行业大公司不多，跳一个少一个）  芯片验证工程师的职业规划（也是写给自己）  一年时间，完成芯片验证工程师的入门 三年时间，从初级芯片验证工程师到独立承担模块验证 三年时间，从独立承担模块验证到验证leader（也有可能转向芯片设计） N年时间，从验证人员到验证主管（或技术专家）  验证流程  创建验证计划：参照设计人员提供的设计功能描述文档创建验证计划，并且与设计工程师完成多次review，确保验证计划无明显缺陷 搭建验证环境：验证工程师搭建验证环境平台，准备测试激励 模拟仿真和debug：开始跑测试激励，进行验证环境和设计电路的debug（如果是环境问题择优化环境，设计问题定位具体bug，提交给设计人员） 回归测试：当设计电路通过了一定量的测试激励，验证人员需要准备回归测试，也就是将已有的所有测试通过的用例重新测试一遍 验证代码检查：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等 收集覆盖率：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标 完备性检查：此项任务由验证项目经理完成，主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押 硅后测试：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训  除了技术，我们还需要做什么？ 虽然我们是技术从业者，但是毕竟人的社会是复杂的，那么除了技术，我们还需要做什么？\n 提高团队合作性，让更多的人乐于和自己合作，是对自己人品和性格的最好肯定 提高行业敏锐度，多关心了解行业领域的一些事情，相信我这样是有好处的 跟对一个好领导，作为领导的主要干将，相信我这样是有好处的 保持好同事和前同事的联系，相信我这样是有好处的  顺便，对于新入职的毕业生，教你如何快速与同事和领导建立起社交关系，那就从吃食堂开始。\n书单 基础  《SystemVerilog验证》 《UVM实战》 《芯片漫游指南：从系统理论到UVM的验证全视界》 《全面的功能验证：完整的工业流程》 《Verilog与SystemVerilog的编程陷阱》 《综合与时序分析的设计约束：Synopsys设计约束（SDC）实用指南》  提升  《设计模式：可复用面向对象软件的基础》 《敏捷软件开发：原则、模式与实践》 《代码大全》 《代码阅读》 《重构：改善既有代码的设计》 《改善程序与设计的55个具体做法》  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":49,"section":"docs","tags":null,"title":"芯片验证工程师","uri":"https://www.wenhui.space/docs/digital_verifer/creation/digital_verifer/"},{"content":"本文 主要介绍对word编辑文档的一些建议。\n   版本 说明     0.1 初版发布    背景 本篇文章参考自王老师。\n写在前面 出于各方面原因，我们编辑文档时，主要还是使用微软的office工具word。word不敢说是最好的文档编辑工具，但是功能最强，使用最广的文档编辑工具，而我们在使用word编辑文档时，是否有好好利用了其强大的功能呢？这是一个值得思考的问题。\n我们在编辑文档时，是在编辑什么？一篇文档包含两方面，一是内容，指文档的表述文字、图表、公式等，二是表现，指文档的表现形式，比如字体字号、页边距页面大小等。那么关于是否有好好利用word强大的功能的思考，答案就有了，如果你编辑文档时，是在编辑内容，而表现形式由word工具完成，那你就好好利用word强大的功能。而往往大多数人在使用word时，还在花费大量的时间在人工排版上。换句话说，word被当做了记事本来使用。\n建议 一定要使用样式 word除了提供已有的标题和正文等样式，还可以自定义样式，也就是说，当你发现自己当前文字使用的格式会多次被使用，那就请定义一个样式吧。建议坚持使用样式，这样不仅可以减少出错和节省时间，而且方便样式替换，以及可以自动生成目录和索引。\n一定使用交叉引用 一定使用交叉引用，不要手敲编号，否则会对你的文档修改维护带来无穷后患。使用交叉引用不仅可以自动更新编号，还可以自动生成图表目录。\n一定不要敲空格来对齐 一般只有英文单词前后才会出现空格，中文文档不会出现空格，对齐应该采用制表符、对齐方式和段落缩进等，而绝不是空格。\n绘图 建议使用visio，如果是统计图建议使用excel生成。（其他visio可替代工具亦可）\n数学公式 建议使用MathType，可集成在word使用，会在word增加一个菜单项，一定要使用MathType的自动编号和引用功能，使用方法参考 MathType在Word中的使用。\n使用节 如果你希望在一篇文档中使用不同的页眉页脚等，可以插入分节符，并设置当前节与上一节格式不相同。\n使用子文档 如果你的文档过于大（几十页），且包含大量图片、公式、表格等，所有内容保存到一个文件里，一是打开、保存文件较慢，二是有破坏和丢失内容的风险。建议对于大文件的编辑，可以将每一章定义为一个子文档，在主文档中定义格式，这样既提高了文件访问速度也降低了破坏和丢失内容的风险。建议在主文档中创建子文档。\n及时保存 编辑文档时，一定要多按Ctrl+s，及时保存。\n多做备份 对编辑的文档多做版本备份。不仅word不可靠，windows也不可靠，越是重要的、工作量大的文档，越要多做备份。\n另存图片、表格和公式 文档中一张好图胜过千言，而一张好图所需的时间也不只于千言，所以对于文档中的图片、表格和公式，最好另存到其他文件夹，防止以后因为工具、格式或其他问题，导致文档中的图片、表格和格式无法正常显示，到时候哭都来不及。\n使用大纲视图 使用大纲视图，可以方便调整章节顺序。\n使用文档导航窗口 使用文档导航窗口可以方便的对文档定位。\n使用文档保护 使用文档保护可以方便对文档审阅和修改。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":50,"section":"docs","tags":["Office"],"title":"关于word编辑文档的一些建议","uri":"https://www.wenhui.space/docs/about_windows/some_advices_of_word/"},{"content":"本文 主要介绍用emacs auto-insert命令实现用模板文件创建新文件。\n   版本 说明     0.1 初版发布   0.2 添加两个函数    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs中那些简化输入的方法\u0026ndash;Autotyping Auto Insert Mode Emacs如何使用文件模板  创建模板文件 在.emacs.d目录下新建文件夹 templates，并创建verilog模板文件 templates.v，内容如下(文件名、路径、内容均可根据个人喜好进行定义，这里只是举例说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module xx(/*AUTOARG*/); /*AUTOWIRE*/ /*AUTOREG*/ endmodule   修改配置文件 我们创建了模板文件，还需要在配置文件中进行配置，打开.emacs或.emacs.d/init.el，添加以下内容(除了verilog文件模板，我还添加了shell等其他模板，不再一一说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;;about template file ;;---------------------------------------------------- (auto-insert-mode) ;; Adds hook to find-files-hook (setq auto-insert-directory \u0026#34;~/.emacs.d/templates/\u0026#34;) (setq auto-insert-query nil) ;; If you don\u0026#39;t want to be prompted before insertion (setq auto-insert-alist (append \u0026#39;((verilog-mode . \u0026#34;template.v\u0026#34;) (python-mode . \u0026#34;template.py\u0026#34;) (c-mode . \u0026#34;template.c\u0026#34;) (shell-mode . \u0026#34;template.sh\u0026#34;) ) auto-insert-alist)) ;;----------------------------------------------------   添加两个函数 插入当前时间 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前时间时， M-x now 即可。\n1 2 3 4 5  (defvar current-date-time-format \u0026#34;%Y/%m/%d %H:%S\u0026#34;) (defun now () (interactive) (insert (format-time-string current-date-time-format (current-time))) )   插入当前文件名 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前文件名时， M-x name 即可。\n1 2 3 4  (defun name () (interactive) (insert (file-name-nondirectory buffer-file-name)) )   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":51,"section":"docs","tags":["emacs","verilog"],"title":"emacs 中使用模板文件","uri":"https://www.wenhui.space/docs/about_emacs/emacs_auto_insert/"},{"content":"本文 主要介绍如何使用 Verilog-Perl 脚本对verilog代码进行神奇操作。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3 Verilog-Perl版本：Verilog-Perl-3.468  参考  Verilog-Perl使用手册  安装verilog-perl 下载  Verilog-Perl主页 我的百度网盘分享资源(Verilog-Perl-3.468) 链接：https://pan.baidu.com/s/18cqcuv3MwtlGheuy2wWl8g 密码：73wd 也可以直接使用我安装后的可执行程序，百度网盘分享资源 链接：https://pan.baidu.com/s/1w1AykoGr0AFmfnoar87FRQ 密码：9nzf  安装 安装过程中，发现有依赖错误，先下载依赖文件(我也并不知道这些依赖有何作用，无非就是报出了依赖错误，乖乖安装罢了)：\n1 2 3 4  sudo apt install flex sudo apt install bison sudo apt install g++ sudo apt install gcc   接下来进行安装(详情可查看安装包中RENAME)：\n1 2 3 4  perl Makefile.PL make make test sudo make install   vrename的使用 使用场景 vrename的使用主要有两个场景：\n 一是同一文件，修改某信号名称，不用一一修改，通过vrename即可完成全部信号名的修改（好像查找替换也行，不过修改信号名较多时，vrename还是方便一些） 二是交互文件，子模块与顶层模块间的实例化，此时修改信号就需要在不同的文件里修改或查找替换，当需要修改的信号较多时，就会繁杂且易出错，此时vrename将信号统一到一个文件里，修改此文件后使用vrename \u0026ndash;change即可完成修改，方便快捷。  使用方法 vrename可以比较方便的从多个文件中为信号和模块重命名。操作过程分为两步：\n 读取文件，你将会得到 signals.vrename 文件，其中包含了所有信号的列表。   1  vrename --list file1.v file2.v file3.v ...    可以编辑此文件，修改信号名，然后在运行第如下命令，就可以把新的信号名应用到源文件上了。   1  vrename --change file1.v file2.v file3.v ...   展示 signals.vrename 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Generated by vrename on Fri Jan 3 16:56:31 2020 # # Files read for this analysis: vfile\t\u0026#34;testbench.v\u0026#34; vfile\t\u0026#34;dut.v\u0026#34; # #\tOriginal Signal Name\tName to change to #\t--------------------\t----------------- # sigren\t\u0026#34;clk\u0026#34;\t\u0026#34;clk\u0026#34; sigren\t\u0026#34;din0\u0026#34;\t\u0026#34;din0\u0026#34; sigren\t\u0026#34;din1\u0026#34;\t\u0026#34;din1\u0026#34; sigren\t\u0026#34;din2\u0026#34;\t\u0026#34;din2\u0026#34; sigren\t\u0026#34;dout\u0026#34;\t\u0026#34;dout\u0026#34; sigren\t\u0026#34;dout_a\u0026#34;\t\u0026#34;dout_a\u0026#34; sigren\t\u0026#34;dout_b\u0026#34;\t\u0026#34;dout_b\u0026#34; sigren\t\u0026#34;dout_c\u0026#34;\t\u0026#34;dout_c\u0026#34; sigren\t\u0026#34;dout_x\u0026#34;\t\u0026#34;dout_x\u0026#34; sigren\t\u0026#34;dout_y\u0026#34;\t\u0026#34;dout_y\u0026#34; sigren\t\u0026#34;dout_z\u0026#34;\t\u0026#34;dout_z\u0026#34; sigren\t\u0026#34;dut\u0026#34;\t\u0026#34;dut\u0026#34; sigren\t\u0026#34;i_dut\u0026#34;\t\u0026#34;i_dut\u0026#34; sigren\t\u0026#34;rst_n\u0026#34;\t\u0026#34;rst_n\u0026#34; sigren\t\u0026#34;sig1\u0026#34;\t\u0026#34;sig1\u0026#34; sigren\t\u0026#34;testbench\u0026#34;\t\u0026#34;testbench\u0026#34; # # Use M-x compile in emacs to automatically perform the changes: ## Local Variables: *** ## compile-command: \u0026#34;./vrename -change testbench.v dut.v \u0026#34; *** ## End: ***   多目录问题的解决 如果文件分布到不同目录里，可以创建新的工作目录，并将源文件复制软链接至工作目录，此时就可以操作了。不过，vrename并不建议一次打开太多文件，以免信号过多。\nvhire的使用 待补充，如有使用者，欢迎传授使用技巧。\nvpassert的使用 待补充，如有使用者，欢迎传授使用技巧。\nvsplitmodule的使用 待补充，如有使用者，欢迎传授使用技巧。\nvppreproc的使用 待补充，如有使用者，欢迎传授使用技巧。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":52,"section":"docs","tags":["emacs","verilog"],"title":"Emacs Verilog Perl 的使用","uri":"https://www.wenhui.space/docs/about_emacs/verilog_perl_useguide/"},{"content":"本文 主要介绍使用emacs verilog-mode 编辑verilog的神奇操作。\n   版本 说明     0.1 初版发布   0.2 添加快捷键插入内容    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  verilog-mode  什么是verilog mode verilog-mode是Emacs的一种编辑模式，主要面对verilog的开发环境，拥有很方便的自动缩进机制和AUTO机制。AUTO机制是Emacs verilog-mode中一些自动化实现的脚本功能，比如自动填充模块参数列表、自动完成模块例化、自动声明连线等等。\n为什么使用verilog-mode verilog语法中有很多内容是冗余的，模块中必须出现却起不到什么功能作用，列举如下：\n 模块参数列表和模块端口声明input/output reg语句和已经声明为输出的信号 子模块实例化的连线声明 子模块的实例化语句和子模块的端口声明 组合逻辑always语句的敏感信号表（不过已经可以使用*来代替了）  可见verilog语法中的垃圾信息还是不少的，不过这是语法规则导致的，是语言本身的缺陷，作为使用者只能遵守语法规则。这些冗余信息中比如参数列表和模块例化连线，不仅需要花费时间去编写，而且还特别容易出错，给RTL编写以及后续的修改维护都带来很多问题。那么如果解决这些问题，会带来什么效果呢？个人认为有以下几点：\n 代码整洁，便于阅读 提高编码效率，尤其是顶层实例化 减少拼写错误 便于维护，比如修改、增加和删除端口，无需修改参数列表，比如修改、增加和删除子模块端口，无需修改顶层实例化  AUTO机制的使用 Emacs verilog-mode的AUTO机制，就是在代码中相应的位置写一些/*AUTO*/类似的注释，verilog-mode可以自动替换为所需的内容。Emacs编辑器和verilog-mode的AUTO机制结合，可以很方便的看到AUTO的效果，而且AUTO是以注释形式添加到verilog文件，在语法上本身是合法的，不会影响EDA工具的使用。举例如下：\n 原代码  top module     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  module top_md(/*AUTOARG*/); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ /*AUTOWIRE*/ wire din_a; wire din_b; always@(/*AUTOSENSE*/) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md    sub_module   1 2 3 4 5 6 7 8 9  module sub_md(/*AUTOARG*/); input din_a; input din_b; output [1:0] dout_a; wire [1:0] dout_a; assign dout_a[1:0] = {din_b,din_a}; endmodule // sub_md    AUTO之后   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  module top_md(/*AUTOARG*/ // Outputs dout1, dout2, // Inputs din1, din2 ); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ // Beginning of automatic regs (for this module\u0026#39;s undeclared outputs) reg dout1; // End of automatics /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire [1:0] dout_a; // From i_sub_md of sub_md.v // End of automatics  wire din_a; wire din_b; always@(/*AUTOSENSE*/din1 or din2) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/ // Outputs  .dout_a (dout_a[1:0]), // Inputs  .din_a (din_a), .din_b (din_b)); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md   使用 AUTOSENSE 自动生成敏感表 在Verilog 2000中，已经对语法做出了简化，比如使用 @(×) 来代替敏感信号列表，但是需要EDA工具的支持。不过现在EDA工具都已经支持verilog 2005了，可以将敏感信号列表直接写为 @(×) 即可，所以 AUTOSENSE 功能可以不使用。\n1 2 3 4  always @ (/*AUTOSENSE*/) begin outin = ina | inb; out = outin; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4  always @ (/*AUTOSENSE*/ina or inb) begin outin = ina | inb; out = outin; end   使用AUTOARG自动生成模块参数表 1 2 3 4  module ex_arg (/*AUTOARG*/); input i; output o; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_arg (/*AUTOARG*/ // Outputs  o, // Inputs  i); input i; output o; endmodule   不支持带 `ifdefs 等条件限制的端口声明，如有此需求，可以将其写在 AUTOARG 之前， AUTOARG 不会对其进行重新声明。不过不建议这种方式，因为在 AUTOINST 中会引入更多的 `ifdefs 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  module ex_arg ( `ifdef need_x_input x, `endif /*AUTOARG*/ // Outputs  o, // Inputs  i); `ifdef need_x_input input x; // This is an optional input, if `need_x_signal is defined `endif ...   使用AUTOINST自动实例化 子模块：\n1 2 3 4 5  module fanout (o,i) input i; output [31:0] o; wire [31:0] o = {32{i}}; endmodule   顶层模块：\n1 2 3 4 5  module ex_inst (o,i) input i; output [31:0] o; fanout fanout (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_inst (o,i) output o; input i; fanout fanout (/*AUTOINST*/ // Outputs  .o (o[31:0]), // Inputs  .i (i)); endmodule   注意，子模块需要与顶层例化模块保存在同一文件目录，否则会索引不到子模块，而且实例化的端口名与子模块的端口名，默认是一致的。一般来讲，提倡实例化的端口名与子模块的端口名一致，这样对综合及维护都会带来好处，但是由于某些原因无法使其一致，那最简单的方法就是在 AUTOINST 之前指定实例化的端口名，所有在 AUTOINST 之前定义的端口不会再次生成，但是你最好加上 //Inputs //Outputs 注释，否则 AUTOWIRE 不知道信号方向。举例如下:\n1 2 3 4 5 6  fanout fanout ( // Inputs  .i (my_i_dont_mess_with_it), /*AUTOINST*/ // Outputs  .o (o[31:0]));   如果你被端口名不一致所困扰，可以参考我的另一篇帖子 Emacs Verilog Perl 的使用中vrename的使用章节。\n使用AUTO_TEMPLATE创建模板 如果一个模块被实例化多次，你可以使用verilog的 generate 语法，也可以使用Emacs verilog-mode的 AUTO_TEMPLATE 和 AUTOINST 。Verilog-mode向上索引最近的模板，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。\n1 2 3 4  /* psm_mas AUTO_TEMPLATE ( .PTL_MAPVALIDX (PTL_MAPVALID[@]), .PTL_BUS (PTL_BUSNEW[]), ); */   TEMPLATE中的模块名称必须与实例中的模块名称相同，并且只需列出每次实例化时名字不同的那些信号就好了。如上文的例子，要遵守此格式（每行只有一个端口，并且以逗号结尾，最后以分号结尾，就像AUTOINST产生的一样）。实际上，最简单的方法是完成一个AUTOINST，并将其修改后复制到AUTO_TEMPLATE。\n1  psm_mas ms2 (/*AUTOINST*/);   AUTO效果：\npsm_mas ms2 (/*AUTOINST*/ // Outputs .INSTDATAOUT (INSTDATAOUT), .PTL_MAPVALIDX (PTL_MAPVALID[2]), // Templated .PTL_BUS (PTL_BUSNEW[3:0]), // Templated .... @ 字符非常有用，他将被实例名的末尾数字代替（不限于1位数字），比如ms2，@替换为2。AUTO机制把模板中的 [] 替换为子模块中该信号真实的字段范围，比如 PTL_BUSNEW[] 替换成了 PTL_BUSNEW[3:0] ，因为子模块中PTL_BUSNEW信号声明就是 [3:0]。这样写的好处就是子模块的修改自动响应到顶层模块。（其实如果端口信号位宽一致，实例化端口也可以不指明位宽字段，不过为了便于维护和减少出错，建议指明位宽字段）\n神奇的 @ 不仅支持数字，还可以支持字母，这需要在模板做以下操作（模板支持正则表达式）：\n1 2 3 4 5 6 7  /* InstModule AUTO_TEMPLATE \u0026#34;_\\([a-z]+\\)\u0026#34; ( .ptl_mapvalidx\t(@_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_@), ); */ InstModule ms2_FOO (/*AUTOINST*/); InstModule ms2_BAR (/*AUTOINST*/);   AUTO效果如下：\n1 2 3 4 5 6 7 8  InstModule ms2_FOO (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(FOO_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_FOO)); InstModule ms2_BAR (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(BAR_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_BAR));   在模板中使用Lisp 在AUTO_TEMPLATE中指定简单的线名称并不能够解决所有需求，尤其是在多个实例化中使用同一信号不同数据位时。因此，Verilog-Mode允许你编写一个程序来进行计算并为实例化端口进行命名，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* InstModule AUTO_TEMPLATE ( .a(in[@\u0026#34;(+ (* 8 @) 7)\u0026#34;:@\u0026#34;(* 8 @)\u0026#34;]), );*/ InstModule u_a0 (/*AUTOINST*/ // Inputs  .a (in[7:0])); // Templated InstModule u_a1 (/*AUTOINST*/ // Inputs  .a (in[15:8])); // Templated InstModule u_a2 (/*AUTOINST*/ // Inputs  .a (in[23:16])); // Templated InstModule u_a3 (/*AUTOINST*/ // Inputs  .a (in[31:24])); // Templated   这里对上述Lisp代码部分解释一下， 也就是 @\u0026quot;(+ (* 8 @) 7)\u0026quot;:@\u0026quot;(* 8 @)\u0026quot; ：\n 基础结构为 @\u0026quot;\u0026quot; 代表@为输入参数，引号内为计算处理 每个括号内容为一步计算，形如 (* 8 @) ，意思是 @参数乘8 (+ (* 8 @) 7) 就是将 (* 8 @) 的结果加7  AUTOINSTPARAM的使用 如何在实例化时自动填充参数列表？AUTOINSTPARAM可以做到，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  module InstModule; parameter PARAM1 = 1; parameter PARAM2 = 2; endmodule module ModnameTest; InstModule #(/*AUTOINSTPARAM*/ // Parameters  .PARAM1 (PARAM1), .PARAM2 (PARAM2)) instName (/*AUTOINST*/ ...);   verilog-mode中如何使用正则表达式 在顶层实例化时，有大量的信号需要重新命名，使用模板的话会增加大量的注释内容，不过往往这些信号命名有特定的规律，我们可以使用正则表达式来处理，下面举几个例子：\n 提取信号中固定位置的数字   1 2 3  .pci_req\\([0-9]+\\)_j (pci_req_jtag_[\\1]), .pci_req12_j (pci_req_jtag_[12]),    删除末尾下划线内容   1 2 3  .\\(.*\\)_j (\\1_[]), .pci_req_j (pci_req[7:0]),    对信号矢量化处理(\\1内容代表提取末尾数字之前的内容，\\2内容代表提取末尾数字)（将@改为\\([0-9]+\\)也是可以的）   1 2 3 4 5 6  .\\(.*[^0-9]\\)@ (\\1[\\2]), .pci_req0 (pci_req[0]), .pci_req1 (pci_req[1]), .pci_req2 (pci_req[2]), .pci_req3 (pci_req[3]),   AUTOWIRE 的使用 顶层实例化时，需要将连线进行声明， AUTOWIRE 可以完成此项任务。 AUTOWIRE 将声明所有子模块输出的连接线。这对于在两个子模块之间互连但未在顶部模块中使用的信号特别有用。\n1 2 3 4 5 6 7 8 9  module top (o,i) output o; input i; /*AUTOWIRE*/ inst inst (/*AUTOINST*/); other other (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module ex_wire (o,i) output o; input i; /*AUTOWIRE*/ // Beginning of automatic wires  wire [31:0] ins2oth; // From inst of inst.v  wire [31:0] oth2ins; // From other of other.v  // End of automatics  inst inst (/*AUTOINST*/ // Outputs  .ins2oth (ins2oth[31:0]), .o (o), // Inputs  .oth2ins (oth2ins[31:0]), .i (i)); other other (/*AUTOINST*/ // Outputs  .oth2ins (oth2ins[31:0]), // Inputs  .ins2oth (ins2oth[31:0]), .i (i)); endmodule   AUTOREG的使用 如果模块输出来自寄存器，则需要将信号声明为寄存器和输出端口。 AUTOREG 将完成输出信号的寄存器声明，并且如果输出来自非寄存器，则不会添加reg声明。\n1 2 3 4 5 6 7 8  module ex_reg (o,i) output o; input i; /*AUTOREG*/ always o = i; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11  module ex_reg (o,i) output o; input i; /*AUTOREG*/ // Beginning of automatic regs  reg o; // End of automatics  always o = i; endmodule   AUTOINPUT、AUTOOUTPUT的使用 在top层中，一般只有子模块的例化，没有任何其他粘合逻辑，这也是最期望的。这时top层通过 AUTOWIRE 声明了子模块的输出连线， AUTOINST 实现了子模块的实例化，其余未声明的信号，就是top模块的输入输出信号，我们可以通过 AUTOINPUT AUTOOUTPUT 完成输入输出信号的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module top_md(/*AUTOARG*/); /*AUTOINPUT*/ /*AUTOOUTPUT*/ /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/); endmodule // top_md  module sub_md(/*AUTOARG*/); input din_a; input [1:0] din_b; output [2:0] dout_a; assign dout_a[2:0] = {din_b,din_a}; endmodule // sub_md   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module top_md(/*AUTOARG*/ // Outputs dout_a, // Inputs din_b, din_a ); /*AUTOINPUT*/ // Beginning of automatic inputs (from unused autoinst inputs) input din_a; // To i_sub_md112 of sub_md.v input [1:0] din_b; // To i_sub_md112 of sub_md.v // End of automatics /*AUTOOUTPUT*/ // Beginning of automatic outputs (from unused autoinst outputs) output [2:0] dout_a; // From i_sub_md112 of sub_md.v // End of automatics  /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/ // Outputs  .dout_a (dout_a[2:0]), // Inputs  .din_a (din_a), .din_b (din_b[1:0])); endmodule // top_md   AUTORESET的使用 寄存器类型的变量往往需要赋初值。描述时序逻辑的always时，最好对复位条件下进行寄存器变量的初始化；描述组合逻辑的always时，最好对寄存器变量赋缺省值，这样不会产生latch。对于多信号的always语句，手动添加不仅费时，而且容易出错，此时我们可以使用 AUTORESET 自动完成。这里默认初始化赋值为0，如需其他值，需要将其手动添加到 AUTORESET 之前，AUTO不会对其重复添加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_a = 1\u0026#39;h0; dout_b = 2\u0026#39;h0; dout_c = 3\u0026#39;h0; // End of automatics if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_x \u0026lt;= 1\u0026#39;h0; dout_y \u0026lt;= 2\u0026#39;h0; dout_z \u0026lt;= 3\u0026#39;h0; // End of automatics end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   注意，要先声明reg， AUTORESET 才会自动加上位宽，如果仍然不能自动将位宽加上，请在.emacs或.emacs.d/init.el文件添加以下设置：\n1  (setq verilog-auto-reset-widths t)   如果对时序逻辑always语句中的复位赋值需要添加延迟，请在.emacs或.emacs.d/init.el文件添加以下设置（注意：#1后必须有空格）：\n1  (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;)   AUTOREGINPUT的使用 在写测试激励时，往往将设计模块（也可以叫dut）作为一个子模块在testbench中进行实例化，这事需要定义一些reg类型的信号，作为dut的输入激励。 AUTOREGINPUT 可以帮你完成此任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  module testbench; /*AUTOREGINPUT*/ initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  module testbench; /*AUTOREGINPUT*/ // Beginning of automatic reg inputs (for undeclared instantiated-module inputs) reg din1; // To i_dut of dut.v reg din2; // To i_dut of dut.v // End of automatics  initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/ // Outputs  .dout (dout), // Inputs  .din1 (din1), .din2 (din2)); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   其他使用技巧 多目录问题（如果文件在同一目录，可忽略） 我们的项目工程会有很多代码，存放在不同的文件目录里，而Verilog-mode进行 AUTOINST 只会自动查找当前目录，这时候就会遇到问题了。那我们就来讲一讲verilog-mode是如何查找的吧。首先如果您在单文件中定义了多个模块，则会优先选择当前文件中的模块，然后在当前文件所在目录查找，如果定义了verilog-library-extensions，则继续查找附加扩展名的文件中查找模块，最后，它在verilog-library-directories中定义的每个目录中查找。 因此，如果您有一个顶层模块需要实例化其他目录的子模块，则需要告诉Verilog-Mode在哪些目录中查找，最好的方法是在每个需要它们的Verilog文件的末尾定义库变量：\n1 2 3 4 5  // Local Variables: // verilog-library-directories:(\u0026#34;.\u0026#34; \u0026#34;subdir\u0026#34; \u0026#34;subdir2\u0026#34;) // verilog-library-files:(\u0026#34;/some/path/technology.v\u0026#34; \u0026#34;/some/path/tech2.v\u0026#34;) // verilog-library-extensions:(\u0026#34;.v\u0026#34; \u0026#34;.h\u0026#34;) // End:   define问题（如果AUTO相关内容不涉及define，可忽略） 使用AUTOINST或AUTOSENSE时，有些场景中信号会带有define，这时候需要verilog-mode将define信息读进来，才可以正确完成AUTO功能。使用如下：\n1 2 3 4  // Local Variables: // eval:(verilog-read-defines) // eval:(verilog-read-defines \u0026#34;group_standard_includes.v\u0026#34;) // End:   第一行是读取当前文件中的define，第二行是读取define文件。\ninclude file问题（如果AUTO相关内容不涉及include，可忽略） 出于速度原因，Verilog-Mode不会自动读取include文件。这意味着include文件中定义的常量将不被作为AUTOSENSE的常量。解决方法如下：\n1 2 3  // Local Variables: // eval:(verilog-read-includes) // End:   verilog-mode 的AUTO使用方法 上文也看到了，可以通过打开emacs，使用快捷键来完成AUTO和取消AUTO，除此之外还可以当做脚本来处理，使用方法如下：\n1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   由此可见，我们可以通过脚本进行批量处理代码文件，完成AUTO机制，并且可以通过将不同目录文件复制其软连接到同一目录，再通过脚本实现AUTO机制，这样解决了不同目录对 AUTOINST 的影响。\nemacs的配置（关于verilog-mode） 以下是我的关于verilog-mode的emacs配置内容，“;;”代表注释符号。(所有设置参数均已添加注释，查看其他参数可以在verilog-mode模式下快捷键C-h m，查看verilog-mode.el)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  ;;my verilog mode config (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.vp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.vp file with verilog-mode (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.svp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.svp file with verilog-mode (setq verilog-date-scientific-format t) ;;dates are written in scientific format (e.g. 1997/09/17) (setq-default indent-tabs-mode nil) ;;false tab indent mode (setq verilog-indent-level 4) ;;Indentation of Verilog statements with respect to containing block (setq verilog-indent-level-module 0) ;;Indentation of Module level Verilog statements (eg always, initial) (setq verilog-indent-level-declaration 0) ;;Indentation of declarations with respect to containing block (setq verilog-case-indent 4) ;;Indentation for case statements (setq verilog-cexp-indent 4) ;;Indentation of Verilog statements split across lines (setq verilog-indent-lists t) ;;Indentation of lists, look the under content. ;; \u0026#34;How to treat indenting items in a list. ;;If t (the default), indent as: ;;\talways @( posedge a or ;; reset ) begin ;; ;;If nil, treat as: ;;\talways @( posedge a or ;;\treset ) begin\u0026#34; (setq verilog-indent-level-behavioral 4) ;;Absolute indentation of first begin in a task or function block (setq verilog-indent-level-directive 4) ;;Indentation to add to each level of \\\\=`ifdef declarations (setq verilog-auto-indent-on-newline t) ;;Non-nil means automatically indent line after newline (setq verilog-tab-always-indent t) ;;Non-nil means TAB should always re-indent the current line. ;;A nil value means TAB will only reindent when at the beginning of the line. (setq verilog-indent-begin-after-if t) ;;Non-nil means indent begin statements following if, else, while, etc. Otherwise, line them up. (setq verilog-auto-newline t) ;;Non-nil means automatically newline after semicolons and the punctuation mark after an end (setq verilog-auto-endcomments t) ;;Non-nil means a comment /* ... */ is set after the ends which ends cases, tasks, functions and modules. The type and name of the object will be set between the braces. (setq verilog-auto-reset-widths t) ;;True means AUTORESET should determine the width of signals (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;) ;;Text used for delays in delayed assignments. Add a trailing space if set (setq verilog-auto-lineup \u0026#39;all) ;; ;; \u0026#34;Type of statements to lineup across multiple lines. ;;If `all\u0026#39; is selected, then all line ups described below are done. ;; ;;If `declarations\u0026#39;, then just declarations are lined up with any ;;preceding declarations, taking into account widths and the like, ;;so or example the code: ;;\treg [31:0] a; ;;\treg b; ;;would become ;;\treg [31:0] a; ;;\treg b; ;; ;;If `assignment\u0026#39;, then assignments are lined up with any preceding ;;assignments, so for example the code ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f; ;;would become ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f;   有些参数目前我也不清楚具体用法和含义，如有其他好用的配置参数，欢迎推荐给我。\n忘了C-c C-a怎么办 有时候我们会忘记 C-c C-a ，显然这样会导致代码错误，如果是全部未实现AUTO还好，很容易及时发现，但是如果是在修改代码，并且仅仅是很小的改动，在功能仿真时不能及时发现，那就成了隐藏的bug，后果还是很严重的。比如组合逻辑always块的 AUTORESET ，功能仿真时并不容易被发现。 所以为了防止忘记 C-c C-a ，这里提供两种方案：\n 将verilog-auto与保存文件的 C-x C-s 绑定（注意，只有使用 C-x C-s 才有效，功能栏点击保存不会实现AUTO），请将以下代码添加到.emacs或.emacs.d/init.el（只在verilog-mode下有效，不会影响其他模式）   1 2 3 4 5 6 7  (add-hook \u0026#39;verilog-mode-hook \u0026#39;(lambda () (local-set-key (kbd \u0026#34;C-x C-s\u0026#34;) \u0026#39;(lambda () (interactive) (verilog-auto) (save-buffer)))))    使用脚本处理，将自己的源文件通过脚本处理后生成新的文件，比如我将原始文件命名为 *.vp 或 *.svp，最终处理后的文件为 *.v 或 *.sv，这样可以避免忘记完成verilog-auto。以脚本的形式进行处理还有一个好处，那就是对vim以及其他编辑器使用者比较友好，因为并非所有开发者都使用emacs。脚本处理命令如下：   1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   快捷键插入内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  C-c C-t a Insert an always @(AS) begin .. end block. C-c C-t b Insert a begin .. end block. C-c C-t c Insert a case block, prompting for details. C-c C-t f Insert a for (...) begin .. end block, prompting for details. C-c C-t g Insert a generate .. endgenerate block. C-c C-t h Insert a header block at the top of file. C-c C-t i Insert an initial begin .. end block. C-c C-t j Insert a fork begin .. end .. join block. C-c C-t m Insert a module .. (/*AUTOARG*/);.. endmodule block. C-c C-t o Insert an OVM Class block. C-c C-t u Insert an UVM Object block. C-c C-t U Insert an UVM Component block. C-c C-t p Insert a primitive .. (.. );.. endprimitive block. C-c C-t r Insert a repeat (..) begin .. end block. C-c C-t s Insert a specify .. endspecify block. C-c C-t t Insert a task .. begin .. end endtask block. C-c C-t w Insert a while (...) begin .. end block, prompting for details. C-c C-t x Insert a casex (...) item: begin.. end endcase block, prompting for details. C-c C-t z Insert a casez (...) item: begin.. end endcase block, prompting for details. C-c C-t ? Insert an if (..) begin .. end block. C-c C-t : Insert an else if (..) begin .. end block. C-c C-t / Insert a comment block. C-c C-t A Insert an assign .. = ..; statement. C-c C-t F Insert a function .. begin .. end endfunction block. C-c C-t I Insert an input declaration, prompting for details. C-c C-t O Insert an output declaration, prompting for details. C-c C-t S Insert a state machine definition, prompting for details. C-c C-t = Insert an inout declaration, prompting for details. C-c C-t W Insert a wire declaration, prompting for details. C-c C-t R Insert a register declaration, prompting for details. C-c C-t D Define signal under point as a register at the top of the modul   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":53,"section":"docs","tags":["emacs","verilog"],"title":"Emacs verilog-mode 的使用","uri":"https://www.wenhui.space/docs/about_emacs/verilog_mode_useguide/"},{"content":"本文 主要记录了emacs使用过程中的小技巧。\n   版本 说明     0.1 初版发布   0.2 添加参考链接    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs Wiki 子龙山人的emacs学习记录  文本编辑相关 Emacs 中的批量查找与替换 Emacs 有很强大的批量查找与替换功能。操作如下：\n 切换到源码项目目录，然后 M-x find-dired ，输入 . ，表示查找当前目录下的所有文件，回车，在输入 -name \u0026ldquo;.el\u0026rdquo;* ，表示只查找.el文件。再次回车后，Emacs 会打开一个缓冲区显示出项目中所有的.el后缀的文件 在显示所有查找文件的缓存页面，可以直接按t来标记所有文件，或者按m来一个一个的进行标记，如果标记错误了，可以按u来取消标记 标记完所有要进行查找替换的文件之后按Q快捷键，使用正则表达式来查找与替换被标记文件中的内容，第一次需要输入的是被查找项，回车之后在输入替换项，之后在回车，Emacs 会逐个打开被标记的文件，然后用高亮显示被正则搜索到的要替换的语句，逐个的问你是否要进行替换 显示的高亮替换项，你可以按y来确认替换，也可以按n取消替换，或者按!强制不提示而进行所有替换 替换完成后 C-x s 保存所有修改项，会逐个询问是否保存，yes代表保存，no代表不保存，！代表强制保存所有  Emacs 的查找与替换功能看似比其他软件繁琐与麻烦许多，实际上这是非常稳健的操作方式，查找与替换的过程非常透明化，你可以详细的看到要被替换的项，仔细谨慎的进行确认替换，之间也有非常多的机会来中断查找替换过程，来恢复文件中被错误替换的内容。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":54,"section":"docs","tags":["emacs"],"title":"emacs的使用技巧记录","uri":"https://www.wenhui.space/docs/about_emacs/emacs_use_tips/"},{"content":"本文 主要介绍了为firefox安装插件的小技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  安装插件  打开firefox浏览器 打开菜单栏（右侧三杠图标），选择附加组件，打开附加组件管理器（也可以使用快捷键Ctrl-Shift-A） 附加组件管理器可以搜索、添加和删除插件  解决安装插件时浏览器无反应问题 有时候进入插件页面，点击 添加到Firefox 之后无反应，具体原因不知道，不过经过尝试，可以右键选择 在新建窗口打开链接 ，问题解决。\n推荐几个我使用的插件  侧边翻译：可以将选中的内容快速翻译，也可以选择有道或谷歌翻译整页（谷歌翻译好像不太行，不知道原因） 网页截图 Bitwarden（免费密码管理器，妈妈再也不用担心我忘记密码了） OneTab（以列表形式显示标签页，解决功能栏标签繁杂的问题）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":55,"section":"docs","tags":["firefox"],"title":"为firefox安装插件","uri":"https://www.wenhui.space/docs/install_software/install_plugins_for_firefox/"},{"content":"本文 主要介绍一款开源密码管理工具 Bitwarden 。\n   版本 说明     0.1 初版发布   0.2 更正 验证器秘钥（TOTP） 的理解    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  什么是Bitwarden？ Bitwarden是一款开源的密码管理器，所谓密码管理器，就是将所有密码交由工具管理，我们只需要记住主密码就行，生成密码、记忆密码和填写密码都由工具来自动完成。类似于此功能的还有PassWord、KeePass 、Lastpass等等，不过他们都是付费的，而Bitwarden是开源免费的。关于Bitwarden的详细信息可查看Bitwarden官网。\n这里简单列出个人认为Bitwarden的优点：\n 这是一款免费、开源的密码管理软件 支持 Windows、Mac、Linux 操作系统 通过插件可支持主流的浏览器，如google和firefox 提供苹果、安卓的原生应用 支持浏览器自动填写以及二次验证 可以使用官方的免费服务，也可以自建服务器  关于安全性 就安全性而言，这些密码管理工具采用的是高强度 AES-256 加密算法，想要破解几乎是不可能的事。也有人会担心把密码放在别人的服务器上不安全？个人认为是安全的，它们的加密方法，是把帐号和主密码通过算法得到一个值，然后用这个值去加密用户的各个密码，最后储存在服务器上。而加密解密都需要在本地进行，也就是说，黑客即使攻破了服务器，但无法破解密码数据库，除了把你的密码数据库删除外，其他什么也做不了。\n不过还有一句话，互联网没有绝对的安全，所以我一般把各个密码分级。\n 三级： 一般社交平台账户密码和其他应用账户密码 二级： 邮箱以及其他带有注册性的账户密码 一级： 带有支付性的账户密码 特级： 支付密码  三级交由密码工具管理，二级和一级由密码工具加个人前缀码组合，特级只放在脑子里。\n安装Bitwarden Bitwarden可以网页访问，可以安装浏览器插件，也可以下载应用程序。下载应用程序和网页登录可以选择进入Bitwarden官网，安装浏览器插件这里以firefox为例，参考我另一篇帖子 为firefox安装插件。\n如何使用Bitwarden?  打开firefox浏览器，点击插件Bitwarden，注册登录，注意， 一定要记住主密码，一定要记住主密码，一定要记住主密码 添加项目，项目内容有名称、用户名、密码、验证器密钥、网址、文件夹、笔记等等，其中网址会根据当前打开网页自动添加，密码可以选择工具生成也可以自动输入，验证器密钥TOTP（与二次验证相关，不开启二次验证可忽略），文件夹可以根据个人需求创建和选择，笔记以及其他根据个人需求填写，也可不写。 打开网页，Bitwarden插件会自动识别，打开Bitwarden，可以选择自动填充也可以手动复制  什么是 验证器秘钥（TOTP） 验证器秘钥与二次验证相关，二次验证就像除了密码之外还需要短信验证码一样，这里的两步验证也是相当于给帐号多加一把“锁”(多一步的验证)，在输入正确的账号密码之后，用户同样还需要额外输入一个每 30 秒自动变化一次的 6 位数字「二步验证码」才能完成登录。这里的验证器秘钥通过基于时间和加密算法生成“每 30 秒变化一次的 6 位数字验证码”，也叫做 TOTP (Time-Based One-time Password) 或 OTP 一次性密码。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":56,"section":"docs","tags":["firefox"],"title":"Bitwarden的安装","uri":"https://www.wenhui.space/docs/install_software/install_bitwarden/"},{"content":"本文 主要对日常linux系统使用使用的命令进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  查看系统信息  查看系统版本： “cat /etc/issue” 查看内核版本（具体可以查看etc目录下关于系统和内核的文件内容）：  RedHat内核： “cat /etc/redhat-release” Debian内核： “cat /etc/debian_version”    查看命令是否存在  which perl alias print_declare  head和tail  读取前10行： head -n 10 file 读取后10行： tail -n 10 file 读取前200字符： head -c 200 file 读取前200x512字符： head -c 200b file（200k=200x1024） 读取动态文件末尾，适合动态输出的log文件：tail -f file.log 读取中间内容，如读取101行到150行内容： cat file | head -n 150 | tail -n 50  批量重命名rename  替换单个字符（小写变大写）： rename \u0026lsquo;y/a-z/A-Z/\u0026rsquo; * （替换表达式中y代表替换字符一一对应，即a替换为A，b替换为B\u0026hellip; 最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件） 替换特定字符串： rename \u0026lsquo;s/abc/123/\u0026rsquo; * （替换表达式中s代表特定字符串替换，即abc替换为123，最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件）  常用命令之grep grep命令功能是搜索文本中包含的字符串，常用方法如下：\n grep “字符串” * 搜索当前目录下的所有文件，也可以使用 *.v 只搜索带.v后缀的文件（不包含子目录下的文件） grep -r “字符串” * -r或-R可以递归搜索，也就是搜索包含子目录以及子子目录等中的所有文件 grep -i “字符串” * 忽略字符串中的大小写 grep -n \u0026ldquo;字符串\u0026rdquo; * 列出字符串所在文件的行号 grep实际使用中，由于某些特殊字符带有特殊含义，而在使用其本意时，需要结合转义字符\\，比如字符串“**“，就需要加转义”\\*\\*“，不然会匹配成任意。  终极使用：我会将此命令定义别名为gg（将下面代码赋值到.bashrc即可），这样终端命令行使用gg来达到“搜索当前目录以及子目录下所有文件，显示行号，搜索字符高亮显示”功能，这对熟悉他人文档环境时很有用，能够快速定位到自己想要搜索的内容，更快的熟悉文档环境。\n1  alias gg=\u0026#39;grep --color=auto -rn\u0026#39;   常用命令之find find是查找文件的命令，常用就是查找文件名为xx的文件，使用方法如下，这里就是在（.）当前目录及其子目录下查找带.c后缀的文件：\n1  find . -name \u0026#34;*.c\u0026#34;   也可以搭配管道命令（可以理解为同时执行），如下命令指在 find . 结果中使用 grep搜索特定字符串：\n1  find . | grep \u0026#34;文件名\u0026#34;   还可以使用参数-maxdepth来指定层级深度，我的终极使用，我会将此命令定义别名为ff（将下面代码赋值到.bashrc即可），这样终端命令行使用ff来达到“查找当前目录并设定搜索深度，比如1代表仅当前目录，带特定字符串的文件名”，使用方法如：ff 3 \u0026ldquo;*.c\u0026rdquo;\n1  alias ff=\u0026#39;ff() { find . -maxdepth $1 -name $2;}; ff\u0026#39;   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":57,"section":"docs","tags":null,"title":"Linux使用命令记录","uri":"https://www.wenhui.space/docs/about_linux/use_notes/linux_use_notes/"},{"content":"本文 主要介绍如何使用org-mode和ox-hugo写博客。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58 emacs版本：Linux GNU Emacs 26.3  参考  ox-hugo的使用手册 Org to Markdown for Hugo 使用emacs中的包管理器安装插件 Blogging with org-mode and ox-hugo  声明 当你看到此帖子，我必须要声明一下，如果你是非emacs用户，并不强烈推荐你使用emacs org-mode来写博客，除非你有足够的兴趣了解和学习emacs。\n什么是org-mode？什么是ox-hugo？  org-mode是文本编辑软件Emacs的一种支持内容分级显示的编辑模式，是一个基于快速高效的文本方式来实现做笔记、管理待办事项（TODO list）以及做项目计划的模式。本人使用感受最好的就是大纲显示模式。 ox-hugo是emacs的一个插件，可以将org格式文件转换为hugo识别的markdown格式文件。  安装emacs和安装ox-hugo插件 安装emacs就不介绍了，可参考我的另一篇帖子 emacs的安装。\n这里主要介绍一下如何安装ox-hugo插件。给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   emacs的基础使用 emacs的使用可以简单了解一下emacs启动页面的使用手册，简单了解就可以上手了。这里把最基础的使用粘贴出来。\nEmacs的快捷键都是绑定在ctrl和alt上的，例如C-x就是ctrl+x，M-x就是alt+x。\n 文件操作  C-x C-f 打开文件 C-x C-s 保存文件 C-x C-c 退出Emacs   编辑操作  C-f 前进一个字符（方向键也可以） C-b 后退一个字符（方向键也可以） C-a 移到行首 C-e 移到行尾 C-p 后退一行（方向键也可以） C-n 前进一行（方向键也可以） M-g M-g 跳到指定行 M-\u0026lt; 文档头部（配合Shift键） M-\u0026gt; 文档尾部（配合Shift键） C-d 删除一个字符（delete键也可以） C-k 删除一行 C-Shift-空格 标记开始区域 C-w 删除标记区域 C-y 粘贴删除的内容，注意：C-y可以粘贴连续C-k删除的内容；先按C-y，然后按M-y可以选择粘贴被删除的内容 M-w 复制标记区域 C-/ or C-x u 撤消操作   窗口操作  C-x 0 关闭本窗口 C-x 1 只留下一个窗口 C-x 2 垂直均分窗口 C-x 3 水平均分窗口 C-x o 切换到别的窗口 C-x s 保存所有窗口的缓冲 C-x b 选择当前窗口的缓冲区   缓冲区列表操作  C-x C-b 打开缓冲区列表 C-x k 关闭缓冲区   搜索模式  C-s 向前搜索 C-s 查找下一个 ENTER 停止搜索 C-r 反向搜索 C-s C-w 以光标所在位置的字为关键字搜索 M-% (配合Shift键) 替换， 输入y表示同意此处替换，否则输入n，全部替换使用！   帮助  C-h t 入门指南 C-h ? 查看帮助列表    org-mode和ox-hugo写博客 ox-hugo 支持两种方式来管理 org 格式的博客文章，一种是多个文章放在同一个 org 文件里，另一种是对不同的文章使用独立的 org 文件。本人喜欢第一种方式，我会将同一类的博客文章放在同一个org文件来管理。如下：\n  emacs org mode    文件头部说明  HUGO_BASE_DIR：这里是博客的根目录，因为我的org文件放在博客根目录下的 orgposts ，所以这里博客的根目录就是 “../” ，也就是本目录的上一层目录 HUGO_SECTION：生成的markdown文件的位置，比如 “./post/create_blog_site/” 就会将markdown文件生成在博客根目录下的 “content/post/create_blog_site/” hugo_auto_set_lastmod：最后修改的时间，也就是org转markdown时的时间，t的话会自动生成，也可以选择f，这个时间在jane主题也就是文章末的最后更新时间 hugo_custom_front_matter：这里是markdown文件头部参数的设置，比如toc，是否开启目录，不开启的话浏览时无目录显示，为了阅读方便建议开启 hugo_categories：分类名称，我是将同一类博客放在了一个org文件，这里就是分类名，然后每个subtree就是一个博客，会生成一个markdown文件 author:nil：这里是作者名称，在hugo的配置文件中已经配置了作者名称，这里将作者名称的控制关掉   1 2 3 4 5 6 7  #+HUGO_BASE_DIR: ../ #+HUGO_SECTION: ./post/create_blog_site/ #+hugo_auto_set_lastmod: t #+hugo_custom_front_matter: :toc true #+hugo_categories: 搭建博客站点 #+OPTIONS: author:nil   subtree 下面是一个subtree的内容(为了防止转义，前面都加了#号，实际中无#号)，下面一行一行介绍：\n 第一行是一级标题，这里也就是一个subtree，也是文章标题，后面冒号间的文字是标签，对应markdown文件中的tag，注意，冒号需要为英文符号，也可以使用 C-c C-c 快捷键输入tag；标题前的 DONE 表示完成状态，除此之外还有 TODO 状态，对应markdown文件中的 draft ， TODO 状态时，会认为是草稿，不会发布到站点，还要注意的是，状态不是手动敲上去的，而是光标放在标题行，通过Shift和左右键切换 第二行是文章创建的时间，对应markdown文件的date 第三四五行，EXPORT_FILE_NAME是输出markdown文件的名称，这里是subtree的属性描述，可使用参数应该还有很多，不过暂时没了解 最后就是博客内容了，二级标题和三级标题   1 2 3 4 5 6 7  #* DONE title_level1 :hugo:emacs: # CLOSED: \u0026lt;2019-09-13 五 14:22\u0026gt; # :PROPERTIES: # :EXPORT_FILE_NAME: Thinkpad_S2 # :END: #** title_level2 #*** title_level3   特殊需求  外链：可以使用 C-c C-l (这里是小写L)快捷键，输入链接和链接说明 图片：官方提供的方式如下(这里为了防止转义使用的小括号，实际为英文大括号)：   1  ((\u0026lt;figure src=\u0026#34;/image/cook/image0.jpg\u0026#34; title=\u0026#34;图片\u0026#34; \u0026gt;))   由于我还是希望对图片显示大小和位置能够控制，也许有其他方法还不知道，不过在这里写一个html格式的图片引用，能够实现我想要的效果，方式如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;    subtree中设置分类，如下，@后是分类，:后是标签（为了防止转义，添加了#号，实际中无#号）   1  # :@笔记:昨天:今天:明天:    脚注：在需要插入脚注的地方写下 “【fn:1】” ，在文章末尾添加脚注的说明 “【fn:1】 脚注说明” ，这里为了防止转义使用了中文符号，实际中记得使用英文符号  org文件转为markdown文件  将所有subtree都转为对应的Hugo markdown文件，快捷键 C-c C-e H A ，其中 C-c C-e 是导出快捷键，可选的有很多，比如h代表html，l代表laTex等，H代表Hugo，后面的A代表All（快捷键操作过程中会有提示，详细信息可以看提示信息） 将某subtree转为对应的Hugo markdown文件，首先光标移至对应的subtree，再通过快捷键 C-c C-e H H ，其中 C-c C-e 是导出快捷键，H代表Hugo，后面的H代表subtree（快捷键操作过程中会有提示，详细信息可以看提示信息） 其他说明：content不存在对应的目录也没关系，ox-hugo会自动创建  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":58,"section":"docs","tags":["hugo","emacs"],"title":"使用org-mode和ox-hugo写博客","uri":"https://www.wenhui.space/docs/create_blog_site/org_mode_and_ox_hugo/"},{"content":"本文 主要介绍如何为自己的博客自定义域名。\n   版本 说明     0.1 初版发布   0.2 解决push后自定义域名失效问题    背景  需要购买域名，我使用的是阿里云  参考  GitHub Pages 绑定来自阿里云的域名 个人独立博客如何与阿里云域名绑定  准备域名 购买域名 点击进入阿里云域名注册页面，选择自己喜欢的域名，点击查询，看一下是否被注册以及售价，我使用的是 wenhui.space ，售价十年179元，还可以。当然购买之前要先登录账户，这里使用支付宝登录即可，登录后需要实名认证，可以选择支付宝快速完成实名认证。选择心仪的域名，进行购买。\n完成域名持有者认证 需要上传个人身份证正面照片，提交认证，一般当天可以认证完成。\n域名解析 找到github page的IP地址 需要ping一下自己的github page网址，如下图，红色部分就是IP地址。\n  ping github IP    配置阿里云域名解析 登录你的阿里云账号,进入管理控制台,在左侧菜单找到 域名与网站(万网), 然后进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。输入如下图内容：\n  ping github IP    说明：  记录类型  A记录： 将域名指向一个IPv4地址（例如：8.8.8.8） CNAME：将域名指向另一个域名（例如www.qcloud.com）   主机记录  www： 解析后的域名为www.qcloud.com。 @： 直接解析主域名 qcloud.com。    配置github pages的custom domain 进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：\n     设置到这里,你就可以 通过你的域名访问你的博客啦!(可以适当等几分钟再使用新的网址访问自己的博客) 解决push后自定义域名失效问题 自定义域名失效是因为仓库中没有CNAME文件，该文件是指向你自定义域名的文件。\n 创建CNAME文件，打开终端，进入博客根目录，输入以下命令（替换为你自己的域名）：   1  echo www.wenhui.space \u0026gt;CNAME    修改issue.sh脚本，使其在每次上传public文件时，不会破坏CNAME，issue.sh如下：   1 2 3 4 5 6 7 8 9 10 11 12  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ cp ./CNAME ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":59,"section":"docs","tags":["hugo"],"title":"给自己的博客自定义域名","uri":"https://www.wenhui.space/docs/create_blog_site/modify_url_for_blog/"},{"content":"本文 主要介绍了一个hugo博客内容的使用技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  插入图片 1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   这里显示的是插入本地图片，图片位置放在博客站点根目录下的static文件内，上文所示路径对应文件存放路径为 “my_blog/static/image/me.jpg” ，这里可以对图片大小，显示位置，图片标题进行设置。也可以将相对路径改为网址全路径，也就是引用网上图片，这时候需要图床工具，PicGo是一个不错的选择，可参考我的另一篇帖子PicGo的安装。\n注意：static目录下的所有文件名不要使用下划线，否则会导致图片索引错误，可以使用 \u0026ldquo;-\u0026rdquo; 连字符。\n其他 我相信还有其他使用技巧，待后续补充，如果你有好的用法，欢迎推荐。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":60,"section":"docs","tags":["hugo"],"title":"hugo博客内容的使用技巧","uri":"https://www.wenhui.space/docs/create_blog_site/hugo_content_tips/"},{"content":"本文 主要介绍了如何将hugo创建的博客站点部署到github。\n   版本 说明     0.1 初版发布   0.2 修改issue.sh脚本    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  git的安装与介绍 请参考我的另一篇帖子git的安装。\n部署过程 在github创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    在这里要创建两个仓库，一个私有仓库，名字自定义，可以为“my\\_blog”，用来存放博客站点文件；另一个公共仓库，名字为 **username.github.io** ，记住，一定为 **username.github.io** (username替换为你的用户名），后面启用 **github page** 时会解释为什么如此命名。 克隆仓库 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。\n启用github page功能 GitHub Pages 是一个静态网站托管服务，简单说就是他可以实现创建个人网页。我们需要给名为 username.github.io 的仓库启用github page功能，需要以下几步：\n 首先空仓库是不能启用page功能的，你需要添加一个文件（无所谓什么文件，可以写个readme），通过以下git命令，上传到远程仓库。这里可能需要输入账户密码，可以使用 \u0026quot;git config \u0026ndash;global credential.helper store\u0026quot; ，避免重复输入账户密码。   1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push    打开github，进入名为 username.github.io 的仓库，然后点击 settings ，拉到最下面会看到 Github Pages ，此时关于github page是 None 状态，将其选择为 master branch （如果是私有仓库是无法开通的，所以创建时我们选择了公共仓库），如果有显示 “Your site is published at https://username.github.io/” ，就是启动了page功能，你可以使用此网址访问你的个人网页了，只不过目前什么内容都没有。这里对page的网址说明一下，如果仓库名为 username.github.io ，那网址就为 “https://username.github.io/” ，如果仓库名为其他，则网址中会带有仓库名，也就是 “https://username.github.io/reponame/” ，如果是这样，使用hugo时，本地相对路径索引的图片上传后通过网页是无法加载的，hugo生成的图片链接没有仓库名，这里是经过试错得到结论。  生成博客站点静态文件并上传到远程仓库  打开终端，进入博客站点根目录 my_blog ，使用 “hugo server” 命令预览博客，无问题的话输入 \u0026ldquo;hugo\u0026rdquo; 命令，生成博客站点静态文件 public ，我们将 public 内文件全部粘贴到 username.github.io 仓库，并上传到远程仓库，命令参考上文。 打开浏览器，输入开启github page时提示的网址，就看到你的个人博客网页了，到此部署成功。 我们也可以写一个脚本方便处理，我起名为 issue.sh ，如下：   1 2 3 4 5 6 7 8 9 10 11  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   维护自己的博客内容和环境 最初我们创建了两个仓库，目的就是一个开启page功能，将博客静态文件发布到网络，另一个就是维护博客内容和环境文件。\n 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。 将博客站点根目录my_blog中的所有文件复制到克隆的仓库文件（仓库名也可以为my_blog） 这里themes中的jane本身是一个git仓库，我们可以不用上传到远程仓库，生成的public是中间文件也不需要上传到远程仓库，所以添加一个 .gitignore 文件，git可以自动忽略 .gitignore 列出的文件，不上传到远程仓库。终端中进入博客站点根目录，输入如下命令即可：   1 2  echo themes \u0026gt;\u0026gt;.gitignore echo public \u0026gt;\u0026gt;.gitignore    将博客内容和环境文件上传之远程仓库，命令参考上文。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":61,"section":"docs","tags":["hugo"],"title":"将hugo博客部署到github","uri":"https://www.wenhui.space/docs/create_blog_site/hugo_deploy_to_github/"},{"content":"牛人博客  子龙山人：emacs大牛 骏的世界：CPU从业者 \u0026amp; IC验证 ManateeLazyCat：emacs elisp大牛 \u0026amp; Deepin and Emacs 开源贡献者 蜂窝科技-涉及Linux内核、ARMv8架构和Linux使用技巧等高质量文章  学习网站  在线EDA仿真网站 在线Verilog仿真网站 学习systemverilog和UVM的好网站 在线编程学习网站：实验楼  其他网站  Linux内核下载 ARM编译器（linaro）下载网站 ARM文档下载网站  ","description":"","id":62,"section":"","tags":null,"title":"Links","uri":"https://www.wenhui.space/links/"},{"content":"本文 主要介绍了markdown基本语法。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  什么是markdown？ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。可能听起来有些抽象，简单来说就是纯文本编辑方式，依据特殊语法，经过工具渲染，可以达到很漂亮的显示效果，除此之外还能支持更多复杂功能，比如数学符号的显示等等。\nMarkdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此很多博客平台都支持markdown，比如简书和CSDN，对markdown都有很好的支持，有些网站的评论窗口也支持markdown。目前markdown因为简单易用的特点，已经被广泛使用。不过各平台对markdown的支持情况也不太统一，所以存在部分兼容问题，不过不用担心，常用语法还是一致的。\n语法介绍 标题 注意，中间有空格。\n1 2 3 4 5 6  # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题   字体  加粗：将要加粗的文字左右分别用**号包起来，如“**粗体**” （好像用下划线包起来也可以，如“__粗体__”） 斜体：将要倾斜的文字左右分别用*号包起来，如“*斜体*” （好像用下划线包起来也可以，如“_斜体_”） 斜体加粗：将要倾斜和加粗的文字左右分别用三个*号包起来，如“***粗斜体***” （好像用下划线包起来也可以，如“___粗斜体___”） 删除线：将要加删除线的文字左右分别用两个~~号包起来，如“删除线” 高亮：将要加高亮的文字左右分别用两个==号包起来，如“==高亮==”  分割线 三个或者三个以上的 - 或者 * 都可以。\n1  ---   图片 图片名称就是显示在图片下面的文字，相当于对图片内容的解释。图片标题就是当鼠标移到图片上时显示的内容。图片标题可加可不加。\n1  ![图片名称](图片网址 \u0026#39;\u0026#39;图片标题\u0026#39;\u0026#39;)   当然也可以使用html格式，这里添加了对图片的大小和显示位置做了控制，如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;图片网址\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   超链接 title可不加\n1 2  [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) [百度](http://baidu.com)   列表  无序列表(注意，符号与内容间有空格)   1 2  - 列表内容 + 列表内容    有序列表(注意，符号与内容间有空格)   1 2  1. 列表内容 2. 列表内容    列表嵌套   1 2 3 4  - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容   表格 第二行分割表头和内容，其中“-”有一个就行，也可以为了对齐多加几个；文字默认左对齐，“-”两边加“:”表示文字居中，\u0026quot;-\u0026ldquo;右边加“:”表示文字右对齐。注意，符号为英文符号。\n1 2 3 4  |表头|表头|表头| |---|:--:|---:| |内容|内容|内容| |内容|内容|内容|   代码  单行代码，代码之间分别用一个反引号包起来   1  `代码内容`    多行代码，代码之间分别用三个反引号包起来   1 2 3 4 5  ``` 代码... 代码... 代码... ```   段落、换行、缩进 Markdown语法中，两个段落之间是用空白行分隔的，如果作为两个段落，编辑时请在中间加空白行，不过中间加即时多个空白行却只显示一个空白行，如果想加多个空白行，就要借助html的换行命令，如下；如果想首行缩进，需要输入全角空格，不过不建议使用，markdown是用空白行来区分段落的，而不是缩进。\n1  \u0026lt;br\u0026gt;   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":63,"section":"docs","tags":["markdown"],"title":"markdown语法","uri":"https://www.wenhui.space/docs/create_blog_site/markdown/"},{"content":"本文 主要介绍了如何下载和使用hugo。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  hugo的介绍和安装 可查看本站另一篇帖子 hugo的安装。\n快速使用 根据自己的摸索，保存了一个基于jane主题的基本使用框架，开箱及用，只需要在content目录下写markdown文件即可。查看我的百度网盘分享资源 链接：https://pan.baidu.com/s/1l4RU%5FJx-2XKI-pflL-a7zA 密码：pf03 。基于此框架你也可以根据个人需求，简单调整。\n使用hugo生成站点 使用Hugo生成站点，比如希望生成到当前目录，文件名为my_blog。打开终端，命令如下：\n1  hugo new site ./my_blog   这样就在当前目录下生成了初始站点 my_blog ，进去目录查看，其文件结构如下：\n├─archetypes ├─content ├─data ├─layouts ├─static ├─themes └─config.toml 这里对站点的几个文件介绍一下：\n archetypes：原型文件，里面存在一个markdown文件的模板，使用 “hugo new xx.md” 命令时会依据该模板创建markdown文件，我一般不使用 “hugo new” 命令，而是直接手动创建markdown文件，所以不关心模板 content：内容文件，所有的帖子都以markdown文件形式存在这里，hugo会自动索引，一般功能栏的 “关于” “友链” 等页面，我会存在content一级目录，其他帖子内容在content内另建post目录，而且根据不同分类可以在post内新建目录存储，hugo会自动层级索引，也就是只要在content内的markdown文件，hugo都能找到 data：这个目前还真不知道做什么的，但不影响使用，可暂不关心（如果有熟悉的可以帮忙解释一下） layouts：个人理解这里存放的应该是关于网站布局以及其他关于网站页面显示的文件（html），不过我们一般都会安装主题，所以这个可以不关心 static：静态文件，一般js(javascript)和css文件会存放在这里，这些文件主要是与博客网页显示相关的，我没这个需求，主要是也不懂，在这里我主要存放的就是博客中用到的图片了 themes：主题文件，可以寻找自己喜欢的主题，存放在这里，简单配置即可使用 config.toml：全局配置文件，博客站点所有的配置，都在此文件完成，最比如设置使用的主题  安装主题 hugo生成站点后，还不能正常使用，需要安装自己喜欢的主题，也叫皮肤。到hugo主题列表选择一款自己喜欢的主题，下载到themes目录下，每个主题都会有一个readme文件，介绍主题的特性和指导你如何使用主题。这里以我使用的主题为例，hugo-theme-jane，此主题是由贤民大哥开发的，可以先浏览一下他的主页 贤民的比特记忆，看一下效果。\n下载jane主题  进入jane主题github网址，点击 [Clone or download] ，选择 [Download Zip] ，通过网页下载压缩包，解压后放到themes目录下 通过git下载，打开终端，进入themes目录，输入以下命令(这个网址就是github中 [Clone or download] 栏显示的网址)：   1  git clone https://github.com/xianmin/hugo-theme-jane.git    通过我的百度网盘分享资源下载， 链接：https://pan.baidu.com/s/1xQJXLyNcI0Jbymrr9uZRGQ 密码：rhaw  测试体验  存放主题文件和更名：将下载的jane主题文件放到站点的themes目录下，并将文件名hugo-theme-jane改为jane（因为exampleSite中config.toml文件对主题的选择是jane，当然你也可以修改config.toml） 复制一些示例文本：打开终端，进入站点根目录 my_blog ，输入以下命令(如果content有自己的文件，请先备份，此命令会覆盖content)   1  cp -rf themes/jane/exampleSite/content ./    复制默认的站点设置：打开终端，进入站点根目录 my_blog ，输入以下命令(如果config.toml有自己的内容，请先备份，此命令会覆盖config.toml)   1  cp -rf themes/jane/exampleSite/config.toml ./    启动 hugo server：打开终端，进入站点根目录 my_blog ，输入以下命令   1  hugo server    查看博客效果：打开 http://localhost:1313/ ，你将会看到一个示例网站，效果如下    jane主题效果    配置主题 根据自己的需求，我做了如下改动：\n 修改菜单栏为中文显示，配置文件的修改详见下文 我的配置 将外链菜单，改为页面显示，需在content目录创建 links.md 文件，文件内容就是外链页面显示内容，配置文件的修改详见下文 我的配置 （添加新菜单页面都可以使用此方式） 将about菜单页面添加到配置文件，统一管理，目的是将“about”改为中文“关于”，需要将原about.md文件的 \u0026ldquo;menu: \u0026ldquo;main\u0026rdquo; 删除（其实将title改为中文“关于”也可以实现），配置文件的修改详见下文 我的配置 调整了菜单的顺序，更改weight值即可，配置文件的修改详见下文 我的配置 删除doc菜单，个人觉得不需要此功能，删除方法是将doc菜单下的几个帖子对应的markdown文件打开，删除下面所示的代码设置（这也是一种加功能菜单的方法，需要时可以用起来）   1 2 3 4  menu: main: parent: \u0026#34;docs\u0026#34; weight: 3    删除社交链接，本人觉得不需要，所以将所有社交链接注释掉了，但还有一个RSS订阅图标，有点强迫症，还是想把它删掉，于是进入主题jane，找到 \u0026quot;./layouts/partials/social_links.html\u0026rdquo; ，将RSS图标显示相关代码注释掉了，如下   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!-- {{/* RSS icon */}} {{ with .Site.GetPage \u0026#34;home\u0026#34; -}} {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; rel=\u0026#34;noopener {{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; class=\u0026#34;iconfont\u0026#34; title=\u0026#34;rss\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; {{ partial \u0026#34;svg/rss.svg\u0026#34; }} \u0026lt;/a\u0026gt; {{ end -}} {{- end -}} --\u0026gt;    下面展示一下 我的配置 ，基本每一处都做了注释，并标注了需要改的地方：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177  # 基础设置 #------------------------------------------------------------------- baseURL = \u0026#34;https://wenhui.space\u0026#34; # 博客部署网址 ：部署到github时需要改 title = \u0026#34;Wenhui\u0026#39;s Rotten Pen\u0026#34; # 网址名称 ：改 enableRobotsTXT = true # 是否支持Robots协议，也就是机器人协议/爬虫协议，简单说可以通过搜索引擎搜索到你的主页（不确定） enableEmoji = true # 是否支持Emoji表情符号 theme = \u0026#34;jane\u0026#34; # 选用jane主题 hasCJKLanguage = true # 自动检测是否包含 中文\\日文\\韩文 paginate = 10 # 首页每页显示的文章数目 rssLimit = 20 # 限制 Rss 文章输出数量 disqusShortname = \u0026#34;\u0026#34; # disqus_shortname googleAnalytics = \u0026#34;\u0026#34; # 配置google统计，这里设置一个 google 的统计配置id,格式为UA-XXXXXXXX-X copyright = \u0026#34;\u0026#34; # 默认为下面配置的author.name， # 关于语言 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 默认博客语言环境，可选：en, zh-cn (选项由theme中i18n文件支持所决定) [languages.zh-cn] # 语言支持 en/zh-cn/other... 可查看theme中i18n文件 languageCode = \u0026#34;zh-cn\u0026#34; # 关于语法高亮，具体使用可查看https://gohugo.io/content-management/syntax-highlighting/ PygmentsCodeFences = true # Enable syntax highlighting with GitHub flavoured code fences PygmentsUseClasses = true # Use CSS classes to format highlighted code PygmentsCodefencesGuessSyntax = true # PygmentsOptions = \u0026#34;linenos=table\u0026#34; # 开启显示行号 [author] # 作者名称 ：改 name = \u0026#34;文辉\u0026#34; [sitemap] # 暂不清楚 changefreq = \u0026#34;weekly\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; #------------------------------------------------------------------- #菜单设置 #------------------------------------------------------------------- [[menu.main]] name = \u0026#34;主页\u0026#34; weight = 10 identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; [[menu.main]] name = \u0026#34;归档\u0026#34; weight = 20 identifier = \u0026#34;archives\u0026#34; url = \u0026#34;/post/\u0026#34; [[menu.main]] name = \u0026#34;分类\u0026#34; weight = 30 identifier = \u0026#34;categories\u0026#34; url = \u0026#34;/categories/\u0026#34; [[menu.main]] name = \u0026#34;标签\u0026#34; weight = 40 identifier = \u0026#34;tags\u0026#34; url = \u0026#34;/tags/\u0026#34; [[menu.main]] name = \u0026#34;关于\u0026#34; weight = 50 identifier = \u0026#34;about\u0026#34; url = \u0026#34;/about/\u0026#34; [[menu.main]] name = \u0026#34;友链\u0026#34; weight = 60 identifier = \u0026#34;links\u0026#34; url = \u0026#34;/links/\u0026#34; [[menu.main]] name = \u0026#34;订阅\u0026#34; weight = 70 identifier = \u0026#34;feed\u0026#34; url = \u0026#34;/index.xml\u0026#34; #------------------------------------------------------------------- #其他参数设置 #------------------------------------------------------------------- [params] since = \u0026#34;2019\u0026#34; # 站点建立时间 homeFullContent = false # 主页是否显示全部文章内容，否的话仅显示摘要，建议设为否 rssFullContent = true # if false, Rss feed instead of the summary logoTitle = \u0026#34;文辉的烂笔头\u0026#34; # 博客标题，默认值是上面设置的title，也就是网址名称 keywords = [\u0026#34;Hugo\u0026#34;, \u0026#34;linux\u0026#34;, \u0026#34;emacs\u0026#34;, \u0026#34;CPU\u0026#34;] # 关键字，应该是与搜索引擎搜索有关，博客内无展示 description = \u0026#34;\u0026#34; # 网页描述，应该是与搜索引擎搜索有关，博客内无展示 archive-paginate = 30 # 归档、标签、分类每页显示的文章数目，建议修改为一个较大的值 dateFormatToUse = \u0026#34;2006-01-02\u0026#34; # 日期显示格式，查看可支持的格式见https://gohugo.io/functions/format/ moreMeta = true # 是否显示字数统计与阅读时间 showMenuLanguageChooser = true # 显示语言选择开关 showAuthorInfo = true # 文章末尾显示作者信息 # 一些全局开关，这些是默认值，也可以在每一篇内容的 front matter 中对单篇内容关闭或开启某些功能，在 archetypes/default.md 查看更多信息。 toc = true # 是否开启目录 photoswipe = true # 是否启用PhotoSwipe（图片可点击） bootcdn = true # 是否使用bootcdn(@Deprecated: 请使用[params.publicCDN])（好像可以加快网页访问速度） mathjax = false # 是否使用mathjax（数学公式） contentCopyright = \u0026#39;文辉原创文章，如需转载请注明出处，谢谢！！！\u0026#39; # 改 customCSS = [] # if [\u0026#39;custom.css\u0026#39;], load \u0026#39;/static/css/custom.css\u0026#39; file customJS = [] # if [\u0026#39;custom.js\u0026#39;], load \u0026#39;/static/js/custom.js\u0026#39; file #------------------------------------------------------------------- # CDN设置，据说是提高访问速度的，具体也没感受到 #------------------------------------------------------------------- [params.publicCDN] # load these files from public cdn，若启用公共CDN，需自行定义 enable = true jquery = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js\u0026#34; integrity=\u0026#34;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; slideout = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js\u0026#34; integrity=\u0026#34;sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentJS = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipe = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js\u0026#34; integrity=\u0026#34;sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeUI = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js\u0026#34; integrity=\u0026#34;sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css\u0026#34; integrity=\u0026#34;sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipeSKIN = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css\u0026#34; integrity=\u0026#34;sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; #------------------------------------------------------------------- # 下面是关于评论系统，更新显示commit内容，谷歌搜索，文章打赏，访问数据统计等等，个人觉得不需要，全部false掉了 #------------------------------------------------------------------- [params.utteranc] # utteranc is a comment system based on GitHub issues. see https://utteranc.es enable = false repo = \u0026#34;xianmin/comments-for-hugo-theme-jane\u0026#34; # The repo to store comments issueTerm = \u0026#34;pathname\u0026#34; [params.gitment] # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments clientId = \u0026#34;\u0026#34; # Your client ID clientSecret = \u0026#34;\u0026#34; # Your client secret [params.livere] #LiveRe comment. see https://www.livere.com/ uid = \u0026#34;\u0026#34; [params.reward] # 文章打赏 enable = false wechat = \u0026#34;/path/to/your/wechat-qr-code.png\u0026#34; # 微信二维码 alipay = \u0026#34;/path/to/your/alipay-qr-code.png\u0026#34; # 支付宝二维码 [params.counter.busuanzi] # a Chinese visitor counter # 卜算子计数器 enable = false [params.counter.leancloud] # Chinese leancloud visitor counter # leancloud 计数器 enable = false appId = \u0026#34;\u0026#34; appKey = \u0026#34;\u0026#34; [params.commentCount.disqus] # show counts of comments for Disqus enable = false [params.search.google] # google custom search, see https://cse.google.com enable = false id = \u0026#34;002186711602136249422:q1gkomof_em\u0026#34; title = \u0026#34;Search\u0026#34; [params.gitInfo] gitRepo = \u0026#34;https://github.com/xianmin/xianmin.org\u0026#34; showCommitMessage = false #------------------------------------------------------------------- #社交链接，不需要可注释掉 #------------------------------------------------------------------- # [params.social] # a-email = \u0026#34;mailto:your@email.com\u0026#34; # b-stack-overflow = \u0026#34;http://localhost:1313\u0026#34; # c-twitter = \u0026#34;http://localhost:1313\u0026#34; # d-facebook = \u0026#34;http://localhost:1313\u0026#34; # e-linkedin = \u0026#34;http://localhost:1313\u0026#34; # f-google = \u0026#34;http://localhost:1313\u0026#34; # g-github = \u0026#34;http://localhost:1313\u0026#34; # h-weibo = \u0026#34;http://localhost:1313\u0026#34; # i-zhihu = \u0026#34;http://localhost:1313\u0026#34; # j-douban = \u0026#34;http://localhost:1313\u0026#34; # k-pocket = \u0026#34;http://localhost:1313\u0026#34; # l-tumblr = \u0026#34;http://localhost:1313\u0026#34; # m-instagram = \u0026#34;http://localhost:1313\u0026#34; # n-gitlab = \u0026#34;http://localhost:1313\u0026#34; # o-goodreads = \u0026#34;http://localhost:1313\u0026#34; # p-coding = \u0026#34;http://localhost:1313\u0026#34; # q-bilibili = \u0026#34;http://localhost:1313\u0026#34; # r-codeforces = \u0026#34;http://localhost:1313\u0026#34; # s-mastodon = \u0026#34;http://localhost:1313\u0026#34; #-------------------------------------------------------------------   到此，你可以启动 hugo server ，查看一下自己的博客了，若仍有不满意的，可以尝试继续修改。\n开始写帖子 hugo是对markdown支持的，若对markdown语法不了解，可参考另一篇帖子 markdown基本语法。这里只对hugo使用的markdown文件头部进行说明（其他参数可以查看hugo官方文档）:\n date ： 文件创建时间 draft ： 是否为草稿，草稿文件不会发布到站点 title ： 文件标题 tag ： 标签 categories ： 分类 toc ： 是否开启目录   1 2 3 4 5 6 7 8  +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; tags = [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] categories = [\u0026#34;分类1\u0026#34;] toc = true +++   可以开始书写你的博客内容了，顺便说一句，markdown的编辑器可使用typora。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":64,"section":"docs","tags":["hugo"],"title":"hugo的使用","uri":"https://www.wenhui.space/docs/create_blog_site/hugo_usage/"},{"content":"本文 主要介绍了如何为firefox手动安装flash player插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0 flash player版本：32.0  参考  firefox帮助：安装 Flash 插件 百度经验：deepin linux下firefox怎么升级flash player  安装过程 为什么安装Flash插件 由于deepin没有发现简单易用的图片处理软件，比如调整大小、拼图、裁剪等等，最佳选择就是使用美图秀秀网页版了，但是发现缺少可用的Flash插件，于是开始了安装过程。\n下载Flash插件  你可以到官网下载，请进入Adobe Flash Player下载页面，选择要下载的版本，我这里选择的是 .tar.gz 适用于 Linux 也可以选择我的百度网盘分享资源 链接：https://pan.baidu.com/s/18FLcCARtjnogcBB%5F950s-Q 密码：xbcu  解压安装 将下载的安装包解压，放到自己合适的位置，比如我的 “~/Treasury/tools_and_drives/flash_player/” ，“Treasure”的意思就是财富宝藏了，没错，我的所有“财富”都在这里。然后将下载的文件包中 libflashplayer.so 复制到firefox的插件目录 “/usr/lib/mozilla/plugins/” 。打开终端进入下载的文件包目录，输入如下命令(中途会提示输入用户密码)：\n1  sudo cp ./libflashplayer.so /usr/lib/mozilla/plugins/   如果没有firefox的插件目录，需要自己创建：\n1  sudo mkdir -p /usr/lib/mozilla/plugins/   查看 重启firefox，点击菜单打开 附加组件 或快捷键 Ctrl+Shift+A ，点击左侧的“插件”即可看到flash palyer的版本。\n  flash player版本为32.0    如果还没有的话，可以试试点击 **齿轮图标** 选择 **从文件安装附加组件** 。 文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":65,"section":"docs","tags":["firefox"],"title":"为firefox安装flash player插件","uri":"https://www.wenhui.space/docs/install_software/install_flash_player_for_firefox/"},{"content":"本文 主要介绍emacs如何安装插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  安装过程 给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":66,"section":"docs","tags":["emacs"],"title":"emacs如何安装插件","uri":"https://www.wenhui.space/docs/about_emacs/emacs_package_install/"},{"content":"本文 主要介绍emacs的基本使用方法。\n   版本 说明     0.1 初版发布    获取教程的途径  子龙山人的《21天学会Emacs》电子书在线阅读 打开emacs，快捷键C-h t，获取emacs的快速指南  帮助的使用 使用emacs最重要的是学会查找帮助。 C-h 是使用帮助功能，下面描述常用的几种查找帮助：\n C-h ? Emacs会告诉你它提供了哪些帮助 C-h t 打开Emacs快速指南 C-h c 命令说明【C-h c后面加要查询的命令】 C-h k 查看某个快捷键对应的命令【C-h k后面加要查询的快捷键】 C-h w 查看某个命令对应的快捷键 (where-is) C-h m 查看某个mode的文档 C-h f 解释一个函数【需要输入函数名】 C-h i 阅读手册【也就是通常讲的 Info】 C-h r Emacs使用手册【也就是通常讲的 Manual】  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":67,"section":"docs","tags":["emacs"],"title":"emacs的基本使用","uri":"https://www.wenhui.space/docs/about_emacs/emacs_useguide_aa/"},{"content":"本文 主要对正则表达式的常用语法进行整理和介绍。\n   版本 说明     0.1 初版发布   0.2 添加正则表达式在线测试网址    背景  Linux  什么是正则表达式？ 正则表达式（regular expression 简称regex），正则表达式是一种文本处理工具，用途就两种：一是进行搜索，二是进行搜索和替换。但是它比普通的搜索更强大，具体可以在如下场景中体现：\n 在某文本中搜索或搜索加替换单词car，但是并不将carry等包含car字符的单词作为目标 在某文本中搜索或搜索加替换单词car，但是只将行末位置作为目标 在某文本中搜索或搜索加替换begin****end，这里将begin和end以及中间任意字符作为目标  总之，正则表达式就是一个文本处理功能强大的工具，主要任务就是用正则表达式语言构造特定的目标来进行搜索和替换操作。但是它又不能算作一个独立的工具或语言，二是嵌入在其他语言和工具中，换句话说，其他大多数工具和语言都支持正则表达式。\n正则表达式知识点 任意字符“.”  “.”字符可以匹配任何单个字符、字母、数字以及“.”字符本身。 “.”字符可以在同一正则表达式在任意位置出现任意次数。 如果想搜索“.”字符本身，需要自“.”字符前加“\\”字符进行转义，即“\\.”。  字符集合[]  [ns]a\t匹配na和sa，将部分字符集合作为目标 [Rr]eg\t匹配Reg和reg，特定位置区分大小写和不区分大小写 [0-9]\t匹配任意数字，这里“-”为连字符（仅限于字符集合[]内，字符集合外为普通字符-），常用为0-9，A-Z，a-z [A-Za-z0-9]\t匹配任意大小写字母和数字，字符集合中可以出现多个区间 [^0-9]\t匹配非数字任意字符，取非字符“^”，主要取非的含义是对整个字符集合，而不是^后紧跟的那个集合  使用元字符  特殊字符需要转义，如\\\\匹配\\，\\.匹配.，\\[匹配[ 匹配空白字符，\\f换页符，\\n换行符，\\r回车符，\\t制表符（如匹配空白行，linux下将换行符作为文本结束标志，而windows将回车符换行符作为文本结束标志，所以linux匹配空白行即\\n\\n，windows下陪陪空白行即\\r\\t\\r\\t） 匹配某类字符，\\d匹配任何数字字符，\\D匹配任意非数字字符，\\w匹配任意字母数字下划线字符（不区分大小写），\\W匹配任意非字母数字下划线 匹配空白字符，\\s匹配任意空白字符（等同于[\\f\\n\\r\\t\\v]），\\S匹配任意空白字符（等同于[^\\f\\n\\r\\t\\v]）  重复匹配  [0-9]或\\d代表任意一个数字，[0-9]+或\\d+代表任意一个或多个连续数字 +和*和？的使用区别，+代表重复出现一次或多次，*代表重复出现0次或多次，？代表重复出现0次或1次。举例：https+匹配https和httpss…，https*匹配http和https和httpss…，https？匹配http和https。 设定重复次数，a{5}匹配aaaaa，重复5次；a{3,5}匹配aaa和aaaa和aaaaa，重复3-5次；a{3,}匹配a重复最少3次 防止过度匹配：+，*，{3,}这样的无限重复都属于贪婪型，容易造成过度匹配，举例如下，AxxxB 555 AmmmmB，正则表达式为A.*B，本意是将AxxxB和AmmmmB匹配，实际匹配为AxxxB 555 AmmmmB，显然不是我们希望的结果，在贪婪型元字符+和*和{3,}后加?可以将贪婪型转为懒惰型，如A.*?B，匹配结果为AxxxB和AmmmmB。  位置匹配  单词边界符\\b：例如匹配car，可能将carry也作为了目标，这时候需要使用单词边界，\\bcar\\b。这里对\\b的匹配说明一下，他并不知道什么是单词边界，只是找到构成单词的字符（字母数字下划线\\w）和一个不能构成单词的字符（\\W）之间位置。 字符串的边界：开头^，结尾$，比如^.*$，在语法上完全正确，而且总能匹配到一个结果，但是却无任何用途。这里字符串边界符要搭配分行匹配模式(?m)来使用的，举例说明：匹配verilog代码中的注释行内容：(?m)^\\s*//.*$，解释：(?m)分行匹配模式，将一行内容作为一个字符串处理；^字符串开头；\\s*任意一个或多个空白符，如空格、制表符、换行符等等；//为verilog中的注释符；.*为任意字符重复0次或多次，其实这里代表注释内容；$代表字符串结尾。 总之，比较难理解的是字符串边界的使用，这里对常用的几个举例：  ^\\s*：代表文本开头的有效内容处（这里有效内容是排除空行、空格、tab等） \\s*$：代表文本末尾的有效内容处（这里有效内容是排除空行、空格、tab等） 搭配(?m)作为行处理：(?m)^\\s*代表行首有效内容；(?m)\\s*$代表行尾有效内容    子表达式  什么是子表达式？举一个简单例子，as{2}匹配的内容是ass，因为{2}是以紧跟自己上一个字符作为操作对象的，而当你想匹配asas时，需要写为(as){2}，这里括号里内容就是子表达式，括号就是子表达式的标志，这样{2}以子表达式内容为操作对象。 另一举例：文本内容为1965，匹配年份数字，正则表达式为19|20\\d{2}，实际匹配到内容为19，而本意是将19xx和20xx的年份数字匹配出来，问题出在|操作，这里|或操作是将符号两边都作为整体来处理，即19和20\\d{2}，所以这里需要子表达式将19|20作为整体，即(19|20)\\d{2} 子表达式的嵌套，这里对于子表达式的嵌套没什么好讲的，就是支持无限嵌套，但是也要适可而止，以便于阅读分析。这里举个例子：匹配三个连续0-255的数字（注意，正则表达式不会有任何计算，它只关心字符），正则表达式为：((\\d{1,2})|(1\\d{1,2})|(2[0-4]\\d)|(25[0-5])){3}；这里就是将0-99，100-199，200-249,250-255分段描述。  回溯引用  回溯引用其实就是后面匹配引用前面匹配的结果，简单的就是前后一致匹配。例如：+(\\w+)+\\1，解释为+代表任意一个或多个空格；(\\w+)代表任意一个或多个数字字母下划线；+代表任意一个或多个空格；\\1为前面子表达式(\\w+)匹配的内容，这里就是回溯引用。这段表达式实际功能就是在匹配两个连续单词的出现，如and and，we we等等。 回溯引用通过\\1，\\2等来表达的，这里数字是通过相对位置来引用的，即此处\\1，代表表达式中第一个子表达式（嵌套表达式是如何暂不清楚，认为是指引用层级相同的子表达式），注意数字从1开始。 回溯引用在替换中的应用：  将电话号码重新排版，将313-555-1234和251-555-2031排版为(313) 555-1234和(251) 555-2031。匹配表达式：(\\d{3})(-)(5{3})(-)(\\d{4})，替换表达式：($1) $3-$5。 大小写转换：元字符（\\E作为结束标志；\\l把下一个字符转换为小写；\\u把下一个字符转换为大写；）举例：AaBbCcDd，匹配：([Aa]{2})([Bb]{2})([Cc]{2})([Dd]{2})，替换：$1\\U$2$3\\E$4，替换效果为AaBBCCDd（将第二第三表达式全部替换为大写）    前后查找  什么是前后查找？前后查找就是将匹配部分作为位置标记，选择前面内容还是后面内容，而作为位置标记的内容不作为匹配目标或者说不做内容提取。 向前查找?=，向后查找?\u0026lt;=，作为查找位置的匹配写在=后面，且必须作为子表达式，换句话说必须括起来，如(?=:)。 举例：http:xxxx和https:ssss，匹配：.+(?=:)，匹配结果http和https，注意无:本身。 举例：001:$0.23和002:\\(1.54，匹配：(?\u0026lt;=\\))[\\d.]+，匹配结果0.23和1.54，注意无$本身。向后匹配要注意内容的匹配条件，不要过多匹配，其实用的最多还是向前匹配，以及向前向后匹配合用。 举例：begin 12345678 end，匹配(?\u0026lt;=begin).+(?=end)，匹配结果 12345678 ，注意无begin和end。 之前描述的向前向后查找被称为正向前查找和正向后查找，除此外，还有负向前查找(?!)和负向后查找(?\u0026lt;!)，用法相同，只是将非匹配位置作为搜索条件，注意，对于使用负向前和符负向后查找时，可以适当加单词边界符\\b。举例：\\(30 for 10 apples，匹配：(?\u0026lt;!\\))\\d+，匹配结果为$30 for 10 apples，因为$30中的0并不是\\(开头，所以会作为匹配目标，只需加字符边界符\\b就可以解决：\\b(?\u0026lt;!\\))\\d+\\b。  嵌入条件  嵌入条件使用?来表示，在两种情况下使用：一是根据一个回溯引用来进行条件处理；二是根据一个前后查找来进行条件处理。 回溯引用使用嵌入条件，举例：123-456-7890和(123)456-7890，匹配：(\\()?\\d{3}(?(1)\\)|-)\\d{3}-\\d{4}，解释：(\\()?是一个可选（?为0或1个）的左括号(；\\d{3}是区号123；(?(1)\\)|-)是引用条件第一个子表达式成立则匹配右括号)，否则必须匹配-符号；\\d{3}-\\d{4}是后面7位号码。 前后查找条件的嵌入条件，举例：11111和44444-444，匹配：\\d{5}(?(?=-)-\\d{4})，解释：\\d{5}表示前五位数字；(?(?=-)-\\d{4}向前查找是否存在-，如果存在-再后续查找-\\d{4}也就是连字符-和三个数字。 总之，嵌入条件的模式还是很复杂的，建议先对该模式的各个组成部分一一调试，然后再组合到一起，还有，工作中使用到如此复杂的情况还是比较少见的，建议还是用更简单的方法实现同样的目的。  元字符列表 注意：因为org-mode下列表中“|”符号为特殊符号，为了防止描述真实的“|”符号时被转义，文中使用中文 “竖线” 替代。\n基本元字符    元字符 说明     . 匹配任意单个字符   竖线 逻辑或操作符   [] 匹配字符集合中的任意一个字符   [^] 对字符集合取非   - 定义一个区间，如A-Z   \\ 对下一个字符转义    数量元字符    元字符 说明     * 匹配前一个字符或子表达式零次或多次重复   *? *的懒惰型，懒惰型的理解可参考第五节内容重复匹配   + 匹配前一个字符或子表达式一次或多次重复   +? +的懒惰型   ? 匹配前一个字符或表达式重复一次或零次（可以理解为有无该字符）   {n} 匹配前一个字符或表达式重复n次，n为具体数值   {n,m} 匹配前一个字符或表达式重复m次至n次   {n,} 匹配前一个字符或表达式重复至少n次   {n,}? {n，}的懒惰型    特殊字符元字符    元字符 说明     [\\b] 匹配一个退格字符   \\c 匹配一个控制字符   \\d 匹配任意数字字符   \\D \\d的反义   \\f 换页符   \\n 换行符   \\r 回车符   \\s 匹配一个空白字符   \\§ \\s的反义(大写S)   \\t 制表符tab   \\v 垂直制表符   \\w 任意数字字母下划线   \\W \\w的反义   \\x 匹配一个十六进制数   \\0 匹配一个八进制数    回溯引用和前后查找    元字符 说明     () 定义子表达式   \\1 匹配第一个子表达式，若是\\2表示匹配第二个子表达式   ?= 向前查找   ?\u0026lt;= 向后查找   ?! 负向前查找   ?\u0026lt;! 负向后查找   ?() 条件if then   ?()加竖线 条件if then else    大小写转换    元字符 说明     \\E 结束\\L或\\U转换标志   \\l 把下面一个字符转义为小写   \\L 把下面字符转义为小写直至\\E   \\u 把下面一个字符转义为大写   \\U 把下面字符转义为大写直至\\E    匹配模式    元字符 说明     (?m) 分行匹配模式    其他说明 使用正则表达式的难点不在于将一个匹配情况考虑清楚并且写出一个符合要求的正则表达式，难点在于将不需要匹配的情况考虑清楚将其排除在外。\n在线测试  正则表达式在线测试  典型应用 待补充。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":68,"section":"docs","tags":["shell"],"title":"正则表达式语法简明教程","uri":"https://www.wenhui.space/docs/about_linux/language_notes/regular_expression/"},{"content":"本文 主要对日常shell脚本使用中的一些技巧进行记录。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 shell： bash  字符串替换的小技巧 在一个文件里替换一个字符串  替换结果保存在临时文件   1  sed -e s/OLDSTRING/NEWSTRING/g src_file \u0026gt;tempfile    直接覆盖源文件   1  sed -i -e s/OLDSTRING/NEWSTRING/g src_file   在一个文件里进行有条件替换 我们经常有这样的需求，对某个文件中某些参数值进行修改，比如将TRUE改为FALSE，而且有些参数的keyword可能由多个单词构成（中间空格分离）。shell中for循环的默认分隔符是：空格、tab、\\n，，根据需求选择只将\\n作为分隔符（原分隔符暂存，处理完后恢复，为的是不影响后面的脚本运行）(for语句中的shell命令用反引号包起来)\n1 2 3 4 5 6 7 8 9 10  #!/bin/bash IFS_OLD=$IFS IFS=$\u0026#39;\\n\u0026#39; for key in `cat keywords`; do sed -i \u0026#34;/${key}/s/TRUE/FALSE/g\u0026#34; src_file done IFS=$IFS_OLD   在一组文件里替换一个字符串 1 2 3 4  for file in `cat flist` do sed -i -e s/OLDSTRING/NEWSTRING/g ${file} done   在一个文件里替换一组字符串 1 2 3 4  sed -i -e s/OLDSTRING1/NEWSTRING1/g \\  -e s/OLDSTRING2/NEWSTRING2/g \\  -e s/OLDSTRING3/NEWSTRING3/g \\  src_file   更多无耻要求 更多无耻要求可以基于以上简单脚本进行嵌套实现，不再一一说明。\n其他方案：Emacs 如果你是Emacs用户的话，可以使用emacs的批量替换，具体可查看我的另一篇帖子 emacs的使用技巧记录中 “Emacs 批量查找与替换” 章节。Emacs 批量查找与替换功能操作起来虽然比其他软件繁琐许多，但是你可以详细的看到要被替换的项，这一点相对于单纯的脚本替换是有安全性的。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":69,"section":"docs","tags":["shell"],"title":"shell脚本使用记录","uri":"https://www.wenhui.space/docs/about_linux/script_notes/shell_script/"},{"content":"本文 主要介绍hugo和记录hugo的安装过程。\n   版本 说明     0.1 初版发布   0.2 添加特别说明 和 分享hugo_extended_0.65.3_Linux-64bit.tar.gz    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  Hugo中文文档  什么是hugo？ Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。简单来说就是你可以用它来生成自己的博客站点，而且安装极简单，无依赖。类似此功能的工具还有Hexo，， Jekyll, Ghost，我强烈推荐Hugo。更多内容可以查看Hugo中文文档。\n安装hugo 下载 推荐二进制安装，也就是直接下载可执行程序，方便简单。\n 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） 采用我的百度网盘分享资源（里面包含hugo_0.58和extend_hugo_0.61两个版本，选其一即可） 链接：https://pan.baidu.com/s/1ub-6LSw9VABaf0GNe7oeGQ 密码：pvb4  安装 将下载的文件解压，找到hugo文件，将其放入 “/usr/local/bin/” 目录，若其为非可执行文件，请更改文件属性。可参考以下执行命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./hugo #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./hugo /usr/local/bin/hugo   特别说明 如果使用某些主题时，提示HUGO版本不支持某些特性，首先考虑自己的版本是不是太低，然后最可能的情况是需要安装扩展版本。\n如错误信息为：\nBuilding sites … ERROR 2020/03/06 14:23:59 Transformation failed: TOCSS: failed to transform \u0026quot;main_parsed.scss\u0026quot; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information Built in 218 ms Error: Error building site: logged 1 error(s) 这里分享一个 hugo_extended_0.65.3_Linux-64bit 版本： *链接：https://pan.baidu.com/s/1DUleZmjcLCl7wJP9i3smJA 密码：n86i*。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":70,"section":"docs","tags":["hugo"],"title":"hugo的安装","uri":"https://www.wenhui.space/docs/install_software/install_hugo/"},{"content":"本文 主要介绍图床工具PicGo和记录PicGo的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 PicGo版本： picgo-2.1.2-x86_64.AppImage  参考  在Linux上安装PicGO  什么是PicGo？ PicGo是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。网络上的图床工具有很多，PicGo算得上一款比较优秀的图床工具了，它可以支持微博， 七牛云， 腾讯云COS， 又拍云， GitHub， 阿里云OSS， SM.MS， imgur 等8种常用图床，功能强大，简单易用。\n为什么安装PicGo？ 写博客内容时，常常会用到图片，最初是将图片放在本地并随博客public一同上传至github，但是在本地网址显示好好的图片，上传至github就打不开了，其主要原因还是因为填写的是相对地址，上传github后，往往地址会发生变化，导致图片索引不到，所以只好通过图床工具转化为链接，作为全路径添加到博客内容，这样就可以解决了。网上搜索了一下图床工具，好像PicGo有点独步天下的意思，网上评价PicGo是最好的图床工具，没有之一。所以，开始折腾起来，下载安装。\n安装过程 下载PicGo  去PicGo官方github页面下载最新版本的PicGo，我这里选择的是picgo-2.1.2-x86_64.AppImage 采用我的百度资源分享 链接：https://pan.baidu.com/s/14ZhG87VBDfNi9w7%5FK4my1A 密码：4zvy ，另附有一张logo图  安装 安装很简单，其实下载的就是一个可执行程序，放到自己的 系统变量PATH 即可，我习惯是放在 “/usr/local/bin/” 。打开终端进入下载解压后的picgo目录，执行以下命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./picgo-2.1.2-x86_64.AppImage #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./picgo-2.1.2-x86_64.AppImage /usr/local/bin/picgo   添加到启动器 可参考另一篇帖子 将软件添加到deepin启动器 。\n安装依赖 虽然PicGo已经开始运行了，可是有些功能需要依赖其他程序来实现。在程序内实现粘贴板上传需要用到xclip，不装的话会报 \u0026ldquo;xclip not found\u0026rdquo; 的错误。可以通过包管理器安装，命令如下：\n1  sudo apt install xclip -y   ","description":"","id":71,"section":"docs","tags":null,"title":"PicGo的安装","uri":"https://www.wenhui.space/docs/install_software/install_picgo/"},{"content":"本文 主要介绍词典工具GoldenDict和记录GoldenDict的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 GoldenDict版本：1.5.0-RC2+git  参考  安装使用 GoldenDict 查词神器  什么是GoldenDict？ GoldenDict是一款优秀的的词典软件，其特点如下：\n 免费 纯净无广告 跨平台：Windows / Mac / Linux 支持多种词典格式 支持查维基百科 / 支持在线翻译（需配置） 支持屏幕取词 支持听取 forvo.com 上的发音 更多特点可详见GoldenDict 官网    GoldenDict就是它了    安装GoldenDict  可选择使用deepin软件商店安装，操作简单 可通过软件包管理工具下载（版本不一定是最新的，但应该比软件商店提供的版本新，安装后按需手动添加到启动器），命令如下：   1 2 3 4 5  # Ubuntu / Debian sudo apt install goldendict -y # CentOS sudo yum install goldendict -y   添加离线词典  下载词典 ，我这里使用的是三个词典，百度网盘分享资源 链接： https://pan.baidu.com/s/1wXbxsUlLLsGl9namvO4q-g 密码：45o3  en-zh：牛津现代英汉双解词典 zh-en：朗道汉英字典 zh-zh：新华字典   存放词典 ，解压后根据个人喜好选择存放位置，且后续不能移动，我这里放在 “~/Treasury/tools_and_drives/GoldenDict/” 下 导入词典 ，菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【文件】\u0026gt;【添加】 ，选择上一步的词典位置打开，并勾选上递归搜索，点击 “重新扫描” 完成后点击 【应用】 即可 功能测试 ，在搜索栏分别输入“you”和“你”，回车，查看翻译结果。  添加网页翻译（有道）  菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【网站】\u0026gt; 【添加】 ，输入名称为“youdao”，输入地址， 勾选已启用，点击 【应用】 。 地址内容为“http://dict.youdao.com/search?q=%GDWORD%\u0026amp;ue=utf8” 功能测试，在搜索栏输入“you”，回车，查看youdao翻译结果 也可以使用其他网页翻译以及搜索引擎  添加google翻译（translate-shell） 以上添加的离线词典只能翻译词典里存在的词汇，不能对整句整段进行翻译，而有道翻译的页面广告多，让人不舒服，所以我们为词典添加一个google翻译。translate-shell是命令行版google翻译，在终端命令行可以直接通过 “trans” 命令使用，也可以将命令添加到GoldenDict使用。\n下载安装 translate-shell 安装方法有三种：\n 直接下载可执行文件，百度网盘分享资源 链接：https://pan.baidu.com/s/1kQYl%5F%5FhptxA5X0k9h7ZYcg 密码：sxeq ，打开终端进入下载目录，执行以下命令：   1 2  chmod 755 ./trans sudo mv trans /usr/local/bin/    手动安装，下载trans_shell安装包，以下是使用git工具进行下载，也可以登录网址通过浏览器下载压缩包，或使用我的百度网盘分享资源 链接：https://pan.baidu.com/s/1aHXNwKm6QYcXMtuk77roPg 密码：yzxu ，安装命令如下：   1 2 3 4  git clone https://github.com/soimort/translate-shell cd translate-shell make sudo make install    通过包管理器安装，命令如下：   1 2  sudo apt install translate-shell which trans   trans_shell的使用 本文目的主要是安装trans_shell给GoldenDictionary使用，不过在终端也可以使用，使用方法如下：\n1 2  trans en:zh \u0026#39;Hello World\u0026#39; trans zh:en \u0026#34;你好\u0026#34;   为GoldenDict添加trans_shell 菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【程序】\u0026gt; 【添加】 ，类型选择纯文本，勾选已启用，名字（可以自己命名）与命令行内容如下：\n 名字：google_2_en  命令行：trans -e google -s auto -t en-US -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”   名字：google_2_zh  命令行：trans -e google -s auto -t zh-CN -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages n -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”    填写完之后点击 【应用】 即可。\n为GoldenDict分组 分组的目的是为了方便快速翻译，更加快速准确的找到自己想要的内容。菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【群组】 ，此时左栏会看到已启用的词典（牛津现代英汉双解词典、google_2_zh、youdao、新华字典、朗道汉英字典5.0、google-2-en）。点击 【添加群组】 ，进行命名，选择词典加入该群组，并且可以在群组内调整词典的优先级，也可以根据个人需求为群组设置快捷键。我的分组如下：\n en_zh： google-2-zh、牛津现代英汉双解词典 zh_en： google-2-en、朗道汉英字典5.0 zh_zh： 新华字典 youdao： youdao    给词典进行分组    使用技巧 快捷键 Ctrl+C+C ，翻译剪切板中的内容，通过鼠标或快捷键选择群组，快速找到想要的内容。更多快捷键、屏幕取词以及其他使用技巧，可查看 【编辑】\u0026gt; 【首选项】 。（个人不太喜欢屏幕取词，工具会自动调用 Ctrl-C 命令，在终端中会误杀死进程）\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":72,"section":"docs","tags":null,"title":"GoldenDict的安装","uri":"https://www.wenhui.space/docs/install_software/install_goldendict/"},{"content":"本文 主要介绍了如何将手动安装的软件添加到deepin启动器中显示。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  操纵过程 手动安装的工具可在终端运行，但对于某些软件来说使用不方便，也可以将可执行程序放在桌面，但是又使桌面不整洁美观，也可以添加至任务栏，但会导致任务栏工具繁多杂乱，最好的方式就是将其加入到deepin的启动器，以firefox为例，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Name、Icon、Exec、Categories、Comment，其他建议不要修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":73,"section":"docs","tags":["deepin"],"title":"将软件添加到deepin启动器","uri":"https://www.wenhui.space/docs/install_software/add_software_to_deepin_launcher/"},{"content":"本文 主要介绍firefox浏览器和记录firefox浏览器的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  参考  deepin linux如何安装最新版firefox火狐浏览器 firefox帮助中心 firefox官网  什么是firefox？ Mozilla Firefox，中文俗称 “火狐” ，是一个自由及开放源代码的网页浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS X及GNU/Linux等。\n为什么选择firefox？ firefox浏览器有如下特点：\n 风格简洁，同时支持多主题，可自行选择 据说相对其他浏览器，启动速度慢（这一点我没有明显体验，大多数用户的浏览器处于常开状态，启动速度也就无关紧要了） 安全性高，有隐私保护机制，拦截多种常见的跟踪器和有害的脚本，减少第三方搜集浏览行为数据的能力 拓展性强，有丰富的拓展性插件支持 多平台支持，同步数据无障碍  选择firefox主要因为其两个特点，一是丰富的插件，虽然谷歌插件也很丰富，但国内环境无法访问应用商店，导致安装起插件来比较麻烦，所以放弃；二是多平台支持，支持Linux、Windows、Mac OS以及移动端，同步数据无障碍。\n安装firefox deepin的软件商店自带firefox浏览器，不过不是最新版的，通过软件商店安装firefox就不介绍了，只介绍手动安装过程。\n 打开firefox下载中心，不要点击 “立即下载” ，而是点击下方 “高级安装选项和其他平台” ，选择 “Linux 64-bit” 进行下载 将下载的最新版的firefox压缩包进行解压 打开文件管理器，并进入刚刚解压后的目录，双击运行目录下的 \u0026ldquo;firefox\u0026rdquo; 可执行文件，firefox浏览器就启动了 在任务栏中右键点击firefox，选择驻留可添加至任务栏，也可以将执行程序发送到桌面 将firefox可执行文件放在 \u0026quot;/usr/local/bin/” 目录，可以在终端命令打开firefox，命令就是 “firefox”  如何将firefox添加至deepin的启动器 如果不想将firefox的可执行程序放在桌面，影响美观，又不想添加至任务栏，导致任务栏工具繁多，可以选择将其加入到deepin的启动器，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Icon和Exec两项，其他无需修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":74,"section":"docs","tags":["firefox"],"title":"firefox的安装","uri":"https://www.wenhui.space/docs/install_software/install_firefox/"},{"content":"本文 主要介绍git和记录git的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 git版本： git version 2.11.0  参考  Deepin 系统下安装git  什么是Git？什么是Github？ Git是一个帮我们管理文件版本的程序，专业名称叫：分布式版本控制系统。GitHub是基于git的代码库托管站，也算是程序员的SMS（以码会友），其中一个主要的开源代码发布或托管站git的作用就是对文件进行版本管理，方便在不同版本进行切换修改，类似文件分不同时间备份然后需要时可以找回其中一个版本。GitHub某种程度上就是代码的网盘，也有开源开发商作为代码发布、存放、征集Bug和意见用。类似于相同功能的，国内版为Gitee（码云）。\n对了，还有人称gitub为世界上最大的同性交友网站，貌似也有道理。\n下载Git 打开终端，命令行输入以下命令，然后等待系统自动安装：\n1  sudo apt install git   结束后在终端输入命令 “git \u0026ndash;version” ，查看git是否安装成功，输出版本号则代表安装成功。\ngithub的使用指南 登录github，会显示 Learn Git and GitHub without any code! ，点击 Read the Guide 可查看使用指南，会点击这里。\ngit的使用指南 创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    克隆仓库到本地 github每个仓库页面都会有一个 [Clone or download] 绿色图标，点击后复制自己仓库的 \u0026quot;https://github.com\u0026hellip;\u0026hellip;/\u0026quot; 链接（其实就是仓库e页面网址后加.git），打开终端输入以下命令\n1  git clone https://github.com/......   等待克隆完成（终端会显示进度），克隆完成后在本地会看到自己的仓库文件。\npush 和 pull 首先搞清楚两个概念，本地仓库和远程仓库，本地仓库也就是你本地电脑的文件了，远程仓库就是指github。 pull 就是将远程仓库的最新文件下拉到本地（会输入用户名和密码），命令如下：\n1  git pull   push 就是将本地文件上传到远程仓库，不过需要经过三步，一是add，添加追踪或修改的文件，也就是想要把哪些文件提交上去就进行添加；二是commit，添加提交注释，提交到缓存区；三是push，刚刚提交到缓存区，也仅仅是在本地，我们需要上传到远程仓库。命令如下(会输入用户名和密码)（其中 add . 是指添加本地所有文件，也可以指定某文件，输入路径和文件名即可）：\n1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push   详细使用技巧 至此，其实已经可以基本使用git了，其他详细使用技巧请期待后续帖子更新。也可以参考网上教程廖雪峰git使用教程。\n","description":"","id":75,"section":"docs","tags":["git"],"title":"git的安装","uri":"https://www.wenhui.space/docs/install_software/install_git/"},{"content":"本文 主要介绍emacs和记录emacs的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本： Linux GNU Emacs 26.3  什么是emacs？ emacs是一款功能强大的编辑器，被公认为是最受专业程序员喜爱的代码编辑器之一，而另一个就是vim，在业界vim被称为编辑器之神，而emacs被称为神之编辑器。对于初学者可能都有这样的疑问，那就是究竟是Vim还是Emacs好呢？这样的问题已经争辩了十几年，但至今无解，不过为了让初学者有一定的了解，还是做个简单介绍。\nVim ：\n 开箱即用，大多数操作系统自带，不需要安装 体量小，启动快 采用双模式（命令模式和编辑模式），这样按键组合少，但是要频繁进行模式切换 vim的上下左右jkhl，右手控制相对舒服 相对emacs使用人群多，配置和使用技巧可参考内容较多  Emacs ：\n 需要自己安装，碰到依赖库的问题，还是有点麻烦的 体积大，启动慢，但功能强大 主模式操作，不用切换模式，但按键组合就多了，Ctrl、Alt、Shift是离不开的，让你的小拇指粗壮起来 emacs的上下左右pnbf放在了两个手，还要配合Ctrl键，需要适应 缓存机制个人感觉很有用 可扩展性极强，可重新定义变量和快捷键绑定，可自己定制插件，也可通过内置的包管理系统安装和卸载大神们的插件，目前可使用的插件还是很丰富的 不同的语言环境对应不同的模式，每个模式都有自己独特的功能，本人最常用的就是org-mode和verilog-mode，org写工程日记，verilog就不说了，IC工程师离不开的  总之，Vim和Emacs功能都很强大，选择一款适合自己的编辑器即可。\n安装emacs 下载emacs安装包  可查看emacs官网或国内镜像文件，当前最新版本是emacs-26.3（更新时间29-Aug-2019) 可查看我的百度网盘分享资源(linux emacs-26.3版本) 链接：https://pan.baidu.com/s/1VZ88kGZpBiC59qGU7sk7tA 密码：lki0 可直接使用我的可执行程序，无需安装，将其放在自己的 “/usr/local/bin/” 目录即可，百度网盘分享资源 链接：https://pan.baidu.com/s/18K8WNnr5ytIkx%5Fe7n%5FuAcQ 密码：rrtt  安装依赖库 开启终端，输入以下命令，安装相应的依赖库。\n1 2 3 4 5  sudo apt-get install libgtk2.0-dev --fix-missing sudo apt-get install libxpm-dev sudo apt-get install libjpeg62-turbo-dev sudo apt-get install libgif-dev sudo apt-get install libtiff5-dev   编译和安装 开启终端，进入emacs安装包目录，输入以下命令：\n1  sudo ./configure   已经安装了相应的依赖，此时应该不会发生error，经过configure后，执行以下命令：\n1 2  sudo make sudo make install   查看是否安装成功 终端中输入以下命令：\n1  emacs --version   正常显示emacs版本号，即安装成功，安装的可执行程序默认在 “/usr/local/bin/” 。\n启动emacs 启动命令为 emacs ，如下：\n1  emacs ~/Destop/demo.txt   启动页面会有简单的使用说明，熟悉熟悉即可上手操作。\n  emacs启动页面      emacs org mode    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":76,"section":"docs","tags":["emacs"],"title":"emacs的安装","uri":"https://www.wenhui.space/docs/install_software/install_emacs/"},{"content":"本文 主要介绍如何为deepin系统安装 rtl8821ce 无线网卡驱动。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11 无线驱动：rtl8821ce  参考  LINUX 下无线网卡 rtl8821CE/rtl8723de 驱动 无法驱动解决办法  查看自己的网卡型号 在终端输入以下命令：\n1  dmesg | grep -i eth   显示如下：\n1 2 3 4 5 6 7 8 9 10  [18690.091602] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19611.409023] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19669.877403] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19974.291420] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20093.240319] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20484.342884] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20605.303770] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20893.593415] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20937.945192] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20990.361341] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000   下载驱动  rtl8821CE git源网址 rtl8723de git源网址 百度网盘分享资源（rtl8821CE） 链接：https://pan.baidu.com/s/1zkMNEdvtXpuh8PnnJkfkLQ 密码：gxwh  安装驱动  解压rtl8821ce.zip 修改 Makefile 文件，将 TopDIR 变量改为 Makefile 文件所在路径，如下：   1 2 3  export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce #modify to export TopDIR ?= /home/caowenhui/Treasury/tools_and_drives/wireless/rtl8821ce    安装，打开终端，进入Makefile所在路径，输入以下命令：   1 2 3  make sudo make install sudo modprobe -a 8821ce   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":77,"section":"docs","tags":["deepin"],"title":"为deepin系统安装无线网卡驱动","uri":"https://www.wenhui.space/docs/install_software/install_rtl8821ce_wireless_drive/"},{"content":"本文 主要介绍deepin系统和记录deepin系统的安装过程。\n   版本 说明     0.1 初版发布    参考  deepin官网-如何安装 实操：安装深度DeepinLinux桌面操作系统（替代微软Windows的国产开源系统）  背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11  什么是deepin？ deepin操作系统是由武汉深之度科技有限公司开发的Linux发行版。deepin操作系统是一个基于Debian的Linux操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。它包含了所有您需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等。以上内容摘自百度百科，了解详细信息可登录deepin操作系统官网。\n简而言之，deepin是基于Debian内核、简单易用又美观的Linux操作系统，适合轻量应用的普通用户和初识Linux的学习者。deepin从使用习惯上是最接近Windows的Linux操作系统，它自带应用商店、文件管理器、系统监视器、深度截屏、深度录屏、深度录音、深度影院等等，深度应用商店中提供的软件还是很丰富的，涉及网络应用、社交沟通、音乐欣赏、视频播放、图形图像、游戏娱乐、办公学习、阅读翻译、编程开发和系统管理，比如微信、QQ、百度网盘、迅雷、网易云音乐等都可以使用，但是有些软件版本较低且部分功能不支持，不过好在还是可以用的，你也可以通过手动安装最新版本，也可以发掘其他好玩好用的Linux版软件。这里说一下，deepin对游戏支持不太好，如果玩游戏的话建议还是整个Windows稳定环境吧。\n安装deepin 下载安装包和启动盘制作工具 打开deepin官网下载页面，下载ISO镜像文件，我选择的是左边第一个的 “官方下载” ，启动盘制作工具下载链接在deepin官网下载页面最下面的 “下载深度启动盘制作工具” ，或者点击这里。官网下载的深度启动盘制作工具在Windows下运行总是提示内存无法访问，不知道其他使用者情况，我再提供一个自己使用过的启动盘制作工具，百度网盘分享资源 链接：https://pan.baidu.com/s/1ph70bhA4h70cgB1PLoxPOg 密码：mphc 。\n制作启动盘  准备好一个不小于8G的U盘，最好格式化 插入准备的U盘并打开启动盘制作工具，选择深度操作系统镜像文件以及准备好的U盘，这里会有勾选项 “格式化磁盘可提高制作成功率” ，若之前U盘未格式化，在备份好内容的前提下建议勾选上 点击 “开始” 即可制作  准备分区 我的存储系统是一块256G的固态硬盘，现在要压缩出50G给deepin系统使用，方法如下：\n 选中 “此电脑” ，右键选择 \u0026ldquo;管理\u0026rdquo; ，然后选择并打开 “磁盘管理” 选择要压缩的磁盘，我这里就一个256G盘，也就没什么选择的了，然后右键选中 “压缩卷” ，输入压缩空间大小，单位是MB，50G=1024MBx50=51200MB，点击 “压缩” 这里出现了一个未分配的50G磁盘，这就是留给deepin使用的磁盘空间了  安装系统  将制作好的启动盘插入电脑 重启电脑，在屏幕处于黑屏状态时连续敲 F12（Fn+F12） ，进入启动项选择页面，选择插入的U盘，回车 系统进入安装界面，选择需要安装的语言，简体中文 进入账户界面，输入系统用户名和密码 点击 “下一步” 进入选择安装位置页面，这里选择之前压缩出的未分配磁盘，并且选择默认的 “简单” 安装即可，若对Linux磁盘分区有了解的话可以选择 “高级” ，因为是双系统，所以不建议选择 “全盘安装” ，可能会影响Windows系统的数据。 点击 “继续” ，系统开始自动化安装了 安装完成后，拔掉U盘，开始体验deepin吧    deepin主页      deepin启动器      deepin应用商店    开机启动 安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，第一选项是deepin，其他选项有Windows和硬盘等，默认等待时间是5秒，在5秒内可以选择进入win10系统还是deepin系统，不选择默认第一启动项deepin。\n如何删除deepin系统 有可能deepin安装体验后，并不喜欢，没关系，我们可以删除它。\n删除磁盘：\n 重启电脑，在启动页面选择Windows启动，进入Windows系统 选中此电脑，右键选择管理，然后选择并打开磁盘管理，选中deepin的磁盘，右键选择删除卷 原deepin磁盘此时处于未分配状态，选择要扩展的磁盘（未分配空间会添加到此盘），右键选择 \u0026ldquo;扩展卷\u0026rdquo; ，进入使用扩展向导 点击 “下一步” ，选择扩展的空间容量，这里一般选择最大值即可，设置完毕，点击 “下一步” 完成扩展向导，点击 *“完成”*，即可扩展成功，扩展之后发现扩展磁盘空间增大了  设置开机启动顺序：\n安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，虽然删除了deepin的磁盘，但还会进入deepin的开机引导页面，这样会出现问题，所以需要修改开机启动项顺序。方法如下：\n 重启电脑，在屏幕处于黑屏状态时连续敲 F1（Fn+F1） ，进入BIOS页面 通过左右键选择 “Startup” 在 “Startup” 页面选择 “Boot” 项，回车 当前 “deepin” 是第一项，此时将 “Windows Boot Manager” 设为第一项 按 “F10” ，保存并退出 重启电脑，此时电脑直接进入Win10系统，与安装deepin系统前一样  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":78,"section":"docs","tags":["deepin"],"title":"deepin系统安装","uri":"https://www.wenhui.space/docs/install_software/install_deepin_os/"},{"content":"本文 主要介绍购买笔记本电脑前的选择和购买后的使用测评。\n   版本 说明     0.1 初版发布    背景 购置需求 本人IC工程师，但不会在个人电脑运行大型软件，不爱好游戏，不涉及图像视频相关工作，主要应用场景也就是轻量办公和轻量娱乐，所以对性能要求不高，对显卡要求不高，对屏幕显示要求不高。最大的要求就是小巧轻便，续航能力强，不想再背着联想大G跑来跑去了。\n购置理由 最终选择了这款Thinkpad S2，其购置理由如下：\n 13.3英寸，1.47Kg，厚度19.1mm，满足小巧轻便要求。 待机时长5~7小时，满足续航要求。 黑色机身，经典Thinkpad外观，商务风格（由于只有A面是金属的，其余为塑料材质，感觉银色款缺少了金属质感，所以放弃）。 接口丰富，USB3.0，Type-C，HDMI，同时具有可扩展性，足够满足日常使用（好像大多数电脑都满足这些要求了）。 可升级，ThinkPad的电脑的内存和存储都是可以升级的，内存最大升级为32G，所以买了基本配置8G+256G，后续可升级。 价格中等，6000上下，可以接受  为什么  为什么处理器不买i7？ 太贵！！！ 为什么不买x1？ 太贵！！！  图片 外观   Black Boy    接口   接口展示    参数    部件名称 部件描述     CPU型号 i5-8250U   CPU主频 1.60GHz   最高睿频 3.4GHz   总线规格 4 GT/s   CPU缓存 6 MB   核心/线程数 4/8   制程工艺 光刻 14nm   指令集 64-bit   功耗 15 W   内存容量 8GB   内存类型 2400MHz DDR4   插槽数量 2个内存插槽（一个插有8G内存，另一个空余供升级使用）   最大内存容量 32GB（每个插槽最大16GB）   硬盘容量 256GB (M.2 SSD) (可升级)   光驱 无   触控屏 不支持   屏幕尺寸 13.3英寸   显示比例 16:9   屏幕分辨率 1366x768   屏幕技术 LED背光TN显示屏，防眩目显示屏   显卡类型 集成显卡   显卡芯片 Intel UHD Graphics 620   显存容量 共享系统内存   DirectX版本 DirectX 12   摄像头 720p 高清摄像头   音频系统 HD Audio，Realtek ALC3287 codec   扬声器 立体扬声器 2Wx2   麦克风 DualArray Microphone（内置双阵列麦克风）   无线网卡 支持802.11AC协议的无线网卡   有线网卡 内置Intel Ethernet Connection I219-V（Jacksonville）   蓝牙 无线网卡集成   数据接口 2个USB3.0 Gen1（其中一个为Always On），2个USB3.0 Type-C   视频接口 HDMI   音频接口 Combo jack（麦克风/耳机二合一接口）   读卡器 MicroSD 读卡器   指纹识别 支持   键盘 6行全尺寸键盘（不带背光）   电池类型 3芯45Wh   续航时间 5-7小时   电源适配器 65W USB C型 AC Adapter   预装操作系统 Win10家庭中文版64位   WWAN 不支持    使用测评  整机算是比较轻，但算不上薄，毕竟不是超级本，不过也是thinkpad中小巧轻便的了，整体不错。 机身材料只有A面是金属的，其它全是塑料材质，这个买之前就已经知晓了，不过选的黑色款，外观还不错，不知道银色款怎么样，唯一的吐槽点是开箱时塑料味稍微有点大。 接口丰富，一个USB给无线键鼠使用，一个可供存储读取使用，其中一个USB口是Always On的，也就是在关机时直插可以给手机充电，两个Type-C都可以充电，HDMI可扩展屏幕，还有mini网口和SD卡读口，足够满足日常需求了，个别需求需要另购扩展坞或转换头。 电池续航能力亲测可以，满足日常办公待机5～6小时，可以设置电池充电至90%，这样接电源使用对电池比较好。 键盘手感还可以，本人要求不高，中间的红色指杆，是ThinkPad经典标志，不过我觉得现在挺鸡肋的，反正我不会去用，触控板已足够。 网上有人说风扇和散热的问题，我这里没发现什么异常 在Win10系统，无线网不自动刷新连接，手动刷新有时候找不到自己的网络，估计也不是电脑的问题，回头重装系统试试。 联想客服，可以添加微信公众号，绑定自己的设备，有啥问题都可以咨询人工客服  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":79,"section":"docs","tags":null,"title":"My Black Boy","uri":"https://www.wenhui.space/docs/install_software/thinkpad_s2/"},{"content":"  这就是我了    你好，欢迎来到这里，我叫文辉，一位一直从事于CPU行业的IC工程师，这是我的个人博客站点，在此总结一些技术经验和记录生活中的点点滴滴。\n关于我 漂于北京的雄安土著 我是一个漂于北京的雄安土著。2017年4月1日，我多了个称号 “雄安土著” 。当时我还在西安上学，成立雄安新区的消息竟然还是室友告诉我的，想想也是有意思。2017年8月，我来到了长沙工作，一年后又到了北京，成为了一只漂于北京的雄安土著。\nCPU行业从事者 我是一个CPU行业从事者。CPU的启蒙是从 “计算机组成原理” 这门课程开始的，紧接着完成了 “基于MIPS指令集的多周期处理器” 的课程设计，对处理器产生了浓厚的兴趣，后续又完成了 \u0026ldquo;兼容ARM指令集的五级流水处理器\u0026rdquo; 的毕业设计，期间还读了一本姚永斌先生写的 《超标量处理器设计》 一书，对现代处理器的设计有了基础认识。毕业之后顺利进入一家处理器设计公司，任职 微处理器逻辑设计工程师 ，开启了我CPU领域的职业之旅。在长沙工作期间，要特别感谢王老师、高老师、赵老师、郑老师对我工作的指导，使我有了很大的进步。一年后来到北京，从事了一段时间CPU验证工作，要特别感谢文彬师兄，在CPU验证方面传授了很多经验给我，也感谢浩哥，从北京CPU产业方面了解到很多东西，相对于从前的我，视野更开阔了。更要感谢我的女朋友，对我一直以来的支持和鼓励，包括对一个工科男的包容和理解。总之，我很荣幸从事于自己喜欢的CPU行业，也很荣幸有一路帮助我的人们，我会一直坚持在CPU领域努力前行。\nEmacs User 我是一个忠实的 Emacs User 。开始使用Emacs是受王老师推荐，演示了一版 verilog mode 中 AUTO机制 的惊艳操作，从此开始成为一名 Emacs User 。对于 emacs 我主要使用 org mode 和 verilog mode ， org mode 主要用来写博客写笔记，支持大纲浏览和导出各种格式； verilog mode 主要用于代码编辑， AUTO机制 可实现自动顶层连线、自动声明端口列表、自动声明连线等等。\n美食爱好者（吃货） 我是一个美食爱好者（吃货）。本人自出生以来就喜欢吃，喜欢吃肉，喜欢吃甜食，绝对的 资深吃货 。出去旅游必去的是小吃街：\n 在西安吃过泡馍（包括小炒泡馍，牛羊肉泡馍，葫芦头泡馍\u0026hellip;）、葫芦鸡、定家小酥肉、贾三灌汤包、水盆羊肉、胡辣汤、葱油饼、凉皮、肉夹馍、油糕、柿饼、甑糕、各种面食\u0026hellip;\u0026hellip; 感觉可以发一个长帖了 “论在西安的吃喝四年（读大学）” 。 在兰州吃过灰豆、牛肉饼、甜蓓子、酿皮、牛肉面，都好吃，不过甜蓓子吃了不少，火车上我肚子胀的跟小皮球儿似的，难道在我肚子里发酵了 在天水吃过荞面凉粉、天水呱呱，不过个人不太喜欢，在天水吃的最好吃的竟然是永和豆浆的红烧肉盖饭 在洛阳吃过丸子汤，汤是牛肉汤，丸子焦酥，美味极了 在邢台吃过石头饼，很好吃 在长沙吃过小龙虾、辣椒炒肉、带皮羊肉、卜豆角炒肉、卜辣椒炒肉、梅干菜扣肉饼、糖油粑粑、葱油粑粑、臭豆腐\u0026hellip;\u0026hellip; 在我老家，要说好吃的，我强烈推荐五香流油烤鸭蛋和小鱼咸菜加贴饼  生活在一个地方，最喜欢逛的是菜市场和超市，在西安，我认识了火晶小柿子，认识了拐枣，认识了秦椒\u0026hellip; 在长沙认识了花生芽、擂辣椒、卜豆角、卜辣椒、凉薯、红菜苔、白菜苔、腊鱼腊肉和腊肠\u0026hellip; 在北京好像更国际一些，五道口的帝玛进口超市，认识了更多西餐使用的罗勒酱、迷迭香、鱼露、各种果醋、日本酱油、小洋葱\u0026hellip;\n对于吃，我还有个小癖好，那就是收集老菜谱，那些破烂的、发黄的、散发着陈年油墨味的老菜谱，就是我的收集对象了。目前我也收集了十几本老菜谱了，包括六十年代、七十年代、八十年代、九十年代，也有手写油印版的，也许研究他们就是我老了以后的主要工作了。\n在北京，一个不大的出租屋里，我却置办了很多炊具，想吃炒菜买了炒锅，想吃米饭和粥买了电饭锅，想吃粉蒸肉买了电蒸锅，想吃鸡蛋饼买了电饼铛，想吃红烧肉买了电压力锅，想喝豆浆买了豆浆机，想吃烤肉买了烤箱，不知道下一个我要买的会是什么。\n台球爱好者 我是一个台球爱好者。说到台球，不得不讲我大学期间的三个目标， “爱上一座城市 爱上一个人 爱上一项运动” ，完成这三个目标的大学生活才是圆满的。如果单从一项运动来讲，没有比在悠哉的大学生活时期去培养更适合了，我已经充分感受到了工作中的忙碌，很难有足够的时间和精力去认真学习一项运动，比如台球。\n我是从大三开始打台球的，那时候找来教学视频，一点点学起，包括手架、握杆、站位、瞄点、发力\u0026hellip;\u0026hellip; 不得不说，台球技巧性很强的，要想学好需要花费不少的时间和精力。我之前看的教学视频是庞卫国老师的，不过是斯诺克教学视频，本人也很喜欢庞卫国老师的解说，尤其是和主持人姜毅搭档。现在教学视频也多了，可以看看前斯诺克职业球手刘松的，还有新锐台球教练王桁的，也可以关注他们的公众号。以前看直播是在星期五台球网，现在有中国体育直播APP方便了，基本所有赛事都有直播，包括八球和斯诺克，而且一般的斯诺克赛事刘松都会主播，刘教练划线很准的。顺便说一句，我的球杆就是野豹中国体育定制款的，千元球杆，打感还可以。\n我平时斯诺克比赛看的多一些，八球比赛很少看，喜欢的球员当然是火老师，打球那叫一个行云流水，还有墨菲，喜欢他打球的节奏，还有中国一哥丁俊晖，喜欢的八球球员就是二宝郑宇伯，打球就两个字 “痛快” 。近年来国内台球很热，好多年轻小将涌现，进入斯诺克职业赛了，比如颜丙涛、周跃龙、袁思俊、赵心童、雷佩凡、斯佳辉\u0026hellip; 斯佳辉是刘松教练的徒弟，雷佩凡是陕西安康人，我室友也是安康人，还记得大二时跟他回家玩，去球厅看到小小的雷佩凡一个人在练球，那年他十一岁，如今也是职业球手了。今年的世界斯诺克中国公开赛在北京国家奥林匹克体育中心体育馆举行，我终于圆了自己一个梦想，看了一次现场斯诺克比赛，前几轮比赛的票价很便宜，毕竟斯诺克是小众运动，我买了99元票坐到了199的位置，还记得当时包括我只有两个观众看了布雷切尔的比赛，下半场我就偷偷溜到二号台，看了马叔两杆破败一杆50+，不过没坚持到比赛结束，太晚了就回家了。斯诺克的票价真的不贵，你可见过黄牛票都打折。在北京的朋友可以看一看中国公开赛，一般举行时间是4月1日到4月7日。\n再来说一说为什么喜欢台球。首先台球是一项绅士运动，不像足球篮球碰撞性那么强，我怕把别人撞坏了，更怕别人把我撞坏了。打台球最让人极致舒适的不是一杆进洞，而是一杆进洞的同时伴随着漂亮的走位，对白球的控制才是让人最爽的。打台球真正的敌人不是对手，而是自己，你需要的是自己的完美发挥。打台球像一场博弈，有进攻，有防守，有思考，有抉择，不仅需要娴熟的技艺，还需要沉着冷静的头脑。打台球更像是解决一道难题，目标就是一杆致胜，但达到目标需要解决一路障碍。我们看下图的球形，开球后9号球落袋，白球位置不太好打全色球，所以击打15号选定花色球，同时白球K停5号，这样12号和14号左下袋口进球线路打开，同时叫到11号左上袋口，击打11号时根据白球角度可以选择轻K12号，也可以单叫10号，打完10号可以顺势解决12号和14号，最后通过13号叫8号球，完成清台。当然这是A计划，如果击球过程中走位出现失误，那就要执行B计划了（防守）。找一个安全的位置，最好对手看不到目标球，其次是无进球线路，在其次是进球难度高的位置，贴库位置是个不错的选择，配合自己的球形大脑里快速评估一下防守成功率，然后进行方案决策以及实施。可是如果对手有袋口球，让你无处可防怎么办，此时要么破坏袋口球的同时白球走一个相对安全位置，要么将对手某目标球锁死，比如赌袋口，实在不行就大捅一杆，洗洗牌，也许会出现对自己有利的球形哦。总之，B计划的宗旨就一个，增加对手清台难度，一杆打不死我，老子就有机会上来收拾你。怎么样，也许看到这里你也喜欢上了台球。\n  台球    我喜欢的  节目  强烈推荐优酷的 《圆桌派》 ，这是一个聊天节目，一个圆桌，一个话题，一炉焚香，四位嘉宾开始畅谈，各自表述观点和想法，作为听众有时也会陷入深思，不知不觉融入其中。圆桌派的话题涉及很广，有发人深省的，也有幽默风趣的，最主要的是全部贴近生活。最喜欢的是陈晓卿参加的那期 “饭局” 。   音乐和歌手  郑钧：私奔、赤裸裸 李志：天空之城、梵高、和你在一起、不多 伍佰：再度重相逢、晚风 吴宁越：羊肉面 马条：阳光中的向日葵 赵雷：鼓楼 奇葩的歌：少林奥运、李伯伯、罗马表、我想我想\u0026hellip;\u0026hellip; 最近听的：Chris Stapleton的Tennessee Whiskey、北野武的浅草キッド、John Lennon的Imagine、老王乐队的我还年轻、杨学的泸沽湖、鱼大叔的后来的我、丢火车的火车日记、莫染的给英格兰友人、房东的猫的下一站茶山刘\u0026hellip;\u0026hellip;   喜欢的电影  我喜欢看轻松娱乐类的电影，比如无名之辈、情圣、人在囧途、让子弹飞\u0026hellip;\u0026hellip; 严重抵触悬疑惊悚类，天生胆小 有点喜欢战争类，非神剧，比如天空之眼、狂怒、猎杀红色十月、拆弹部队、美国狙击手、孤独的幸存者、兵临城下\u0026hellip;\u0026hellip; 不怎么看电视剧，感觉没时间追剧    关于本博客 本博客主要内容 本博客主要是总结一些工作中的技术经验，以及记录生活中的一些点点滴滴。\n本博客名字由来 我始终坚持一句话， “第一次问过或查过的问题，就应该记下来；第二次再问或再查的问题，就必须记下来。” 既然没有强大的大脑，那就多动动手，记录下来，正所谓好记性不如烂笔头，本博客就是我的 烂笔头 。\n本博客创建过程 实际上整个过程是这样的，最初自己只做一些工程上的笔记，使用工具就是word了；后来熟悉了emacs的org mode，开始用org来记笔记，可以导出html文件用浏览器查看；再后来从emacs china论坛中发现有人开发了基于org的笔记管理系统，但是已经不再维护了，所以只是简单了解了一下；接下来仍一直在寻找一种笔记管理方法，网上有人推荐了hexo，一个博客站点生成器，折腾了一段时间，从安装hexo工具到配置主题就要晕死了；在折腾hexo的过程中又发现了hugo博客站点生成器，免安装，还有天然支持org转markdown的插件，简直太舒服了。使用emacs和hugo构建自己的博客，目前对我来说是最舒服的方式没有之一。整个过程是不是很曲折，如果你看到这里，推荐你直接使用hugo搭建自己的博客站点，非emacs用户的话可以直接书写markdown文件，顺便推荐一款markdown编辑器 Typora 。这里就不对如何使用hugo搭建自己的博客站点进行介绍了，有单独的一篇帖子介绍详细的搭建过程。\n","description":"","id":80,"section":"","tags":null,"title":"About","uri":"https://www.wenhui.space/about/"}]
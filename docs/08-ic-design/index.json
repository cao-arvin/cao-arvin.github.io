[{"content":"本文 主要介绍多核体系结构，包括多核体系结构的由来，以及多和体系结构中的几大关键技术。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《多核体系结构概览》 赵老师 培训    专业术语与缩略语    缩写 全称 说明           什么是多核体系结构   处理器设计的几大目标：\n 功能 性能 功耗 成本 其他    如何实现上述目标：体系结构\n 冯诺依曼体系结构：存储、程序、计算、控制 Tomasulo算法、多发射、分支预测、预期、SIMD \u0026hellip;    为什么需要多核体系结构   如何提高汽车产量？\n 流水线技术、多部件同时组装、优化配合 还能怎么做？多条生产线、多个工厂、批量化零件生产    怎么提高计算机系统性能？\n 提高单个处理器核的性能：并行性、局部性、可预测性；边际效应递减，功耗和面积的开销加大 还能怎么做？使用多个处理器核同时计算 为什么多核能提高性能？线程间的并行性 另一个促进因素：工艺技术的提高，可容纳更多晶体管资源    SoC：更高的集成度\n MCU、I/O、DSP、GPU、Crypto\u0026hellip;    一个典型的ARM多核系统   ARM N1 hyperscal reference design      ARM N1 Floorplan View    多核体系结构关键问题  如何把多核连接起来？ 如何保持一个统一的存储视图？ 如何减少访存延迟？ 如何控制中断在多个核之间的派发？ I/O子系统 调试子系统 电源管理子系统  如何把多核连接起来   采用什么样的连接方式？\n 总线：链路负载重、带宽低 XBar：带宽高、可扩展性差 交换式：Ring、Mesh    数据如何传输？\n 数据在相邻两个节点之间的可靠传输：链路层 数据在任意两个节点之间的可靠传输：网络层 设备节点间的高层语义模型（共享存储、消息传输）：协议层    关键问题：\n Order的保证 死锁的避免 拥塞的控制    如何保持一个统一的存储视图   每个core都有自己的cache，怎么保证不同core间的cache内容不冲突？\n core0修改，core1不修改，core1是否能看到core0对x的修改？ core0和core1都修改，会不会出现core0认为x=1，core1认为x=0的情况？    怎么可靠的通过共享存储在两个核之间传输数据？\n core0先写data，然后置flag=1,；core1先检查flag，然后读data；对硬件设计有什么影响？ core0写x=1，core1看到了x=1并通知了core2，core2看到的x一定是1吗？    怎么减小访存延迟？  告诉缓存 cache 局部性：时间局部性和空间局部性 cache自身也存在访问延迟和容量之间的权衡 使用多级cache，取得最小平均延迟 各级存储层次的带宽平衡问题  中断的派发   中断是一种slave主动向master发信息的方式\n 使能、优先级、中断状态管理、虚拟化 Level Sensitive、Edge Triggered、Message Based    和单核系统的不同之处：\n 如何在多核之间派发中断？ 如何避免一个核总是不响应中断？ 如何防止多个核响应同一个中断？    I/O子系统   主要包含两类：\n On-Chip device：UART、I2C \u0026hellip; PCI-Express subsystem    两个方向的通路：\n Master to Slave：PIO Slave to Master：DMA、Interrupt    主要的问题：\n Order：PIO order、PCIE order/deadlock I/O virtualization    调试子系统   软件写错了，如何调试？\n 暂停处理器执行：断点、观察点、单步执行 观察内部状态：读写寄存器、读写Memory    CPU硬件会定义相应的支持机制：\n 上述暂停机制、观察机制 调试器向CPU发送命令的通路    电源管理子系统  在某些组件闲置时将其降频、关时钟或断电，以节省功耗  监测机制：CPU核空闲，NoC接口空闲 控制机制：被控制组件和电源控制器间的握手协议 执行机制：PLL频率调节，电源关断    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":0,"section":"docs","tags":["CPU"],"title":"初识多核体系结构","uri":"https://www.wenhui.space/docs/08-ic-design/cpu/multi-core/"},{"content":"本文 主要介绍关于浮点运算单元的一些基础知识，和作为验证师应该关注的点。\n   版本 说明     0.1 初版发布    专业术语与缩略语    缩写 全称 说明     FPU Floatpoint Unit 浮点运算单元   LSB least significant bit 最低有效位   MSB most significant bit 最高有效位   NaN not a number 非数   qNaN quiet NaN 一般表示未定义的算术运算结果   sNaN signaling NaN 一般表示标记未初始化的值   FMP fused Multiply Add 融合乘加   RM Rounding Mode 舍入模式    Sign 符号位（浮点格式中的组成部分，0表示正,1表示负）    trailing significand field 尾数有效位（浮点格式中的组成部分，除前导数字外的所有有效数字）    biased exponent 偏指数（浮点格式中的组成部分，指数与偏移量常数的和，目的是biased exponent为非负数）    Mantissa 尾数    radix 基数(进制)    precision 精度    infinite 无穷         参考    名称 作者 来源     《DDI0487D_b_armv8_arm》 ARM ARM官网   《IEEE-754-2008》 IEEE IEEE官网    IEEE-754标准 概述  浮点数的表示可以理解为实数连续无线集合的有限子集，另外加上一些扩展集（qNaN和sNaN）。 根据给定的格式（单精度/双精度/其他），通过舍入将实数集合映射到该格式可表示的浮点数。 浮点数据包含以下类型：有符号零、有限的非零数、有符号无穷大、NaN（非数）。 将浮点数据的表示映射到固定的比特位，形成浮点数的二进制表示方法，以及相应到运算规则。       二进制表示  1-bit符号位 S w-bit偏指数 E = e+bias (t=p−1)-bit尾数有效位 T=d1 d2 \u0026hellip; dp−1 ，有效位的首位d0被隐含在偏指数E中，如果E等于0，则d0等于0，如果E非0且非全1，则d0等于1。        关于 k、p、t、w、bias 在不同精度表示格式下的值，如下图：         关于 biased exponent E 的可取范围：\n 1 至 2^w −2 的整数，也就是E非全0且非全1，用来表示常规的浮点数。 0 ,用来表示正负0，以及非规格化的小数。 2^w −1 ，也就是E全1，用来表示正负无穷大。    二进制浮点格式 r 与十进制浮点值 v 的对应关系：\n 如果E为 2^w −1，也就是全1，并且T不等于0，则 r 是qNaN或sNaN， v 是NaN（不关心符号位S）。 如果E为 2^w −1，也就是全1，并且T等于0，则 r 和 v 都是正负无穷大。 如果E为 1至2^w −2 的整数, 也就是非全0非全1，表示常规浮点数， v = (−1)^S * 2^(E−bias) * (1 + 2^(1−p)*T) 。（这里可以看出，隐藏的有效位首位d0是1） 如果E为 0，并且T不等于0，则 v = (−1)^S * 2^emin * (0 + 2^(1−p)*T) 。（这里可以看出，隐藏的有效位首位d0是0） 如果E为 0，并且T等于0，则 v = (−1)^S * (+0) ，也就是正负0。 （emax = bias = 2^(w−1) − 1； emin = 1 − emax = 2 − 2^(w−1)）    舍入模式   舍入模式：\n roundTiesToEven ：就近舍入的向偶数舍入，类似于熟悉的四舍五入，而这里是 四舍六入五凑偶 ，另外向偶数舍入是规范中默认的舍入模式。 roundTowardPositive ：向上舍入，正浮点数，尾数非0，则向前进1，负浮点数，尾数非0，则舍去尾数。 roundTowardNegative ：向下舍入，正浮点数，尾数非0，则舍去尾数，负浮点数，尾数非0，则向前进1。 roundTowardZero ：向零舍入，也就是无论正负，都舍去尾数。 roundTiesToAway ：就近舍入中的向上舍入，也就是四舍五入。roundTiesToAway为十进制提供，而规范中并不建议使用roundTiesToAway舍入模式。    举例说明（保留1位小数）：\n 保留位(Guard bit)：以保留1位小数为例，保留位即第一位小数。 近似位(Round bit)：以保留1位小数为例，近似位即保留位的下一位，也就是第二位小数。 中间值：距两个最近的精确值相等，以保留1位小数为例，十进制2.3和2.4的中间值为2.35，二进制1.0和1.1的中间值为1.01。 向偶数舍入，所谓四舍六入五凑偶，就是原始值等于中间值，如果当前保留位是奇数，则进1，如果当前保留位是偶数，则舍去。       原始值 中间值 向偶数舍入 向上舍入 向下舍入 向零舍入     +1.1110 +1.11 +10.0 +10.0 +1.1 +1.1   +1.0101 +1.01 +1.1 +1.1 +1.0 +1.0   +1.0010 +1.01 +1.0 +1.1 +1.0 +1.0   +1.1000 +1.11/+1.01 +1.1 +1.1 +1.1 +1.1   +1.1100 +1.11 +10.0 +10.0 +1.1 +1.1   +1.0100 +1.01 +1.0 +1.1 +1.0 +1.0   -1.1110 -1.11 -10.0 -1.1 -10.0 -1.1   -1.0101 -1.01 -1.1 -1.0 -1.1 -1.0   -1.0010 -1.01 -1.0 -1.0 -1.1 -1.0   -1.1000 -1.11/-1.01 -1.1 -1.1 -1.1 -1.1   -1.1100 -1.11 -10.0 -1.1 -10.0 -1.1   -1.0100 -1.01 -1.0 -1.0 -1.1 -1.0     为什么采用向偶数舍入？  四舍五入：十进制中近似位可能的数字为 1 到 9，1/2/3/4舍去，9/8/7/6进位，毋庸置疑，但是对于5，如果采用进位的话，在进行大量数据的统计时，就会累积比较大的偏差。 向偶数舍入：在大多数情况下，5舍去还是进位概率相等，统计时产生的偏差也就相应要小一些。    特殊值  特殊值参与的运算，在规范中有特殊的处理方式，在FPU验证中都要格外关注。 规格化值虽然不算特殊值，但最大值、最小值、最小精度值在FPU验证中也是需要关注的。 对于0、无穷大、非数这类特殊值参与运算，可能会产生浮点异常，详见 浮点异常 章节。 本例只对半精度做展示，单精度和双精度与其类似。     特殊值 半精度     +0 0_00000_0000000000   -0 1_00000_0000000000   正无穷 0_11111_0000000000   负无穷 1_11111_0000000000   qNaN x_11111_1xxxxxxxxx   sNaN x_11111_0xxxxxxxxx   非规格化最大值 0_00000_1111111111   非规格化最小值 1_00000_1111111111   非规格化正最小精度值 0_00000_0000000001   非规格化负最小精度值 1_00000_0000000001   规格化最大值 0_11110_1111111111   规格化最小值 1_11110_1111111111   规格化正最小精度值 0_00001_0000000001   规格化负最小精度值 1_00001_0000000001     不发生异常的特殊值运算：  无穷 加/减 规格化/非规格化/0 无穷 乘 规格化/非规格化 无穷 除 规格化/非规格化 正无穷 开方运算 规格化/非规格化 除 无穷大 取余 无穷 格式转换（如单精度、双精度间的转换） 0 加/减/乘 规格化/非规格化/0 0 除 规格化/非规格化/无穷 0 开方运算    浮点异常   Invalid operation，无效操作输出结果为qNaN：\n 操作数为 NaN 的运算，格式转换除外，如单/双精度间的转换 0 乘 无穷 ，以及融合乘加中乘法项为 0 和 无穷 的运算 正无穷 加 负无穷 （包括减法形式），以及融合乘加中最后加法项为 正无穷 和 负无穷 的运算 0 除 0 ， 无穷 除 无穷 取余，被除数是 规格化/非规格化值 除数是 0 ，或者被除数是 无穷 除数是 规格化/非规格化值 负数开方 NaN、无穷 转换为整数 NaN、无穷、0 取对数 NaN 参与的比较运算，及正无穷与正无穷的大小比较等    Division by zero ，除零运算输出结果为无穷。\n 被除数为 规格化/非规格化值 除数是 0 logB(0)，对应结果浮点格式为 负无穷    Overflow ，操作数为 规格化/非规格化值 ，并且运算结果根据舍入模式进行舍入后，大小超出可表示的最大值，则发生上溢异常。\n roundTiesToEven/roundTiesToAway 舍入模式下，正溢出输出结果为正无穷，负溢出输出结果为负无穷。 roundTowardZero 舍入模式下，正溢出输出结果为最大值，负溢出输出结果为最小值。 roundTowardNegative 舍入模式下，正溢出输出结果为最大值，负溢出输出结果为负无穷。 roundTowardPositive 舍入模式下，正溢出输出结果为正无穷，负溢出输出结果为最小值。 另外，在输出运算结果的同时，还要发出上溢和非精确异常。    Underflow ，操作数为 规格化/非规格化值 ，并且运算结果为非规格化值（小于2^emin），则发生下溢异常。\n 运算结果为非规格化值，无需舍入操作，则只发生下溢异常。 运算结果为非规格化值，并且需舍入操作，则发生下溢异常和非精确异常。 最终结果要根据舍入模式进行舍入操作，可能为 0、2^emin、非规格化值    Inexact ，运算结果需要根据舍入模式进行舍入操作，择发生非精确异常。\n 当浮点格式的精度无法表示运算结果，需要根据舍入模式进行舍入操作，得到近似值，这时要报告非精确异常。 输出结果为舍入后的结果。    浮点类型指令(ARMv8 AArch64) 浮点寄存器型数据传输  FMOV(general)：Floating-point Move to or from general-purpose register without conversion.（设计中一般不存在浮点寄存器和通用寄存器间的通路，需要借用ld/st的通路实现）   FMOV \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FMOV \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FMOV \u0026lt;Hd\u0026gt;, \u0026lt;Wn\u0026gt; FMOV \u0026lt;Sd\u0026gt;, \u0026lt;Wn\u0026gt; FMOV \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FMOV \u0026lt;Hd\u0026gt;, \u0026lt;Xn\u0026gt; FMOV \u0026lt;Dd\u0026gt;, \u0026lt;Xn\u0026gt; FMOV \u0026lt;Vd\u0026gt;.D[1], \u0026lt;Xn\u0026gt; FMOV \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt; FMOV \u0026lt;Xd\u0026gt;, \u0026lt;Vn\u0026gt;.D[1]  FMOV(register)：Floating-point Move register without conversion.   FMOV \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FMOV \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FMOV \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; 浮点立即数型数据传输  FMOV(scalar, immediate)：Floating-point move immediate (scalar). 立即数可表示范围以及数据组织结构请参考下文。   FMOV \u0026lt;Hd\u0026gt;, #\u0026lt;imm\u0026gt; FMOV \u0026lt;Sd\u0026gt;, #\u0026lt;imm\u0026gt; FMOV \u0026lt;Dd\u0026gt;, #\u0026lt;imm\u0026gt;  FMOV(vector, immediate)：Floating-point move immediate (vector). 立即数可表示范围以及数据组织结构请参考下文。   FMOV \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, #\u0026lt;imm\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S FMOV \u0026lt;Vd\u0026gt;.2D, #\u0026lt;imm\u0026gt;  imm立即数可表示范围以及数据组织结构：8bit数据{abcdefgh}，{a}为符号位，{bcd}为阶码，({!b, cd} - 3)，{efgh}为尾数。    8位浮点立即数表示及与半/单/双精度的转换关系      8位浮点立即数可表示的十进制范围    浮点转换指令 scalar类型  FCVT：Floating-point Convert precision (scalar)   FCVT \u0026lt;Sd\u0026gt;, \u0026lt;Hn\u0026gt; FCVT \u0026lt;Dd\u0026gt;, \u0026lt;Hn\u0026gt; FCVT \u0026lt;Hd\u0026gt;, \u0026lt;Sn\u0026gt; FCVT \u0026lt;Dd\u0026gt;, \u0026lt;Sn\u0026gt; FCVT \u0026lt;Hd\u0026gt;, \u0026lt;Dn\u0026gt; FCVT \u0026lt;Sd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTAS (scalar)：Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar).   FCVTAS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTAS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTAS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTAS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTAU (scalar)：Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar).   FCVTAU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTAU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTAU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTAU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTMS (scalar)：Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar).   FCVTMS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTMS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTMS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTMS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTMU (scalar)：Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar).   FCVTMU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTMU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTMU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTMU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTNS (scalar)：Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar).   FCVTNS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTNS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTNS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTNS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTNU (scalar)：Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar).   FCVTNU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTNU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTNU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTNU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTPS (scalar)：Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar).   FCVTPS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTPS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTPS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTPS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTPU (scalar)：Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar).   FCVTPU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTPU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTPU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTPU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTZS (scalar, fixed-point)：Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;, #\u0026lt;fbits\u0026gt;  FCVTZS (scalar, integer)：Floating-point Convert to Signed integer, rounding toward Zero (scalar).   FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTZS \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTZS \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  FCVTZU (scalar, fixed-point)：Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt;, #\u0026lt;fbits\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;, #\u0026lt;fbits\u0026gt;  FCVTZU (scalar, integer)：Floating-point Convert to Unsigned integer, rounding toward Zero (scalar).   FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Sn\u0026gt; FCVTZU \u0026lt;Wd\u0026gt;, \u0026lt;Dn\u0026gt; FCVTZU \u0026lt;Xd\u0026gt;, \u0026lt;Dn\u0026gt;  SCVTF (scalar, fixed-point)：Signed fixed-point Convert to Floating-point (scalar).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width SCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; SCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; SCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; SCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt; SCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt; SCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt;  SCVTF (scalar, integer)：Signed integer Convert to Floating-point (scalar).   SCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Wn\u0026gt; SCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Wn\u0026gt; SCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Wn\u0026gt; SCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Xn\u0026gt; SCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Xn\u0026gt; SCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Xn\u0026gt;  UCVTF (scalar, fixed-point)：Unsigned fixed-point Convert to Floating-point (scalar).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width UCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; UCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; UCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Wn\u0026gt;, #\u0026lt;fbits\u0026gt; UCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt; UCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt; UCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Xn\u0026gt;, #\u0026lt;fbits\u0026gt;  UCVTF (scalar, integer)：Unsigned integer Convert to Floating-point (scalar).   UCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Wn\u0026gt; UCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Wn\u0026gt; UCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Wn\u0026gt; UCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Xn\u0026gt; UCVTF \u0026lt;Sd\u0026gt;, \u0026lt;Xn\u0026gt; UCVTF \u0026lt;Dd\u0026gt;, \u0026lt;Xn\u0026gt; vector类型  FCVTAS (vector)：Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector).   FCVTAS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTAS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTAU (vector)：Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector).   FCVTAU \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTAU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTAU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTMS (vector)：Floating-point Convert to Signed integer, rounding toward Minus infinity (vector).   FCVTMS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTMS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTMU (vector)：Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector).   FCVTMU \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTMU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTMU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.73 FCVTNS (vector)：Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector).   FCVTNS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTNS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTNU (vector)：Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector).   FCVTNU \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTNU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTNU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTPS (vector)：Floating-point Convert to Signed integer, rounding toward Plus infinity (vector).   FCVTPS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTPS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTPU (vector)：Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector).   FCVTPU \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTPU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTPU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTZS (vector, fixed-point)：Floating-point Convert to Signed fixed-point, rounding toward Zero (vector).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width FCVTZS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt;, #\u0026lt;fbits\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTZS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #\u0026lt;fbits\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTZS (vector, integer)：Floating-point Convert to Signed integer, rounding toward Zero (vector).   FCVTZS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZS \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTZS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTZU (vector, fixed-point)：Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width FCVTZU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt;, #\u0026lt;fbits\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTZU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #\u0026lt;fbits\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  FCVTZU (vector, integer)：Floating-point Convert to Unsigned integer, rounding toward Zero (vector).   FCVTZU \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FCVTZU \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D FCVTZU \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  SCVTF (vector, fixed-point)：Signed fixed-point Convert to Floating-point (vector).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width SCVTF \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt;, #\u0026lt;fbits\u0026gt; // \u0026lt;V\u0026gt;: H,S,D SCVTF \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #\u0026lt;fbits\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  SCVTF (vector, integer)：Signed integer Convert to Floating-point (vector).   SCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; SCVTF \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D SCVTF \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  UCVTF (vector, fixed-point)：Unsigned fixed-point Convert to Floating-point (vector).   // \u0026lt;fbits\u0026gt; For the scalar variant: is the number of fractional bits, in the range 1 to the operand width UCVTF \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt;, #\u0026lt;fbits\u0026gt; // \u0026lt;V\u0026gt;: H,S,D UCVTF \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #\u0026lt;fbits\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  UCVTF (vector, integer)：Unsigned integer Convert to Floating-point (vector).   UCVTF \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; UCVTF \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;V\u0026gt;\u0026lt;n\u0026gt; // \u0026lt;V\u0026gt;: S,D UCVTF \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 浮点舍入到整数 scalar类型  C7.2.141 FRINTA (scalar)：Floating-point Round to Integral, to nearest with ties to Away (scalar).   FRINTA \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTA \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTA \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.143 FRINTI (scalar)：Floating-point Round to Integral, using current rounding mode (scalar).   FRINTI \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTI \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTI \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.145 FRINTM (scalar)：Floating-point Round to Integral, toward Minus infinity (scalar).   FRINTM \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTM \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTM \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.147 FRINTN (scalar)：Floating-point Round to Integral, to nearest with ties to even (scalar).   FRINTN \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTN \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTN \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.149 FRINTP (scalar)：Floating-point Round to Integral, toward Plus infinity (scalar).   FRINTP \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTP \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTP \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.151 FRINTX (scalar)：Floating-point Round to Integral exact, using current rounding mode (scalar).   FRINTX \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTX \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTX \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.153 FRINTZ (scalar)：Floating-point Round to Integral, toward Zero (scalar).   FRINTZ \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRINTZ \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRINTZ \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; vector类型  C7.2.140 FRINTA (vector)：Floating-point Round to Integral, to nearest with ties to Away (vector).   FRINTA \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.142 FRINTI (vector)：Floating-point Round to Integral, using current rounding mode (vector).   FRINTI \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.144 FRINTM (vector)：Floating-point Round to Integral, toward Minus infinity (vector).   FRINTM \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.146 FRINTN (vector)：Floating-point Round to Integral, to nearest with ties to even (vector).   FRINTN \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.148 FRINTP (vector)：Floating-point Round to Integral, toward Plus infinity (vector).   FRINTP \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.150 FRINTX (vector)：Floating-point Round to Integral exact, using current rounding mode (vector).   FRINTX \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.152 FRINTZ (vector)：Floating-point Round to Integral, toward Zero (vector).   FRINTZ \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 浮点（融合）乘加指令  C7.2.93 FMADD：Floating-point fused Multiply-Add (scalar).   FMADD \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, \u0026lt;Ha\u0026gt; FMADD \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, \u0026lt;Sa\u0026gt; FMADD \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, \u0026lt;Da\u0026gt;  C7.2.126 FMSUB：Floating-point Fused Multiply-Subtract (scalar).   FMSUB \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, \u0026lt;Ha\u0026gt; FMSUB \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, \u0026lt;Sa\u0026gt; FMSUB \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, \u0026lt;Da\u0026gt;  C7.2.134 FNMADD：Floating-point Negated fused Multiply-Add (scalar).   FNMADD \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, \u0026lt;Ha\u0026gt; FNMADD \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, \u0026lt;Sa\u0026gt; FNMADD \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, \u0026lt;Da\u0026gt;  C7.2.135 FNMSUB：Floating-point Negated fused Multiply-Subtract (scalar).   FNMSUB \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, \u0026lt;Ha\u0026gt; FNMSUB \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, \u0026lt;Sa\u0026gt; FNMSUB \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, \u0026lt;Da\u0026gt; 浮点一源算数指令 scalar类型  C7.2.39 FABS (scalar)：Floating-point Absolute value (scalar).   FABS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FABS \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FABS \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.133 FNEG (scalar)：Floating-point Negate (scalar).   FNEG \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FNEG \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FNEG \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;  C7.2.157 FSQRT (scalar)：Floating-point Square Root (scalar).   FSQRT \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FSQRT \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FSQRT \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; vector类型  C7.2.38 FABS (vector)：Floating-point Absolute value (vector).   FABS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.132 FNEG (vector)：Floating-point Negate (vector).   FNEG \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.156 FSQRT (vector)：Floating-point Square Root (vector).   FSQRT \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 浮点二源算数指令 scalar类型  C7.2.43 FADD (scalar)：Floating-point Add (scalar).   FADD \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FADD \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FADD \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.159 FSUB (scalar)：Floating-point Subtract (scalar).   FSUB \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FSUB \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FSUB \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.91 FDIV (scalar)：Floating-point Divide (scalar).   FDIV \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FDIV \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FDIV \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.129 FMUL (scalar)：Floating-point Multiply (scalar).   FMUL \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FMUL \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FMUL \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.136 FNMUL (scalar)：Floating-point Multiply-Negate (scalar).   FNMUL \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FNMUL \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FNMUL \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; vector类型  C7.2.42 FADD (vector)：Floating-point Add (vector).   FADD \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.158 FSUB (vector)：Floating-point Subtract (vector).   FSUB \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.90 FDIV (vector)：Floating-point Divide (vector).   FDIV \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.128 FMUL (vector)：Floating-point Multiply (vector).   FMUL \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 浮点最大和最小值 scalar类型  C7.2.95 FMAX (scalar)：Floating-point Maximum (scalar).   FMAX \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FMAX \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FMAX \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.101 FMAXP (scalar)：Floating-point Maximum of Pair of elements (scalar).   FMAXP \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;V\u0026gt;: H/S/D; \u0026lt;T\u0026gt;:2H/2S/2D  C7.2.97 FMAXNM (scalar)：Floating-point Maximum Number (scalar). If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).   FMAXNM \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FMAXNM \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FMAXNM \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.98 FMAXNMP (scalar)：Floating-point Maximum Number of Pair of elements (scalar).   FMAXNMP \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 2H, 2S, 2D  C7.2.105 FMIN (scalar)：Floating-point Minimum (scalar).   FMIN \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FMIN \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FMIN \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.111 FMINP (scalar)：Floating-point Minimum of Pair of elements (scalar).   FMINP \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;V\u0026gt;: H/S/D; \u0026lt;T\u0026gt;:2H/2S/2D  C7.2.107 FMINNM (scalar)：Floating-point Minimum Number (scalar). If one vector element is numeric and the other is a quiet NaN, the result that is placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).   FMINNM \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FMINNM \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FMINNM \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;  C7.2.108 FMINNMP (scalar)：Floating-point Minimum Number of Pair of elements (scalar).   FMINNMP \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 2H, 2S, 2D vector类型  C7.2.94 FMAX (vector)：Floating-point Maximum (vector).   FMAX \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.102 FMAXP (vector)：Floating-point Maximum Pairwise (vector).   FMAXP \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.96 FMAXNM (vector)：Floating-point Maximum Number (vector). If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMAX (scalar).   FMAXNM \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.99 FMAXNMP (vector)：Floating-point Maximum Number Pairwise (vector).   FMAXNMP \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.100 FMAXNMV：Floating-point Maximum Number across Vector.   FMAXNMV \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4S, 4H/8H \u0026lt;V\u0026gt;: H, S  C7.2.104 FMIN (vector)：Floating-point minimum (vector).   FMIN \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.112 FMINP (vector)：Floating-point Minimum Pairwise (vector).   FMINP \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.106 FMINNM (vector)：Floating-point Minimum Number (vector). If one vector element is numeric and the other is a quiet NaN, the result placed in the vector is the numerical value, otherwise the result is identical to FMIN (scalar).   FMINNM \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.109 FMINNMP (vector)：Floating-point Minimum Number Pairwise (vector).   FMINNMP \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.110 FMINNMV：Floating-point Minimum Number across Vector.   FMINNMV \u0026lt;V\u0026gt;\u0026lt;d\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4S, 4H/8H \u0026lt;V\u0026gt;: H, S 浮点比较指令 scalar类型  C7.2.59 FCMP：Floating-point quiet Compare (scalar).It raises an Invalid Operation exception only if either operand is a signaling NaN.   FCMP \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FCMP \u0026lt;Hn\u0026gt;, #0.0 FCMP \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FCMP \u0026lt;Sn\u0026gt;, #0.0 FCMP \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FCMP \u0026lt;Dn\u0026gt;, #0.0  C7.2.60 FCMPE：Floating-point signaling Compare (scalar).If either operand is any type of NaN, or if either operand is a signaling NaN, the instruction raises an Invalid Operation exception.   FCMPE \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FCMPE \u0026lt;Hn\u0026gt;, #0.0 FCMPE \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FCMPE \u0026lt;Sn\u0026gt;, #0.0 FCMPE \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FCMPE \u0026lt;Dn\u0026gt;, #0.0  C7.2.47 FCCMP：Floating-point Conditional quiet Compare (scalar). It raises an Invalid Operation exception only if either operand is a signaling NaN.   FCCMP \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt; FCCMP \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt; FCCMP \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt;  C7.2.48 FCCMPE：Floating-point Conditional signaling Compare (scalar).   FCCMPE \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt; FCCMPE \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt; FCCMPE \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, #\u0026lt;nzcv\u0026gt;, \u0026lt;cond\u0026gt; vector类型  C7.2.49 FCMEQ (register)：Floating-point Compare Equal (vector).   FCMEQ \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FCMEQ \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FCMEQ \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FCMEQ \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.50 FCMEQ (zero)：Floating-point Compare Equal to zero (vector).   FCMEQ \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, #0.0 FCMEQ \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, #0.0 FCMEQ \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, #0.0 FCMEQ \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #0.0 //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.51 FCMGE (register)：Floating-point Compare Greater than or Equal (vector).   FCMGE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FCMGE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FCMGE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FCMGE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.52 FCMGE (zero)：Floating-point Compare Greater than or Equal to zero (vector).   FCMGE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, #0.0 FCMGE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, #0.0 FCMGE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, #0.0 FCMGE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #0.0 //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.53 FCMGT (register)：Floating-point Compare Greater than (vector).   FCMGT \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FCMGT \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FCMGT \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FCMGT \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.54 FCMGT (zero)：Floating-point Compare Greater than zero (vector).   FCMGE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, #0.0 FCMGE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, #0.0 FCMGE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, #0.0 FCMGE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #0.0 //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.57 FCMLE (zero)：Floating-point Compare Less than or Equal to zero (vector).   FCMLE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, #0.0 FCMLE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, #0.0 FCMLE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, #0.0 FCMLE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #0.0 //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.58 FCMLT (zero)：Floating-point Compare Less than zero (vector).   FCMLT \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, #0.0 FCMLT \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, #0.0 FCMLT \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, #0.0 FCMLT \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, #0.0 //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.40 FACGE：Floating-point Absolute Compare Greater than or Equal (vector).   FACGE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FACGE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FACGE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FACGE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.41 FACGT：Floating-point Absolute Compare Greater than (vector).   FACGT \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FACGT \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FACGT \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FACGT \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 浮点条件选择指令  C7.2.61 FCSEL：Floating-point Conditional Select (scalar).   FCSEL \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt;, \u0026lt;cond\u0026gt; FCSEL \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt;, \u0026lt;cond\u0026gt; FCSEL \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt;, \u0026lt;cond\u0026gt; 其他指令  C7.2.137 FRECPE：Floating-point Reciprocal Estimate.   FRECPE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRECPE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRECPE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; FRECPE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.138 FRECPS：Floating-point Reciprocal Step.   FRECPS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FRECPS \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FRECPS \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FRECPS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.139 FRECPX：Floating-point Reciprocal exponent (scalar).   FRECPX \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FRECPX \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FRECPX \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; FRECPX \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.154 FRSQRTE：Floating-point Reciprocal Square Root Estimate.   FSQRTE \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt; FSQRTE \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt; FSQRTE \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt; FSQRTE \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D  C7.2.155 FRSQRTS：Floating-point Reciprocal Square Root Step.   FSQRTS \u0026lt;Hd\u0026gt;, \u0026lt;Hn\u0026gt;, \u0026lt;Hm\u0026gt; FSQRTS \u0026lt;Sd\u0026gt;, \u0026lt;Sn\u0026gt;, \u0026lt;Sm\u0026gt; FSQRTS \u0026lt;Dd\u0026gt;, \u0026lt;Dn\u0026gt;, \u0026lt;Dm\u0026gt; FSQRTS \u0026lt;Vd\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vn\u0026gt;.\u0026lt;T\u0026gt;, \u0026lt;Vm\u0026gt;.\u0026lt;T\u0026gt; //\u0026lt;T\u0026gt;: 4H/8H, 2S/4S, 2D 典型浮点运算(ARMv8 AArch64) FPAdd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //以下代码为FPAdd运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; rounding = FPRoundingMode(fpcr); (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity); zero1 = (type1 == FPType_Zero); zero2 = (type2 == FPType_Zero); if inf1 \u0026amp;\u0026amp; inf2 \u0026amp;\u0026amp; sign1 == NOT(sign2) then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); else if (inf1 \u0026amp;\u0026amp; sign1 == \u0026#39;0\u0026#39;) || (inf2 \u0026amp;\u0026amp; sign2 == \u0026#39;0\u0026#39;) then result = FPInfinity(\u0026#39;0\u0026#39;); else if (inf1 \u0026amp;\u0026amp; sign1 == \u0026#39;1\u0026#39;) || (inf2 \u0026amp;\u0026amp; sign2 == \u0026#39;1\u0026#39;) then result = FPInfinity(\u0026#39;1\u0026#39;); else if zero1 \u0026amp;\u0026amp; zero2 \u0026amp;\u0026amp; sign1 == sign2 then result = FPZero(sign1); else result_value = value1 + value2; if result_value == 0.0 then // Sign of exact zero result depends on rounding mode  result_sign = if rounding == FPRounding_NEGINF then \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; result = FPZero(result_sign); else result = FPRound(result_value, fpcr, rounding); return result;   FPSub 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //以下代码为FPSub运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; rounding = FPRoundingMode(fpcr); (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity); zero1 = (type1 == FPType_Zero); zero2 = (type2 == FPType_Zero); if inf1 \u0026amp;\u0026amp; inf2 \u0026amp;\u0026amp; sign1 == sign2 then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); else if (inf1 \u0026amp;\u0026amp; sign1 == \u0026#39;0\u0026#39;) || (inf2 \u0026amp;\u0026amp; sign2 == \u0026#39;1\u0026#39;) then result = FPInfinity(\u0026#39;0\u0026#39;); else if (inf1 \u0026amp;\u0026amp; sign1 == \u0026#39;1\u0026#39;) || (inf2 \u0026amp;\u0026amp; sign2 == \u0026#39;0\u0026#39;) then result = FPInfinity(\u0026#39;1\u0026#39;); else if zero1 \u0026amp;\u0026amp; zero2 \u0026amp;\u0026amp; sign1 == NOT(sign2) then result = FPZero(sign1); else result_value = value1 - value2; if result_value == 0.0 then // Sign of exact zero result depends on rounding mode  result_sign = if rounding == FPRounding_NEGINF then \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; result = FPZero(result_sign); else result = FPRound(result_value, fpcr, rounding); return result;   FPMul 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //以下代码为FPMul运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity); zero1 = (type1 == FPType_Zero); zero2 = (type2 == FPType_Zero); if (inf1 \u0026amp;\u0026amp; zero2) || (zero1 \u0026amp;\u0026amp; inf2) then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); else if inf1 || inf2 then result = FPInfinity(sign1 EOR sign2); else if zero1 || zero2 then result = FPZero(sign1 EOR sign2); else result = FPRound(value1*value2, fpcr); return result;   FPDiv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //以下代码为FPDiv运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPDiv(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then inf1 = (type1 == FPType_Infinity); inf2 = (type2 == FPType_Infinity); zero1 = (type1 == FPType_Zero); zero2 = (type2 == FPType_Zero); if (inf1 \u0026amp;\u0026amp; inf2) || (zero1 \u0026amp;\u0026amp; zero2) then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); else if inf1 || zero2 then result = FPInfinity(sign1 EOR sign2); if !inf1 then FPProcessException(FPExc_DivideByZero, fpcr); else if zero1 || inf2 then result = FPZero(sign1 EOR sign2); else result = FPRound(value1/value2, fpcr); return result;   FPSqrt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //以下代码为FPSqrt运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPSqrt(bits(N) op, FPCRType fpcr) assert N IN {16,32,64}; (fptype,sign,value) = FPUnpack(op, fpcr); if fptype == FPType_SNaN || fptype == FPType_QNaN then result = FPProcessNaN(fptype, op, fpcr); else if fptype == FPType_Zero then result = FPZero(sign); else if fptype == FPType_Infinity \u0026amp;\u0026amp; sign == \u0026#39;0\u0026#39; then result = FPInfinity(sign); else if sign == \u0026#39;1\u0026#39; then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); else result = FPRound(Sqrt(value), fpcr); return result;   FPMulAdd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  //以下代码为FPMulAdd运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; rounding = FPRoundingMode(fpcr); (typeA,signA,valueA) = FPUnpack(addend, fpcr); (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); inf1 = (type1 == FPType_Infinity); zero1 = (type1 == FPType_Zero); inf2 = (type2 == FPType_Infinity); zero2 = (type2 == FPType_Zero); (done,result) = FPProcessNaNs3(typeA, type1, type2, addend, op1, op2, fpcr); if typeA == FPType_QNaN \u0026amp;\u0026amp; ((inf1 \u0026amp;\u0026amp; zero2) || (zero1 \u0026amp;\u0026amp; inf2)) then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); if !done then infA = (typeA == FPType_Infinity); zeroA = (typeA == FPType_Zero); // Determine sign and type product will have if it does not cause an Invalid  // Operation.  signP = sign1 EOR sign2; infP = inf1 || inf2; zeroP = zero1 || zero2; // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and  // additions of opposite-signed infinities.  if (inf1 \u0026amp;\u0026amp; zero2) || (zero1 \u0026amp;\u0026amp; inf2) || (infA \u0026amp;\u0026amp; infP \u0026amp;\u0026amp; signA != signP) then result = FPDefaultNaN(); FPProcessException(FPExc_InvalidOp, fpcr); // Other cases involving infinities produce an infinity of the same sign.  else if (infA \u0026amp;\u0026amp; signA == \u0026#39;0\u0026#39;) || (infP \u0026amp;\u0026amp; signP == \u0026#39;0\u0026#39;) then result = FPInfinity(\u0026#39;0\u0026#39;); else if (infA \u0026amp;\u0026amp; signA == \u0026#39;1\u0026#39;) || (infP \u0026amp;\u0026amp; signP == \u0026#39;1\u0026#39;) then result = FPInfinity(\u0026#39;1\u0026#39;); // Cases where the result is exactly zero and its sign is not determined by the  // rounding mode are additions of same-signed zeros.  else if zeroA \u0026amp;\u0026amp; zeroP \u0026amp;\u0026amp; signA == signP then result = FPZero(signA); // Otherwise calculate numerical result and round it.  else result_value = valueA + (value1 * value2); if result_value == 0.0 then // Sign of exact zero result depends on rounding mode  result_sign = if rounding == FPRounding_NEGINF then \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; result = FPZero(result_sign); else result = FPRound(result_value, fpcr); return result;   FPMax 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //以下代码为FPMax运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then if value1 \u0026gt; value2 then (fptype,sign,value) = (type1,sign1,value1); else (fptype,sign,value) = (type2,sign2,value2); if fptype == FPType_Infinity then result = FPInfinity(sign); else if fptype == FPType_Zero then sign = sign1 AND sign2; // Use most positive sign  result = FPZero(sign); else // The use of FPRound() covers the case where there is a trapped underflow exception  // for a denormalized number even though the result is exact.  result = FPRound(value, fpcr); return result;   FPMin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  //以下代码为FPMin运算的伪码，摘自ARMARM，意在表示运算规则，这里借用verilog语法高亮，该伪码并非遵循verilog语法规则。 bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr) assert N IN {16,32,64}; (type1,sign1,value1) = FPUnpack(op1, fpcr); (type2,sign2,value2) = FPUnpack(op2, fpcr); (done,result) = FPProcessNaNs(type1, type2, op1, op2, fpcr); if !done then if value1 \u0026lt; value2 then (fptype,sign,value) = (type1,sign1,value1); else (fptype,sign,value) = (type2,sign2,value2); if fptype == FPType_Infinity then result = FPInfinity(sign); else if fptype == FPType_Zero then sign = sign1 OR sign2; // Use most negative sign  result = FPZero(sign); else // The use of FPRound() covers the case where there is a trapped underflow exception  // for a denormalized number even though the result is exact.  result = FPRound(value, fpcr); return result;   浮点运算功能点 关注的操作数  关注的操作数主要指特殊值，以及规格化的最大值、最小值、正负经典值、正负精度值，这些值在浮点运算中往往涉及特殊运算规则，需要格外关注。 二进制表示形式以半精度浮点为例，并注意，NaN值尾数非全零。 经典值指典型的常规值，可以添加多个经典值作为操作数的覆盖。     操作数类型 二进制形式     +0 0_00000_0000000000   -0 1_00000_0000000000   正无穷 0_11111_0000000000   负无穷 1_11111_0000000000   qNaN x_11111_1xxxxxxxxx   sNaN x_11111_0xxxxxxxxx   非规格化最大值 0_00000_1111111111   非规格化最小值 1_00000_1111111111   非规格化正最小精度值 0_00000_0000000001   非规格化负最小精度值 1_00000_0000000001   非规格化正经典值 0_00000_1001011010   非规格化负经典值 1_00000_0110100101   规格化最大值 0_11110_1111111111   规格化最小值 1_11110_1111111111   规格化正最小精度值 0_00001_0000000001   规格化负最小精度值 1_00001_0000000001   规格化正经典值 0_10110_1001011010   规格化负经典值 1_01001_0110100101    加减指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    后面是以结果角度分析，对功能点的补充。   结果为非规格化     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果为0     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果上溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果下溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果非精确     上溢且非精确    下溢且非精确    结果正非精确    结果负非精确   结果为最大值     opa为正normal值, opb为正normal值    opa为正normal值, opb为负normal值   结果为最小值     opa为负normal值, opb为负normal值    opa为负normal值, opb为正normal值   结果为正/负normal     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值    乘法指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    后面是以结果角度分析，对功能点的补充。   结果为非规格化     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果上溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果下溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果非精确     上溢且非精确    下溢且非精确    结果正非精确    结果负非精确   结果为最大值     opa为正normal值, opb为正normal值    opa为负normal值, opb为负normal值   结果为最小值     opa为正normal值, opb为负normal值    opa为负normal值, opb为正normal值   结果为正/负normal     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值    除法指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    后面是以结果角度分析，对功能点的补充。   结果为非规格化     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果上溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果下溢     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值   结果非精确     上溢且非精确    下溢且非精确    结果正非精确    结果负非精确   结果为最大值     opa为正normal值, opb为正normal值    opa为负normal值, opb为负normal值   结果为最小值     opa为正normal值, opb为负normal值    opa为负normal值, opb为正normal值   结果为正/负normal     opa为正normal值, opb为正normal值    opa为负normal值, opb为正normal值    opa为正normal值, opb为负normal值    opa为负normal值, opb为负normal值    比较指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    开方指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    后面是以结果角度分析，对功能点的补充。   结果为非规格化     被开方数为正normal值   结果下溢     被开方数为正normal值   结果非精确     被开方数为正normal值   结果为正normal     被开方数为正normal值    转换指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    后面是以结果角度分析，对功能点的补充。   结果上溢     被转换数为正normal值    被转换数为负normal值   结果下溢     被转换数为正normal值    被转换数为负normal值    FMOV指令    Feature Sub_Feature     操作数类型     关注的操作数组合遍历    通过遍历，可覆盖结果为NaN、结果为0、结果为无穷、结果为非规格化，以及特殊值运算优先级等场景    舍入模式    Feature Sub_Feature result     就近舍入      结果为正，最低有效位的后一位为0 舍    结果为正，最低有效位的后一位为1,且后面数位不全为0 入    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 入    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍    结果为负，最低有效位的后一位为0 舍    结果为负，最低有效位的后一位为1,且后面数位不全为0 入    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 入    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍   向上舍入      结果为正，最低有效位的后一位为0 入    结果为正，最低有效位的后一位为1,且后面数位不全为0 入    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 入    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 入    结果为负，最低有效位的后一位为0 舍    结果为负，最低有效位的后一位为1,且后面数位不全为0 舍    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 舍    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍   向下舍入      结果为正，最低有效位的后一位为0 舍    结果为正，最低有效位的后一位为1,且后面数位不全为0 舍    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 舍    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍    结果为负，最低有效位的后一位为0 入    结果为负，最低有效位的后一位为1,且后面数位不全为0 入    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 入    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 入   向0舍入      结果为正，最低有效位的后一位为0 舍    结果为正，最低有效位的后一位为1,且后面数位不全为0 舍    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 舍    结果为正，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍    结果为负，最低有效位的后一位为0 舍    结果为负，最低有效位的后一位为1,且后面数位不全为0 舍    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为奇数 舍    结果为负，最低有效位的后一位为1,且后面数位全为0，最低有效位为偶数 舍    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":1,"section":"docs","tags":null,"title":"FPU验证那些事","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/fpu-verify/"},{"content":"本文 主要介绍一个基于Python实现的ARM随机指令生成器。\n   版本 说明     0.1 初版发布    背景 在CPU验证中，出于各种原因，经常需要通过汇编程序来实现定向测试，不管是TOP验证环境还是UT验证环境，都有这样的需求。\n通过elf作为CPU验证的激励是一个很好的选择，通过已有的高质量测试集合可以有效的保证验证质量，比如ARM Raven测试集。但是对于UT验证或TOP验证的某些场景下需要手写汇编程序作为激励输入，手写汇编的方式提高了灵活性，可以定向测试某些场景，但是毕竟产能有限，且不好保证测试质量。\n基于上述背景，所以基于Python实现了ARM随机指令生成器。\n功能 支持指令集合中随机选取指令组成测试程序，并且单条指令支持以下字段的随机：\n# \u0026lt;id\u0026gt; : 整型寄存器编号d # \u0026lt;in\u0026gt; : 整型寄存器编号n # \u0026lt;im\u0026gt; : 整型寄存器编号m # \u0026lt;ia\u0026gt; : 整型寄存器编号a # \u0026lt;fd\u0026gt; : 浮点寄存器编号d # \u0026lt;fn\u0026gt; : 浮点寄存器编号n # \u0026lt;fm\u0026gt; : 浮点寄存器编号m # \u0026lt;fa\u0026gt; : 浮点寄存器编号a # \u0026lt;T1\u0026gt; : 向量处理类型1 # \u0026lt;T2\u0026gt; : 向量处理类型2 # \u0026lt;V\u0026gt; : 浮点寄存器类型（H/S/D） # \u0026lt;R\u0026gt; : 整型寄存器类型（X/W） # \u0026lt;index\u0026gt; : element索引值 目前仅支持这些随机字段，本文目的不是提供一个完整功能的随机指令生成器，而是展示一个框架，方便使用者自定义一些功能。\n文件结构 ├── A64_TPL.list ├── A32_TPL.list ├── T32_TPL.list ├── gen_testcode.py ├── src │ ├── Function.py │ ├── SuperTPL.py │ └── TPL │ ├── TPL_demo1.py │ ├── TPL_demo2.py └── tools Function.py文件 Function.py文件是一个函数集合：（TPL指template）\n add_TPL(TPL)：将某指令TPL添加到TPL_list，作为一个指令集合，便于从中随机选取指令，组合成测试程序。 get_random_TPL()：从TPL_list随机选取一条指令TPL。 gen_testinstr_codeblock(test_depend)：从指令集合中随机抽取100次，组成100条指令的测试程序，这里test_depend为1，会缩小寄存器编号的随机范围，提高指令间依赖的概率。 gen_cfgfreg_codeblock_a64(random_data_list)：从random_data_list中随机选取数据来更新浮点寄存器，通过此方法更新操作数可提高测试质量。 gen_cfgfreg_codeblock_a32(random_data_list)、gen_cfgfreg_codeblock_t32(random_data_list)同上。 gen_cfggreg_codeblock_a64(random_data_list)：从random_data_list中随机选取数据来更新整型寄存器，通过此方法更新操作数可提高测试质量。 gen_cfggreg_codeblock_a32(random_data_list):、gen_cfggreg_codeblock_t32(random_data_list)同上。 gen_cfgfpcr_codeblock_a64()：产生合法的随机数据，配置浮点控制寄存器，目的是覆盖更多的随机场景。 gen_cfgfpcr_codeblock_a32()、gen_cfgfpcr_codeblock_t32()同上。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229  import random import re TPL_list =[] cfgfreg_codeblock_a64 = [\u0026#34; mov x0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov x1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; mov x2, #0x\u0026lt;data2\u0026gt;\u0026#34;, \\ \u0026#34; mov x3, #0x\u0026lt;data3\u0026gt;\u0026#34;, \\ \u0026#34; mov x4, #0x\u0026lt;data4\u0026gt;\u0026#34;, \\ \u0026#34; mov x5, #0x\u0026lt;data5\u0026gt;\u0026#34;, \\ \u0026#34; mov x6, #0x\u0026lt;data6\u0026gt;\u0026#34;, \\ \u0026#34; mov x7, #0x\u0026lt;data7\u0026gt;\u0026#34;, \\ \u0026#34; bfi x11, x0, #0, #16\u0026#34;, \\ \u0026#34; bfi x11, x1, #16, #16\u0026#34;, \\ \u0026#34; bfi x11, x2, #32, #16\u0026#34;, \\ \u0026#34; bfi x11, x3, #48, #16\u0026#34;, \\ \u0026#34; bfi x12, x4, #0, #16\u0026#34;, \\ \u0026#34; bfi x12, x5, #16, #16\u0026#34;, \\ \u0026#34; bfi x12, x6, #32, #16\u0026#34;, \\ \u0026#34; bfi x12, x7, #48, #16\u0026#34;, \\ \u0026#34; fmov d\u0026lt;num\u0026gt;, x11\u0026#34;, \\ \u0026#34; fmov v\u0026lt;num\u0026gt;.D[1], x12\u0026#34;] cfgfreg_codeblock_a32 = [\u0026#34; mov r0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; mov r2, #0x\u0026lt;data2\u0026gt;\u0026#34;, \\ \u0026#34; mov r3, #0x\u0026lt;data3\u0026gt;\u0026#34;, \\ \u0026#34; bfi r8, r0, #0, #16\u0026#34;, \\ \u0026#34; bfi r8, r1, #16, #16\u0026#34;, \\ \u0026#34; bfi r9, r2, #32, #16\u0026#34;, \\ \u0026#34; bfi r9, r3, #48, #16\u0026#34;, \\ \u0026#34; vmov d\u0026lt;num\u0026gt;, r8, r9\u0026#34;] cfgfreg_codeblock_t32 = [\u0026#34; mov r0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; mov r2, #0x\u0026lt;data2\u0026gt;\u0026#34;, \\ \u0026#34; mov r3, #0x\u0026lt;data3\u0026gt;\u0026#34;, \\ \u0026#34; bfi r8, r0, #0, #16\u0026#34;, \\ \u0026#34; bfi r8, r1, #16, #16\u0026#34;, \\ \u0026#34; bfi r9, r2, #32, #16\u0026#34;, \\ \u0026#34; bfi r9, r3, #48, #16\u0026#34;, \\ \u0026#34; vmov d\u0026lt;num\u0026gt;, r8, r9\u0026#34;] cfggreg_codeblock_a64 = [\u0026#34; mov x0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov x1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; mov x2, #0x\u0026lt;data2\u0026gt;\u0026#34;, \\ \u0026#34; mov x3, #0x\u0026lt;data3\u0026gt;\u0026#34;, \\ \u0026#34; bfi x0, x0, #0, #16\u0026#34;, \\ \u0026#34; bfi x0, x1, #16, #16\u0026#34;, \\ \u0026#34; bfi x0, x2, #32, #16\u0026#34;, \\ \u0026#34; bfi x0, x3, #48, #16\u0026#34;, \\ \u0026#34; mov x\u0026lt;num\u0026gt;, x0\u0026#34;] cfggreg_codeblock_a32 = [\u0026#34; mov r0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; bfi r0, r0, #0, #16\u0026#34;, \\ \u0026#34; bfi r0, r1, #16, #16\u0026#34;, \\ \u0026#34; mov r\u0026lt;num\u0026gt;, r0\u0026#34;] cfggreg_codeblock_t32 = [\u0026#34; mov r0, #0x\u0026lt;data0\u0026gt;\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data1\u0026gt;\u0026#34;, \\ \u0026#34; bfi r0, r0, #0, #16\u0026#34;, \\ \u0026#34; bfi r0, r1, #16, #16\u0026#34;, \\ \u0026#34; mov r\u0026lt;num\u0026gt;, r0\u0026#34;] #fpcr #[19]:FZ16; [23:22]:RMode, [24]:FZ; [25]:DN; [26]:AHP cfgfpcr_codeblock_a64 = [\u0026#34; mov x0, #0x0000\u0026#34;, \\ \u0026#34; mov x1, #0x\u0026lt;data\u0026gt;\u0026#34;, \\ \u0026#34; mov x2, #0x0000\u0026#34;, \\ \u0026#34; mov x3, #0x0000\u0026#34;, \\ \u0026#34; bfi x11, x0, #0, #16\u0026#34;, \\ \u0026#34; bfi x11, x1, #16, #16\u0026#34;, \\ \u0026#34; bfi x11, x2, #32, #16\u0026#34;, \\ \u0026#34; bfi x11, x3, #48, #16\u0026#34;, \\ \u0026#34; msr fpcr, x11\u0026#34;] cfgfpcr_codeblock_a32 = [\u0026#34; mov r0, #0x0000\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data\u0026gt;\u0026#34;, \\ \u0026#34; bfi r0, x0, #0, #16\u0026#34;, \\ \u0026#34; bfi r0, r1, #16, #16\u0026#34;, \\ \u0026#34; vmsr fpscr, r0\u0026#34;] cfgfpcr_codeblock_t32 = [\u0026#34; mov r0, #0x0000\u0026#34;, \\ \u0026#34; mov r1, #0x\u0026lt;data\u0026gt;\u0026#34;, \\ \u0026#34; bfi r0, x0, #0, #16\u0026#34;, \\ \u0026#34; bfi r0, r1, #16, #16\u0026#34;, \\ \u0026#34; vmsr fpscr, r0\u0026#34;] def add_TPL(TPL): global TPL_list TPL_list.append(TPL) def get_random_TPL(): global TPL_list return random.choice(TPL_list) def gen_testinstr_codeblock(test_depend): codeblock = [] for i in range(100): instr_tpl = get_random_TPL() if test_depend == 1: instr_tpl.test_depend() codeblock.append(instr_tpl.gen_one_instr()) return codeblock def gen_cfgfreg_codeblock_a64(random_data_list): global cfgfreg_codeblock_a64 codeblock = [] for i in range(32): data0 = random.choice(random_data_list) data1 = random.choice(random_data_list) for instr in cfgfreg_codeblock_a64: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[12:16], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[8:12], instr) instr = re.sub(r\u0026#34;\u0026lt;data2\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data3\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;data4\u0026gt;\u0026#34;, data0[12:16], instr) instr = re.sub(r\u0026#34;\u0026lt;data5\u0026gt;\u0026#34;, data0[8:12], instr) instr = re.sub(r\u0026#34;\u0026lt;data6\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data7\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfgfreg_codeblock_a32(random_data_list): global cfgfreg_codeblock_a32 codeblock = [] for i in range(32): data0 = random.choice(random_data_list) for instr in cfgfreg_codeblock_a32: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[12:16], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[8:12], instr) instr = re.sub(r\u0026#34;\u0026lt;data2\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data3\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfgfreg_codeblock_t32(random_data_list): global cfgfreg_codeblock_t32 codeblock = [] for i in range(32): data0 = random.choice(random_data_list) for instr in cfgfreg_codeblock_t32: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[12:16], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[8:12], instr) instr = re.sub(r\u0026#34;\u0026lt;data2\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data3\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfggreg_codeblock_a64(random_data_list): global cfggreg_codeblock_a64 codeblock = [] for i in range(1, 29): data0 = random.choice(random_data_list) for instr in cfggreg_codeblock_a64: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[12:16], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[8:12], instr) instr = re.sub(r\u0026#34;\u0026lt;data2\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data3\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfggreg_codeblock_a32(random_data_list): global cfggreg_codeblock_a32 codeblock = [] for i in range(1, 12): data0 = random.choice(random_data_list) for instr in cfggreg_codeblock_a64: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfggreg_codeblock_t32(random_data_list): global cfggreg_codeblock_t32 codeblock = [] for i in range(1, 12): data0 = random.choice(random_data_list) for instr in cfggreg_codeblock_a64: instr = re.sub(r\u0026#34;\u0026lt;data0\u0026gt;\u0026#34;, data0[4:8], instr) instr = re.sub(r\u0026#34;\u0026lt;data1\u0026gt;\u0026#34;, data0[0:4], instr) instr = re.sub(r\u0026#34;\u0026lt;num\u0026gt;\u0026#34;, str(i), instr) codeblock.append(instr) return codeblock def gen_cfgfpcr_codeblock_a64(): global cfgfreg_codeblock_a64 codeblock = [] data0 = [\u0026#34;0\u0026#34;, \u0026#34;8\u0026#34;] data1 = [\u0026#34;0\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;c\u0026#34;] data2 = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] data3 = [\u0026#34;0\u0026#34;] data = random.choice(data3)+random.choice(data2)+random.choice(data1)+random.choice(data0) for instr in cfgfpcr_codeblock_a64: instr = re.sub(r\u0026#34;\u0026lt;data\u0026gt;\u0026#34;, data, instr) codeblock.append(instr) return codeblock def gen_cfgfpcr_codeblock_a32(): global cfgfreg_codeblock_a32 codeblock = [] data0 = [\u0026#34;0\u0026#34;, \u0026#34;8\u0026#34;] data1 = [\u0026#34;0\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;c\u0026#34;] data2 = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] data3 = [\u0026#34;0\u0026#34;] data = random.choice(data3)+random.choice(data2)+random.choice(data1)+random.choice(data0) for instr in cfgfpcr_codeblock_a32: instr = re.sub(r\u0026#34;\u0026lt;data\u0026gt;\u0026#34;, data, instr) codeblock.append(instr) return codeblock def gen_cfgfpcr_codeblock_t32(): global cfgfreg_codeblock_t32 codeblock = [] data0 = [\u0026#34;0\u0026#34;, \u0026#34;8\u0026#34;] data1 = [\u0026#34;0\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;c\u0026#34;] data2 = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;] data3 = [\u0026#34;0\u0026#34;] data = random.choice(data3)+random.choice(data2)+random.choice(data1)+random.choice(data0) for instr in cfgfpcr_codeblock_t32: instr = re.sub(r\u0026#34;\u0026lt;data\u0026gt;\u0026#34;, data, instr) codeblock.append(instr) return codeblock   SuperTPL.py文件 SuperTPL.py文件是每个指令TPL的父类，定义了基础的变量和函数。主要内容如下：\n 定义各字段的随机范围（属于默认值）。 设置test_depend下的寄存器编号字段随机范围。 设置非A64下的寄存器编号字段随机范围。 各个字段的随机范围重新定义函数（为子类的个性化设置提供方法）。 各个字段的获取随机值函数。 gen_one_instr(self)函数：生成一条指令，主要对指令TPL的各个字段进行随机值替换。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  import random import re class SuperTPL(object): def __init__(self): super(SuperTPL, self).__init__() self._instr_tpl = \u0026#34;TPL V\u0026lt;d\u0026gt;.\u0026lt;T1\u0026gt;, V\u0026lt;n\u0026gt;.\u0026lt;T1\u0026gt;, V\u0026lt;m\u0026gt;.\u0026lt;T1\u0026gt;\u0026#34; self._id_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;] self._in_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;] self._im_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;] self._ia_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;] self._fd_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;29\u0026#34;,\u0026#34;30\u0026#34;,\u0026#34;31\u0026#34;] self._fn_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;29\u0026#34;,\u0026#34;30\u0026#34;,\u0026#34;31\u0026#34;] self._fm_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;29\u0026#34;,\u0026#34;30\u0026#34;,\u0026#34;31\u0026#34;] self._fa_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;,\u0026#34;16\u0026#34;,\u0026#34;17\u0026#34;,\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,\u0026#34;26\u0026#34;,\u0026#34;27\u0026#34;,\u0026#34;28\u0026#34;,\u0026#34;29\u0026#34;,\u0026#34;30\u0026#34;,\u0026#34;31\u0026#34;] self._T1_list = [\u0026#34;8B\u0026#34;, \u0026#34;16B\u0026#34;, \u0026#34;4H\u0026#34;, \u0026#34;8H\u0026#34;, \u0026#34;2S\u0026#34;, \u0026#34;4S\u0026#34;, \u0026#34;2D\u0026#34;] self._T2_list = [\u0026#34;8B\u0026#34;, \u0026#34;16B\u0026#34;, \u0026#34;4H\u0026#34;, \u0026#34;8H\u0026#34;, \u0026#34;2S\u0026#34;, \u0026#34;4S\u0026#34;, \u0026#34;2D\u0026#34;] self._V_list = [\u0026#34;H\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;D\u0026#34;] self._R_list = [\u0026#34;W\u0026#34;, \u0026#34;X\u0026#34;] self._index_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;] def test_depend(self): self._id_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._in_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._im_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._ia_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._fd_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._fn_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._fm_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] self._fa_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;] def is_not_a64(self): self._id_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;] self._in_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;] self._im_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;] self._ia_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;] self._fd_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;] self._fn_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;] self._fm_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;] self._fa_list = [\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;13\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;15\u0026#34;] def set_instr_tpl(self, instr_tpl): self._instr_tpl = instr_tpl # set random range #------------------------------------------------------------- def set_randomrange_id(self, id_list): self._id_list = id_list def set_randomrange_in(self, in_list): self._in_list = in_list def set_randomrange_im(self, im_list): self._im_list = im_list def set_randomrange_ia(self, ia_list): self._ia_list = ia_list def set_randomrange_fd(self, fd_list): self._fd_list = fd_list def set_randomrange_fn(self, fn_list): self._fn_list = fn_list def set_randomrange_fm(self, fm_list): self._fm_list = fm_list def set_randomrange_fa(self, fa_list): self._fa_list = fa_list def set_randomrange_T1(self, T1_list): self._T1_list = T1_list def set_randomrange_T2(self, T2_list): self._T2_list = T2_list def set_randomrange_V(self, V_list): self._V_list = V_list def set_randomrange_R(self, R_list): self._R_list = R_list def set_randomrange_index(self, index_list): self._index_list = index_list #------------------------------------------------------------- # get random value #------------------------------------------------------------- def get_randomvalue_id(self): return random.choice(self._id_list) def get_randomvalue_in(self): return random.choice(self._in_list) def get_randomvalue_im(self): return random.choice(self._im_list) def get_randomvalue_ia(self): return random.choice(self._ia_list) def get_randomvalue_fd(self): return random.choice(self._fd_list) def get_randomvalue_fn(self): return random.choice(self._fn_list) def get_randomvalue_fm(self): return random.choice(self._fm_list) def get_randomvalue_fa(self): return random.choice(self._fa_list) def get_randomvalue_T1(self): return random.choice(self._T1_list) def get_randomvalue_T2(self): return random.choice(self._T2_list) def get_randomvalue_V(self): return random.choice(self._V_list) def get_randomvalue_R(self): return random.choice(self._R_list) def get_randomvalue_index(self): return random.choice(self._index_list) #------------------------------------------------------------- # gen one instr #------------------------------------------------------------- def gen_one_instr(self): self._instr = self._instr_tpl self._instr = re.sub(r\u0026#34;\u0026lt;id\u0026gt;\u0026#34;, self.get_randomvalue_id(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;in\u0026gt;\u0026#34;, self.get_randomvalue_in(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;im\u0026gt;\u0026#34;, self.get_randomvalue_im(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;ia\u0026gt;\u0026#34;, self.get_randomvalue_ia(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;fd\u0026gt;\u0026#34;, self.get_randomvalue_fd(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;fn\u0026gt;\u0026#34;, self.get_randomvalue_fn(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;fm\u0026gt;\u0026#34;, self.get_randomvalue_fm(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;fa\u0026gt;\u0026#34;, self.get_randomvalue_fa(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;T1\u0026gt;\u0026#34;, self.get_randomvalue_T1(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;T2\u0026gt;\u0026#34;, self.get_randomvalue_T2(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;V\u0026gt;\u0026#34;, self.get_randomvalue_V(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;R\u0026gt;\u0026#34;, self.get_randomvalue_R(), self._instr) self._instr = re.sub(r\u0026#34;\u0026lt;index\u0026gt;\u0026#34;, self.get_randomvalue_index(), self._instr) return self._instr #-------------------------------------------------------------   TPL下的文件 TPL下的文件是指令的模板，继承自SuperTPL.py。以下指令模板仅为展示所用，不代表ARM合法指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  from SuperTPL import SuperTPL from Function import add_TPL class demo1_ADD_01(SuperTPL): def __init__(self): super(demo1_ADD_01, self).__init__() self.set_instr_tpl(\u0026#34; ADD01 W\u0026lt;id\u0026gt;, W\u0026lt;in\u0026gt;, W\u0026lt;im\u0026gt;\u0026#34;) self.set_randomrange_id([\u0026#34;0, 1\u0026#34;]) add_TPL(demo1_ADD_01()) class demo1_ADD_02(SuperTPL): def __init__(self): super(demo1_ADD_02, self).__init__() self.set_instr_tpl(\u0026#34; ADD02 W\u0026lt;id\u0026gt;, W\u0026lt;in\u0026gt;, W\u0026lt;im\u0026gt;\u0026#34;) self.set_randomrange_id([\u0026#34;3, 4\u0026#34;]) add_TPL(demo1_ADD_02()) class demo1_ADD_03(SuperTPL): def __init__(self): super(demo1_ADD_03, self).__init__() self.set_instr_tpl(\u0026#34; ADD03 W\u0026lt;id\u0026gt;, W\u0026lt;in\u0026gt;, W\u0026lt;im\u0026gt;\u0026#34;) self.set_randomrange_id([\u0026#34;5, 6\u0026#34;]) add_TPL(demo1_ADD_03()) class demo1_ADD_04(SuperTPL): def __init__(self): super(demo1_ADD_04, self).__init__() self.set_instr_tpl(\u0026#34; ADD04 W\u0026lt;id\u0026gt;, W\u0026lt;in\u0026gt;, W\u0026lt;im\u0026gt;\u0026#34;) self.set_randomrange_id([\u0026#34;7, 8\u0026#34;]) add_TPL(demo1_ADD_04()) class demo1_ADD_05(SuperTPL): def __init__(self): super(demo1_ADD_05, self).__init__() self.set_instr_tpl(\u0026#34; ADD05 W\u0026lt;id\u0026gt;, W\u0026lt;in\u0026gt;, W\u0026lt;im\u0026gt;\u0026#34;) self.set_randomrange_id([\u0026#34;9, 10\u0026#34;]) add_TPL(demo1_ADD_05())   xx_TPL.list文件 xx_TPL.list是src/TPL/目录下的集合清单，罗列了单个TPL名称，也对多个TPL进行了分组，供gen_testcode.py使用。\n注意：对于单个TPL文件的组织，可以定义单条指令及它的多种变型，也可以定义多条指令，具体粒度由使用者灵活掌握。这里建议一个TPL定义一组同类型指令，比如浮点双精度加法运算。\ncasename=TPL_demo1, groupname=demo casename=TPL_demo2, groupname=demo gen_testcode.py文件 gen_testcode.py文件是整个环境的top脚本。提供的使用参数如下：\n args_ISA ：设置生成的指令类型，A64 or A32 or T32 args_filename ：设置输出文件名称 args_casename ：设置随机的TPL名称（不可与groupname同时设置） args_groupname ：设置随机的多个TPL组合名称（不可与casename同时设置） args_testfloat ：设置是否使用testfloat数据更新浮点寄存器，可选参数为FP64、FP32、FP16（此环境暂时没集成testfloat，不可设置），如果不设置默认使用随机值。 args_sizelevel ：设置sizelevel（默认为1），生成的测试指令数等于 sizelevel*100 + cfgfreg_instrnum\u0026hellip; args_cfgfpcr ：设置支持fpcr寄存器配置（在每100条测试指令前配置） args_seednum ：设置随机种子，随机种子会注释到输出文件首行，目的是支持可复现性。 args_test_depend ：设置支持test_depend，如果测试指令依赖，会将寄存器编号的随机范围缩小。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299  import sys import os import random import re sys.path.insert(0, \u0026#34;src\u0026#34;) sys.path.insert(0, \u0026#34;src/TPL\u0026#34;) from Function import * args_ISA = \u0026#34;\u0026#34; args_filename = \u0026#34;\u0026#34; args_casename = \u0026#34;\u0026#34; args_groupname = \u0026#34;\u0026#34; args_testfloat = \u0026#34;\u0026#34; args_sizelevel = 1 args_cfgfpcr = 0 args_seednum = 0 args_test_depend = 0 # usage #-------------------------------------------------------- if sys.argv[1] == \u0026#34;--help\u0026#34; or sys.argv[1] == \u0026#34;-h\u0026#34;: print \u0026#34;\u0026#34; print \u0026#34;\u0026lt;usage\u0026gt;:\u0026#34; print \u0026#34; python gen_testcode.py [ISA=xxx] [filename=xxx] ([casename=xxx] or [groupname=xxx]) [testfloat=xxx] [sizelevel=xxx] [-cfgfpcr] [seednum=xxx] [-test_depend]\u0026#34; print \u0026#34;\u0026lt;args\u0026gt;:\u0026#34; print \u0026#34; ISA=xxx : set A64 or A32 or T32\u0026#34; print \u0026#34; filename=xxx : set the outfile testcode filename.s\u0026#34; print \u0026#34; casename=xxx : one TPL case exist in TPL.list, generate testcode by the TPL case instr template\u0026#34; print \u0026#34; groupname=xxx : one group TPL case exist in TPL.list, generate testcode by the group TPL case instr template\u0026#34; print \u0026#34; testfloat=xxx : insert code block in testcode to config fp registers by testfloat special value(FP64/FP32/FP16)\u0026#34; print \u0026#34; sizelevel=xxx : set code size level, size is n*100 test isntrs\u0026#34; print \u0026#34; -cfgfpcr : insert code block in testcode to config fpcr register by random value\u0026#34; print \u0026#34; seednum=xxx : set the random seed,the purpose is to be able to recover the test scenario\u0026#34; print \u0026#34; -test_depend : if test instr depend, the reg random range is 0~5\u0026#34; print \u0026#34;\u0026lt;note\u0026gt;:\u0026#34; print \u0026#34; filename must be set\u0026#34; print \u0026#34; casename and groupname can\u0026#39;t be set at the same time\u0026#34; print \u0026#34;\u0026lt;example\u0026gt;:\u0026#34; print \u0026#34; one case: python gen_testcode.py filename=test0 ISA=A64 casename=TPL_demo1 sizelevel=10 testfloat=FP64 -cfgfpcr\u0026#34; print \u0026#34; one group case: python gen_testcode.py filename=test0 ISA=A64 groupname=demo sizelevel=10 testfloat=FP64 -cfgfpcr\u0026#34; print \u0026#34;\u0026#34; sys.exit() root_path = os.getcwd() if os.path.basename(root_path) != \u0026#34;random_instr_generator\u0026#34;: print \u0026#34;[GEN_TESTCODE ERROR]: must run the script under the random_instr_generator path, please double check your current work directory\u0026#34; sys.exit() #-------------------------------------------------------- # fet args #-------------------------------------------------------- gen_testcode_command = \u0026#34;python gen_testcode.py\u0026#34; for args in sys.argv: gen_testcode_command = gen_testcode_command+\u0026#34; \u0026#34;+args print \u0026#34;[GEN_TESTCODE START]: \u0026#34;+gen_testcode_command for args in sys.argv: if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;ISA\u0026#34;: args_ISA = args.strip().split(\u0026#34;=\u0026#34;)[1].strip() if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;filename\u0026#34;: args_filename = args.strip().split(\u0026#34;=\u0026#34;)[1].strip() if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;casename\u0026#34;: args_casename = args.strip().split(\u0026#34;=\u0026#34;)[1].strip() if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;groupname\u0026#34;: args_groupname = args.strip().split(\u0026#34;=\u0026#34;)[1].strip() if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;testfloat\u0026#34;: args_testfloat = args.strip().split(\u0026#34;=\u0026#34;)[1].strip() if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;sizelevel\u0026#34;: args_sizelevel = int(args.strip().split(\u0026#34;=\u0026#34;)[1].strip()) if args.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;seednum\u0026#34;: args_seednum = int(args.strip().split(\u0026#34;=\u0026#34;)[1].strip()) if args == \u0026#34;-cfgfpcr\u0026#34;: args_cfgfpcr = 1 if args == \u0026#34;-test_depend\u0026#34;: args_test_depend = 1 # args check if args_filename == \u0026#34;\u0026#34;: print \u0026#34;[GEN_TESTCODE ERROR]: args filename=xxx must be set, please double check ypur args\u0026#34; sys.exit() if args_casename == \u0026#34;\u0026#34; and args_groupname == \u0026#34;\u0026#34;: print \u0026#34;[GEN_TESTCODE ERROR]: args casename=xxx and groupname=xxx must be set one of them, please double check ypur args\u0026#34; sys.exit() if args_casename != \u0026#34;\u0026#34; and args_groupname != \u0026#34;\u0026#34;: print \u0026#34;[GEN_TESTCODE ERROR]: args casename=xxx and groupname=xxx can\u0026#39;t be set at the same time, please double check ypur args\u0026#34; sys.exit() # set random seed if args_seednum != 0: random.seed(args_seednum) #-------------------------------------------------------- # import TPL #-------------------------------------------------------- if args_ISA == \u0026#34;A64\u0026#34;: TPL_listpath = \u0026#34;./A64_TPL.list\u0026#34; if args_ISA == \u0026#34;A32\u0026#34;: TPL_listpath = \u0026#34;./A32_TPL.list\u0026#34; if args_ISA == \u0026#34;T32\u0026#34;: TPL_listpath = \u0026#34;./T32_TPL.list\u0026#34; TPL_listfile = open(TPL_listpath, \u0026#34;r\u0026#34;) TPL_casename = \u0026#34;\u0026#34; TPL_groupname = \u0026#34;\u0026#34; import_TPL_list = [] # get import_TPL_list from TPL.list while True: TPL_line = TPL_listfile.readline() if not TPL_line: break TPL_casename = \u0026#34;\u0026#34; TPL_groupname = \u0026#34;\u0026#34; find_result = re.findall(r\u0026#34;^[ ]*//.*\u0026#34;, TPL_line) if len(find_result) != 0: continue find_result = re.findall(r\u0026#34;^[ ]*casename=([a-zA-Z_0-9]+),[ ]*groupname=([a-zA-Z_0-9]+)[ ]*\u0026#34;, TPL_line) if len(find_result) != 0: TPL_casename = find_result[0][0] TPL_groupname = find_result[0][1] # one case if args_casename != \u0026#34;\u0026#34;: if args_casename == TPL_casename: import_TPL_list.append(TPL_casename) # one group if args_groupname != \u0026#34;\u0026#34;: if args_groupname == TPL_groupname: import_TPL_list.append(TPL_casename) TPL_listfile.close() # check import_TPL_list import_TPL_num = len(import_TPL_list) if args_casename != \u0026#34;\u0026#34;: if import_TPL_num != 1: print \u0026#34;[GEN_TESTCODE ERROR]: can\u0026#39;t find the \u0026#34;+args_casename+\u0026#34; or more than one in TPL.list, please double check run args or TPL.list\u0026#34; sys.exit() if args_groupname != \u0026#34;\u0026#34;: if import_TPL_num == 0: print \u0026#34;[GEN_TESTCODE ERROR]: can\u0026#39;t find the \u0026#34;+args_groupname+\u0026#34; in TPL.list, please double check run args or TPL.list\u0026#34; sys.exit() # import the TPL list for TPL in import_TPL_list: __import__(TPL) #-------------------------------------------------------- # prepare random data list #-------------------------------------------------------- fdata_list = [] tf_path = root_path+\u0026#34;/tools/testfoat/berkeley-testfloat-3/build/Linux-ARM-VFPv2-GCC/\u0026#34; if args_testfloat == \u0026#34;FP64\u0026#34;: os.chdir(tf_path) testfloat_command = \u0026#34;./testfloat_gen f64 1 -seed \u0026#34;+str(args_seednum)+\u0026#34; -n 1000 \u0026gt;tf64_\u0026#34;+str(args_seednum) os.system(testfloat_command) tf64_file = open(\u0026#34;./tf64_\u0026#34;+str(args_seednum), \u0026#34;r\u0026#34;) for i in range(1000): line = tf64_file.readline() line = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line) line = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line) fdata_list.append(line) tf64_file.close() os.system(\u0026#34;rm -rf tf64_\u0026#34;+str(args_seednum)) os.chdir(root_path) if args_testfloat == \u0026#34;FP32\u0026#34;: os.chdir(tf_path) testfloat_command = \u0026#34;./testfloat_gen f32 1 -seed \u0026#34;+str(args_seednum)+\u0026#34; -n 2000 \u0026gt;tf32_\u0026#34;+str(args_seednum) os.system(testfloat_command) tf32_file = open(\u0026#34;./tf32_\u0026#34;+str(args_seednum), \u0026#34;r\u0026#34;) for i in range(1000): line0 = tf32_file.readline() line0 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line0) line0 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line0) line1 = tf32_file.readline() line1 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line1) line1 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line1) fdata_list.append(line0+line1) tf32_file.close() os.system(\u0026#34;rm -rf tf32_\u0026#34;+str(args_seednum)) os.chdir(root_path) if args_testfloat == \u0026#34;FP16\u0026#34;: os.chdir(tf_path) testfloat_command = \u0026#34;./testfloat_gen f16 1 -seed \u0026#34;+str(args_seednum)+\u0026#34; -n 4000 \u0026gt;tf16_\u0026#34;+str(args_seednum) os.system(testfloat_command) tf16_file = open(\u0026#34;./tf16_\u0026#34;+str(args_seednum), \u0026#34;r\u0026#34;) for i in range(1000): line0 = tf16_file.readline() line0 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line0) line0 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line0) line1 = tf16_file.readline() line1 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line1) line1 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line1) line2 = tf16_file.readline() line2 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line2) line2 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line2) line3 = tf16_file.readline() line3 = re.sub(r\u0026#34;[ ]\u0026#34;, \u0026#34;\u0026#34;, line3) line3 = re.sub(r\u0026#34;[\\n]\u0026#34;, \u0026#34;\u0026#34;, line3) fdata_list.append(line0+line1+line2+line3) tf16_file.close() os.system(\u0026#34;rm -rf tf16_\u0026#34;+str(args_seednum)) os.chdir(root_path) if args_testfloat == \u0026#34;\u0026#34;: data0_list = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] for i in range(1000): data = [] data = random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) fdata_list.append(data) idata_list = [] data0_list = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] for i in range(1000): data = [] data = random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) data = data + random.choice(data0_list) idata_list.append(data) #-------------------------------------------------------- # gen testcode #-------------------------------------------------------- testcode = [] for i in range(args_sizelevel): testcode0 = [] testcode1 = [] testcode2 = [] testcode3 = [] if args_ISA == \u0026#34;A64\u0026#34;: testcode0 = gen_cfgfpcr_codeblock_a64() testcode1 = gen_cfgfreg_codeblock_a64(fdata_list) testcode2 = gen_cfgfreg_codeblock_a64(idata_list) testcode3 = gen_testinstr_codeblock(args_test_depend) if args_ISA == \u0026#34;A32\u0026#34;: testcode0 = gen_cfgfpcr_codeblock_a32() testcode1 = gen_cfgfreg_codeblock_a32(fdata_list) testcode2 = gen_cfgfreg_codeblock_a32(idata_list) testcode3 = gen_testinstr_codeblock(args_test_depend) if args_ISA == \u0026#34;T32\u0026#34;: testcode0 = gen_cfgfpcr_codeblock_t32() testcode1 = gen_cfgfreg_codeblock_t32(fdata_list) testcode2 = gen_cfgfreg_codeblock_t32(idata_list) testcode3 = gen_testinstr_codeblock(args_test_depend) testcode = testcode + testcode0 + testcode1 + testcode2 + testcode3 testcode_path = root_path+\u0026#34;/\u0026#34;+args_filename+\u0026#34;.s\u0026#34; if os.path.exists(testcode_path): os.system(\u0026#34;rm -rf \u0026#34;+testcode_path) os.system(\u0026#34;touch \u0026#34;+testcode_path) testcode_file = open(testcode_path, \u0026#34;a\u0026#34;) for instr in testcode: testcode_file.write(instr+\u0026#34;\\n\u0026#34;) testcode_file.close() #--------------------------------------------------------   tools目录 tools目录下是为了集成testfloat或其他应用程序而提供的，暂时未集成testfloat。\n使用方法  首先参考/src/TPL/TPL_demo1.py文件，定义新的指令类型，对于随机字段的随机范围可重新定义，也可以使用默认范围。 如果有环境中未支持的随机字段，需要在SuperTPL.py文件添加相关操作，包括定义随机范围、获取随机值、随机字段替换等。 将TPL添加至对应的xx_TPL.list，casename与TPL文件名称保持一致，groupnamename可自定义。 使用gen_testcode.py脚本生成随机指令，具体gen_testcode.py的使用方法和参数可以通过-h获取。 对于生成随机指令的合法性，需要通过ARM编译器进行检验，成功编译说明TPL没问题，成熟的TPL可能需要经过多次检验。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":2,"section":"docs","tags":["ARM","Python"],"title":"基于Python实现ARM随机指令生成器","uri":"https://www.wenhui.space/docs/09-arm/random-instr-generator/"},{"content":"本文 主要介绍一个关于处理器中DPU模块的验证环境。\n   版本 说明     0.1 初版发布    专业术语与缩略语    缩写 全称 说明     IFU Instruction Fetch Unit 取指令部件   DPU Data Processing Unit 数据运算部件   DCU/LSU Data Cache Unit / Load Store Unit 访存部件   IQ Instruction Queue 指令队列         先修知识  ARM处理器架构和微架构基础。 Verilog与SystemVerilog。 UVM基础。 Shell和Python脚本编程。 Makefile编程。 交叉编译环境。 ARM汇编裸机程序。  什么是DPU？ 处理器主要分为三个大的模块：\n IFU：取指部件。 DPU：数据运算部件。 DCU/LSU：访存部件。  其中DPU内主要包含指令的译码、整型寄存器和浮点寄存器、运算单元以及其他流水控制等功能模块。\n IFU与DPU之间存在一个IQ，其目的是将IFU与DPU的连接进行解耦，解除强相关。 DPU接收来自IFU发送的指令码，其中指令已经由IFU完成了预译码操作，主要获取指令类型和归整寄存器编号等字段。 decode模块接收来自IFU或IQ的指令，对指令进行译码以及拆分微操作。 dispatch模块完成指令依赖的检查，依据规则控制指令或微操作进入issue阶段。 issue模块将指令或微操作依据类型发送到各个执行单元，同时读取寄存器获取操作数。 运算单元完成相应指令的运算。 将运算结果写回目的寄存器，指令结束。 其中还会发生异常和跳转，需要刷新流水线，以及正常的流水线控制都在dpu_ctl模块。  dpu部件流水线大致如下：\n     DPU_UT环境主要内容  测试程序框架：基于ARM汇编程序实现一个裸机测试程序框架，主要涉及内容为系统寄存器初始化、异常向量表、栈指针初始化、异常等级切换、A64和A32混合编程，以及基于Makefile实现的自动化编译和链接。 基于Python实现的随机指令生成器：支持通用寄存器、扩展寄存器、系统寄存器的更新。 ARM FastModel的启动脚本：将通过FastModel载入elf文件，trace出指令流信息（tarmac文件），以此作为验证平台的激励和Reference Model。 基于Python实现的指令信息提取脚本：负责将指令执行信息从tarmac文件中提取出来，重新组织格式输出到文件，便于验证平台载入。 基于UVM搭建的验证平台：driver负责载入指令信息并控制驱动dut，并将指令信息传送给checker，注意在驱动前需要先配置dut部分寄存器，并且配置信息要与fastmodel和裸机程序中的系统寄存器初始化保持一致；checker将接收来自driver发送的指令信息，并更新至checker中的通用寄存器和扩展寄存器结构，同时对dut通用寄存器和扩展寄存器进行采样，保存数据并与checker的数据进行check。 验证环境的自动化：基于shell实现单条case的仿真自动化，并支持多种仿真参数；基于Python实现回归测试的自动化，主要内容包括查找caselist确定测试case集合、调用单条case的仿真脚本启动仿真、回归结果报告、自动merge覆盖率数据。  测试程序框架 请参考之前的博客“一个简易bootloader框架”。\n随机指令生成器 请参考之前的博客“基于Python实现ARM随机指令生成器”。\nFastModel启动脚本 FastModel启动脚本重点是配置参数，这里展示部分内容，具体请根据项目自行设定。\n1 2 3 4 5 6 7 8 9 10 11 12 13  MODEL=\u0026#34;VAL_VAL_AEMv8A\u0026#34; trace_args=\u0026#34;-t -C TRACE.tarmac.trace-file=your_testcode\u0026#34; elf_args=\u0026#34;-C elfloader.elf=./your_testcode.elf\u0026#34; rvbar_args=\u0026#34;0x00000000\u0026#34; $MODEL \\ $trace_args \\ $elf_args \\ -C cpu.cpu0.RVBAR=$rvbar_args \\ -C cpu.has_arm_v8-1=1 \\ -C cpu.has_arm_v8-2=1 \\ -C cpu.has_fp16=0x1 \\ ......    可以在$MODEL后加-l，查看log，能够看到一些默认的配置信息。 由于指令程序可能会发生死锁，导致程序无法正常结束而一直执行，这样会生成非常大的tarmac文件，为了避免这种情况的发生，在调用fastmodel的启动脚本时，最好加上\u0026quot;timeout 3\u0026rdquo;，超时则会自动杀死进程。 详细使用说明，可以-h查找帮助，或者登录https://developer.arm.com/tools-and-software/simulation-models/fast-models ,下载使用手册。  从tarmac提取指令信息 从tarmac提取指令信息实际就是一个纯文本处理脚本，使用Python和正则表达式个人认为是最佳选择。\ntarmac的内容 首先看一下tarmac的内容格式：\n      第一，第二个字段：仿真cycle数 第三个字段：指令类型： IT代表普通指令，IS代表跳转指令 第四个字段：当前指令编号 第五个字段：PC值，如果VA和PA相等，只会显示一个，如果不等，显示为 VA:PA 第六个字段：二进制指令码 第七个字段：架构，O代表A64架构，A代表A32架构，T代表thumb架构 第八个字段：对于AArch64，为exception EL和secure state，对于AArch32，为exception mode和secure state 第九个字段：反汇编 另外会显示寄存器写回的结果，以及cpsr或fpsr状态更新值。  提取的内容 需要提取的格式（根据验证环境需求自定义，这里只作为示例）：\n100 d2805001 00003a58 101 11 0 0000000000000280 000 00 0 0000000000000000 000 00 0 0000000000000000 0 00 0 0000000000000000 以上字段按顺序排列，其含义如下：\n \u0026lt;instr_id\u0026gt;：指令的编号，十进制 \u0026lt;instr_raw_code\u0026gt;：指令码，32位十六进制 \u0026lt;instr_pc\u0026gt;：指令的PC值，32位十六进制 \u0026lt;instr_tgt_reg1_vfg\u0026gt;：指令第一个目的寄存器的valid、float、global，3位二进制 \u0026lt;instr_tgt_reg1_wren\u0026gt;：指令第一个目的寄存器的高/低32写有效信号，2位二进制 \u0026lt;instr_tgt_reg1_num\u0026gt;：指令第一个目的寄存器的编号，十进制 \u0026lt;instr_tgt_reg1_data\u0026gt;：指令第一个目的寄存器的数据，64位十六进制 \u0026lt;instr_tgt_reg2_vfg\u0026gt;：指令第二个目的寄存器的valid、float、global，3位二进制 \u0026lt;instr_tgt_reg2_wren\u0026gt;：指令第二个目的寄存器的高/低32写有效信号，2位二进制 \u0026lt;instr_tgt_reg2_num\u0026gt;：指令第二个目的寄存器的编号，十进制 \u0026lt;instr_tgt_reg2_data\u0026gt;：指令第二个目的寄存器的数据，64位十六进制 \u0026lt;instr_tgt_reg3_vfg\u0026gt;：指令第三个目的寄存器的valid、float、global，3位二进制 \u0026lt;instr_tgt_reg3_wren\u0026gt;：指令第三个目的寄存器的高/低32写有效信号，2位二进制 \u0026lt;instr_tgt_reg3_num\u0026gt;：指令第三个目的寄存器的编号，十进制 \u0026lt;instr_tgt_reg3_data\u0026gt;：指令第三个目的寄存器的数据，64位十六进制 \u0026lt;instr_tgt_sreg_valid\u0026gt;：指令系统寄存器的valid，1位二进制 \u0026lt;instr_tgt_sreg_wren\u0026gt;：指令系统寄存器的高/低32写有效信号，2位二进制 \u0026lt;instr_tgt_sreg_num\u0026gt;：指令系统寄存器的第三个目的寄存器的编号，十进制 \u0026lt;instr_tgt_sreg_data\u0026gt;：指令系统寄存器的数据，64位十六进制  寄存器组织形式： 验证环境与dut的寄存器组织形式：\n 通用（整型）寄存器共有32个64bit寄存器，A64下x对应{d}的64bit，w对应{d}的低32bit；A32和Thumb下r对应{d}的低32bit。 扩展（浮点）寄存器共有64个64bit寄存器，A64下v对应{2*d+1, 2*d}两个64bit寄存器组成128bit，d对应{2*d}寄存器的64bit，s对应{2*d}寄存器的低32bit，h对应{2*d}寄存器的低16bit；A32和Thumb下q对应{2*d+1, 2*d}两个64bit寄存器组成128bit，d对应{d}寄存器的64bit，s对应{d/2}寄存器的低或高32bit（取决于余数），h对应{d/4}寄存器的4个16bit中某一个（取决于余数）。  以上描述中对于通用寄存器容易理解，而对于扩展寄存器可能难于理解，下面以图说明:\n  A64下扩展寄存器的组织结构      A32下扩展寄存器的组织结构    python脚本 关于从tarmac提取指令信息的python脚本，a64、a32、t32略有不同，主要体现在扩展寄存器num的提取和tarmac字段的匹配上，这里只展示a64下的脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216  import sys import os import re args_tmcfile = \u0026#34;\u0026#34; # usage and get args #-------------------------------------------- if sys.argv[1] == \u0026#34;--help\u0026#34; or sys.argv[1] == \u0026#34;-h\u0026#34;: print \u0026#34;\u0026#34; print \u0026#34;\u0026lt;usage\u0026gt;:\u0026#34; print \u0026#34; python extract_tarmac.py [tmcfile=xxx]\u0026#34; print \u0026#34;\u0026lt;example\u0026gt;:\u0026#34; print \u0026#34; python extract_tarmac.py tmcfile=test.tmc\u0026#34; print \u0026#34;\u0026#34; sys.exit() for run_arg in sys.argv: if run_arg.strip().split(\u0026#34;=\u0026#34;)[0].strip() == \u0026#34;tmcfile\u0026#34;: args_tmcfile = run_arg.strip().split(\u0026#34;=\u0026#34;)[1].strip() cur_path = os.getcwd() tmcfile_path = cur_path+\u0026#34;/\u0026#34;+args_tmcfile # args check if os.path.isfile(tmcfile_path) == 0: print \u0026#34;TMC ERROR: \u0026#34;+tmcfile_path+\u0026#34; not exist, please double check!!!\u0026#34; sys.exit() #-------------------------------------------- # extract information #-------------------------------------------- strat_instr_id = 100000000 end_instr_id = 100000000 instr_id = \u0026#34;0\u0026#34; #%d instr_raw_code = \u0026#34;00000000\u0026#34; #%h instr_pc = \u0026#34;00000000\u0026#34; #%h instr_tgt_reg1_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_reg1_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg1_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg1_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_reg2_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_reg2_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg2_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg2_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_reg3_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_reg3_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg3_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg3_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_sreg_valid = \u0026#34;0\u0026#34; #%b instr_tgt_sreg_wren = \u0026#34;00\u0026#34; #%b instr_tgt_sreg_num = \u0026#34;0\u0026#34; #%d instr_tgt_sreg_data = \u0026#34;0000000000000000\u0026#34; #%h tmcfile = open(tmcfile_path, \u0026#34;r\u0026#34;) if os.path.isfile(\u0026#34;./instr_datasheet\u0026#34;): os.system(\u0026#34;rm -rf ./instr_datasheet\u0026#34;) assembfile = open(\u0026#34;./instr_datasheet\u0026#34;, \u0026#34;a+\u0026#34;) while True: tmc_line = tmcfile.readline() if not tmc_line: break instr_id = int(instr_id) end_instr_id = int(end_instr_id) start_instr_id = int(start_instr_id) if instr_id \u0026gt; end_instr_id: break # if start instr find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk IT \\(([\\d]+)\\) [abcdef\\d]{8} d29757c1 0 El0t_n : MOV x1,#0xbabe\u0026#39;, tmc_line) if len(find_result) != 0: start_instr_id = find_result[0] start_instr_id = int(start_instr_id) # if end instr find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk IT \\(([\\d]+)\\) [abcdef\\d]{8} d29bd5a1 0 El0t_n : MOV x1,#0xdead\u0026#39;, tmc_line) if len(find_result) != 0: end_instr_id = find_result[0] end_instr_id = int(end_instr_id) # write instr code find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk IT \\([\\d]+\\) [abcdef\\d]{8} [abcdef\\d]{8} 0 El0t_n : .+\u0026#39;, tmc_line) if len(find_result) != 0 and instr_id \u0026lt; end_instr_id and instr_id \u0026gt; start_instr_id: assembfile.write(instr_id+\u0026#34; \u0026#34;+instr_raw_code+\u0026#34; \u0026#34;+instr_pc+\u0026#34; \u0026#34;+instr_tgt_reg1_vfg+\u0026#34; \u0026#34;+instr_tgt_reg1_wren+\u0026#34; \u0026#34;+instr_tgt_reg1_num+\u0026#34; \u0026#34;+instr_tgt_reg1_data+\u0026#34; \u0026#34;+instr_tgt_reg2_vfg+\u0026#34; \u0026#34;+instr_tgt_reg2_wren+\u0026#34; \u0026#34;+instr_tgt_reg2_num+\u0026#34; \u0026#34;+instr_tgt_reg2_data+\u0026#34; \u0026#34;+instr_tgt_reg3_vfg+\u0026#34; \u0026#34;+instr_tgt_reg3_wren+\u0026#34; \u0026#34;+instr_tgt_reg3_num+\u0026#34; \u0026#34;+instr_tgt_reg3_data+\u0026#34; \u0026#34;+instr_tgt_sreg_valid+\u0026#34; \u0026#34;+instr_tgt_sreg_wren+\u0026#34; \u0026#34;+instr_tgt_sreg_num+\u0026#34; \u0026#34;+instr_tgt_sreg_data+\u0026#34;\\n\u0026#34;) # if new instr find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk IT \\([\\d]+\\) [abcdef\\d]{8}.+\u0026#39;, tmc_line) if len(find_result) != 0: instr_id = \u0026#34;0\u0026#34; #%d instr_raw_code = \u0026#34;00000000\u0026#34; #%h instr_pc = \u0026#34;00000000\u0026#34; #%h instr_tgt_reg1_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_reg2_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_reg3_vfg = \u0026#34;000\u0026#34; #%b instr_tgt_sreg_valid = \u0026#34;000\u0026#34; #%b instr_tgt_reg1_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg2_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg3_wren = \u0026#34;00\u0026#34; #%b instr_tgt_sreg_wren = \u0026#34;00\u0026#34; #%b instr_tgt_reg1_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg2_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg3_num = \u0026#34;0\u0026#34; #%d instr_tgt_sreg_num = \u0026#34;0\u0026#34; #%d instr_tgt_reg1_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_reg2_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_reg3_data = \u0026#34;0000000000000000\u0026#34; #%h instr_tgt_sreg_data = \u0026#34;0000000000000000\u0026#34; #%h # get instr_id, instr_raw_code, instr_pc find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk IT \\(([\\d]+)\\) ([abcdef\\d]{8}) ([abcdef\\d]{8}) 0 El0t_n : .+\u0026#39;, tmc_line) if len(find_result) != 0: instr_id = find_result[0][0] instr_pc = find_result[0][1] instr_raw_code = find_result[0][2] # get instr_tgt_reg1/2 vfgs and num and data find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk R ([Xqds])([\\d]+) ([abcdefABCDEF\\d]+).*\u0026#39;, tmc_line) if len(find_result) != 0: if instr_tgt_reg1_vfg == \u0026#34;000\u0026#34;: if find_result[0][0] == \u0026#34;X\u0026#34;: instr_tgt_reg1_vfg = \u0026#34;101\u0026#34; instr_tgt_reg1_wren = \u0026#34;11\u0026#34; instr_tgt_reg1_num = find_result[0][1] instr_tgt_reg1_data = find_result[0][2] if find_result[0][0] == \u0026#34;q\u0026#34;: instr_tgt_reg1_vfg = \u0026#34;110\u0026#34; instr_tgt_reg1_wren = \u0026#34;11\u0026#34; instr_tgt_reg1_num = str(int(find_result[0][1])*2) instr_tgt_reg1_data = find_result[0][2][16:32] instr_tgt_reg2_vfg = \u0026#34;110\u0026#34; instr_tgt_reg3_wren = \u0026#34;11\u0026#34; instr_tgt_reg2_num = str(int(find_result[0][1])*2 +1) instr_tgt_reg2_data = find_result[0][2][0:16] if find_result[0][0] == \u0026#34;d\u0026#34;: instr_tgt_reg1_vfg = \u0026#34;110\u0026#34; instr_tgt_reg1_wren = \u0026#34;11\u0026#34; instr_tgt_reg1_num = str(int(find_result[0][1])*2) instr_tgt_reg1_data = find_result[0][2] if find_result[0][0] == \u0026#34;s\u0026#34;: instr_tgt_reg1_vfg = \u0026#34;110\u0026#34; instr_tgt_reg1_wren = \u0026#34;01\u0026#34; instr_tgt_reg1_num = str(int(find_result[0][1])*2) instr_tgt_reg1_data = \u0026#34;00000000\u0026#34;+find_result[0][2] elif instr_tgt_reg2_vfg == \u0026#34;000\u0026#34;: if find_result[0][0] == \u0026#34;X\u0026#34;: instr_tgt_reg2_vfg = \u0026#34;101\u0026#34; instr_tgt_reg2_wren = \u0026#34;11\u0026#34; instr_tgt_reg2_num = find_result[0][1] instr_tgt_reg2_data = find_result[0][2] if find_result[0][0] == \u0026#34;q\u0026#34;: instr_tgt_reg2_vfg = \u0026#34;110\u0026#34; instr_tgt_reg2_wren = \u0026#34;11\u0026#34; instr_tgt_reg2_num = str(int(find_result[0][1])*2) instr_tgt_reg2_data = find_result[0][2][16:32] instr_tgt_reg3_vfg = \u0026#34;110\u0026#34; instr_tgt_reg3_wren = \u0026#34;11\u0026#34; instr_tgt_reg3_num = str(int(find_result[0][1])*2 +1) instr_tgt_reg3_data = find_result[0][2][0:16] if find_result[0][0] == \u0026#34;d\u0026#34;: instr_tgt_reg2_vfg = \u0026#34;110\u0026#34; instr_tgt_reg2_wren = \u0026#34;11\u0026#34; instr_tgt_reg2_num = str(int(find_result[0][1])*2) instr_tgt_reg2_data = find_result[0][2] if find_result[0][0] == \u0026#34;s\u0026#34;: instr_tgt_reg2_vfg = \u0026#34;110\u0026#34; instr_tgt_reg2_wren = \u0026#34;01\u0026#34; instr_tgt_reg2_num = str(int(find_result[0][1])*2) instr_tgt_reg2_data = \u0026#34;00000000\u0026#34;+find_result[0][2] elif instr_tgt_reg3_vfg == \u0026#34;000\u0026#34;: if find_result[0][0] == \u0026#34;X\u0026#34;: instr_tgt_reg3_vfg = \u0026#34;101\u0026#34; instr_tgt_reg3_wren = \u0026#34;11\u0026#34; instr_tgt_reg3_num = find_result[0][1] instr_tgt_reg3_data = find_result[0][2] if find_result[0][0] == \u0026#34;q\u0026#34;: print \u0026#34;TGT REGS ERROR1: more than three tgt regs, please double check!!!\u0026#34; if find_result[0][0] == \u0026#34;d\u0026#34;: instr_tgt_reg3_vfg = \u0026#34;110\u0026#34; instr_tgt_reg3_wren = \u0026#34;11\u0026#34; instr_tgt_reg3_num = str(int(find_result[0][1])*2) instr_tgt_reg3_data = find_result[0][2] if find_result[0][0] == \u0026#34;s\u0026#34;: instr_tgt_reg3_vfg = \u0026#34;110\u0026#34; instr_tgt_reg3_wren = \u0026#34;01\u0026#34; instr_tgt_reg3_num = str(int(find_result[0][1])*2) instr_tgt_reg3_data = \u0026#34;00000000\u0026#34;+find_result[0][2] else: print \u0026#34;TGT REGS ERROR2: more than three tgt regs, please double check!!!\u0026#34; # get instr_tgt_sreg valid and num and data find_result = [] find_result = re.findall(r\u0026#39;[\\d]+ clk R (cpsr|FPSR) ([abcdefABCDEF\\d]+).*\u0026#39;, tmc_line) if len(find_result) != 0: if find_result[0][0] == \u0026#34;cpsr\u0026#34;: instr_tgt_sreg_valid = \u0026#34;1\u0026#34; instr_tgt_sreg_wren = \u0026#34;01\u0026#34; instr_tgt_sreg_num = \u0026#34;0\u0026#34; instr_tgt_sreg_data = \u0026#34;00000000\u0026#34;+find_result[0][1] if find_result[0][0] == \u0026#34;FPSR\u0026#34;: instr_tgt_sreg_valid = \u0026#34;1\u0026#34; instr_tgt_sreg_wren = \u0026#34;01\u0026#34; instr_tgt_sreg_num = \u0026#34;1\u0026#34; instr_tgt_sreg_data = \u0026#34;00000000\u0026#34;+find_result[0][1] tmcfile.close() assembfile.close()   UVM验证框架 验证环境结构      dut的顶层模块是dpu 环境中目前只有一个agent，ifu_agent来模拟ifu的行为，为dut提供驱动，后续根据验证环境的完善情况，可能会增加dcu agent等其他与dut交互模块的agent 目前只有ifu interface和dpu interface，ifu interface是dut与ifu交互的接口信号，dpu interface是其他信号，dpu interface内对信号做了初始化，后续根据验证环境的完善情况，可能会增加dcu interface等其他与dut交互模块的interface Ifu agent通过载入instr_datasheet，获取指令的信息，包括指令码和写回寄存器结果，并压入队列，后续依次弹出来驱动dut，同时支持单发射、双发射和随机发射，支持A64、A32、T32指令类型，其中指令的predecode是通过hdl force方式将instr_raw_code传输给precode模块，然后通过hdl_read方式获取instr_pdc_code，再由ifu_agent 驱动给dut。另外ifu_agent在指令驱动前要先初始化系统寄存器和通用/扩展寄存器。 Predecode模块例化在testbench，该模块大部分逻辑内容来自ifu design，验证环境中只是将predecode的逻辑操作进行了集成和取消了时序逻辑。 Checker通过hdl_read读取通用寄存器、浮点寄存器和系统寄存器的信号，当写信号有效时，下一拍将寄存器值存入dut_queue；checker通过接收ifu agent发来的trans，获取指令的寄存器写回结果，存入ref queue；最后将dut queue和ref queue结果依次比对（通用寄存器和扩展寄存器单独组织）。 other logic是testbench下的其他逻辑，比如时钟和复位逻辑，cycle_id逻辑，以及其他辅助debug的逻辑。  验证组件      run_test是验证环境的顶层，除了作为环境顶层，还有主要功能是为sequencer指定sequence，每个testcase对应一个test，test为ifu_sequencer指定该testcase的sequence。 env中例化ifu_agent和checker，以及完成组件间的连接。 Checker完成结果检测，Checker有三个线程并行执行：接收driver发来的trans，获取指令结果，存入ref queue；读取dut寄存器写信号，获取dut的寄存器结果，存入dut queue；ref queue和dut queue弹出指令信息，结果比对。 Ifu_agent例化ifu_sqr、ifu_driver、ifu_monitor。 Ifu_moitor只对驱动信号进行检查。 dut_sequencer为uvm环境框架固有组件，主要功能是启动sequence产生trans并将其发送给ifu_driver，这些由uvm自动完成，没有添加额外的功能。 ifu_driver主要功能是组织激励和驱动dut，通过读取instr_datasheet文件，获取指令信息，再通过hdl_force和hdl_read方式获取predecode，最终驱动dut。另外还有寄存器初始化的控制。 Ifu_trans是定义的随机数据以及随机约束，是环境组件间数据传送的包。这里定义instr_valid来实现指令随机发射的控制。 Ifu_sequnece调用ifu_trans，是产生trans的控制组件，同时可以使用do_with来添加额外的随机约束。  文件列表 ./env ├── agents │ └── ifu_agent │ ├── ifu_agent.sv │ ├── ifu_driver.sv │ ├── ifu_monitor.sv │ ├── ifu_sequencer.sv │ ├── ifu_sequence.sv │ ├── ifu_trans.sv │ └── predecode │ └── predecode.sv ├── checker │ └── main_checker.sv ├── coverage │ └── demo_cov.sv ├── filelist │ └── flist ├── include │ ├── env_flist.sv │ ├── env_headfile.sv │ └── timescale.sv ├── interface │ ├── dpu_if.sv │ └── ifu_if.sv ├── README ├── script │ ├── base_runtest.sh │ └── super_runtest.py ├── setup │ └── setup.bashrc ├── testbench │ ├── env_cfg.sv │ ├── env_env.sv │ ├── run_uvmtest.sv │ ├── tb.sv │ └── uvmtest.sv ├── testcase │ ├── a32 │ │ └── a32_demo_random0001 │ │ ├── instr_datasheet │ │ ├── your_testcode.elf │ │ └── your_testcode.tmc │ ├── a64 │ │ └── a64_demo_random0001 │ │ ├── instr_datasheet │ │ ├── your_testcode.elf │ │ └── your_testcode.tmc │ └── t32 │ └── t32_demo_random0001 │ ├── instr_datasheet │ ├── your_testcode.elf │ └── your_testcode.tmc └── testcase.list  env目录，验证环境目录。 checker/main_checker.sv文件，实现reference和check功能，之所以叫main_check，因为该目录下可能还会有更多的check以及assert文件。 coverage/demo_cov.sv文件，功能点的coverpoint都在此目录下，一般以 模块名_cov 命名。 interface目录，内部包含ifu_if.sv和dpu_if.sv，其中dpu_if包含除ifu接口外其他接口信号，并进行了接口信号的初始化。 filelist/flist文件，列出了设计和验证相关文件的filepath。 setup目录，包含setup.bashrc，环境设置文件，主要设置环境变量和配置eda工具。 testcase.list文件，列出了所有case信息，包括casename、testname和groupname。 script目录，包含base_runtest.sh和super_runtest.py，base_runtest.sh是shell脚本，实现单条case仿真的参数化运行，super_runtest.py是python脚本，实现单次和回归测试的运行。 Include目录，包含env_headfile.sv、env_flist.sv和timescale.sv。env_headfile.sv中定义一些关于模块路径的宏和一些teypedef定义；env_flist.sv以include方式列出所有验证环境文件；timescale.sv定义仿真时间精度。 agents/ifu_agent/Predecoe目录，预译码模块，该模块下例化了ifu内部有关预译码逻辑模块。 agents/ifu_agent/ifu_driver.sv文件，主要完成激励的组织和dut的驱动。 agents/ifu_agent/Ifu_sequencer.sv文件，调用transaction和转发给driver。 agents/ifu_agent/Ifu_sequence.sv文件，sequence的集合，其中base_sequence定义通用的变量和方法，作为其他sequence的父类。 agents/ifu_agent/Ifu_monitor.sv文件，监测接口信号，做一些接口检查。 agents/ifu_agent/Ifu_trans.sv文件，transaction，定义随机变量和约束。 testcase目录，测试用例，包含a64、a32、t32，其中随机测试用例通过随机指令生成器获得。 testbench/uvmtest.sv文件，test集合，其中base_test定义通用的变量和方法，作为其他test的父类。每个testcase对应一个test，在test中设置default_sequence。 testbench/env_cfg.sv文件，环境的配置文件，包含一些全局静态变量，贯穿整个验证平台。（没有使用config_db来实现环境配置，原因是此环境后续不涉及与其他环境集成，这样实现简易且灵活） testbench/env_env.sv文件，env组件，例化checker和agent，并实现组件间连接。 testbench/run_uvmtest.sv文件，uvm的启动入口，以及完成uvm_config_db的set操作。 testbench/tb.sv文件，testbench顶层，例化dut和interface，产生时钟和复位，以及其他辅助debug的逻辑。  ifu_driver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  task ifu_driver::run_phase(uvm_phase, phase); super.run_phase(phase); while(1)begin ifu_trans tr; seq_item_port.get_next_item(tr); // prepare drv_trans  @(posedge vif.clk); ifu_drv_ctl(tr); rst_update_trans(tr); cfg_update_trans(tr); sim_update_trans(tr); // send drv_trans  @(negedge vif.clk); send_to_dut(tr); // send to dut  ap.write(tr); // send to ref  seq_item_port.item_done(); end endtask // run_phase   main_checker 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  task main_checker::run_phase(uvm_phase, phase); super.run_phase(phase); fork // get result from ref  while(1)begin @(negedge ifu_vif.clk); ifu_bp.get(ifu_tr); judege_cancel_type(ifu_tr); if(ifu_tr.instr0_valid == 1\u0026#39;b1) store_ref_result(2\u0026#39;b00, ifu_tr.instr0_datasheet); if(ifu_tr.instr1_valid == 1\u0026#39;b1) store_ref_result(chk_cancel_type, ifu_tr.instr1_datasheet); end // get result from dut  while(1)begin @(posedge ifu_vif.clk); env_flipflop(); @(negedge ifu_vif.clk); env_get_from_dut(); if(env_cfg::cycle_id \u0026gt; 100) store_dut_fregs(); store_dut_gregs(); end // main check  while(1)begin @(posedge ifu_vif.clk); check_fregs(); check_gregs(); check_watchdog(); check_ref_queue(); end join endtask // run_phase   验证环境的自动化  支持单条case运行的bash脚本：base_runtest.sh   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  # declare \u0026amp; initial variables, and get variables value from command #--------------------------------------------- usage() { echo \u0026#34;usage: $0[--nocmp] [--debug] [--casename casename] [--testname testname] [--simpath simpath] [--dump] [--seed seednum] [--cov] [--funcov]\u0026#34; } nocmp=0 debug=0 casename=\u0026#34;\u0026#34; testname=\u0026#34;\u0026#34; simpath=\u0026#34;\u0026#34; dump=0 seednum=\u0026#34;\u0026#34; cov=0 funcov=0 # get and check args value while [[ x$1 != x]]; do case $1 in --nocmp ) nocmp=1 ;; --debug ) debug=1 ;; --casename ) shift casename=$1 ;; --testname ) shift testname=$1 ;; --simpath ) shift simpath=$1 ;; --dump ) dump=1 ;; --seed ) shift seednum=$1 ;; --cov ) cov=1 ;; --funcov ) funcov=1 ;; * ) usage exit ;; esac shift done if [ X$casename = X]; then usage exit fi if [ X$testname = X]; then usage exit fi if [ X$simpath = X]; then usage exit fi if [ X$seednum = X]; then usage exit fi cur_path=`pwd` cur_path=${cur_path##*/} if [ $cur_path != env ]; then echo \u0026#34;runtest must in env path, please double check!\u0026#34; exit fi #--------------------------------------------- # prepare #--------------------------------------------- caseseedname=\u0026#34;$casename\u0026#34;_\u0026#34;$seednum\u0026#34; if [ X$nocmp = X0]; then if [ ! -d \u0026#34;./$simpath\u0026#34; ]; then mkdir ./$simpath fi fi if [ X$nocmp = X1]; then if [ ! -d \u0026#34;./$simpath\u0026#34; ]; then echo \u0026#34;no $simpathfile, please double check!!!\u0026#34; exit fi fi if [ ! -d \u0026#34;./$simpath/$caseseedname\u0026#34; ]; then mkdir ./$simpath/$caseseedname fi cp ./filelist/flist $simpath/flist #--------------------------------------------- # gen cmp and sim args #--------------------------------------------- # compile #============ cmp_cmd=\u0026#34;xrun -f ./filelist/xrun.flist\u0026#34; cmp_args=\u0026#34;-64 -uvm -c -sv -access +rwc -xmlibdirname $simpath-l $simpath/xcompile.log +casename=$casename+caseseedname $caseseedname+simpath=$simpath\u0026#34; if [ X$dump = X1 ]; then cmp_args=\u0026#34;$cmp_args+memcbk -q +loadpli1=debpli:novas_pli_boot\u0026#34; cmp_defs=\u0026#34;$cmp_defs-define DUMP\u0026#34; fi if [ X$cov = X1 ]; then cmp_args=\u0026#34;$cmp_args-covdut yumi_dpu -coverage all\u0026#34; fi if [ X$funcov = X1 ]; then cmp_defs=\u0026#34;$cmp_defs-define OPEN_FUNCOV\u0026#34; fi # simulation #============ sim_cmd=\u0026#34;xrun\u0026#34; sim_args=\u0026#34;-64 -R -xmlibdirname ../../$simpath-seed $seednum-l ./xrun.log +UVM_TESTNAME=$testname+casename=$casename+caseseedname $caseseedname+simpath=$simpath\u0026#34; if [ X$dump = X1 ]; then sim_args=\u0026#34;$sim_args+loadpli1=debpli:novas_pli_boot +fsdb -licqueue\u0026#34; fi if [ X$cov = X1 ]; then sim_args=\u0026#34;$sim_args-covoverwrite -covworkdir ../../$simpath/$caseseedname-covscope cov_work -covtest $caseseedname-write_metrics\u0026#34; fi # debug #=========== verdi=\u0026#34;verdi\u0026#34; verdi_args=\u0026#34;-ssy -sv -f ../flist -nologo -workMode hardwareDebug -ssf test.fsdb\u0026#34; #--------------------------------------------- # final #--------------------------------------------- if [ X$nocmp = X0 ]; then $cmp_cmd $cmp_args $cmp_defs fi cd ./$simpath/$caseseedname $sim_cmd $sim_args | tee sim.log if [ X$debug = X1 ]; then $verdi $verdi_args fi echo \u0026#34;\u0026#34; echo \u0026#34;=====================================\u0026#34; if [ X$nocmp = X0 ]; then echo \u0026#34;CMP COMMAND: $cmp_cmd$cmp_args$cmp_defs\u0026#34; fi echo \u0026#34;SIM COMMAND: $sim_cmd$sim_args| tee sim.log\u0026#34; echo \u0026#34;=====================================\u0026#34; echo \u0026#34;\u0026#34; #---------------------------------------------    支持回归测试的python脚本：super_runtest.py   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297  import sys import os import datetime import random import re args_nocmp = 0 args_debug = 0 args_regress = 0 args_casename = \u0026#34;\u0026#34; args_groupname = \u0026#34;\u0026#34; args_simpath = \u0026#34;\u0026#34; args_dump = 0 args_seednum = \u0026#34;\u0026#34; args_seedrand = 0 args_cov = 0 args_funcov = 0 args_covmerge = 0 if sys.argv[1] == \u0026#34;-help\u0026#34; or sys.argv[1] == \u0026#34;-h\u0026#34;: print \u0026#34;\u0026#34; print \u0026#34;\u0026lt;usage\u0026gt;:\u0026#34; print \u0026#34;python script/super_run.py [-nocmp] [-debug] ([casename=casename] or [-regress groupname=groupname]) [simpath=simpath] [-dump] ([seednum=seednum] or [-seedrand]) [-cov] [-funcov] [-covmerge]\u0026#34; print \u0026#34;\u0026lt;args\u0026gt;:\u0026#34; print \u0026#34; -nocmp : don\u0026#39;t compile rtl and env.\u0026#34; print \u0026#34; -debug : open verdi automatic after finish simulation(should set -dump).\u0026#34; print \u0026#34; casename=xxx : your testcase exist in testcase.list, can\u0026#39;t be set when regression mode.\u0026#34; print \u0026#34; -regress groupname=xxx : open regression mode, and run all cases in the groupname.\u0026#34; print \u0026#34; simpath=xxx : set simulation log generate path, must be set.\u0026#34; print \u0026#34; -dump : generate waveform.\u0026#34; print \u0026#34; seednum=xxx : fixed seed number, can\u0026#39;t be set when seedrand mode.\u0026#34; print \u0026#34; -seedrand : random seed number, can\u0026#39;t be set when fixed seed mode.\u0026#34; print \u0026#34; -cov : enable code coverage collect.\u0026#34; print \u0026#34; -funcov : enable function coverage collect.\u0026#34; print \u0026#34; -covmerge : merge coverage data when finish all testcase.\u0026#34; print \u0026#34;\u0026lt;example\u0026gt;:\u0026#34; print \u0026#34; single testcase : python script/super_run.py casename=random_a64_test0000 -dump simpath=./sim seednum=123456\u0026#34; print \u0026#34; regress testcase : python script/super_run.py -regress groupname=random_group simpath=./sim_random_group -seedrand\u0026#34; print \u0026#34;\u0026#34; sys.exit() # get args #------------------------------------------------- super_run_args=\u0026#34;\u0026#34; for args in sys.argv: super_run_args = super_run_args + \u0026#34;\u0026#34; + args print \u0026#34;[SUPER_RUN START]: your run testcase command args:\u0026#34; print super_run_args print \u0026#34;\u0026#34; for args in sys.argv: if args == \u0026#34;-nocmp\u0026#34;: args_nocmp = 1 if args == \u0026#34;-debug\u0026#34;: args_debug = 1 if args.strip().split(\u0026#34;=\u0026#34;)[0].sprit() == \u0026#34;casename\u0026#34;: args_casename = args.strip().split(\u0026#34;=\u0026#34;)[1].sprit() if args == \u0026#34;-regress\u0026#34;: args_regress = 1 if args.strip().split(\u0026#34;=\u0026#34;)[0].sprit() == \u0026#34;groupname\u0026#34;: args_groupname = args.strip().split(\u0026#34;=\u0026#34;)[1].sprit() if args.strip().split(\u0026#34;=\u0026#34;)[0].sprit() == \u0026#34;simpath\u0026#34;: args_simpath = args.strip().split(\u0026#34;=\u0026#34;)[1].sprit() if args == \u0026#34;-dump\u0026#34;: args_dump = 1 if args == \u0026#34;-seedrand\u0026#34;: args_seedrand = 1 if args.strip().split(\u0026#34;=\u0026#34;)[0].sprit() == \u0026#34;seednum\u0026#34;: args_seednum = args.strip().split(\u0026#34;=\u0026#34;)[1].sprit() if args == \u0026#34;-cov\u0026#34;: args_cov = 1 if args == \u0026#34;-funcov\u0026#34;: args_funcov = 1 if args == \u0026#34;-covmerge\u0026#34;: args_covmerge = 1 # args check if args_regress == 1: if args_groupname == \u0026#34;\u0026#34;: print \u0026#34;[SUPER_RUN ERROR]: args -regress and groupname must be set at same time, please double check your args\u0026#34; sys.exit() if args_casename != \u0026#34;\u0026#34;: print \u0026#34;[SUPER_RUN ERROR]: args casename and groupname don\u0026#39;t allow to set at same time, please double check your args\u0026#34; sys.exit() if args_seedrand == 1: if args_seednum != \u0026#34;\u0026#34;: print \u0026#34;[SUPER_RUN ERROR]: args -seedrand and seednum don\u0026#39;t allow to set at same time, please double check your args\u0026#34; sys.exit() if args_simpath == \u0026#34;\u0026#34;: print \u0026#34;[SUPER_RUN ERROR]: args simpath must set, please double check your args\u0026#34; sys.exit() if args_cov == 0 and args_funcov == 0: if args_covmerge == 1: print \u0026#34;[SUPER_RUN ERROR]: args -covmerge and (-cov or -funcov) must set at same time, please double check your args\u0026#34; sys.exit() if args_debug == 1: if args_dump == 1: print \u0026#34;[SUPER_RUN ERROR]: args -debug don\u0026#39;t allow to set without -dump, please double check your args\u0026#34; sys.exit() #------------------------------------------------- # prepare #------------------------------------------------- cur_path = os.getcwd() if os.path.basename(cur_path) != \u0026#34;env\u0026#34;: print \u0026#34;[SUPER_RUN ERROR]: must run the script under the dpu_ut/env, please double check your current work directory!\u0026#34; sys.exit() if os.path.isdir(args_simpath) == 0: os.system(\u0026#34;mkdir \u0026#34;+args_simpath) nowTime = datetime.datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) report_dir = cur_path+\u0026#34;/\u0026#34;+args_simpath+\u0026#34;/\u0026#34;+\u0026#34;report_\u0026#34;+nowTime os.system(\u0026#34;mkdir \u0026#34;+report_dir) allcase_list = report_dir+\u0026#34;/allcase_list\u0026#34; passcase_list = report_dir+\u0026#34;/passcase_list\u0026#34; failcase_list = report_dir+\u0026#34;/failcase_list\u0026#34; nologcase_list = report_dir+\u0026#34;/nologcase_list\u0026#34; allcase_listfile = open(allcase_list, \u0026#34;a+\u0026#34;) passcase_listfile = open(passcase_list, \u0026#34;a+\u0026#34;) failcase_listfile = open(failcase_list, \u0026#34;a+\u0026#34;) nologcase_listfile = open(nologcase_list, \u0026#34;a+\u0026#34;) tc_list = \u0026#34;./testcase.list\u0026#34; tc_listfile = open(tc_list, \u0026#34;r\u0026#34;) tc_casename = \u0026#34;\u0026#34; tc_testname = \u0026#34;\u0026#34; tc_groupname = \u0026#34;\u0026#34; run_case_list = [] while True: tc_line = tc_listfile.readline() if not tc_line: break tc_casename = \u0026#34;\u0026#34; tc_testname = \u0026#34;\u0026#34; tc_groupname = \u0026#34;\u0026#34; find_result = re.findall(r\u0026#39;[ ]*//*.\u0026#39;, tc_line) if len(find_result) != 0: continue find_result = re.findall(r\u0026#39;[ ]*casename=([a-zA-Z_0-9]+),[ ]*testname=([a-zA-Z_0-9]+),[ ]*groupname=([a-zA-Z_0-9]+)[ ]*\u0026#39;, tc_line) if len(find_result) != 0: tc_casename = find_result[0][0] tc_testname = find_result[0][1] tc_groupname = find_result[0][2] # single case if args_regress == 0: if tc_casename == args_casename: run_case_list.append([tc_casename,tc_testname,tc_groupname]) # regress case if args_regress == 1: if tc_groupname == args_groupname: run_case_list.append([tc_casename,tc_testname,tc_groupname]) tc_listfile.close() # check run_case_list run_case_num = len(run_case_list) if args_regress == 0: if run_case_num != 1: print \u0026#34;[SUPER_RUN ERROR]: can\u0026#39;t find the \u0026#34;+args_casename+\u0026#34; or more than one in testcase.list, please double checkrun args and testcase.list\u0026#34; sys.exit() if args_regress == 1: if run_case_num == 0: print \u0026#34;[SUPER_RUN ERROR]: can\u0026#39;t find the \u0026#34;+args_groupname+\u0026#34; in testcase.list, please double checkrun args and testcase.list\u0026#34; sys.exit() #------------------------------------------------- # run case #------------------------------------------------- runtest_args = \u0026#34;\u0026#34; runtest_args = runtest_args+\u0026#34;--simpath \u0026#34;+args_simpath+\u0026#34; \u0026#34; if args_nocmp == 1 or args_regress == 1: runtest_args = runtest_args+\u0026#34;--nocmp \u0026#34; if args_debug == 1: runtest_args = runtest_args+\u0026#34;--debug \u0026#34; if args_dump == 1: runtest_args = runtest_args+\u0026#34;--dump \u0026#34; if args_cov == 1: runtest_args = runtest_args+\u0026#34;--cov \u0026#34; if args_funcov == 1: runtest_args = runtest_args+\u0026#34;--funcov \u0026#34; runtest_casename = \u0026#34;\u0026#34; runtest_testname = \u0026#34;\u0026#34; runtest_seednum = \u0026#34;\u0026#34; for runcase in run_case_list: runtest_casename = \u0026#34;--casename \u0026#34;+runcase[0]+\u0026#34; \u0026#34; runtest_testname = \u0026#34;--testname \u0026#34;+runcase[1]+\u0026#34; \u0026#34; # generate seednum if args_seedrand == 0: runtest_seednum = \u0026#34;--seed \u0026#34;+args_seednum+\u0026#34; \u0026#34; caseseedname = runcase[0]+\u0026#34;_\u0026#34;+args_seednum else: nowTime = datetime.datetime.now().strftime(\u0026#34;%Y%m%d%H%M%S\u0026#34;) randomNum = random.randint(100,999) runtest_seednum = \u0026#34;--seed \u0026#34;+str(nowTime)+str(randomNum)+\u0026#34; \u0026#34; caseseedname = runcase[0]+\u0026#34;_\u0026#34;+str(nowTime)+str(randomNum) # write run_case to allcase_listfile allcase_listfile.write(caseseedname+\u0026#34;\\n\u0026#34;) # run case run_command = \u0026#34;./script/xrun_runtest.sh \u0026#34;+runtest_args+runtest_casename+runtest_testname+runtest_seednum print \u0026#34;[SUPER_RUN COMMAND]: \u0026#34;+run_command os.system(run_command) allcase_listfile.close() #------------------------------------------------- # report result #------------------------------------------------- allcase_num = 0 passcase_num = 0 failcase_num = 0 nologcase_num = 0 allcase_listfile = open(allcase_list, \u0026#34;r\u0026#34;) while True: allcase_line = allcase_listfile.readline() if not allcase_line: break allcase_line = re.findall(r\u0026#39;([^\\s]*)\u0026#39;, allcase_line) allcase_line = str(allcase_line[0]) allcase_num = allcase_num +1 simlog = cur_path+\u0026#34;/\u0026#34;+args_simpath+\u0026#34;/\u0026#34;+allcase_line+\u0026#34;/sim.log\u0026#34; if os.path.exists(simlog) == False: nologcase_listfile.write(allcase_line+\u0026#34;\\n\u0026#34;) nologcase_num = nologcase_num +1 continue simlog_file = open(simlog, \u0026#34;r\u0026#34;) no_error = 0 no_fatal = 0 for simlog_line in simlog_file: if len(simlog_line) != 0: find_result = re.findall(r\u0026#39;[ ]*UVM_ERROR :[ ]*([0-9]+)[ ]*\u0026#39;,simlog_line) if len(find_result) != 0 and find_result[0] == \u0026#34;0\u0026#34;: no_error = 1 find_result = re.findall(r\u0026#39;[ ]*UVM_FATAL :[ ]*([0-9]+)[ ]*\u0026#39;,simlog_line) if len(find_result) != 0 and find_result[0] == \u0026#34;0\u0026#34;: no_fatal = 1 simlog_file.close() if no_error == 1 and no_fatal == 1: passcase_num = passcase_num +1 passcase_listfile.write(allcase_line+\u0026#34;\\n\u0026#34;) else: failcase_num = failcase_num +1 failcase_listfile.write(allcase_line+\u0026#34;\\n\u0026#34;) allcase_listfile.close() passcase_listfile.close() failcase_listfile.close() nologcase_listfile.close() if args_regress == 1: print \u0026#34;\\n**************** \u0026lt;SUMMARY REPORT\u0026gt; *******************\\n\u0026#34; print \u0026#34; allcase number is: \u0026#34;+str(allcase_num) print \u0026#34; passcase number is: \u0026#34;+str(passcase_num) print \u0026#34; failcase number is: \u0026#34;+str(failcase_num) print \u0026#34; nologcase number is: \u0026#34;+str(nologcase_num) else: os.system(\u0026#34;rm -rf\u0026#34;+report_dir) if passcase_num == 1: print \u0026#34;\\n**************** \u0026lt;SUMMARY REPORT\u0026gt; *******************\\n\u0026#34; print \u0026#34; \u0026#34;+caseseedname+\u0026#34; is PASS \\n\u0026#34; if failcase_num == 1: print \u0026#34;\\n**************** \u0026lt;SUMMARY REPORT\u0026gt; *******************\\n\u0026#34; print \u0026#34; \u0026#34;+caseseedname+\u0026#34; is FAIL \\n\u0026#34; if nologcase_num == 1: print \u0026#34;\\n**************** \u0026lt;SUMMARY REPORT\u0026gt; *******************\\n\u0026#34; print \u0026#34; \u0026#34;+caseseedname+\u0026#34; is NOLOG \\n\u0026#34; #------------------------------------------------ # coverage data merge #------------------------------------------------ os.chdir(cur_path+\u0026#34;/\u0026#34;+args_simpath) if args_covmerge == 1: print \u0026#34;[SUPPER_RUN INFO]: regression end, coverage merge now ......\u0026#34; print \u0026#34;\u0026#34; covmerge_command = \u0026#34;imc -execcmd \\\u0026#34;merge -initial_model union_all -metrics all ./*/cov_work/* -out ./regress_merge_out -message 0\\\u0026#34;\u0026#34; os.system(covmerge_command) print \u0026#34;\u0026#34; print \u0026#34;[SUPER_RUN INFO]: coverage data merge finish!\u0026#34; #------------------------------------------------    关于验证环境的自动化的使用：  所有case通过testcase.list维护，要跑的case必须包含在testcase.list内。 单条case测试时可直接使用super_runtest.py，详细参数可-h查询。 回归测试时，需要先运行一个单条case，若收集覆盖率必须加cov和fun_covc参数，待单条case执行完毕后，启动回归测试，注意此时simpath要与之前单条case一致，若收集覆盖率必须加cov和fun_covc参数。 可以理解为，回归前需要通过运行一个单条case来准备回归环境，好处在保证回归环境的稳定性，避免无效的提交。    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":3,"section":"docs","tags":null,"title":"DPU验证环境全套解决方案","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/dpu-ut/"},{"content":"本文 主要针对CPU的两个漏洞熔断（Meltdown）和幽灵（Spectre），谈谈自己的理解。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《谈谈幽灵和熔断两兄弟》 看雪学院-ixiaohuo 简书    专业术语与缩略语    缩写 全称 说明     OoO Out of Order 乱序执行         概述   Meltdown-and-Spectre    这两组漏洞来源于为了提高CPU性能而采用的乱序执行和预测执行技术。乱序执行是指CPU并不是严格按照指令的顺序串行执行，而是根据相关性对指令进行并行执行，最后顺序提交。预测执行是CPU根据当前掌握的信息预测某个条件判断的结果，然后选择对应的分支提前执行。\n不管是乱序执行和预测执行，总之会使一些指令提前执行，当乱序执行和预测执行发生错误时，会将先前执行的指令作废，flush流水线，保证程序的正确性。但是，CPU进行flush时会作废掉load/store指令，但并不会恢复CPU缓存原始状态，而这两组漏洞正是利用了这一设计上的缺陷进行测信道攻击。\n利用乱序执行的是熔断(Meltdown)，利用预测执行的是幽灵(Spectre)。\n重要概念 乱序执行 为了进一步提升CPU的性能，基于超标量流水技术的微架构被广泛应用于现代CPU当中，微架构可以依据指令相关性进行乱序执行。顺序提交。乱序执行可以使无依赖指令先执行，以减少指令依赖导致流水线的堵塞，这样可以尽可能保证运算单元不空闲，从而提高处理器性能，最后指令顺序提交，可以保证软件层面的执行顺序。\n以下是程序指令，由于指令1/2/3之间存在依赖关系，所以乱序执行处理器中，指令4/5/6可以先于指令2/3执行。\n(1) LDR R1, [R0] (2) ADD R2, R1, 1 (3) SUB R3, R2, 1 (4) ADD R5, R4, 1 (5) ADD R5, R4, 1 (6) ADD R5, R4, 1      分支预测 条件分支指令通常具有两路后续执行分支。即不采取（not taken）跳转，顺序执行后面紧挨JMP的指令；以及采取（taken）跳转到另一块程序内存去执行那里的指令。是否条件跳转，只有在该分支指令在指令流水线中通过了执行阶段（execution stage）才能确定下来。\n如果没有分支预测器，处理器将会等待分支指令确定了是否taken，才把下一条指令送入流水线。这种技术叫做流水线停顿或者分支延迟间隙。分支预测器会预测是否taken以及目标地址，直接将后续指令送入流水线，来避免流水线停顿造成的时间浪费。如果后来发现分支预测错误，那么流水线需要作废推测执行的指令，flush流水线。\n数据缓存 由于CPU的计算速度要远远的快于存储的读写速度，为了弥补因存储速度造成的计算延迟，提升计算机整体的性能，出现了缓存、主存储器、辅助存储器的三级存储结构，其中缓存的作用是改善主存储器与CPU的速度匹配问题，往往被集成到CPU中。\nCPU高速缓存，其容量远小于内存，但速度却可以接近处理器的频率。当处理器发出内存访问请求时，会先查看缓存内是否有请求数据。如果存在（hit），则不经访问内存直接返回该数据；如果不存在（miss），则要先把内存中的相应数据载入缓存，再将其返回处理器。\n之所以CPU高速缓存容量远小于内存，但其仍具有很大的意义就是因为局部性原则：\n 空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息。  幽灵 幽灵利用的是分支预测机制。\n     //此段代码非严格符合某语法类型，仅为描述逻辑使用 bit [511:0] array1 [256]; //512宽度是因为cacheline大小为64Byte，256深度是因为1byte表示最大为256。 bit [7:0] array2 [16]; //8宽度是因为作为array1的索引，深度16无特殊意义。 //program mv r0 #array2_size str r0 [array2_size_addr] function1 //清除array1缓存区 //将array2所有元素设置为0 endfunction function2(input x) ldr r1 [array2_size_addr_addr] //为了与分支指令形成依赖，使array1的访问可以先执行。 ldr r2 [r1] //r1 也就是array2_size_addr ... if(x \u0026lt; r1) { ldr r2 array2[x]; ldr r3 array1[r2 * 512]; } endfunction function3 //依次访问array1所有元素，记录返回时间。 for i is 0 to 255 { ldr r2 [array1_base_addr + i] } endfunction  第一步先定义array1和array2两个数组空间，同时清除array1的缓存区和将array2所有元素设置为0。 第二步多次执行function2，输入符合x小于array2_size的值，训练分支预测器，使其默认为跳转taken。 第三步将x设为目标地址（x大于array2_size），执行function2，此时分支指令前的ldr指令会阻碍分支指令执行，而访问array2的指令会先执行，最终会因为if条件不满足而flush流水线，但是数据已经缓存至cache。 第四步执行function3，扫描array1的所有元素，记录返回时间，由于之前清除了array1的所有缓存区，function2也只是元素0添加至了缓存区，ldr指令从cache和内存拿数据有明显的时间差，换句话说，存在两个结果：  如果扫描结果只有元素0访问最快，则目标地址的数据byte值为0； 如果扫描结果有0元素和某index元素访问最快，则目标地址的数据byte值为index。    熔断 幽灵利用的是乱序执行机制。\n     //此段代码非严格符合某语法类型，仅为描述逻辑使用 bit [511:0] array1 [256]; //512宽度是因为cacheline大小为64Byte，256深度是因为1byte表示最大为256。 //program function1 //清除array1缓存区 endfunction function2 ldr r0 byte[x] //x为目标地址，非法操作 ldr r1 array1[r0 * 512]; endfunction function3 //依次访问array1所有元素，记录返回时间。 for i is 0 to 255 { ldr r2 [array1_base_addr + i] } endfunction  第一步先定义array1数组空间，同时清除array1的缓存区。 第二步执行function2，访问目标地址（非法），并将返回数据作为array1的index访问array1。 第三步执行function3，扫描array1的所有元素，记录返回时间，由于之前清除了array1的所有缓存区，function2也只是元素0添加至了缓存区，ldr指令从cache和内存拿数据有明显的时间差，如果扫描结果为某index元素访问最快，则目标地址的数据byte值为index。  解决方案 待补充\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":4,"section":"docs","tags":["CPU"],"title":"浅谈熔断和幽灵","uri":"https://www.wenhui.space/docs/08-ic-design/cpu/meltdown-and-spectre/"},{"content":"本文 主要介绍ARM DynamIQ架构下的功耗管理策略。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     dsu_trm_100453_0002_00_en ARM ARM官网   cortex_a75_trm_100403_0300_00_en ARM ARM官网   AMBA低功耗接口（一）Q_Channel lujun 个人博客：骏的世界    专业术语与缩略语    缩写 全称 说明     dsu DynamIQ Shared Unit DSU包含L3 Memory System、control logic、 external interfaces，以支持DynamIQ cluster 结构   trm Technical Reference Manual 参考手册   PMU Power Management Unit 功耗管理单元   DVFS Dynamic Voltage and Frequency Scaling 动态电压和频率调节         背景 多核处理器 在早期的单核处理器中，往往通过提高时钟频率来提高性能，但随着频率的提高，设计难度会加大，性能提升效益却降低，以及功耗不断增大导致的散热问题，使得单核处理器性能提升越来越难，典型的就是Intel Pentium 4处理器。\n多核处理器称为性能提升的最佳解决方案，也就是单芯片集成多个处理器核心，来替代复杂性较高的单线程处理器。通过多核的硬件结构，搭配多线程编程，使得处理器性能显著提升。在现代的多核硬件结构中，内存对多个CPU核是共享的，CPU核一般都是对称的，因此多核属于共享存储的对称多处理器（Symmetric Multi-processor，SMP）。\n根据上文已知，多核处理器间共享内存，每个核处理一个进程，那么不同进程间并行执行就会遇到数据竞争的问题，如何解决数据竞争问题是多核处理器设计中的关键。\n一般的cluster架构  一个cluster，最多4个对称的core。 每个core都有L1 Cache（D\u0026amp;I）。 程序运行在一个cluster中的core。 cluster内有L2 cache，4个core共享。 cluster内有snoop control unit，来维护L1 cache的数据一致性。 cluster内有中断控制器，将中断信息分配给对应的cpu。       big.LITTLE架构  先来说一下为什么需要big.LITTLE架构？  从应用场景来分析，分为两类，一是对性能要求高，比如看打游戏，二是对性能要求不高，但尽可能降低功耗，如收发邮件。 大小核的设计，就是根据不同应用场景，来选用高性能核运行还是低功耗核运行。 典型的是低功耗核Coretex-A7和高性能核Coretex-A15，同属于ARMv7架构。          两个cluster，每个cluster最多4个对称的core。 每个core都有L1 Cache（D\u0026amp;I）。 程序运行在两个个cluster中的core。 每个cluster内有L2 cache，4个core共享。 每个cluster内有snoop control unit，来维护L1 cache的数据一致性。 cluster之间通过互连和内存来维护cache数据一致性(CCI [Cache Coherent Interconnect])。 两个cluster共享一个中断控制器，将中断信息分配给对应的cluster，cluster再分配给对应的core。       DynamIQ架构  DynamIQ cluster结构中，可以将不同类型的core放到一个cluster中。比如，将性能高的core，和功耗低的core放进一个cluster。如果没有DynamIQ，需要将其放在2个不同cluster中的 DynamIQ cluster结构中，增加了异步桥的设计，每个核可以工作在不同的频率，也可以单独的控制每个核开关。 DynamIQ cluster结构中，core之间通过Shared Memory（L3 cache）来完成cache数据一致性。 DynamIQ cluster结构中，共享一个中断控制器，将中断信息通过异步桥再分配给对应的core。        举例：Kirin 980  Kirin 970采用传统的big.LITTLE，Kirin 980采用DynamIQ big.LITTLE。 性能提高75%，效能提高58%。 两个Big core，A76 2.6G 两个Middle core， A76 1.92G 四个Little core， A55 1.8G         Power domains  DynamIQ cluster中对不同电源域可以采取上电/下电操作：  单个CPU core、L3 cache、cluster logic、debug。 Cortex-A55还支持SIMD logic独立的电源域. 以上电源域在实现时可选择性实现。         dsu power modes   ON(Logic ON, RAMs ON) :\n 所有core和dsu logic开启。 仅通过必要的时钟门控降低动态功耗。    Functional retention(Logic ON, RAMs RET) ：\n 在不访问L3 cache时，可将L3 cache置于retention状态（数据保持）。 暂停对L3 cache的访问，直到切换为ON状态，但core依然在运行。 可以通过任何一个cluster内的core，来禁用或启用dsu的fun_ret mode。 可以通过软件设定L3 cache进入fun_ret mode的超时值。    Memory retention(Logic RET, RAMs RET) ：\n cluster的休眠模式。 关闭dsu logic，同时L3 cache数据保持。 cluster内的所有core必须处于OFF(powerdown)状态。 mem_ret mode不能维护cache一致性，所以需要在cluster外部无cache一致性维护需求的前提下开启（实际上，只有在cluster是唯一的active cluster时，才可以进入mem_ret mode）。    OFF(Logic OFF, RAMs OFF) ：\n 关闭cluster内所有power domain。 当cluster请求关闭时，应先将L3 cache的数据更新到内存。    以上power mode低功耗深度依次增加 。\n  dsu power modes transitions    Start mode End mode DSU behavior Partner implemented behavior     OFF ON The L3 cache and snoop filter are initialized. The cluster is brought into coherency with the rest of the system. Power applied, isolation disabled.   MEM_RET ON The cluster is brought into coherency with the rest of the system. Power applied, isolation disabled.   MEM_RET FUNC_RET The cluster is brought into coherency with the rest of the system, but the RAMs remain in retention. Power applied, clamps and isolation remain enabled.   ON FUNC_RET Waits for all memory transactions to complete. The clock to the retention domain is gated. L3 cache and snoop filter RAMs are put into retention. RAM clamps and isolation enabled.   FUNC_RET ON L3 cache and snoop filter RAMs are taken out of retention. RAM clamps and isolation disabled.   ON OFF Waits for all memory transactions to complete. L3 cache allocation is disabled. The L3 cache is cleaned and invalidated. The cluster is removed from system coherency. DSU clamps and isolation to the rest of the system are enabled.   ON or FUNC_RET MEM_RET Waits for all memory transactions to complete. The cluster is removed from system coherency. This mode is only useful when the cluster is the only master active. DSU clamps and isolation to the rest of the system are enabled.    core power modes   ON :\n core已经启动，可以全面运行。 可以通过P-channel或tying PREQ LOW初始化为ON mode。 所有缓存均可访问且保持一致性。    Standby ：\n core的待机模式，时钟树的顶部被添加时钟门控。 所有core logic和RAM处于retention状态。 WFI和WFE指令，将core置于低功耗待机模式。    OFF ：\n 全断电并且不保留任何状态，core logic和RAM关闭。 OFF可以针对整个cluster，也可以针对单个core。 cold reset可以在此模式对core进行reset。 可以通过P-channel将core初始化为此模式。    Off (emulated) ：\n 所有core logic和RAM保持ON状态。 可以在外部声明core warm reset，以模拟断电场景，同时保持内核调试状态并允许调试访问。    Core dynamic retention ：\n 所有core logic和RAM处于retention状态。 但是支持Snoop、GIC、debug访问。    Debug Memory Retention/Debug recovery ：\n 可用于协助对外部watchdog触发的复位事件进行事后调试。 允许重置之前可以观察到重置之前存在的L1、L2 cache的数据。 cache的数据将保留，并且在过渡回ON模式时不会更改。    Advanced SIMD retention (Cortex-A55 only) ：\n SIMD logic处于retention状态，其余core逻辑不影响。 当需要在此模式下执行SIMD指令时，将暂停，直到内核进入开启模式为止。    core power modes transitions      example for ARM Cortex-A75 About power management Cortex-A75内核提供了功耗控制的动态和静态功机制：\n  Dynamic power management includes the following features:\n Architectural clock gating. Per-core Dynamic Voltage and Frequency Scaling (DVFS).    Static power management includes the following features:\n Dynamic retention. Powerdown    Voltage domains Cortex-A75内核支持VCPU电压域和VSYS电压域：\n     电压域之间存在异步桥逻辑。\n 异步桥的Cortex-A75核心逻辑和核心时钟域位于VCPU电压域中。 异步桥的DSU时钟域在VSYS电压域中。  Power domains  PDCPU power domain：包括所有core logic，包括core内的异步桥logic。  Advanced SIMD和floating-point单元属于PDCPU power domain，不支持额外独立的power domain。 L1 and L2 RAMs属于PDCPU power domain，不支持额外独立的power domain。   PDSYS power domain：包括dsu logic和异步桥logic。       下图显示了cluster中的电源域，其中所有相同颜色的都属于同一个电源域。该示例显示了四个Cortex-A75内核。Cortex-A75内核的数量可以变化，并且域数量根据存在的Cortex-A75内核的数量而增加。\n        Power domain Descripti     PDCPU The domain includes the Advanced SIMD and floating-point block, the micro and main TLBs, L1 and L2 RAMs, and Debug registers associated with the Cortex-A75 core.  is the number of Cortex-A75 cores. The number represents core 0, core 1, core 2, and core 3. If a core is not present, the corresponding power domain is not present.   PDSYS Top-level DSU power domain.    Architectural clock gating modes(Standby) Wait for Interrupt (WFI) and Wait for Event (WFE) are features of Armv8-A architecture that put the core in a low-power standby mode by architecturally disabling the clock at the top of the clock tree. The core is fully powered and retains all the state in standby mode.\nCore Wait for Interrupt 当core执行WFI指令时，core将等待core内的所有指令retire，然后再进入低功耗状态。WFI指令确保以程序顺序retire在WFI指令之前发生的所有显式内存访问。此外，WFI指令可确保store指令已更新cache或已issue到L3 memory system。\n当内核处于WFI低功耗状态时，如果检测到以下任何事件时，将临时启用core内的时钟，而不会导致core退出WFI低功耗状态：\n L3 memory snoop request A cache or TLB maintenance operation APB access to the debug or trace registers GIC CPU access through the AXI4 stream channel  发生以下情况之一时，发生从WFI低功率状态退出：\n WFI wake-up events. reset  Core Wait for Event 当core执行WFE指令时，core会等待core内的所有指令retire，然后再进入低功耗状态。如果设置了事件寄存器，则执行WFE不会导致进入待机状态，而是清除事件寄存器。\n当内核处于WFE低功耗状态时，如果检测到以下任何事件时，将临时启用core内的时钟，而不会导致core退出WFE低功耗状态：\n L3 memory snoop request A cache or TLB maintenance operation APB access to the debug or trace registers GIC CPU access through the AXI4 stream channel  发生以下情况之一时，发生从WFE低功率状态退出：\n WFE wake-up events The EVENTI input signal is asserted reset  power control 所有power mode转换都是在电源控制器（PMU）的请求下执行的，使用P-channel接口与Cortex-A75内核进行通信。\n每个core都有一个P-channel，而cluster有一个P-channel。 Cortex-A75 core可以通过 PACTIVE 发出当前power mode，电源控制器可以通过 PREQ 和 PSTATE 发出power mode的切换请求。然后，Cortex-A75 core在接受请求之前，执行达到请求的功耗模式所需的所有操作，例如门控时钟，刷新缓存或禁用一致性。\n如果请求无效，或者是由于转换不正确，或者是因为状态已更改，使得状态不再合适，那么该请求将被拒绝。\n具体控制协议参考P-channel。\nCore power modes 下图显示了每个核心域P通道支持的模式，以及它们之间的合法转换：\n     具体各个power mode的含义，请参看上文介绍。\nEncoding for power modes 下图展示了每个core P-channel支持的模式的编码：\n     Power domain states for power modes  Power state description：        Supported core power domain states：       Power up and down sequences Core powerdown 要使core 解除cache一致性，为core powerdown做好准备，必须执行以下掉电步骤：\n Save all architectural states. Configure the GIC distributor to disable or reroute interrupts away from this core. Set the CPUPWRCTLR.CORE_PWRDN_EN bit to 1 to indicate to the power controller that a powerdown is requested. Execute an ISB instruction. Execute a WFI instruction  在执行WFI之后，在电源控制器的指导下，所有L1和L2 cache禁用，L1和L2 cache刷新以及与L3 memory system的通信均在硬件中执行。\nCore powerup 要在reset后使core保持cache一致性，不需要任何软件操作。\nDebug over powerdown Cortex-A75 core支持掉电调试，这使调试器即使在掉电后也能保持与core的连接。掉电调试逻辑是DebugBlock的一部分，它在cluster外部，在掉电调试过程中必须保持通电。\nQ-channel 概述 AMBA提供了，低功耗的接口。用于实现power控制功能。目前，AMBA里面，包含2种低功耗接口。\n Q-Channel：实现简单的power控制，如上电，下电。 P-Channel：实现更精细的power控制，如全上电，半上电，1/4上电等。  在一些场景下，组件只有两种power状态，分别为power-up，power-down。因此对这种组件的power控制，只需要对其上电，断电即可。用Q-Channel，即可实现。\n接口 以下是Q-Channel的接口：\n     分为device端和power controller端（下文均简称为PMU）。device端，就是需要被电源控制的组件，比如core，外设等。PMU端，就是提供电源管理的组件。\n在Q-Channel中，将device的power状态，分成了2种，\n operational状态： device处于工作状态，简单理解为上电状态，下文称为上电状态 quiescent状态：device处于停止状态，简单理解为断电状态，下文称为断电状态  接口如下\n   信号 说明 驱动端     QREQn power controller发送power请求信号，为高表示上电，为低表示断电 PMU   QACCEPTn 为高，表示device接受外部power请求 Device   QDENY 为高，表示device拒绝外部power请求 Device   QACTIVE 提供给device，向PMU发送power请求，更改自己的power状态，为高表示device需要PMU将自己置为上电状态，为低表示device需要PMU将自己置为断电状态 Device    Q-Channel接口的握手状态 ARM对Q-Channel的interface，定义了几种握手状态：\n Q_RUN：device处于上电状态。 Q_REQUEST：device处于上电状态，但是在idle状态时，可以接收power request，进入断电状态。 Q_STOPPED：device进入了断电状态。 Q_EXIT：等待被提供时钟或者power的状态。当device得到外部提供的时钟或者power时，将QACCEPTn拉高，进入Q_RUN状态。 Q_DENIED: device拒绝外部power的请求，不进入断电状态，而保持上电状态。 Q_CONTINUE：PMU在Q_DENIED状态后，将QREQn拉高后的状态。  以下是编码：\n     以下是状态转移图：\n     对于握手信号，有以下的规则：\n REQn只能在QACCEPTn为高并且QDENY为低时，才可以从高变为低。 QREQn满足以下条件，才可以从低变为高：QACCEPTn和QDENY都为低；QACCEPTn和QDENY都为高。 QACCEPTn只能在QREQn和QDENY都为低情况下，才可以从高变为低。 QACCEPTn只能在QREQn和QDENY都为高情况下，才可以从低变为高。 QDENY只能在QREQn和QACCEPTn都为高情况下，才可以从高变为低。 QDENY只能在QREQn为低并且QACCEPTn为高情况下，才可以从低变为高。  Q_Channel的握手协议 device接受PMU的power请求 以下是握手协议时序图：\n      在T1，QREQn和QACCEPTn为高，Q_Channel进入Q_RUN状态。 在T2，QREQn为低，PMU请求device进入断电状态，然后等待外设响应，此时Q_Channel进入Q_REQUEST状态。 在T3，QACCEPTn为低，表示device接收PMU的请求，将自己进入断电状态。此时Q_Channel进入Q_STOPPED状态。 在T4，QREQn为高，PMU请求device进入上电状态，然后等待外设响应。此时Q_Channel进入Q_EXIT状态。 在T5，QACCEPTn为高，表示device接收PMU的请求，将自己进入上电状态。此时Q_Channel进入Q_RUN状态。  device拒绝PMU的power请求 当外部PMU给device发送power请求，device可以拒绝该power请求。PMU收到device的拒绝响应后，应取消该power请求。\n      在T1，QREQn和QACCEPTn为高，Q_Channel进入Q_RUN状态。 在T2，QREQn为低，PMU请求device进入断电状态，然后等待外设响应，此时Q_Channel进入Q_REQUEST状态。 在T3，QDENY为高，表示device拒绝PMU的请求，自己保持上电状态。此时Q_Channel进入Q_DENIED状态。 在T4，PMU接收到device的拒绝响应，将QREQn拉高，PMU请求device进入上电状态，然后等待外设响应。此时Q_Channel进入Q_CONTINUE状态。 在T5，QDENY为低，表示device接收PMU的上电请求，将自己保持上电状态。此时Q_Channel进入Q_RUN状态。  device复位信号与Q_Channel的结合 复位信号，需要和Q_Channel的信号，进行组合。一般来说，复位信号，也会由PMU来控制。\nRESETn复位有效时，QREQn为低       T2时刻，RESETn为高，复位取消。 T3时刻，QREQn为高，PMU向device请求上电。Q_Channel进入Q_EXIT状态。 T4时刻，QACCEPTn为高，device接受PMU的上电请求。Q_Channel进入Q_RUN状态。 T5时刻，QREQn为低，PMU向device请求断电，Q_Channel进入Q_REQUEST状态。T6时刻，QACCEPTn为低，device接受PMU的断电请求。Q_Channel进入Q_STOPPED。 T7时刻，将RESETn拉低。  RESETn复位有效时，QREQn为高       T2时刻，QREQn拉高，PMU向device请求上电。Q_Channel进入Q_EXIT状态。 T3时刻，因为RESETn为低，复位有效，device将QACCEPTn保持为低，Q_Channel保持Q_EXIT状态。 T4时刻，因为RESETn为高，复位无效。device将QACCEPTn拉低，响应PMU的上电请求。Q_Channel进入Q_RUN状态。 T5时刻，QREQn拉低，PMU向device请求断电，Q_Channel进入Q_REQUEST状态。 T6时刻，device将QACCEPTn拉低，响应PMU的断电请求。Q_Channel进入Q_STOPPED状态。 T7时刻，RESETn拉低。  QACTIVE QACTIVE，是提供给device，给PMU发送power请求的信号。可以由多个来源的组合。如果为高，那么PMU要给自己上电，并且之后，不能给自己断电。\nQACTIVE和握手信号（QREQn，QACCEPTn，QDENY）是独立开的。\n请求上电和请求下电       T1时刻，device将QACTIVE拉高，向PMU发起退出断电请求。 T2时刻，PMU将QREQn拉高，Q_Channel进入Q_EXIT状态。 T3时刻，进入Q_RUN状态。 T4时刻，device将QACTIVE拉低，device向PMU发起进入断电请求。 T5时刻，PMU将QREQn拉低，Q_Channel进入Q_REQUEST状态。 T6时刻，进入Q_STOPPED状态。  PMU不允许断电       T1时刻，device将QACTIVE拉高，向PMU发起上电请求。 T2时刻，PMU将QREQn拉高，Q_Channel进入Q_EXIT状态。 T3时刻，进入Q_RUN状态。之后，device处于上电状态。 T4时刻，PMU将QREQn拉低，PMU想让device进入断电状态，但是QACTIVE为高，表示device要一直处于上电状态。因此QACCEPTn持续保持高，Q_Channel一直维持在Q_REQUEST状态。device维持在上电状态。 T5时刻，因为之前QACTIVE拉低，device想进入断电状态，device将QACCEPTn拉低，响应PMU的断电请求，然后Q_Channel进入Q_STOPPED状态。device进入断电状态。  P-channel 概述 为了满足复杂的power管理的需求，ARM提供了P-Channel的低功耗接口，来满足这样的应用场景。\nP-Channel，提出了一个概念，叫power state transition。在P-Channel的应用场景中，power的状态有很多，这个是实现是自己定义的。power的各个状态之间，是可以切换的。\n2个最基本的状态：\n lower-power状态：在这个状态下，power消耗比较少，device处于低功耗状态（具有部分功能） higher-power状态：在这个状态，power消耗比较大，device处于正常状态（具有完整功能）  接口      分为device端和power控制端（下文简称PMU）。\n   信号 说明 驱动端     PACTIVE [N-1:0] 提供wakeup功能 device   PSTATE [M-1:0] 需要切换的目的power状态 PMU   PREQ 为高，表示power状态切换请求 PMU   PACCEPT 为高，表示device接受power状态切换请求 device   PDENY 为高，表示device拒绝power状态切换请求 device     PACCEPT和PDENY在握手中，只能有一个为高。 PACCEPT表示接受请求，PDENY表示拒绝请求。 PACCEPT，PDENY，PREQ，PSTATE，必须是从寄存器直接输出。  其他 待补充\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":5,"section":"docs","tags":["CPU"],"title":"DynamIQ Power Management","uri":"https://www.wenhui.space/docs/08-ic-design/cpu/dynamiq-power-management/"},{"content":"本文 主要介绍我在网上下载电子书的一些渠道。\n   版本 说明     0.1 初版发布    Java知识分享网站  Java知识分享网站，在这里可以搜索到很多关于计算机相关的书籍，可直接下载，对于链接失效或其他不能下载情况，可加锋哥微信询问，锋哥是一个是非常热心的人。 全国图书馆参考咨询联盟，可查询书籍以及其他类型资料。  CSDN搜索 CSDN搜索，找到需要的资源，通过淘宝购买第三方下载链接，可节省成本。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":6,"section":"docs","tags":null,"title":"电子书下载","uri":"https://www.wenhui.space/docs/03-life/ebook-download/"},{"content":"本文 主要讲解跨时钟域的数据传输处理，重点是异步fifo。\n   版本 说明     0.1 初版发布   0.2 添加格雷码转换逻辑   0.3 补充问题   0.4 补充问题：非2次幂fifo深度的处理    参考    名称 作者 来源     各种网络资源  网络    专业术语与缩略语    缩写 全称 说明     CDC clock domain crossing 跨时钟域    基础概念 异步时序 异步时序指的是在设计中有两个或以上的时钟，且时钟之间是同频不同相或不同频的关系。而异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。\n亚稳态 每一个触发器都有其规定的建立(setup)和保持(hold)时间参数，在这个时间参数内，输入信号在时钟的上升沿是不允许发生变的。如果在信号的建立时间中对其进行采样，得到的结果将是不可预知的，即亚稳态。\n格雷码 格雷码就是一种可靠性编码。在一组数的编码中，若 任意两个相邻的码只有一位二进制数不同 ，则称这种编码为格雷码，另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码。\n举例：\n 两位数据格雷码：00 01 11 10 三位数据格雷码：000 001 011 010 110 111 101 100  转换逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Binary to Gray g[0] = b[1] ^ b[0]; g[1] = b[2] ^ b[1]; g[2] = b[3] ^ b[2]; g[3] = b[4] ^ b[3]; ... g[n-1] = b[n] ^ b[n-1]; //b[n-1:0]为常规二进制数，这里b[n]设置为0。g[n-1:0]为格雷码。  // Gray to Binary b[0] = g[0] ^ g[1] ^ g[2] ^ g[3] ^ ... ^ g[n-1] b[1] = g[1] ^ g[2] ^ g[3] ^ ... ^ g[n-1] b[2] = g[2] ^ g[3] ^ ... ^ g[n-1] b[3] = g[3] ^ ... ^ g[n-1] ... b[n-1] = g[n-1]   数据同步 如果一个时钟域直接去采样另一个时钟域的数据，可能会采样到数据的亚稳态，采样到的亚稳态数据，随着时间延长，亚稳态数据可能逐渐稳定为高电平，也可能逐渐稳定为低电平，也有可能依旧处于亚稳态。这时候的采样数据是无效的，直到下一次采样才能拿到有效数据。如下图：\n     首先，跨时钟域采样， 采样到亚稳态的情况是无法避免的 ，亚稳态数据是无法做逻辑运算的，为了防止亚稳态的传播，采用了两级同步电路，也就是两个寄存器级联，可以有效的防止亚稳态的传播。如下图红色框内的两级同步电路，rd_clk域的done0信号， 经过wr_clk域的两级寄存器同步，done2数据为亚稳态的概率几乎为零 。\n     上面的两级同步电路，只是 解决了亚稳态的传播，但是无法保证同步数据的正确性 。如下图，在a_clk时钟上升沿的驱动下，a_data电平拉低，同时b_clk上升沿进行采样，此时采样到数据处于亚稳态，经过第二级同步寄存器，数据处于稳定状态，但是为高电平，所以同步数据错误，直到下一拍才获取正确值低电平。\n     跨时钟域数据传输 上面解决了亚稳态的传播，但是无法保证同步数据的正确性，所以需要特有的跨时钟域数据传输电路。如下图：data由wr传向rd，蓝色为wr时钟域，橙色为rd时钟域，中间的read和done信号需要跨时钟域的同步。操作流程：\n 当外部wr和wr_data到来时，更新寄存器read0和data，这些是在wr时钟域完成的。 read0经过rd时钟域的两级同步，得到read2。 read2有效，则等待外部rd请求，当外部rd请求有效时，更新寄存器done0。 done0经过wr时钟域的两级同步，得到done2。 done2有效，则等待外部wr请求，进行下一次数据传输。  上文已经说过，两级同步电路，只是解决了亚稳态的传播，但是无法保证同步数据的正确性。那么read2或done2数据错误会发生什么？首先read和done都是单比特信号，如果发生错误，也就是导致有效高电平此时为无效低电平，无法进行wr或rd。但是在下一拍会将正确的有效高电平传输到read2或done2，可进行正常的wr或rd。总结， 由于两级同步电路不能保证ready和done传输的正确性，数据data可能会迟到一拍传输到另一个时钟域，但是数据data不会发生错误 。\n     跨时钟域数据传输的解耦 异步fifo 上文介绍的跨时钟域数据传输电路是根据ready和done信号完成的握手协议，可以避免在数据未读走时再次写入。这样电路结构简单，但是对于快时钟域向慢时钟域的数据连续传输，会严重影响传输性能，为了解决此问题，引入fifo，对读写时钟域进行解耦。如下图：\n     写时钟域  起始写指针指向0，wr时钟域的读指针也指向0，fifo非full，可接收写请求。 wr有效，根据写指针将数据写入fifo，同时更新写指针（加1）。 将rd时钟域的读指针同步到wr时钟域。 根据写指针和同步到wr时钟域的读指针，判断fifo是否full。 如果full，反馈给外部电路，不再发送写请求，如果非full，等待下一次写请求。  读时钟域  起始读指针指向0，rd时钟域的写指针也指向0，fifo empty，不可接收读请求，等待fifo写入数据。 将wr时钟域的读指针同步到rd时钟域。 根据读指针和同步到rd时钟域的写指针，判断fifo是否empty。 如果empty，反馈给外部电路，不再发送写请求，如果非empty，等待写请求。 rd有效，根据读指针从fifo读出数据，同时更新读指针（加1）。 根据读指针和同步到rd时钟域的写指针，判断fifo是否empty。 如果empty，反馈给外部电路，不再发送写请求，如果非empty，等待写请求。  指针编码 根据上文描述，读写指针在进行跨时钟域同步，这里读写指针的功能类似之前的done和ready。我们知道，两级同步电路，只是解决了亚稳态的传播，但是无法保证同步数据的正确性，如果像done和ready单比特数据的同步，发生错误的代价是延迟一拍传输，但不会造成功能性错误。显然指针不是单比特数据，例如地址从11跳转到00时，经过同步电路后的数据可能是最新值00，可能是原始值11，也有可能发生错误10或01，这对wr时钟域的full判断和rd时钟域的empty判断，会造成灾难性错误。那么如何保证在发生同步数据错误时不导致功能性错误？答案是采用格雷码。\n格雷码的特点是相邻两个数据之间只要一比特变化（00 01 11 10），也就是指针的加一，只会改变一个比特，这在经过同步电路后的数据无非两个结果，一是最新值，二是原始值。例如地址从11跳转到10时，只有低位比特发生跳变，有可能采样到亚稳态并最终发生同步错误。那么同步后的值可能为最新值10，或原始值11。这对wr时钟域的full判断和rd时钟域的empty判断，其代价就是延迟一拍。\n总结 通过在跨时钟域数据传输电路中添加fifo结构，可以实现两个时钟域的解耦，也就是wr时钟域只负责数据写入fifo，rd时钟域只负责从fifo读出数据， fifo深度越大，两个时钟域相关性越小 。（异步fifo的使用是解决跨时钟域问题最典型的方法，对于由高频向低频进行连续数据传输时，可显著提高传输性能）\nfifo的真实读写指针是rd时钟域的rd_ptr0和wr时钟域的wr_ptr0，两者代表作fifo真实的空满。但是wr时钟域在做full判断时，需要将rd_ptr0进行两级同步到rd_ptr2，rd时钟域在做empty判断时与其类似。由于两级同步电路的存在，以及同步错误（延迟一拍）的存在，wr时钟域的rd_ptr2可能不等于读时钟域的rd_ptr0，这时候根据rd_ptr2和wr_ptr0做出的full信号，可能是 虚满 ； 虚空 与其类似。但是 虚空虚满只会延迟传输时间，并不影响传输功能 。\n补充问题 同步器之前的组合逻辑 如果在两级同步电路之前添加组合逻辑，会产生额外的毛刺或增加不稳定性，影响一个时钟域的同步寄存器对另一个时钟域的采样。如下图：\n     异步复位同步释放 跨时钟域数据传输中的异步复位问题，坚持一个原则，同一个时钟域的触发器中D和reset来自同一个时钟域（每个时钟域有自己的reset信号，这涉及异步复位同步释放问题）。\n 异步复位：复位信号可以理解为一个普通的数据信号，它只有在时钟的跳变沿才会其作用，一般只要复位信号持续时间大于一个时钟周期，就可以保证正确复位。 同步复位：复位可以在任何时候发生，表面上看跟时钟没有关系，但真实情况是异步复位也需考虑时钟跳变沿，因为时钟沿变化和异步复位都可以引起Q端数据变化。如果时钟跳变沿期间异步复位信号发生变化，Q端可能发生亚稳态现象。  同步复位虽然解决了当时钟的有效沿来临的时候rst_n的边沿也正好来临所出现的冒险与竞争。但是从综合的电路上可以看出，多了一个组合逻辑MUX。如果设计中所有的复位都是这样的，那会增加很多的资源，导致芯片面积很大。那么有没有更好的解决办法呢？答案是有，那就是异步复位同步释放机制。\n 异步复位同步释放：异步复位，同步释放就是指在复位信号到来的时候不受时钟信号的同步，而是在复位信号释放的时候受到时钟信号的同步。  如下图，单独看System框的复位策略，是一个异步复位电路，即复位信号有效时不管时钟信号是否处于有效沿，输出都会被复位。但是如果复位信号在时钟信号的上升沿发生时，这时候的输出就是亚稳态。reset_gen框中电路图是实现异步复位同步释放的关键（两级同步电路）。\n     关于毛刺 电路中的毛刺是无法避免的，原因是一个组合逻辑的数据结果，可能与多个数据源以及多个操作路径有关，数据源到来时间不一致，或者操作路径间的长短不一样，都会使组合逻辑的数据结果产生毛刺，同步电路会保证这些毛刺产生在时钟周期内，换句话说，在时钟沿采样时，组合逻辑的数据结果是稳定的最终结果。\n而异步时序中，采样时机无法保证，这时毛刺就会造成采样数据错误。解决方法还是通过格雷码，即使发生采样错误不会导致功能错误。\n异步fifo中读写地址多bit跳变   问题说明：慢时钟域同步快时钟域时候，在慢时钟域的一个周期内，经历多次快时钟域的地址更新，那么对应的格雷码就会有多个bit发生变化，此场景会不会影响地址同步的正确性？\n  答案：不会！ 这里的多bit跳变是在偷换概念，问题中的多bit跳变指的是快时钟域地址同步到慢时钟域时，地址的多次加一。这不会影响电路功能，格雷码解决的问题是慢时钟域向快时钟域采样时刻，保证地址单bit跳变，这里快时钟域的地址也是在快时钟的沿触发下依次加一的，所以采样时不会发生多bit跳变。（换句话说，多bit跳变是指，读时钟域的读地址或写时钟域的写地址，在沿触发前后的地址变化）\n  非2次幂fifo深度的处理 前面所说的fifo深度都是2次幂，在wrap around时能够保持格雷码特性，也就是单bit跳变。那么如何实现任意深度的异步fifo呢？\n这时候我们利用格雷码的另一个特性，那就是对称性。如下图4 bit格雷码为例，以中间为对称的两个数，也保持了单bit跳变的特性，所以我们可以利用这个特性来实现任意深度的异步fifo。但是对于地址更新逻辑和空满判断逻辑需要另外处理。\n     先来看常规深度为8的异步fifo，地址更新采用+1即可，空满判断逻辑使用高位[3]和低位地址是否相同来实现：\n     再来看深度为7的异步fifo，地址更新依然采用+1，但是要注意从1开始到14结束，对14加1要跳变为1，空判断逻辑与深度为8时逻辑相同，但是满判断逻辑需要通过地址差是否为7来实现：\n     文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":7,"section":"docs","tags":null,"title":"跨时钟域数据传输","uri":"https://www.wenhui.space/docs/08-ic-design/typical/clock-domain-crossing/"},{"content":"本文 主要普及ARM处理器的基础知识，不涉及处理器微架构具体设计细节。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     ARM处理器详解 移知 网络    专业术语与缩略语    缩写 全称 说明     PPA Performance Power Area 性能、功耗、面积   ISA Instructions Set Architecture 指令集架构   CISC Complex Instructions Set Computer 复杂指令集计算机   RISC Reduced Instructions Set Computer 精简指令集计算机   CPI Cycle Per Instruction 指令平均时钟周期数   BTB Branch Target Buffer 分支目标地址缓存   BHT Branch History Table 分支历史记录表   RAS Return address stack 返回地址栈   TTB Transaction Table Base 基地址转换表   VA Virtual Address 虚拟地址   PA Physical Address 物理地址   ASID Address Space Identifier 地址空间编号（标记当前进程）   TLB Translation Look-aside Buffers 映射表缓存   MMU Memory Management Unit 内存管理单元   LSQ Load Store Queue 访存队列   AMAT average memory access time 平均存储访问时间，用来衡量cache性能   LRU Least Recently Used 最久未使用替换算法   CCI Cache Coherency Interconnection cache一致性互连   CCN Cache Coherency Network cache一致性网络   HW Hardware 硬件设计   SW Sortware 软件设计   SECDED Single error correct double error detect 单比特错误纠正双比特错误检查   SIMD Single Instruction Multi Data 单指令多数据，向量处理指令   AMP Asymmetric Multi-Processing 非对称的多任务处理   SMP Symmetric Multi-Processing 对称的多任务处理   SCU Snoop Control Unit snoop控制单元，保持cache一致性   DSU DynamIQ Shared Unit 相当于一个wrapper，将cluster包起来         RISC和ARM处理器架构 处理器架构与微架构 处理器架构是一个规范，是一个指令集，这个指令集定义了处理器的基本特性和基本功能。\n处理器微架构，微架构是指一款处理器执行指令集的逻辑结构。\n同一个处理器架构可以由不同的处理器微架构实现。可以简单理解为架构是软件层面的指令集功能，微架构是硬件层面的逻辑实现。\nMemory Wall   处理器执行速度与存储访问速度     Instructions/Seconds：x2 Every 2 Years Memory capacity：x2 Every 2 Years Memory Latenc：x1.1 Every 2 Years  处理器 PPA  Performance：speed(IPC)、clock frequency、benchmark(dhrystone、coremark、specint2006、antutu等) Power：active、static、mw/w(功耗单位) Area：die(芯片裸片)、mm^2(面积单位) Power Efficiency：Performance/Power，如benchmark/Power  什么是CISC架构  是一种微处理器指令集架构(ISA) 指令集功能复杂，数量庞大 多用于高性能高功耗的CPU设计中，如Intel X86 多种指令都可以访问存储器 有少量寄存器 编译器设计简单  什么是RISC架构  是一种微处理器指令集架构(ISA) 指令集功能简单 多用于低功耗移动设备CPU设计中，如ARM 只有load/store指令可以访问存储器 有大量寄存器 编译器设计复杂  ARM架构处理器   ARM处理器的发展      ARM处理器系列    Cortex-A处理器   Cortex-A处理器    Cortex-R处理器   Cortex-R处理器     特点：     Fast High processing performance, Fast interrupt response Scalable multi-core, Superscalar pipelines, Branch prediction     Realtime Hard realtime deterministic, Meet realtime constraints Tightly Coupled Memory, Low Latency Peripheral Ports, Fast low latency interrupt handling   Reliable Dependable with safety features, High error resistance, Extended functional safety support Memory protection and error correction, Dual core lockstep configuration, Hardware hypervisor in ARMv8-R    Cortex-M处理器   Cortex-M处理器    SecureCore处理器   SecureCore处理器    处理器流水线 流水线的结构   处理器流水线结构      指令流水线操作    假设一个CPU没有pipeline，执行一条指令需要20ns，执行10条执行需要多长时间？若把这个CPU划分5级pipeline，且每一级pipeline时间相同，则理想情况下执行10条指令需要多长时间？ 答案：20ns*10instr = 200ns，1*4ns*5cycle + 9*4ns*1cycle = 56ns\n流水线的CPI 上述流水线结构中的CPI趋近于1，但是小于1，不能等于1的原因有两方面：\n Initial fill Pipeline Stall and Flush  流水线的Stall   流水线的Stall    流水线的Flush   流水线的Flush    流水线的控制依赖   流水线的控制依赖    假设在10级流水线CPU中，所执行指令中有50%的branch指令，其中50%的branch都是taken的，最终计算中branch是否taken是在第6级流水线，其他情况都是理想的，那么此时CPU的CPI是多少？答案是：1 + 0.5*0.5*5 = 2.25\n流水线的数据依赖   流水线的数据依赖    判断如下I1和I2指令之间可能存在什么dependency？\nADD R1，R2, R3 SUB R2，R1, 1 答案是：RAW WAR\nDependancies和Hazard 注意：如果是顺序执行的处理器，只有RAW才会产生Hazard，WAR和WAW是假相关；如果是乱序执行的处理器，RAW、WAR、WAW都会产生Hazard。\n以下汇编中，需要在什么地方用到哪些解决Hazards/Dependencies的方法，假设branch指令最终结果是taken？\nBEQ Label ADD R1,R1,R1 SUB R2,R2,R2 Label： LDR R1, [R0] ADD R2, R1, 1 SUB R3, R2, 1  Control Hazards：flush Data Hazards：stall Data Hazards：Forwarding    流水线的forward    流水线的级数 更多流水线的级数会导致 ：\n More Hazards： CPI会增大 Less work per stage：Cycle Time会减小  Execution Time = #instructions * CPI * Cycle Time\n  执行时间与流水线级数的关系     只考虑Performance的情况下：30-40 Stages pipeline 综合考虑Performance和Power的情况下：10-15 Stages pipeline (处理器流水线级数越大，控制逻辑越复杂，寄存器也越多，导致功耗面积增大)  分支指令和分支预测 流水线中的Branch      Branch指令预测 指令预测需要考虑三个问题：\n Is this a branch？ Is it taken？ If taken，what is the target address(PC)？       分支预测精确度      分支预测函数      Branch Target Buffer      1-bit预测   1-bit预测      1-bit预测示例    2-bit预测   2-bit预测      2-bit预测示例    两级2-bit预测   两级2-bit预测示例    关于分支预测的总结  预测总Taken，但面对NNNN\u0026hellip; （常Not Taken）情况，miss率较高。 1bit预测，解决NNNN\u0026hellip; （常Not Taken），但面对NTNTNTNT\u0026hellip; （单次翻转较多）情况，miss率较高。 2bit预测，解决NTNTNTNT\u0026hellip; （单次翻转较多）情况，但面对NNTTNNTT\u0026hellip; （两次翻转较多）情况，miss率较高。 两级2bit预测，解决NNTTNNTT\u0026hellip; （两次翻转较多）情况。 经过多次改进，miss率不断在提高，但仍不可能降为0.  RAS(Return address stack)      分支指令分三种类型 ：\n 条件跳转：Taken or Not Taken由预测算法判断，Target Address由BTB获取。 无条件跳转：始终Taken，Target Address由BTB获取。 函数返回：始终Taken，Target Address？？？  对于函数返回的目标地址，如果由BTB获取，会影响预测的准确性。比如第一次条件跳转至函数FUN，地址为0x1230，函数返回时将0x1230记录在BTB；当第二次无条件跳转至函数FUN，地址为0x1250，函数返回时从BTB获取的是0x1230，显然错误。所以这里引入RAS，在Call FUN时将返回地址记录在RAS。\n其功能与栈指针作用相同，而将其实现在Fetch部件，可提高预测精确度。\nMemory管理 Memory层级       Register：Flip-Flop CPU Cache：SRAM Main Memory：ROM，RAM，DDR Secondary Storage：Flash、硬盘 Server(or Internet)  Memory管理       首先ARM的地址空间是统一编址的。 外设区域是不可缓存的。 OS必须在特权操作下访问。 应用程序可以在用户或特权模式下访问。 异常向量表区域是只读的，不可修改。  虚拟地址与物理地址       物理地址：物理地址空间是实在的存在于计算机中的硬件资源，包括DDR、外设、SRAM、Flash等。 虚拟地址：虚拟地址空间并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。 虚拟地址和物理地址之间存在映射关系，虚拟地址是软件层面的使用方法，而硬件实现时需要将虚拟地址根据映射关系，去访问对应物理地址的空间。  为什么需要虚拟地址？ 一个应用程序（源程序）经编译后，通常会形成若干目标程序；这些目标程序再经过连接便形成了可装入程序。这些程序的地址通常都是从“0”开始的，程序中的其它地址都是相对于起始地址计算的，这些地址被称为“相对地址”。那么这样做的好处是什么？\n 方便编译器和操作系统安排程序的地址分布（起始地址和相对地址）。 方便进程之间隔离（每个程序根据映射关系划分自己的物理空间）。 方便OS合理化使用内存（可以使用不相邻物理空间来映射相邻虚拟地址，同时方便内存页的替换）。  Multi-tasking       每个任务都是独立的，并且是并发的。 每个任务占用空间为32MB，三个任务占用空间为96MB。 实际运行时不必需要96MB，根据映射关系，可将3个任务的部分空间映射在物理内存，并在程序运行时进行动态替换。       Translation Table(Page Table)       处理器架构定义64bit的虚拟地址：  高位标识访问哪个page，用作translation table中的索引。 低位作为物理块内的偏移量。   物理地址就是将translation table中的物理地址位与原虚拟地址中的低位的组合。       多级Page Table  First-level tables将虚拟内存的区域以较大粒度进行粗略划分：  使用VA中的第一位字段对First-level tables进行索引。 在此示例中，每个table entrie包含512MB的物理空间。   Second-level tables在First-level基础上，再进一步划分：  Second-level tables使用VA的第二位字段进行索引。 每个table entrie包含62KB的物理空间。   VA的最后一个位字段作为最终物理地址的偏移量。         多级页表与一级页表相比，可节省更多的资源，比如页大小为4KB(VA[12:0])，虚拟地址空间为4GB(VA[31:0])，一级页表需要1M个entry，如果采用两级页表，一级页大小为4MB(VA[22:0])，一级页表和二级页表个需要1K个entry 。\n  从内存中的First-level tables、Second-level tables\u0026hellip;一级一级拿到Base Address，最后与VA的低位（页内偏移量）组合为物理地址的过程，称为 Called a page table Walk 。\n  Page Size  AArch64 支持3种不同的Page Size：4KB、16KB、64KB。 Page Size的大小决定于最低一级的Page Table。 Page Size的大小可通过系统寄存器TTBR进行配置（如果实现了以上3种Page Size）。 举例：Page Size 4KB，4-level look up，48-bit address，9-bit address per level(512 entries)    地址划分      Called a page table Walk    进程切换和Memory管理  操作系统将一地址范围定义为task space，通常在内存底部。 Task A、Task B、Task C使用的是同一块虚拟地址空间；对于OS而言统一分配一块独立的task space，供所有的任务使用，OS的工作就是切换不同的task由处理器执行。        如果多个任务想要运行在同一个虚拟地址空间，则需要将同一个虚拟地址空间映射到不同的物理地址空间。        TLB存放的是cache的Transaction Table Entries。 如果OS切换任务，需要拿到另外一个任务的Transaction Table Entries，重新做page table Walk，同时需要清除TLB数据。 这样每次进行任务切换都需要进行TLB的清除，这样会导致性能降低。        ASID(Address Space Identifier)用于标识当前运行的进程，ASID是8bits位宽，存储在Context ID Register。 Transaction Table Entries可以标记为Global或Non-Global(nG bit)。  对于Global entry，所有进程都可以使用。 对于Non-Global entry，只有特定的进程才可以使用，这里需要额外存储ASID Value。   通过增加ASID，当不同任务使用相同虚拟地址，OS在进行任务切换时，需要匹配ASID，如果ASID不匹配，则TLB不hit，这样可避免每次进程切换都清除TLB。        举例说明：  nG为0代表Global entry，nG为1代表Non-Global entry。 每个进程都有自己的transaction table（kernal space的静态表）和ASID。 OS可以通过更新TTBR0和ASID来切换进程，而无需清除TLB。      执行应用程序1      执行应用程序2      执行应用程序3    TLB 页表一般都很大，并且存放在内存中，所以处理器读取指令/数据需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令/数据。为了减小对内存访问导致的处理器性能下降，引入了TLB。\n  TLB Entry      TLB类似于存储Transaction Table的cache：\n TLB的目的是实现VA转PA。 减小从外部存储器获取页表的访问时间。    TLB较小，而cache很大：\n L1 Cache容量8〜64KB。 L1 TLB entries数目4〜64 entries，每个entry 大约4word。    TLB仅存储最终的Transaction Table：\n 首先页表本质仍是一块存储区域，可以通过访问存储获取页表项。 通过访问TLB，1cycle就能将VA转换为PA。 通过访问cache来得到PA，几级页表就需要访问几次cache，获得所有级的页表项才能将VA转换为PA。    关于通过访存实现VA转PA的过程（假设两级页表）：\n 访问L1页表项，通过虚拟地址中的L1页表号和TTBR中的基地址来访存，拿到L1页表项。 访问L2页表项，通过虚拟地址的L2页表号和L1页表项中的基地址来访存，拿到L2页表项。 将最终的L1和L2页表项的基地址与虚拟地址的页内偏移量组合为物理地址。    MMU   MMU就是专门处理虚拟地址到物理地址的转换。\n 从硬件上读取内存中的Transaction Table。 Transaction Table的基址寄存器（TTBR）保存Transaction Table的物理基地址。 TLB缓存最近访问的Transaction Table。    开启MMU后，所有CPU的内存访问都要通过MMU进行处理。\n MMU将通过TLB完成VA转PA，当TLB miss时，则需要进行Table Walk操作。 只要MMU实现VA转PA后，才可以访问cache。         Memory Model  典型系统的内存映射被划分为多个逻辑区域。 每个区域可能需要不同的内存属性，比如访问权限。        Normal类型（非外设）的存储，存放代码的程序段和数据段，其存储介质可能是DRAM，SRAM，flash，ROM等。 将地址区域标记为Normal，将告诉处理器访问该位置没有任何副作用。 将地址区域标记为Normal，可以使处理器执行许多优化操作。  Re-ordering：可更改地址访问顺序。 Merging：多次相邻区域访问可合并为一个访问。 Speculation：预测访问。 Unaligned accesses：非对齐访问。   标记为Normal的地址，可以是cacheable也可以是non-cacheable。        Device类型的地址空间用于访问外围设备。 将地址区域标记为Device会告诉处理器访问可能会有副作用（side effects）。 如果地址区域标记为Device，不允许以下访问操作：  Perform speculative data accesses：预测访问。 Re-order accesses：可更改地址访问顺序。 Re-size accesses：更改访问大小。   Device类型的地址空间不能存放代码的程序和数据。 Device类型的地址空间不能cacheable，但是可以bufferable（将外设送来的数据暂时存放，以便处理器将它取走）。        Strongly Ordered：是限制性最强的存储类型，不可以cacheable，也不可以bufferable。 它的访问具有与Device相同的限制，并且不允许提前终止（提前终止是指存储系统一旦缓存了数据，但在该数据未到达最终的从设备之前，即表示写入已完成）。 当未开启MMU时，所有的存储访问都认为是Strongly Ordered，因此，在启动过程中尽早启用MMU，否则会影响性能。  处理器性能 性能的衡量指标  Latency（延迟）：指令从取指到写回寄存器所需要的时间。 Throughput（吞吐量）：单位时间内执行的指令数量。 但是Throughput并不等于Latency的倒数。 举例：五级流水结构，假设Latency为20s，也就是每拍需要4s，而理想情况下的流水操作每拍完成一条指令，那么Throughput为0.25/s  比较性能  SpeedUp简单说就是一个处理器与另一款处理器的运算速度之比（X is N times faster than Y）：  SpeedUp与Latency成反比。 SpeedUp与Throughput成正比。         衡量性能  Performance 近似等于 1/(Execution time)，但是程序的执行时间，是指哪些程序的执行呢？ 通常使用的应用程序吗？  这些应用程序众多，选择哪些，不选择哪些？ 这些应用程序是否具有一定代表性？ 怎么获取这些应用程序？   所以，选择标准的测试程序：Benchmark。  Benchmark专为性能测试而生。 Benchmark是一套测试程序，包含众多测试程序。 每一个测试程序都具有某种应用场景的代表性，比如整型运算和浮点运算。    Benchmark类型  Real Benchmark ：  具有非常强的应用代表性，比如可测试客户终端在Browsing（浏览）的应用场景，CPU性能如何。 但是在CPU开发中没有完善的OS和硬件驱动，因此Real Benchmark的测试环境要求较高。   Kernels Benchmark ：  从应用程序中提取的一些典型的重要的算法，如Geekbench。   Synthetic Benchmark ：  与Kernels Benchmark相比更小的测试片段，非真实的应用程序，如Dhrystone。    Benchmarkn标准       Benchmark组织从一些厂商、研究机构、终端客户中搜集信息形成一套标准的Benchmark测试程序。  TPC：针对DataBase（数据库）和WebServer。 EEMBC：针对嵌入式程序，如CoreMark。 SPEC：针对整型和浮点的运算，如SPEC2000和SPEC2006，以及最新的SPEC2017。    性能的Iron Law       关于CPU的性能，是存在这样一条铁律：CPU time = instr num per program * cycle num per instr * time per clock 。  减小instr num per program，需要优化编译器，同时与指令集相关，单指令功能越复杂，需要的指令数目越少。 减小cycle num per instr，需要优化硬件设计结构，同时与指令集相关，单指令功能越简单，指令需要的cycle数目越少。 减小time per clock，需要优化工艺，同时与指令集和硬件设计结构相关，减少单cycle的逻辑运算复杂度。 实际三者相互制约，再设计CPU的过程，往往在这三者之间做权衡，尽量达到理想状态。    效能（power efficiency） 衡量一款处理器还有一个标准，那就是效能，也就是能耗比，尤其在移动端处理器能效指标非常重要。\nMemory Ordering Memory Ordering介绍  Data Dependency：Forwarding和Stall   ADD R0, R1, R2 SUB R3, R2, R0  Control Dependency：Branch prediction和Flush Memory Dependency？R0 等于 R2？   STR R1, [R0] LDR R3, [R2] Load Store Queue LDR R1, [R1] STR R2, [R3] LDR R4, [R4] STR R5, [R0] LDR R5, [R8]       访问存储器时的Dependency，就是指Store在前，Load在后，访问同一个地址。 如果Store和Load地址已经计算出，Load明确知道自己要去访问Store指令的数据，这时候可以通过数据的forward来提高性能。 如果Store地址未计算出，Load指令不知道是否会发生Dependency怎么办？  In Order：顺序执行，待Store完成后再执行Load。 Wait for all previous store address：确定不发生Dependency再执行Load。 Go anyway：直接执行Load，当发现发生Dependency时，进行Reload，甚至是flush掉load后续的指令（后续指令有可能与load指令的目的寄存器相关）。 往往这种Go anyway的投机方式会使CPU性能提高。    Out of order load/store execution       红色数字代表指令执行顺序。 首先执行的是第一条指令“LDR R3, [R6]”，但是发生cache miss，需要向下一级访问存储，这个过程需要一些时间。 由于第二条指令“ADD R7, R3, R9”的R3依赖第一条指令的R3， 第三条指令的“STR R4, [R7]”的R7依赖第二条指令的R7，所以暂时不能执行。 越过第二条第三条指令，第四条指令“SUB R1, R1, R2”与前面指令没有依赖关系，可以执行。 第四条指令完成后，可以执行第五条指令“LDR R8, [R1]”。（注意这里的完成是指R1的写回结果已经计算完成，但由于前面指令未结束，是不可以写回体系结构寄存器的。） 接着，第一条指令已经load回结果，结束第一条指令。 第二条指令此时也可以执行，获得R7。 第三条指令此时也可以执行，将R4数据存入R7地址。 这里存在一个问题，第三条指令STR和第五条指令LDR是有可能存在依赖的（R1与R7相同），但是R7的结果需要一些时间才可以得知，但是第五条指令在未知是否依赖的前提下进行了前瞻执行，如果在获取R7后，判断是否形成依赖，如果形成依赖，需要reload，甚至flush掉后续其他指令。  In order load/store execution       红色数字代表指令执行顺序。 首先执行的是第一条指令“LDR R3, [R6]”，但是发生cache miss，需要向下一级访问存储，这个过程需要一些时间。 由于第二条指令“ADD R7, R3, R9”的R3依赖第一条指令的R3， 第三条指令的“STR R4, [R7]”的R7依赖第二条指令的R7，所以暂时不能执行。 越过第二条第三条指令，第四条指令“SUB R1, R1, R2”与前面指令没有依赖关系，可以执行。 第四条指令完成后，第五条指令“LDR R8, [R1]”，是访存指令，需要等待前面所有访存指令执行完成才可以执行。 接着，第一条指令已经load回结果，结束第一条指令。 第二条指令此时也可以执行，获得R7。 第三条指令此时也可以执行，将R4数据存入R7地址。 前面访存指令全部完成，可以执行第五条指令“LDR R8, [R1]”，不会发生依赖。  ARM cache管理 Locality原则（局部性）  空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的。 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息。   1 2 3 4 5  sum = 0; for (i=0; i\u0026lt;n; i++) sum = sum + a[i]; return sum;   以上述代码为例：\n data：数组a的元素（空间局部性）；每一次循环的sum值（时间局部性）。 instr：指令代码段顺序存放（空间局部性）；每一次循环相同操作（时间局部性）。  memory层级           cache lookup  cache的特点就是存储量小，访问速度快。 cache是主存的缩影，存储这主存的部分数据。 cahce的访问：  cache hit：访问的数据存在cache里。访问时间快。 cache miss：访问的数据不存在cache里，去更低一级的存储寻找，并将其缓存到cache。访问时间慢。    cache performance       cache性能衡量指标：AMAT(average memory access time)。 要想减小hit time，需要cache容量小，访问速度快。 要想减小miss rate，需要cache容量大，另外cache要足够smart，因为数据访问存在局部性，如何更好的利用局部性原则很关键，比如更优化的替换策略等。 访问主存的时间最长，往往也最不容易优化。 除此之外，多级cache，cache的相连结构，cacheline大小，访问主存带宽等众多因素，都会影响cache的性能。  cache size  L1 Cache直接参与运行程序的load/store指令：  16KB~64KB 如果最大容量，命中率可达90% 如果最小容量，访存时间可达1~3cycles    cache organisation  如何判断hit还是miss？  首先得到访问地址（物理地址）（地址高位做命中判断，低位做cache索引）。 根据访问地址，索引到cache entry。 将cache entry的tag部分与访问地址高位比较，相同则hit，不同则miss。          cache line/block：cache每个entry存放的数据量。  1Byte？显然不行，粒度太小，不足以满足访问指令的需求。 1KByte？显然不行，粒度太大，没有访问指令需要访问如此大的连续空间。 32~128Byte？合理大小。 cache容量一定的条件下，cache line越大，存放的entry量越小，miss率也就越高，所以cache line的大小需要合理。    cache Type  直接映射：  主存与缓存分成相同大小的数据块。 主存容量应是缓存容量的整数倍，将主存空间按缓存的容量分成区，主存中每一区的块数与缓存的总块数相等。 主存中某区的一块存入缓存时只能存入缓存中块号相同的位置。 优点：地址映象方式简单，数据访问时，只需检查区号是否相等即可，因而可以得到比较快的访问速度，硬件设备简单。 缺点：容易产生冲突，替换操作频繁，命中率比较低。          全相联（Fully Associative）：  主存与缓存分成相同大小的数据块。 主存的某一数据块可以装入缓存的任意一块空间中。 优点：命中率比较高，Cache存储空间利用率高。 缺点：每次访问都要与全部内容比较，速度低，成本高，因而应用少。          组相连：  主存和Cache都分组。 主存中一个组内的块数与Cache中的分组数相同。 组间采用直接映射，组内采用全相联映射。 适度兼顾二者的优点，尽量避免二者的缺点，因而得到普遍采用。         ARM Cache \u0026amp; Cache Policy  ARM Cache :  容量小，访问速度快。 存储最近访问的数据。 避免对外部BUS的访问，进而减小了带宽需求和功耗。          Cache Structure ：  Line：cache数据的存放单位量，一般是4Words或8Words。 Way：组相联映射中，每个数据块可以存放在cache的不同way中。 Set：同一个Index下的所有Way。 Tag：memory的地址标记，来自访问地址的高位，用来判断miss or hit。 Index：索引cache的Set号。 补充：可以将cache认为是二维数组（行x列），每个元素是一个cacheline，每一行是一个set，每一行有几个元素就是几Way。          Example：16KB 2-Way Cache ：        2-Way Set Associative Cache :        replacement Strategies  Random Round Robin Least Recently Used（LRU）          Read Allocation ：  执行Load指令，发现cache miss。 访问memory，将memory数据缓存到cache。注意：cache缓存数据是以cacheline为单位的，而此时load指令可能只取cacheline的一部分。 完成load指令，将load数据送至处理器。          Write Allocation ：  执行Store指令，发现cache miss。 访问memory，将memory数据缓存到cache。注意：cache缓存数据是以cacheline为单位的，而此时store指令可能只取cacheline的一部分。 完成store指令，将store数据写入cacheline，并标记为dirty。          Cache Write Strategy ：  Write Back：只是写到Cache里，Memory的内容要等到cache保存的要被别的数据替换或者系统做cache flush时，才会被更新。优点是CPU执行的效率提高，缺点是实现起来技术比较复杂。 Write Through：当写数据进Cache时，也同时更新了相应的Memory里的内容。优点是简单，缺点是每次都要访问memory，速度比较慢。    Further Understand Cache Type   直接映射与全相联映射      组相联映射    cache一致性 cache Coherency Problem  从软件角度，存储是共享的：假如两个core， CoreA writes x=15， CoreB read x, see 15 从硬件角度，每个core的cache是私有的：每个core都有一个L1 cache。       cache Coherency Definition  cache与cache之间数据可能不一致。 cache与memory之间数据可能不一致。 软件做法：将cache数据先放入memory，另外一个core将memory数据缓存至cache。 硬件做法：通过硬件的协议逻辑，保证数据一致性。       Evolution of ARM coherency support  unicore：单core不需要做数据一致性。 MPcore：多core之间维护数据一致性。 System Wide Coherency：系统级数据一致性需要保证cluster多core的一致性，和cluster与cluster之间数据一致性（总线互连）。       Cortex-A处理器的一致性  Cortex-A8处理器为单核处理器，不需要数据一致性的保证。 Cortex-A9及以后的处理器为多核处理器，需要硬件支持数据的一致性，不同cluster之间需要通过总线互连的方法保证数据一致性。    unicore、MPcore和System的一致性处理     在没有一致性机制的系统里（如Mali GPU），软件必须保证所访问的L1/L2数据是clean。 ACE-Lite接口允许没有cache的处理器去窥探其他处理器的cache，确保自己访问的数据是clean状态。    unicore、MPcore和System的一致性处理    MOESI Protocol  cache一致性的实现主要基于MESI或MOESI协议（这些state额外存储在L1 cache）：  Modified：cacheline is dirty and present in only one L1 cache Owned：cacheline is possibly in more than one L1 cache and is dirty Exclusive：cacheline is clean and present in only one L1 cache Shared：cacheline is clean and may be present in more than one L1 cache Invalid：cacheline is valid    Coherency logic  首先这个cluster里有4个core，每个core都有Dcache和Icache。 Dcache的TagRam会复制一份到Cache Coherency Logic。 当一个core访问某个地址空间，先从L1 Cache查找，如果miss，则在Cache Coherency Logic的其他core TagRam查找。 如果找到对应的地址空间，则去对应core的L1 Cache拿到数据。    unicore、MPcore和System的一致性处理    Coherency logic举例  如下图，core0和core分别执行各自的指令。 起始core0和core1的cache以及core外(cluster)的Dup_TAG_RAM，都处于invalid状态。 label是一个cacheline对齐的访存地址，core0执行“LDR X1, [X0, #0x4]”指令，发生cache miss，此时将L2或主存中的相应cacheline缓存至core0 cache，并置为Exclusive状态，因为只有core0 cache存在此cacheline，并且与L2或主存数据一致。 core0相应cacheline的Dup_TAG_RAM同步为valid。        如下图，展示了上一步的执行结果，core0处于Exclusive状态，core1处于Invalid状态。 core1的cache以及core外(cluster)的Dup_TAG_RAM，都处于invalid状态。 此时执行core1的“LDR X1, [X0, #0xc]”指令，发生cache miss，此时查找Dup_TAG_RAM，发现core0内存在该cacheline，将core0内该cacheline缓存至core1 cache，并置为Share状态，因为core0 cache和core1 cache都存在此cacheline，并且与L2或主存数据一致。 core1相应cacheline的Dup_TAG_RAM同步为valid。        如下图，展示了上一步的执行结果，此时core0和core1都保持Share状态。 此时core0将load回来的数据0x7加1后，写回原地址，也就是“STR X1, [X0, #0x4]”指令。 core0 cache中的该cacheline数据进行了更新，并更改为Modify状态，因为此时core0 cache数据是最新的。 core1 cache中相应的cacheline数据已经与最新的数据不同，所以置为invalid，同时Dup_TAG_RAM也同步为invalid。        如下图，展示了上一步的执行结果，core0处于Modify状态，core1处于Invalid状态。 此时core1将load回来的数据0x0加3后，写回原地址，也就是“STR X1, [X0, #0xc]”指令。 core1 cache中的该cacheline数据进行了更新，并更改为Modify状态，因为此时core1 cache数据是最新的，同时Dup_TAG_RAM也同步为Valid。 除此之外，还会将core0中该cacheline的数据更新到core1。 core0 cache中相应的cacheline数据已经与最新的数据不同，所以置为invalid，同时Dup_TAG_RAM也同步为invalid。        如下图，展示了上一步的执行结果，core0处于Invalid状态，core1处于Modify状态。 此时core1执行“DC CVAC, X0”指令，clean cacheline，也就是将cacheline更新到L2/主存。        如下图，展示了上一步的执行结果，core0处于Invalid状态，core1处于Exclusive状态，因为此时core1 cache中该cacheline与L2/主存数据一致，且只有core1 cache存在该cacheline。       Multi-cluster coherency  以上讲的是cluster内core与core之间的cache一致性，那么cluster与cluster之间是如何保存cache一致性呢？请看下图。 以下是Big.little结构，大核是A15，小核是A7，A15与A7内都有4个core。 cluster与cluster之间保持cache一致性，是通过总线来实现的。首先每个cluster内存在一个ACE接口，会互相窥探（snoop）对方cache的数据，如果对方cache不存在所访问的数据，则从下一级存储去取，如果对方cache存在所访问的数据，则从对方cache去获取。 目的就是减少主存（DDR）的访问，一是减少访存时间，二是减少BUS访问阻塞，三是减少Memory controler的访问请求，四是减少功耗。       AMBA Protocol发展   AMBA总线协议的发展     多core要保证cache一致性，所以添加了ACE协议。 CHI相比ACE要复杂很多，这些都是保证cache一致性的重要协议。  CCI \u0026amp; CCN  CCI只支持ACE cluster。    CCI(Cache Coherency Interconnection)      CCN(Cache Coherency Network)    Cluster Coherency举例  Read ：  3个Master，也就是3个cluster。这里的Master概念是对CCI而言的。\n     Master0发送一个read请求。\n     Cache Coherent Interconnection窥探Master1和Master2，看Master1和Master2有没有Master0访问的数据。\n     如果Master2存在Master0访问的数据，则通过CCI将Master2的数据返回给Master0。\n     如果Master1和Master2都不存在Master0访问的数据，只能通过CCI访问BUS Slave，发出BUS请求，从主存（DDR）中取数据。\n      Write ：  3个Master，也就是3个cluster。这里的Master概念是对CCI而言的。\n     Master0发送一个write请求。\n     Cache Coherent Interconnection窥探Master1和Master2。\n     写操作导致Master1和Master2与Master0数据不同，这时要将Master1和Master2对应的数据置为Invalid，之后要返回Response给CCI。\n     CCI接收Master1和Master2的Response后，返回Response给Master0。\n     Master接收CCI的Response，确保Master1和Master2已经完成相应操作，才将数据写入cache。\n     ARM处理器的容错机制 Fault Tolerance介绍  设计的系统，我们希望能够按照自己期望的逻辑去工作，但是系统工作时可能由于某些原因导致不稳定。  物理环境：X射线、高温\u0026hellip; 系统环境：存在未知的bug\u0026hellip;    Faults、Error、Failure   Fault：Deviate(偏离) from specific behavior\n 例如 5+3=7 这种Fault又被称为Latent Error（潜在的错误） 意思是逻辑中存在Fault，但是不执行不会导致系统Error。    Error：Actual behavior within system differ from specific behavior\n 触发后的Fault，真正的error。 例如 add指令执行5+3，得到结果7，并写回的寄存器。    Failure：System deviates from specific behavior\n 系统行为发生错误。 例如 预定一个会议，计划是8点钟，由于执行了5+3指令，导致时间变为了7点钟。    以上Fault、Error、Failure依次递增的：\n Fault不一定导致Error，显然只要不执行就可以； Error不一定导致Failure，比如系统执行“5+3 \u0026gt;0”，显然即使5+3=7,，但不影响系统的结果。    Reliability and Availability   System states（系统状态）：\n Service Accomplishment（系统正常的工作状态） Service Interruption（系统中断状态）    Reliability（可靠性）：Continuity of correct service（系统正确运行的连续性），也就是Service Accomplishment状态。\n  Availability（可用性）：Readiness for correct service（系统正确运行的准备时间），也就是Service Interruption状态。\n  Availability实际是一个比例，比如Service Accomplishment状态保持90小时，Service Interruption状态保持10小时，那么Availability是90%。\n  Fault类型   By Causes:\n Design faults(Sortware/Hardware bugs) Operation faults(User wrong operation) Environment faults(Fire, X-ray)    BY duration（持续时间）:\n Permanent（永久性）：Hardware broken Intermittent（间歇性）：Last for while but recurring    Faults容错技术   2-way Redundancy（冗余）：\n Two modules do the same work, then compare Error detection(检测)    3-way Redundancy（冗余）：\n Three modules(or more) do the same work, then vote(投票) Expsensive, but can detect and correct 1 module error    以上只是通用的解决方法，对于正确性要求比较严格或在特殊环境下运行的系统，可采用3-way方法，但是对于存储数据来说，采用2-way或3-way的代价很大，所以对于memory的容错技术，提供了新的方法。\n  Parity：\n A Parity bit is generate within a specific granule Error detection 也就是常说的奇偶校验。          ECC：  ECC bits are generate from a chunk of data SECDED(Single error correct double error detect) 由于奇偶校验只能检查错误，而ecc可以纠正单比特错误，检查双比特错误，所以在memory的容错技术中应用最广。         Cache ECC   ECC(Error Checking and Correction)。\n  ECC由最简单的奇偶校验演变而来，先来介绍奇偶校验。\n  奇偶校验 ：\n  优点：结构简单，只需异或计算就可以实现，数据量小时（8比特）实现代价小。\n缺点：不能修正错误，只知道8比特中有部分比特发生错误，无法判断哪几个比特发送错误；有偶数个比特位时，无法判断出错；数据位宽较大时实现代价大：如1024比特数据，需要256bit的校验位。\n实现：每8bit数据增加一位Parity，作为校验位，将这8bit异或相加，假设结果为5，如果是奇校验（数据和校验位一共奇数个1），那么Parity为0（因为0+5为奇数），如果为偶校验（数据和校验位一共偶数个1），那么Parity为1（因为1+5为偶数）。当发生1bit错误时，可以根据Parity检查出数据错误。\n ECC校验 ：  优点：大量数据位实现代价低：8比特数据需要5个校验位，256字节（256*8比特）的数据值需要5个列校验位和11行校验位；能够纠正错误：在内存中ECC能够容许错误，并可以将错误更正，使系统得以持续正常的操作，不致因错误而中断\n缺点：当数据只有单比特错误时，ECC能够进行错误修复；超过2比特的数据错误，将无法修复，ECC只能输出多比特错误信号；不保证能检测超过2比特的错误。\n实现：待补充\nSynchronization Synchronization示例  线程A和线程B都在对count进行操作，而且两个线程可能由不同的core执行。 不同的core去执行，从时间上来看，指令间相互穿插执行，同时对count进行操作，导致结果无法确定，这时候就需要同步的处理。    C程序      汇编程序    示例分析   执行顺序1      执行顺序2     线程间出现竞争：  两个线程对共享资源进行操作。 程序的执行结果取决于程序指令的执行顺序。   为了避免竞争的发生，应该在竞争相关的线程间做同步，也就是先执行线程A程序段，再执行线程B程序段，或者相反。  原子访问必要性  上文提到的线程间竞争，主要是因为read-modify-write程序段，而这样的程序段是经常出现的。 这样的read-modify-write程序段，使用共享数据时，这几条指令必须是原子指令，也就是这几条指令像一个原子一样是一个整体，必须顺序完成，中间不可穿插其他指令。        Critical Sections（关键代码段）：  访问share资源的关键代码段 为了保证Critical Sections的执行，需要进行上锁，只要当拿到钥匙后，才可以执行。 上锁方法：Mutex、Semaphore、Flag、Lock\u0026hellip;         同步锁   什么是锁？\n 是一个存放在memory中的lock值。 lock值一般使用一个整数，0/1/2\u0026hellip; 只要程序间能达成握手协议即可。    怎么获取lock？\n 先初始化lock为0，也就是未上锁状态。 Critical Sections程序中去检查是否已上锁，如果已上锁状态则等待，如果未上锁状态则可以执行。 执行的第一步是要上锁，也就是将lock设置为1。 执行完所有程序后，需要解锁，也就是将lock设置为0。          这样线程A和线程B都有检查是否已上锁的逻辑，是否能保证指令能够正确执行呢？换句话说，上锁的逻辑线程间有没有可能存在竞争？答案是存在。  实现锁的指令   ARM架构里，使用Load Exclusive指令代替上文查锁和上锁指令的LDR：\n LDXR(A64) LDREX(A32 and T32)    ARM架构里，使用Store Exclusive指令代替上文查锁和上锁指令的STR：\n STXR(A64) STREX(A32 and T32)    Exclusive指令的作用是什么？后文介绍。\n  Exclusive Monitor  要想实现Load/Store Exclusive操作，需要硬件Exclusive Monitor的支持。 Exclusive Monitor的作用就是监测Lock地址。 每个CPU core内都会有一个local monitor，监测其他core的访问地址，如果某线程使用的lock，local monitor会记录lock地址，其他线程再访问该地址时，是无法访问的。 每一个cluster都会有一个Global Monitor，其功能与local monitorx相似，监测其他cluster的访问地址。 如果core0访问lock地址，且存储属性为non-sharable，那么core0不会与其他core共享lock数据，只需要查看local monitor，不需要查看global monitor。       monitor工作原理 LDREX Rx, [Ry] STREX Rx, Ry, [Rz]  Open状态：其他线程可访问 Exclusive状态：其他线程不可访问 LDREX用来读取内存中的值，并标记对该段内存的独占访问。 如果执行LDREX指令时，Ry指向内存区域为非独占访问（OPEN），将Ry指向内存数据保存到Rx寄存器中，同时标记对Ry指向内存区域的独占访问。 如果执行LDREX指令时，Ry指向内存区域为独占访问，不影响指令功能。 STREX在更新内存数值时，会检查该段内存是否已经被标记为独占访问，并以此来决定是否更新内存中的值。 如果执行STREX指令的时候发现已经被标记为独占访问了，则将寄存器Ry中的值更新到寄存器Rz指向的内存，并将寄存器Rx设置成0。指令执行成功后，会将独占访问标记位清除。 如果执行STREX指令的时候发现没有设置独占标记，则不会更新内存，且将寄存器Rx的值设置成1，STREX Fail。    状态转移图     举例说明：假设系统中有两个处理器内核，而一个程序由三个线程组成，其中两个线程被分配到了第一个处理器上，另外一个线程被分配到了第二个处理器上。且他们的执行序列如下：        CPU2上的线程3最早执行LDREX，锁定某段共享内存区域。它会相应更新本地监视器和全局监视器。 然后，CPU1上的线程1执行LDREX，它也会更新本地监视器和全局监视器。这时在全局监视器上，CPU1和CPU2都对该段内存做了独占标记。 接着，CPU1上的线程2执行LDREX指令，它会发现本处理器的本地监视器对该段内存有了独占标记，同时全局监视器上CPU1也对该段内存做了独占标记，但这并不会影响这条指令的操作。 再下来，CPU1上的线程1最先执行了STREX指令，尝试更新该段内存的值。它会发现本地监视器对该段内存是有独占标记的，而全局监视器上CPU1也有该段内存的独占标记，则更新内存值成功。同时，清除本地监视器对该段内存的独占标记，还有全局监视器所有处理器对该段内存的独占标记。 下面，CPU2上的线程3执行STREX指令，也想更新该段内存值。它会发现本地监视器拥有对该段内存的独占标记，但是在全局监视器上CPU1没有了该段内存的独占标记（前面一步清空了），则更新不成功。 最后，CPU1上的线程2执行STREX指令，试着更新该段内存值。它会发现本地监视器已经没有了对该段内存的独占标记（第4步清除了），则直接更新失败，不需要再查全局监视器了。 所以，可以看出来，这套机制的精髓就是，无论有多少个处理器，有多少个地方会申请对同一个内存段进行操作，保证只有最早的更新可以成功，这之后的更新都会失败。失败了就证明对该段内存有访问冲突了。实际的使用中，可以重新用LDREX读取该段内存中保存的最新值，再处理一次，再尝试保存，直到成功为止。  同步过程  LDXR指令，独占访问，将lock值读取到w1。 比较是否为已上锁状态，如果已上锁，则循环读取lock，如果未上锁，则向下执行。 STXR指令，独占访问，进行上锁操作，也就是将已上锁状态值写入lock指向的地址。 STXR指令执行不一定成功，因为可能有其他线程已经先执行STXR指令。 判断STXR指令是否执行成功，若未成功，则重新执行查锁操作。 只有STXR指令执行成功，才是真正拿到锁，拥有执行权限。        待拿到执行权限后，开始执行程序段，程序段执行完成后，需要解锁。 解锁操作很简单，就是项lock指向的地址写未上锁状态值。       总线原子访问  原子访问（Atomic access）。        Lock访问（AXI3 only）：如果一个Master lock访问slave，那么其他Master则无法访问slave。这样会对系统性能造成一定影响。  早些的ARM处理，如ARM7，由SWP指令实现lock访问。 Coretex-M3/M4（采用AHB协议，非AXI）通过bit-banding操作实现lock访问。          在AXI4中只有Exclusive访问，取消了lock访问，对于Exclusive访问，其他Master仍可以访问Slave，不会影响性能。  总线Exclusive访问机制  0x1代表未上锁，0x3代表已上锁。 Master0去读0xA000地址，数据为0x1（未上锁），返回EXOKAY，将0xA000地址置为Exclusive。        Master1也去读0xA000地址，数据为0x1（未上锁），返回EXOKAY，0xA000地址仍保持Exclusive。        Master0去写0xA000地址，写数据为0x3（上锁），返回EXOKAY，上锁成功，0xA000地址置为OPEN状态。        Master1也去写0xA000地址，写数据为0x3（上锁），返回OKAY，上锁失败，0xA000地址保持OPEN状态。       多核并行处理 Multi-Processing 介绍  How many instruction stream（同时可以执行多少指令）？ How many data stream（同时可以运算多少数据）？       ARM NEON指令  NEON指令是一种Advanced SIMD指令的扩展。 操作数寄存器被视为包含多个元素的向量。 在多个lane上同时执行操作。 NEON多用于图像处理等循环运算较多的运算场景。       NEON和SIMD的优势      SIMD和NEON指令比较      AMP（Asymmetric Multi-Processing）   每个CPU可能运行不同的程序：\n 可能会看到不同的内存映射。 可能有自己的一组中断。    通过共享内存进行数据交换：\n 必须对CPU L1 cache进行一致性管理         SMP（Symmetric Multi-Processing）      multi-Processing问题  两个CPU都执行load指令：        两个CPU都执行store指令：        一个CPU执行store指令，另一个执行load指令：       多处理器同步  多个core之间通过握手协议，CPU1必须等CPU2完成store指令后才能去load。 如果两个store发生冲突，也需要通过握手协议，确保指令执行顺序与期望相同。       Cluster处理器  cluster翻译成中文为簇。 每个cluster可以包含1~4个core。 每个core都有自己私有的资源，比如L1 cache，cluster内包含的多个core共享的资源，比如L2 cache。       为什么需要big.LITTLE？  以前的结构里，一个cluster内4个core，4个core是同频的。 在手机的应用场景中，比如看电影、打游戏等，对性能要求较高，可能4个core在全速运行，而有些场景如收发邮件、听音乐等，对性能要求不高，4个core不需要全速运行，甚至可以在低频下工作，这样可以节省功耗。 从应用场景来分析，也就是分为两类，一是对性能要求高，二是对功耗要求高。 大小核的设计，就是根据不同应用场景，来选择选用高性能核运行还是低功耗核运行。       big.LITTLE处理器？  以Coretex-A7和Coretex-A15为例：首先大小核必须都属于同一个架构，这里A7和A15都属于ARM-v7架构。 Coretex-A7：属于低功耗核。  8~11 stages, In-Order and limited dual-issue   Coretex-A7：属于高性能核。  15+ stages, Out-of-Order and multi-issue, register rename 在一般应用程序中，性能比Cortex-A9平均高40~60%         big.Little架构  一般的cluster架构：  OS运行在一个cluster的CPU。 cluster内有snoop control unit，来维护L1 cache的数据一致性。 cluster内有中断控制器，将中断信息分配给对应的cpu。          big.LITTLE架构：  两个cluster，cluster内的cache数据一致性维护不变。 OS运行在两个cluster中的CPU。 两个cluster共享一个中断控制器，将中断信息分配给对应的cluster，cluster再分配给对应的cpu。 cluster间的数据一致性，通过CCI(Cache Coherent Interconnect)来维护。         DynamIQ架构  big.LITTLE结构中，有一个big cluster和一个little cluster，然后cluster之间通过CCI维护cache的数据一致性，这样通过BUS connection和访问内存来实现cluster间的交互，效率比较低。 在DynamIQ结构中，将big cluster和little cluster放在一起，通过Shared Memory（L3 cache）来完成cluster之间的交互，减少cluster对外部memory访问，从而提高性能，并且降低功耗。        举例：Kirin 980  Kirin 970采用传统的big.LITTLE，Kirin 980采用DynamIQ big.LITTLE。 性能提高75%，效能提高58%。 两个Big core，A76 2.6G 两个Middle core， A76 1.92G 四个Little core， A55 1.8G 可见DynamIQ架构中，支持不同频率的core。         DSU（DynamIQ Shared Unit）      ARM多核系统和互联 多核挑战  core的数量增加，on-chip（内部存储cache）的挑战。  更多的read和write bus请求，导致总线堵塞，需要提高bus的带宽（频率或数据宽度）。 更多的write shared location，为了维护cache数据一致性，会将其他core的cacheline invalid，这样会增加cache miss率。   core的数量增加，off-chip（外部存储DDR）的挑战。  更多的on-chip cache 更多的访问主存请求（功耗和访问时间）    Shared Bus（Shared结构）  早期的bus结构。 比较简单的核间通信方式，内核挂在通信总线上，实现简单。 没两个核通信都需要占用总线，导致其他的核不能通信，通信效率极低。       Cross Bar（交叉结构）  通信效率较高，每个core两两相连。 核太多，需要消耗大量的互联资源，通常用于四个核的处理器。 连线异常复杂，对后端布局布线有较大影响，频率难以提高。       Ring（环形结构）  越近的两个core通信效率越高，通信连线并不复杂，实现成本低。 解决了绕线阻塞。       Mesh（网络结构）  适用于core数非常多的情况。 结构简单，易于扩展，通信效率高。       ARM NIC IP  NIC（Network Interconnect）  不支持cache一致性（AXI/AHB/APB） Crossbar结构 适用于单cluster结构         ARM CCI IP  CCI（Cache Coherent Inteconnect）  AMBA 4 ACE-based Crossbar interconnect IPs core内支持ACE接口，可通过ACE协议维护cache一致性。         ARM CCN IP  CCN（Cache Coherent Network）  AMBA 5 CHI-base ring-bus interconnect IPs CCN-502/504/508/512\u0026hellip;   Crosspoints(XP)  Has four ports, connected to processor, IO master, DRAM, peripherals         ARM CMN IP  CMN(coherent Mesh Network) for high-end networking and enterprise applications Crosspoints(XP)  Has six ports, connected to processor, IO master, DRAM, peripherals\u0026hellip;         文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":8,"section":"docs","tags":["CPU"],"title":"ARM处理器基础介绍","uri":"https://www.wenhui.space/docs/08-ic-design/cpu/arm-cpu-introduction/"},{"content":"本文 主要介绍一款画图软件（亿图图示），以及安装和使用。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  参考  亿图官网 亿图图示使用手册 亿图图示基本操作  亿图图示介绍 亿图软件可以绘制流程图、网络拓扑图、平面布置图、组织结构图、工程图等图形。绘制出的图相比其他同类型软件更为美观，主要原因是亿图软件有上千个绘图模板，图标符号也齐全。另外，软件支持Windows、Linux、Mac平台操作，并有免费亿图云可以使用，实现跨平台云存储、云共享功能。\n绘制完成的作品，可以被亿图图示软件导出为多种格式。比如可以导出为如word、PPT和Excel等办公软件格式外，还可以导出为图片格式jpg、png、gif、bmp，甚至是pdf、Visio、svg和HTML等格式。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":9,"section":"docs","tags":["EdrawMax"],"title":"亿图图示的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_edrawmax/"},{"content":"本文 主要介绍Booth算法与Wallace树结构，并根据其原理实现16x16乘法器，可以实现优化传统乘法器结构，增强并行性提高运算速度。\n   版本 说明     0.1 初版发布    参考  百度百科-Booth算法  背景 在DSP和CPU等各类芯片中，乘法器是必不可少的运算单元，由于乘法操作逻辑复杂，乘法器往往处于关键延时路径上，对系统运行速度影响很大，所以优化乘法器是很有必要的。为了优化乘法器，工程师们提出了很多高效的设计思想，BOOTH算法与wallace树最为典型，BOOTH算法可以减少部分乘积项，wallace树可以提高部分乘积相加的并行性。\nBOOTH算法 介绍 传统的串行乘法使用的是移位相加的办法，这种方法虽然易于理解与实现，但是速度较慢，并且不能直接对补码进行处理，所以需要额外的符号处理逻辑，最终也就是需要三步：\n 乘数符号处理：补码转原码 移位相加 乘级积符号处理：补码转原码  以上运算过程显然比较复杂，组合链延时比较长。解决此问题可以使用BOOTH算法，BOOTH算法有两个特点，一是可以实现补码相乘，二是可以减少乘积项。\n原理 补码加法运算原理 要想理解BOOTH算法为什么支持补码乘法，首先要理解补码是如何直接进行加法运算的，那就是对和进行了取模。假设现在标准时间为4点整，而有一只表已经到7点了，为了校准时间，可以采用两种方法：一种是将逆时针退(7-3=4)3格；二是顺时针进(7+9-12=4)9格。所以y=a-b可以表示为y=a+(m-b)，这里m为模长，(m-b)也就是补码形式。举例说明，因为\u0026rsquo;b1_0000-\u0026lsquo;b10='b1110，这里对16取模，就可以表示为-2，所以\u0026rsquo;b0111(7)+'b1110(-2)='b1_0101，对16取模后，结果为\u0026rsquo;b0101(5)。\n表达式变换1 补码形式a[n-1:0]，其中a[n-1]为符号位，表达式的变换如下：\na[n-1:0] = -a[n-1]*2^(n-1) + a[n-2]*2^(n-2) + a[n-3]*2^(n-3) + \u0026hellip; + a[1]*2^1 + a[0]*2^0\na[n-1:0] = (-a[n-1]+a[n-2])*2^(n-1) + (-a[n-2]+a[n-3])*2^(n-2) + \u0026hellip; + (-a[1]+a[0])*2^1 + (-a[0]+0)*2^0\n举例说明： \u0026lsquo;b1110(-2) = (-1+1)*2^3 + (-1+1)*2^2 + (-1+0)*2^1 + (-0+0)*2^0\n所以 \u0026lsquo;b0111(7) * \u0026lsquo;b1110(-2) 有四个乘积项相加:\n   a[n-1] a[n-2] 乘积项     a[0]=0 a[-1]=0 \u0026lsquo;b0000_0000   a[1]=1 a[0]=0 \u0026lsquo;b1111_0010(-7*2)   a[2]=1 a[1]=1 \u0026lsquo;b0000_0000   a[3]=1 a[2]=1 \u0026lsquo;b0000_0000    由此可判断，基于2位Booth编码的算法，可以直接运算补码形式，但是并没有减少乘积项。\n表达式变换2 补码形式a[n-1:0]，其中a[n-1]为符号位，表达式的变换如下：\na[n-1:0] = -a[n-1]*2^(n-1) + a[n-2]*2^(n-2) + a[n-3]*2^(n-3) + \u0026hellip; + a[1]*2^1 + a[0]*2^0\na[n-1:0] = (-2a[n-1]+a[n-2]+a[n-3])*2^(n-2) + (-2a[n-3]+a[n-4]+a[n-5])*2^(n-4) + \u0026hellip; + (-2a[1]+a[0]+0)*2^0\n举例说明： \u0026lsquo;b1110(-2) = (-2*1+1+1)*2^2 + (-2*1+0+0)*2^0\n所以 \u0026lsquo;b0111(7) * \u0026lsquo;b1110(-2) 有两个乘积项相加:\n   a[n-1] a[n-2] a[n-3] 乘积项     a[1]=1 a[0]=0 a[-1]=0 \u0026lsquo;b1111_0010(-7*2)   a[3]=1 a[2]=1 a[1]=1 \u0026lsquo;b0000_0000    由此可判断，基于3位Booth编码的算法，可以直接运算补码形式，同时可以将乘积项减少一半。\n总结 Booth编码可以使补码直接参与运算，3位Booth编码可以将部分积的个数减少1/2，4位或更多位的Booth编码可以使部分积的个数减少得更多，但是，更多位的Booth编码中，虽然部分积的个数减少了，但是部分积产生电路变复杂了，部分积的产生需要的时间增加了，在一定程度上抵消了部分积的减少带来的好处。综上，使用最多的是基于3位或4位BOOTH编码。\n逻辑实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  reg [3:0] data1; reg [3:0] data2; reg [7:0] data1p; reg [7:0] data1p_n; reg [7:0] p0; reg [7:0] p1; reg [7:0] p; assign data1p = {4{data1[3]},data1[3:0}; assign data1p_n = ~data1p +1; always@* case({data[1:0],1\u0026#39;b0}) 3\u0026#39;b000, 3\u0026#39;b111: p0 = 8\u0026#39;b00000000; 3\u0026#39;b001, 3\u0026#39;b010: p0 = data1p; 3\u0026#39;b011 : p0 = {data1p[6:0],1\u0026#39;b0}; 3\u0026#39;b100 : p0 = {data1p_n[6:0],1\u0026#39;b0}; 3\u0026#39;b101, 3\u0026#39;b110: p0 = data1p_n; endcase always@* case(data[3:1]) 3\u0026#39;b000, 3\u0026#39;b111: p1 = 8\u0026#39;b00000000; 3\u0026#39;b001, 3\u0026#39;b010: p1 = {data1p[5:0],2\u0026#39;b00}; 3\u0026#39;b011 : p1 = {data1p[4:0],3\u0026#39;b000}; 3\u0026#39;b100 : p1 = {data1p_n[4:0],3\u0026#39;b000}; 3\u0026#39;b101, 3\u0026#39;b110: p1 = {data1p_n[5:0],2\u0026#39;b00}; endcase assign p = p0 + p1;   Wallace树 介绍 Wallace在1964年提出采用树形结构减少多个数累加次数的方法，成为wallace树结构加法器。wallance树充分利用全加器3-2压缩的特性，随时将可利用的所有输入和中间结果及时并行计算,大大节省了计算延时。\n原理 Wallace树的原理简单说就是使用全加器把3个n位的数相加转换成2个n+1位的数相加，以此类推，可以用多个全加器把多个数规约成2个数相加，最后用加法器把这两个最终的数相加得到乘积。\n什么是全加器3-2压缩的特性？全加器输入cin、a、b，输出为cout，sum，这就是3-2压缩的特性。举个例子：\na+b+c=a^b^c + (a\u0026amp;b|a\u0026amp;c|b\u0026amp;c)\u0026lt;\u0026lt;1 由此可见，通过Wallace树可以并行处理减少加数项，比如8个加数项：\n   级数 加数个数 结构     1 8-\u0026gt;6 (3,3,2)-\u0026gt;(2,2,2)   2 6-\u0026gt;4 (3,3)-\u0026gt;(2,2)   3 4-\u0026gt;3 (3,1)-\u0026gt;(2,1)   4 3-\u0026gt;2 (3)-\u0026gt;2   5 2-\u0026gt;1 加法器实现两数相加    读到这里可能你会有疑问，直接使用加法器三级就可以实现啊，也就是8-\u0026gt;4-\u0026gt;2-\u0026gt;1，岂不是运算更快？这里需要注意了，这样计算每一级逻辑是多位加法器延时，而采用Wallace树结构每一级逻辑相当于1位全加器延时。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":10,"section":"docs","tags":null,"title":"Booth算法与Wallace树","uri":"https://www.wenhui.space/docs/08-ic-design/typical/booth-and-wallace/"},{"content":"本文 主要介绍计算机中浮点的表示和运算方法。\n   版本 说明     0.1 初版发布    背景 处理器有一个很重要的运算单元就是浮点运算，也是处理器性能很关键的一个指标。在对处理器浮点运算单元进行设计和验证之前，必须掌握浮点的表示和运算方法。\n重要概念   规格化: 为了保证浮点数的精度，需要在计算过程与计算结果让浮点数保持规格化。判断规格化数的方法是检测阶码是否全为0。如果不是规格化数，就要通过增加阶码右移尾数或者减少阶码左移尾数的办法使其变成规格化数。这个过程叫做规格化。\n  扩充位: 在运算过程中为了计算方便，会对阶码以及尾数进行扩充。增加了扩充位后，可以判断并防止溢出，并且能显示出隐藏的前导位，还能有助于近似判断。\n  浮点数的溢出: 上溢: 当浮点数阶码超过了最大阶码时，此时不再运算，进行中断处理; 下溢: 当浮点数小于最小阶码，此时溢出的值很小，处理方式是把尾数置为零，处理器继续运行。\n  浮点数近似模型: 由于计算机计算的结果精度不可能是无穷大的，所以需要采用某种近似模型。根据IEEE－754标准有4种近似模型。分别是: 靠近最近的偶数、靠近 0( 将超出范围的数据直接切除) 、靠近无穷大方向、靠近无穷小方向。\n  浮点表示方法 浮点数由三部分组成：符号位、阶码、尾数。\n   参数 半精度 单精度 双精度     浮点数字长 16bit 32bit 64bit   尾数长度M 10bit 23bit 52bit   符号位S 1bit 1bit 1bit   指数长度 5bit 8bit 11bit   最大指数 +15 +127 +1023   最小指数 -14 -126 -1022   指数偏移量bias +15 +127 +1023    浮点数的表示方法是 x=(-1)^s * (1.M) * 2^(E-bias)。\nS是符号位，M是尾数，E是阶码，当阶码E全为0或全为1时，表示该浮点数不是规格化数，可以表示为无穷大、NaN（非数值）。\nIEEE规定根据指数和尾数可以表示如下几种特殊值：\n 零值：阶码全部为0，尾数全部为0，表示0.0，并且+0.0==-0.0 非规格化值：阶码全部为0，尾数非0，表示非规格化值，也就是(-1)^s * (0.m) * 2^(-bias) 规格化值：阶码非0非1，尾数任意，表示规格化值，也就是(-1)^s * (1.m) * 2^(E-bias) 无穷值：阶码全部为1，尾数全部为0，则根据符号位分别表示正无穷大和负无穷大 NaN：阶码全部为1，尾数非0，则表示这个值不是一个真正的值（Not A Number）。NAN又分成两类：QNAN（Quiet NAN）和SNAN（Singaling NAN）。QNAN与SNAN的不同之处在于，QNAN的尾数部分最高位定义为1，SNAN最高位定义为0；QNAN一般表示未定义的算术运算结果，最常见的莫过于除0运算；SNAN一般被用于标记未初始化的值，以此来捕获异常。  浮点运算 对阶 所谓对阶是指将两个进行运算的浮点数的阶码对齐的操作。对阶的目的是为使两个浮点数的尾数能够进行加减运算。几点需要注意：\n 对阶的原则是小阶对大阶，之所以这样做是因为若大阶对小阶，则尾数的数值部分的高位需移出，而小阶对大阶移出的是尾数的数值部分的低位，这样损失的精度更小。 若阶差＝0，说明两浮点数的阶码已经相同，无需再做对阶操作了。 采用补码表示的尾数右移时，符号位保持不变。 由于尾数右移时是将最低位移出，会损失一定的精度，为减少误差，可先保留若干移出的位，供以后舍入处理用。  尾数运算 尾数运算就是进行完成对阶后的尾数相加减。这里采用的就是纯小数的定点数加减运算。\n结果规格化 为保证浮点数表示的唯一性，浮点数在机器中都是以规格化形式存储的。对于IEEE754标准的浮点数来说，就是尾数必须是1.M的形式。由于在进行上述两个定点小数的尾数相加减运算后，尾数有可能是非规格化形式，为此必须进行规格化操作。\n规格化操作包括左规和右规两种情况。\n 左规操作：将尾数左移，同时阶码减值，直至尾数成为1.M的形式。 右规操作：将尾数右移1位，同时阶码增1，便成为规格化的形式了。  舍入处理 浮点运算在对阶或右规时，尾数需要右移，被右移出去的位会被丢掉，从而造成运算结果精度的损失。为了减少这种精度损失，可以将一定位数的移出位先保留起来，称为保护位，在规格化后用于舍入处理。\nIEEE754标准列出了四种可选的舍入处理方法：\n 就近舍入：这是标准列出的默认舍入方式，其含义相当于我们日常所说的“四舍五入”。 向正无穷舍入：对正数来说，只要多余位不为全0，则向尾数最低有效位进1；对负数来说，则是简单地舍去。 向负无穷舍入：对正数来说，只是简单地舍去；对负数来说，只要多余位不为全0，则向尾数最低有效位进1。 向0舍入：即简单地截断舍去，而不管多余位是什么值。这种方法实现简单，但容易形成累积误差，且舍入处理后的值总是向下偏差。  溢出判断 与定点数运算不同的是，浮点数的溢出是以其运算结果的阶码的值是否产生溢出来判断的。若阶码的值超过了阶码所能表示的最大正数，则为上溢，进一步，若此时浮点数为正数，则为正上溢，若浮点数为负数，则为负上溢；若阶码的值超过了阶码所能表示的最小负数，则为下溢，进一步，若此时浮点数为正数，则为正下溢，若浮点数为负数，则为负下溢。正下溢和负下溢都作为0处理。\n浮点舍入 就近舍入 就近舍入可以理解为常说的四舍五入，但是有一点需要注意，浮点中是向偶数舍入的，下面就来解释为什么如此？\n传统的四舍五入对于0.5这种中间值并不合理。比如0.5，1.5，2.5，3.5都向上入是1，2，3，4，平均值2.5，比原数均值2高了0.5；向下舍同理。如果是向偶数舍入，则变成0，2，2，4，均值刚好与原均值同。很多带0.5的数，不能全都向上入或全都向下舍，这样会导致整体误差走向极端。如果有一部分向上入，有一部分向下舍，可消除部分统计误差。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":11,"section":"docs","tags":null,"title":"浮点数的表示和运算","uri":"https://www.wenhui.space/docs/10-polular-science/floating-point/"},{"content":"本文 主要记录自己生活中的一些所思所想和平日阅读中好文的摘录。\n   版本 说明     0.1 初版发布    名人语录 王世襄 一个人要想取得点成就，至少具备三个条件：\n 有一些能力去做一点事 坚持去做与等待时机 活得长  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":12,"section":"docs","tags":["读书"],"title":"随笔与摘录","uri":"https://www.wenhui.space/docs/03-life/essays_and_excerpts/"},{"content":"本文 主要对工作中遇到关于sv和uvm的问题，在此记录。\n   版本 说明     0.1 初版发布    记录 pkg不能添加interface pkg是软件域，只能添加class，而interface属于硬件域与软件域的衔接，不属于软件域。有些工程师习惯将自己的验证环境打包成pkg来管理，所以才引入了这个问题。我习惯使用单独的一个文件来汇总验证环境的所有文件，方式是include，最后在tb中include这个汇总文件。这样做的原因如下：\n 不用区分class、if还是module，都可以include。 将验证环境文件添加到filelist也可以实现，之所以不这样做，是因为我需要使用`ifedf语句来进行可配置编译，比如是否编译function covergroup文件，filelist中是无法使用`ifdef的。 如果使用了package，pkg内的class必须全部使用软件行为，而像“tb.clk”这种层级索引信号的方式是不可以使用的。  force硬件信号 有时候需要对DUT的信号进行force，force时信号值的源可以是数字，也可以是变量，但是此时对变量是有要求的，不能是任务的传入参数，最好使用静态变量，原因是设计中的变量都是静态变量。\ntrans的约束和driver的修改 trans中对随机变量添加了约束，此时如果driver中处于某种原因需要对其进行修改，如果修改的值与约束发生冲突，会报出警告，或者无法修改，这里需要格外注意。\n变量定义编译失败 一般来说，变量定义，要放在程序的最开头，这样，编译才能成功。而变量定义没有放在最前面，而是放到了赋值语句之后，就会编译报错。所谓变量的声明必须在赋值之前，这是基本的原则，但是即便遵循这个原则，如果变量的声明穿插在代码中间，还是会编译报错。根据多次尝试发现，根据在编译时，其实是按代码块来判断的，也就是变量的声明必须在代码块的开头，所谓代码块可以是：\n initial begin \u0026hellip; end if begin \u0026hellip; and always begin \u0026hellip; end  有时候为了增强代码可读性，习惯将局部变量声明和代码逻辑放在一起，为了使其能编译成功，可以人为添加额外的begin\u0026hellip;end。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":13,"section":"docs","tags":null,"title":"SV与UVM的问题记录","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/sv-and-uvm-notes/"},{"content":"本文 主要介绍一款波形图绘制软件WaveDrom，它可以通过代码形式来实现波形图的绘制。\n   版本 说明     0.1 初版发布    背景  WaveDrom 2.3.2  什么是WaveDrom WaveDromEditor是基于WaveDrom引擎和WaveJSON格式的数字时序图的在线编辑器，可以在网页上实时编辑来生成波形。当然也可以下载单独的WaveDromEditor应用，在Windows、Linux等系统离线编辑。\n WaveDrom官网，官网上有四个选项： Tutorial（教程）， Editor（在线编辑器）， Source（源码，一般也不会去看），Twitter（推特，社交平台，一般也不会去看），下方还有一个Download editor（下载编辑器），可以选择Linux和windows，下载后可离线编辑。  基本使用 {signal: [ {name: 'clk', wave: 'p.....|...'}, {name: 'clk1', wave: 'p..P..|...', period: 2 }, {name: 'clk4', wave: 'n..N..|...', phase: -1 }, {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']}, {name: 'req', wave: '0.1..0|1.0'}, {}, {name: 'ack', wave: '1.....|01.'} ]}  这是生成时序波形的代码的基本结构，首先所有的语法都要在一个大括号{}里。signal关键词表示需要生成一系列波形，在后跟的中括号里编辑多组信号，每个信号的描述都应该写在大括号{}里，并用逗号隔开。 name关键词指明波形的名字，wave关键词是波形的核心，决定了波形的基本样式。 小写p表示以上升沿开始生成一个周期的时钟，大写P在小写p的基础上增加了箭头，更加直观的反映了时钟沿（小写n和大写N代表的含义类似）。 小数点.表示重复前一个字符，例如p\u0026hellip;相当于pppp。 另外还有01xz=23456789等字符，分别代表不同的波形，其中01xz代表四个信号状态，=代表bus，23456789代表bus且不同颜色显示（2为白色）。 如果需要，可以增加选项period和phase，他们分别代表了周期和相位偏移。period表示周期的倍数，默认值为1，phase表示相位的偏移，默认值为0，如果是正数则向左偏移，负数则向右偏移。 一个空的大括号{}里不加任何的关键词，表示“空一行”，你可以使用空的大括号将波形隔开，便于分组。 选项data说明其数据内容，data的内容和wave里的=按照书写顺序一一对应。需要注意的一点是，=.中的小数点虽然重复了上一个字符，但和==表示的含义不同，=.表示两个周期的数据相同，而==表示两个不同的数据。 |竖线表示间隔符，显示为两条曲线。  配置选项 { signal: [ { name:\u0026quot;clk\u0026quot;, wave: \u0026quot;p....\u0026quot; }, { name:\u0026quot;Data\u0026quot;, wave: \u0026quot;x345x\u0026quot;, data: [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;] }, { name:\u0026quot;Request\u0026quot;, wave: \u0026quot;01..0\u0026quot; } ], config: { hscale: 2 }, head: { text: \u0026quot;WaveDrom example\u0026quot;, tick: 0 }, foot: { text: \u0026quot;Figure 100\u0026quot;, tock: 9 } }  关键词config里可以指定hscale的值为以0.5为倍数且大于0的数值，用来改变一个周期的宽度。当hscale为2时，波形看起来比原来更宽敞了。 关键词head可以在波形上方添加标题，也可以在波形上方添加数字标签。选项text的值为标题内容，选项tick的值value表示从value开始在周期节点添加数字标签。 关键词foot可以在波形下方添加标题，也可以在波形下方添加数字标签。选项tock的值value表示从value开始在每个周期中间位置添加数字标签。  信号分组 { signal: [ { name: 'clk', wave: 'p...Pp...P'}, {}, ['Master', ['ctrl', {name: 'write', wave: '01.0...'}, {name: 'read', wave: '0...1...0'} ], { name: 'addr', wave: 'x3.x4...x', data: 'A1 A2'}, { name: 'wdata', wave: 'x3.x...', data: 'D1' }, ], {}, ['Slave', ['ctrl', {name: 'ack', wave: 'x01x0.1x'}, ], { name: 'rdata', wave: 'x...4x', data: 'Q2'}, ] ]}  可以使用[\u0026lsquo;setname\u0026rsquo; \u0026hellip; ],来对信号进行分组，且可以嵌套。  箭头与连线 { signal: [ { name: 'A', wave: '01....0.........', node: '.a....j..' }, { name: 'B', wave: '0.1...0....1....', node: '..b........i' }, { name: 'C', wave: '0..1....0...1...', node: '...c....h...' }, { name: 'D', wave: '0...1..0...1....', node: '....d..g...' }, { name: 'E', wave: '0.1010...1......', node: '..e.f...' }, { node: '..x.z' } ], edge: [ 'a~b t1', 'b-~c t2', 'c-~\u0026gt;d t3', 'd~\u0026gt;e', 'e-x', 'f-z', 'x\u0026lt;-\u0026gt;z 3 ms', ]}  node关键词：声明节点，位置与波形描述对应 ～：S线连接；-～上弧线连接；～-下弧线连接。（可以为连线命名）   ：箭头指向右节点；\u0026lt;\u0026gt;：双向箭头。\n  -：直线，箭头含义相同。可以只定义node而不描述波形，以“\u0026lsquo;e-x\u0026rsquo;, \u0026lsquo;f-z\u0026rsquo;, \u0026lsquo;x\u0026lt;-\u0026gt;z 3 ms\u0026rsquo;,”形式可以描述一段波形区间。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":14,"section":"docs","tags":["WaveDrom"],"title":"波形图绘制软件WaveDrom","uri":"https://www.wenhui.space/docs/01-software-install/install_wavedrom/"},{"content":"本文 主要对shell脚本的基础语法知识进行记录。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 shell：bash  学习网站  shell基础  字符串截取 计数截取  左边开始计数：${string: start :length}  start 是起始位置（从左边开始，从 0 开始计数） length 是要截取的长度（省略的话表示直到字符串的末尾）     1 2 3  url=\u0026#34;c.biancheng.net\u0026#34; echo ${url: 2: 9} # 结果：biancheng    右边开始计数：${string: 0-start :length}  右边开始计数时，起始数字是 1 不管从哪边开始计数，截取方向都是从左到右。     1 2 3  url=\u0026#34;c.biancheng.net\u0026#34; echo ${url: 0-13: 9} # 结果：biancheng   指定子字符串截取  截取右边字符：${string#*chars}  #*chars 表示忽略左边的所有字符，直到遇见 chars（chars 不会被截取） 当有多个匹配时，只从左到右第一个有效     1 2 3  url=\u0026#34;http://c.biancheng.net/index.html\u0026#34; echo ${url#*/} #结果：/c.biancheng.net/index.html    截取右边字符：${string##*chars}  ##*chars 表示忽略左边的所有字符，直到遇见 chars（chars 不会被截取） 当有多个匹配时，只从左到右最后一个有效     1 2 3  url=\u0026#34;http://c.biancheng.net/index.html\u0026#34; echo ${url##*/} #结果：index.html    截取左边字符：${string%chars*}  %chars* 表示忽略右边的所有字符，直到遇见 chars（chars 不会被截取） 当有多个匹配时，只从右到左第一个有效     1 2 3  url=\u0026#34;http://c.biancheng.net/index.html\u0026#34; echo ${url%/*} #结果：http://c.biancheng.net    截取左边字符：${string%%chars*}  %%chars* 表示忽略右边的所有字符，直到遇见 chars（chars 不会被截取） 当有多个匹配时，只从右到左最后一个有效     1 2 3  url=\u0026#34;http://c.biancheng.net/index.html\u0026#34; echo ${url%%/*} #结果：http:   总结    格式 说明     ${string: start :length} 从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。   ${string: start} 从 string 字符串的左边第 start 个字符开始截取，直到最后。   ${string: 0-start :length} 从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。   ${string: 0-start} 从 string 字符串的右边第 start 个字符开始截取，直到最后。   ${string#*chars} 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。   ${string##*chars} 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。   ${string%*chars} 从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。   ${string%%*chars} 从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。    字符串替换 简单的替换  b=\\({a/123/321};将\\){a}里的第一个123替换为321 b=\\({a//123/321};将\\){a}里的所有123替换为321  删除前后空格 1 2 3 4 5 6  a=\u0026#34; 123 456 \u0026#34; # 方法一 b=`echo $a` # 方法二 b=`echo $a | sed -r \u0026#39;s/^[ \\t]*//g\u0026#39;` # 删除行首空格 b=`echo $b | sed -r \u0026#39;s/[ \\t]*$//g\u0026#39;` # 删除行尾空格   sed与正则表达式 基础  命令格式：  面对文件：sed [options] \u0026lsquo;command\u0026rsquo; file(s) 面对变量：echo $b | sed [options] \u0026lsquo;command\u0026rsquo;   常用选项：\n-n ：使用安静(silent)模式，只显示处理的行。\n-r ：支持延伸型正则表达式\n-i ：直接修改读取的文件内容，而不是输出到终端。 常用功能：  s：替换字符串 d：删除行 a：新增行 i：插入行 c：替换行 p：输出到终端    举例  替换字符串：   1 2 3 4  sed \u0026#39;s/aa/AA/\u0026#39; test.txt # 替换aa为AA，注意每行只替换从左到右第一个匹配处 sed \u0026#39;s/aa/AA/g\u0026#39; test.txt # 替换aa为AA，注意每行替换所有匹配处 sed \u0026#39;5,$s/aa/AA/g\u0026#39; test.txt # 指定第5行至文件末尾为操作域 sed \u0026#39;/^[0-9]/s/aa/AA/g\u0026#39; test.txt # 指定数字开头的行为操作域    删除：   1 2  sed \u0026#39;1,4d\u0026#39; test.xx # 删除1至4行 sed \u0026#39;/^2/d\u0026#39; test.txt # 删除以数字2开头的行（//里内容是正则表达式，并且必要时可以添加-r选项）    新增与插入   1 2  sed \u0026#39;1a hello world\u0026#39; test.txt # 在第1行后面新增hello world（也就是处理后的第2行） sed \u0026#39;1i hello world\u0026#39; test.txt # 在第1行前面插入hello world（也就是处理后的第1行）    替换行   1 2  sed \u0026#39;1c hello world\u0026#39; test.txt # 第1行替换为hello world sed \u0026#39;/^2/c hello world\u0026#39; test.txt # 以数字2开头的行替换为hello world    输出到终端   1 2  sed -n \u0026#39;2p\u0026#39; test.txt # 把第二行输出到终端 sed -n -r \u0026#39;/^2/p\u0026#39; test.txt # 把以数字2开头的行输出到终端    文件修改的方法：  sed \u0026lsquo;command\u0026rsquo; file(s) \u0026gt; tmp_file （重定向到临时文件） sed -i \u0026lsquo;command\u0026rsquo; file(s) （直接修改文件，最好处理前备份一下）    条件判断 if if-elif-else-fi 1 2 3 4 5 6 7  if (( $age \u0026lt;= 18 )); then echo \u0026#34;儿童\u0026#34; elif (( $age \u0026gt; 18 \u0026amp;\u0026amp; $age \u0026lt;= 40 )); then echo \u0026#34;青年\u0026#34; else echo \u0026#34;老年\u0026#34; fi   数值比较  数值的运算使用(())：支持 +、-、*、/、%   1 2 3 4 5 6  a=100 b=50 c=$(($a + $b)) d=$((100 + 50)) echo $c echo $d    数值的比较使用(())：支持 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;=、==、!=   1 2 3 4 5 6 7  a=100 b=50 if (($a \u0026gt; $b));then echo \u0026#34;max is a\u0026#34; else echo \u0026#34;max is b\u0026#34; fi   字符串比较  字符表达式的比较使用 [[]]：支持 =、!=、-z 和 \u0026amp;\u0026amp;、|| 、! 运算符 （注意，中括号与表达式间要保留空格）   1 2 3 4 5  # str1 或 str2 非空 if [[ -z $str1 || -z $str2 ]] # 支持通配符 if [[ hest = h??t ]] # ? 表示任意字符 if [ hest = h*t ]] # * 表示任意个任意字符    支持正则表达式：=~  ^ 匹配字符串的开头（一个位置）； [0-9]{10} 匹配连续的十个数字； $匹配字符串的末尾（一个位置）     1 2 3 4 5 6  if [[ $tel =~ ^1[0-9]{10}$ ]] then echo \u0026#34;你输入的是手机号码\u0026#34; else echo \u0026#34;你输入的不是手机号码\u0026#34; fi   文件表达式 文件表达式的测试使用 [[]] ，其运算符如下：\n   表达式 含义     -e filename 如果 filename 存在，则为真   -d filename 如果 filename 为目录，则为真   -f filename 如果 filename 为常规文件，则为真   -L filename 如果 filename 为符号链接，则为真   -r filename 如果 filename 可读，则为真   -w filename 如果 filename 可写，则为真   -x filename 如果 filename 可执行，则为真   filename1 -nt filename2 如果 filename1 比 filename2 新，则为真   filename1 -ot filename2 如果 filename1 比 filename2 旧，则为真    循环for和while for 1 2 3 4  for line in `cat filename` # 或 for line in $(cat filename) do echo $line done   这里有时候会出现问题，bash没有将换行符作为一行的分隔符，而是将空格作为了分隔符。这时候需要更改shell的系统变量IFS。\n1 2 3  IFS=\u0026#39;\\n\u0026#39; # 无效 IFS=$\u0026#34;\\n\u0026#34; # 无效 IFS=$\u0026#39;\\n\u0026#39; # 有效   以上这三个赋值看起来都比较像”将换行符赋值给IFS“，但实际上只有最后一种写法才是我想要的结果，一定要注意。\n IFS=‘\\n’ //将字符n作为IFS的换行符。 IFS=$\u0026rdquo;\\n\u0026rdquo; //这里\\n确实通过$转化为了换行符，但仅当被解释时（或被执行时）才被转化为换行符。 IFS=$\u0026rsquo;\\n\u0026rsquo; //这才是真正的换行符。  while 1 2 3 4  while read -r line do echo $line done \u0026lt; filename   break与continue  break：表示跳出当前的整个循环。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。   1 2 3 4 5 6 7  while read n; do if((n\u0026gt;0)); then ((sum+=n)) else break fi done    continue：表示过本次循环，忽略本次循环的剩余代码，直接进入下一次循环。   1 2 3 4 5 6  while read n; do if((n\u0026lt;1 || n\u0026gt;100)); then continue fi ((sum+=n)) done   重定向 输出重定向 1  echo $str \u0026gt;\u0026gt;demo.txt #将输入结果以追加的方式重定向到文件      类 型 符 号 作 用     标准输出重定向 command \u0026gt;file 以覆盖的方式，把 command 的正确输出结果输出到 file 文件中。   标准输出重定向 command \u0026raquo;file 以追加的方式，把 command 的正确输出结果输出到 file 文件中。   标准错误输出重定向 command 2\u0026gt;file 以覆盖的方式，把 command 的错误信息输出到 file 文件中。   标准错误输出重定向 command 2\u0026raquo;file 以追加的方式，把 command 的错误信息输出到 file 文件中。   正确输出和错误信息同时保存 command \u0026gt;file 2\u0026gt;\u0026amp;1 以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。   正确输出和错误信息同时保存 command \u0026raquo;file 2\u0026gt;\u0026amp;1 以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。   正确输出和错误信息同时保存 command \u0026gt;file1 2\u0026gt;file2 以覆盖的方式，把正确输出保存到 file1 文件，把错误信息保存到 file2 文件中。   正确输出和错误信息同时保存 command \u0026raquo;file1 2\u0026raquo;file2 以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中    输入重定向 1 2 3  while read str; do echo $str done \u0026lt;readme.txt      符号 说明     command \u0026lt;file 将 file 文件中的内容作为 command 的输入。   command \u0026laquo;END 从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。   command file2 将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。    case-esac 以读取命令行参数为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  usage() { echo \u0026#34;usage: $0[--testname testname] [--basetest btname] [--dump] [--debug] [--simpath simlogpath] [--nocmp] [--seed seednum] [--cov] [--funcov] [--xrun]\u0026#34; } while [[ x$1 != x]]; do case $1 in --testname ) shift testname=$1 ;; --basetest ) shift btname=$1 ;; --dump ) dump=1 ;; --debug ) debug=1 ;; --simpath ) shift simlogpath=$1 ;; --nocmp ) nocmp=1 ;; --seed ) shift seednum=$1 ;; --cov ) cov=1 ;; --funcov ) funcov=1 ;; --xrun ) xrun=1 ;; -h ) usage exit 0 ;; * ) usage exit 0 ;; esac shift done   特殊变量    变量 含义     $0 当前脚本的文件名。   $n（n≥1） 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。   $# 传递给脚本或函数的参数个数。   $* 传递给脚本或函数的所有参数。   $@ 传递给脚本或函数的所有参数。当被双引号\u0026rdquo; \u0026ldquo;包含时，$@ 与 $* 稍有不同，我们将在《Shell $*和$@的区别》一节中详细讲解。   $? 上个命令的退出状态，或函数的返回值，我们将在《Shell $?》一节中详细讲解。   $$ 当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":15,"section":"docs","tags":["shell"],"title":"shell脚本基础","uri":"https://www.wenhui.space/docs/06-linux-skills/script-skills/shell_script_basis/"},{"content":"本文 主要针对org-mode中英文混合编辑时表格不对齐问题，提出一种有效解决方法。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Org-Mode 表格对齐设置 【Github】更纱黑体  解决方法 利用更纱黑体这个字体来解决表格对齐的问题，因为更纱黑体字体通过融合现有字体实现中文字符的宽度刚好是英文字符宽度的两倍，以此来解决表格对齐的问题。\n下载更纱黑体 本人使用deepin系统，内核是debian，没能通过apt-get获取字体库，只能使用手动安装。这里使用了清华大学开源软件镜像站，完成下载。\ndeepin自带字体安装器，所以解压后直接使用字体安装器安装即可。（由于其他系统的安装方法没有亲测，这里就不进行说明了）\nemacs配置 把下面的配置放入 ~/.emacs 中即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  (let ((emacs-font-size 14) (emacs-font-name \u0026#34;WenQuanYi Micro Hei Mono\u0026#34;)) (set-frame-font (format \u0026#34;%s-%s\u0026#34; (eval emacs-font-name) (eval emacs-font-size))) (set-fontset-font (frame-parameter nil \u0026#39;font) \u0026#39;unicode (eval emacs-font-name))) (with-eval-after-load \u0026#39;org (defun org-buffer-face-mode-variable () (interactive) (make-face \u0026#39;width-font-face) (set-face-attribute \u0026#39;width-font-face nil :font \u0026#34;等距更纱黑体 SC 15\u0026#34;) (setq buffer-face-mode-face \u0026#39;width-font-face) (buffer-face-mode)) (add-hook \u0026#39;org-mode-hook \u0026#39;org-buffer-face-mode-variable))   上面配置的意思是，默认Emacs使用文泉驿字体，Org-Mode使用更纱黑体字体，这样既可以解决Org-Mode表格对齐问题，又避免对Emacs其他模式产生影响。\n以上内容来自参考文件，我在使用时仅设置了org-mode下的字体，因为其他模式下字体有我自己的设置。注意，字体“等距更纱黑体 SC 15”的字号不能随意设置，否则达不到对齐效果。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":16,"section":"docs","tags":["emacs"],"title":"解决Org-Mode表格不对齐问题","uri":"https://www.wenhui.space/docs/02-emacs/org_mode_table_align/"},{"content":"本文 主要介绍一款文档格式转换工具Pandoc，它可以支持多种文档类型之间转换，包括Markdown、LaTeX、reStructuredText、HTML、Word docx 等。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  官网  Pandoc官网  什么是Pandoc Pandoc，它可以将文档在 Markdown、LaTeX、reStructuredText、HTML、Word docx 等多种标记格式之间相互转换，并支持输出 PDF、EPUB、HTML 幻灯片等多种格式。该程序被称为格式转换界的 “瑞士军刀”。\nPandoc 的作者是 John MacFarlane，他是加州大学伯克利分校的哲学系教授。Pandoc 使用 Haskell 语言编写，被作者用来生成讲义、课件和网站等。该程序开源免费，目前以 GPL 协议托管在 Github 网站上。\n安装 Pandoc 的作者已经为 Windows、macOS、Linux 等操作系统分别制作了对应的程序安装包。要使用该程序，只需下载对应的程序安装包进行安装即可。\n对于 Ubuntu 等 Linux 发行版，Pandoc 已经被集成到系统的软件源内，因此还可以直接从软件源安装：\n1  sudo apt-get install pandoc   使用方法 Pandoc 程序的命令使用方式为：\n1  pandoc \u0026lt;files\u0026gt; \u0026lt;options\u0026gt;     为输入的内容，其输入即可以来自文件，也可以来自标准输入甚至网页链接  为参数选项。主要的参数选项有：  “-f 、-r ”：指定输入文件格式，默认为 Markdown； “-t 、-w ”：指定输出文件格式，默认为 HTML； “-o ”：指定输出文件，该项缺省时，将输出到标准输出； “\u0026ndash;highlight-style [style]”：设置代码高亮主题，默认为 pygments； “-s”：生成有头尾的独立文件（HTML，LaTeX，TEI 或 RTF）； “-S”：聪明模式，根据文件判断其格式； “\u0026ndash;self-contained”：生成自包含的文件，仅在输出 HTML 文档时有效； “\u0026ndash;verbose”：开启 Verbose 模式，用于 Debug； “\u0026ndash;list-input-formats”：列出支持的输入格式； “\u0026ndash;list-output-formats”：列出支持的输出格式； “\u0026ndash;list-extensions”：列出支持的 Markdown 扩展方案； “\u0026ndash;list-highlight-languages”：列出支持代码高亮的编程语言； “\u0026ndash;list-highlight-styles”：列出支持的代码高亮主题； “-v、\u0026ndash;version”：显示程序的版本号； “-h、\u0026ndash;help”：显示程序的帮助信息。    虽然 Pandoc 提供了用于指定输入输出格式的参数，但是很多时候该参数不必使用。Pandoc 已经足够聪明到可以根据文件名判断输入输出格式，所以除非文件名可能造成歧义，否则这两个参数都可以省略。\n典型场景 markdown转html  常规使用，输出的文档不包含任何样式，它的显示效果依赖于你使用的浏览器。   1  pandoc demo.md -o demo.html    引入样式表CSS文件，使输出文档排版更精美。   1  pandoc demo.md -c style.css -o demo.html    将本地图片等文件嵌入到输出文档。   1  pandoc demo.md --self-contained -c style.css -o demo.html    添加目录。   1  pandoc demo.md --self-contained -c style.css --toc -o demo.html   org转html 与markdown转html使用相同，其实emacs自带org转html的插件，不过不能将外部文件嵌入到html，所以pandoc更实用。\n另外多说一些，emacs中设置org文件中图片的显示大小和居中等设置，我还没有找到有效的方法，不过嵌入html代码是可以做到的图片的设置，但是pandoc转换时没有将其嵌入到html内部，所以我还是将org通过ox-hugo转为markdown，再进行markdown转html。看起来好像很麻烦，其实我平时都是使用hugo写博客，emacs、ox-hugo、hugo是日常必备，但是你不能要求所有人都使用emacs，往往需要与外界分享时才会转为html或者doc。\n转为docx 1 2  pandoc demo.md -o demo.docx pandoc demo.org -o demo.docx   将org和markdown文件转为docx的操作是一样的，不过直接转出的效果可能不会太乐观，可能需要二次编辑输出的文件，将标题、正文等调整为满意的样式。好在还可以为文档的格式提供一个简单参考模板（标题样式和正文样式等）。\n1  pandoc test.org -o test.docx --reference-doc=template.docx   文档模板copy自ManateeLazyCat，这里给个链接地址。另外最简单创建模板的方法是:\n 先用命令 pandoc test.org -o template.docx 生成一个带Pandoc默认样式的Word文档。 用Office软件打开 template.docx 文件，修改样式成你喜欢的模样。 保存 template.docx 文件即可。  转为pdf文档 使用 Pandoc 直接生成 PDF 文件时，需要安装 LaTeX。并且，Pandoc 自带的 PDF 引擎不支持中文，必须为中文配置额外的引擎和模板。命令如下：\n1  pandoc demo.md -o demo.pdf   我没有用过Pandoc生成pdf，只是将其功能列在这里，没使用过就不在多做描述。说实话，使用最多的功能就是将markdown转html并将外部文件内嵌其中，如果真需要pdf文件，可以使用浏览器的打印到pdf。\n转为markdown  我们可以将docx转换为 Markdown。   1  pandoc demo.docx -o demo.md    甚至HTML网页转换为 Markdown（不只是本地html，网址也可以）。   1  pandoc https://www.wenhui.space/about/ -o demo.md   也许转出的文档内容不一定让你满意，但是可能对于某些还是有这个需求吧，我使用的并不多。\n其他场景 自行探索吧，如果有好用的欢迎分享。\ncss文件和word模板文件 上文提到了辅助转换的文件css和word模板，可以美化输出结果。\n这里提供一个css文件，参考自使用Pandoc命令将Markdown格式文件转换为HTML格式文件。另外我又添加了标题的自动编号，不过要提醒的是，我一般不使用一级标题（hugo与org文件组织的原因），而是从二级标题开始，所以如果你使用一级标题，请进行修改。代码我就不展示了，提供一个网盘分享链接（包含word模板和linux64版Pandoc 1.17.2可执行文件）： 链接：https://pan.baidu.com/s/1BCmJuAufTa4HeA1c4UZ8CQ 密码：61vm\n绑定emacs快捷键 请参考 高效创作 Mindmap -\u0026gt; Org-Mode -\u0026gt; Word。\n其他进阶学习 pandoc是可以使用模板的，并且网上提供了很多资源，感兴趣的可以去探索，这里提供一些网址。有时候极致的追求是个无底洞，我不是偏执狂，所以就先到这里吧。如果您有好的使用方法，欢迎分享。\n 简书：Pandoc文件转化工具 Pandoc官网提供的Demos 官方收集的各种模板  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":17,"section":"docs","tags":["Pandoc"],"title":"文档格式转换工具Pandoc","uri":"https://www.wenhui.space/docs/01-software-install/install_pandoc/"},{"content":"本文 主要对版本控制工具Git进行简单介绍，以及一些高级场景的应用。\n   版本 说明     0.1 初版发布    背景 本文非原创，整理自掘金小册收费文章《Git 原理详解及实用指南》，作者： 抛物线。\n什么是Git 什么是版本控制 所谓版本控制，意思就是在文件的修改历程中保留修改历史，让你可以方便地撤销之前对文件的修改操作。\n版本控制的三个功能需求：\n 版本控制：在项目开发中我们需要能够回退到任何一个版本状态。 主动提交：在项目开发中我们需要能够主动提交版本状态，而不是自动保存修改内容某版本，这样可以避免大量的无效版本状态。 中央仓库：在项目开发中大多数是多人合作的，需要有一个中央仓库作为代码的存储中心，所有人的改动都会上传到这里，所有人也从这里下载到别人上传的改动。  总结：开发团队中的每个人向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。\n中央式版本控制系统   中央式版本控制系统    假设你在一个三人团队，你们计划开发一个软件或者系统，并决定使用中央式 VCS 来管理代码。于是：\n 作为项目的主工程师，你独自一人花两天时间搭建了项目的框架； 然后，你在公司的服务器上创建了一个中央仓库，并把你的代码提交到了中央仓库上； 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人为了工作方便，总是每人独立负责开发一个功能，在这个功能开发完成后，这个人就把他的这些新代码提交到中央仓库； 每次当有人把代码提交到中央仓库的时候，另外两个人就可以选择把这些代码同步到自己的机器上，保持自己的本地代码总是最新的。  而对于团队中的每个人来说，就会更简单一点：\n 第一次加入团队时，把中央仓库的代码取下来； 写完的新功能提交到中央仓库； 同事提交到中央仓库的新代码，及时同步下来。  这样，一个三人的团队就成功做到了各自在自己的电脑上开发同一个项目，并且互不影响，就好像你们三个人是在同一台电脑上操作一样。\n分布式版本控制系统   分布式版本控制系统    分布式与中央式相比多了本地仓库，一部分版本历史保存在本地仓库，代码同步和版本历史保存在中央仓库。\n依然以三人团队为例，分布式 VCS 的工作模型大致是这样：\n 首先，你作为主工程师，独立搭建了项目架构，并把这些代码提交到了本地仓库； 然后，你在服务器上创建了一个中央仓库，并把 1）中的提交从本地仓库推送到了服务器的中央仓库； 其他同事把中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，从此刻开始，你们三人开始并行开发； 在之后的开发过程中，你们三人总是每人独立负责开发一个功能，在这个功能开发过程中，一个人会把它的每一步改动提交到本地仓库。注意：由于本地提交无需立即上传到中央仓库，所以每一步提交不必是一个完整功能，而可以是功能中的一个步骤或块。 在一个人把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库； 每次当有人把新的提交推送到中央仓库的时候，另外两个人就可以选择把这些提交同步到自己的机器上，并把它们和自己的本地代码合并。  优点与缺点 分布式 VCS 的优点：\n 大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制（例如，你可以在飞机上提交代码、切换分支等等）； 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。  分布式 VCS 的缺点：\n 由于每一个机器都有完整的本地仓库，所以初次获取项目（Git 术语：clone）的时候会比较耗时； 由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。 补充：项目的大多数内容都是文本形式的代码，再加上版本控制工具可以将文本内容极大的压缩，所以实际上内存大和下载慢的问题并不严重。  如何上手之单人开发 已经有 Git 经验的可以跳过这一节。\n安装Git 点击去这里下载个Git，选择对应的平台版本（Linux or Windows），安装到你的机器上。\n建个练习仓库 学习的时候最好别拿团队的正式项目练手，先在 GitHub 上建一个自己的练习项目。\n 访问Github。 注册或登录您的账号。 点击右上角的「New Repository」来新建远程仓库。 填写仓库名称（其他的设置可以先不管，默认即可），点击创建。 点击右边的「Clone or download」，然后把仓库的 clone 地址复制到剪贴板。 把远程仓库取到本地，在 Terminal 或 cmd 中切换到你希望放置项目的目录中，然后输入“git clone 你刚复制的地址”，然后输入正确的用户名和密码。 自己写个提交试试：在克隆到本地的仓库目录下新建个文件，比如temp.txt  使用“git status” 查看当前状态，temp.txt 文件目前属于 \u0026ldquo;untracked\u0026rdquo; 状态，意思是该文件未添加到仓库里，也就没有进行版本追踪。 使用“git add temp.txt”将其添加到仓库，仓库开始对齐进行版本追踪。可以看看再使用“git status”会有什么变化。 使用add后文件添加到了本地仓库的暂存区，现在需要提交到本地仓库，“git commit -m \u0026ldquo;这里写提交注释\u0026rdquo;”，可以看看再使用“git status”会有什么变化，再使用“git log”查看提交历史，可以看到此次的提交。 修改temp.txt文件，执行“git status”会发现文件被修改的提示，重复添加和提交命令，再使用“git log”查看提交历史，可以看到两次的提交。 推送到远程仓库：使用 git push 来把本地提交上传到远程中央仓库。可以在github网页上看到自己本地内容已经更新到远程仓库。    总结 单人开发的基本工作模式如下：\n 从 GitHub 把中央仓库 clone 到本地（使用命令： git clone） 把写完的代码提交（先用 git add 文件名 把文件添加到暂存区，再用 git commit 提交）  在这个过程中，可以使用 git status 来随时查看工作目录的状态 每个文件有 \u0026ldquo;changed / unstaged\u0026rdquo;（已修改）, \u0026ldquo;staged\u0026rdquo;（已修改并暂存）, \u0026ldquo;commited\u0026rdquo;（已提交） 三种状态，以及一种特殊状态 \u0026ldquo;untracked\u0026rdquo;（未跟踪）   提交一次或多次之后，把本地提交 push 到中央仓库（git push）  如何上手之多人协作 对于 Git 来说，团队合作和个人独立工作最大的不同在于，你会提交代码，别人也会提交；你会 push，别人也会 push，因此除了把代码上传，每个人还需要把别人最新的代码下载到自己的电脑。而且，这些工作都是并行进行的。\n把别人的新提交拿到本地  首先你需要一饰多角，除非有同事和你一起练习。为了模拟同事的操作，你需要创建两个文件夹worker1和worker2，在这两个文件夹下将远程仓库clone到本地。现在两个本地仓库就可以代表两个同事在操作了。 worker1提交代码并push到中央仓库：切换worker1的本地仓库，帮他创建个文件写点代码，并依次进行add、commit、push。此时远程中央仓库可以看到已经更新的内容。 worker2更新远程仓库到本地：切换worker2的本地仓库，使用“git pull”将远程仓库内容更新到本地，这时候可以看到worker1的修改的内容。  多人合作的基本工作模型 这就完成了一次简单的合作流程：\n worker1 commit 代码到他的本地，并 push 到 GitHub 中央仓库 worker2把 GitHub 的新提交通过 pull 指令来取到你的本地  比如worker1是同事，worker2是自己，通过这个流程，你和同事就可以简单地合作了：你写了代码，commit，push 到 GitHub，然后他 pull 到他的本地；他再写代码，commit, push 到 GitHub，然后你再 pull 到你的本地。你来我往，配合得不亦乐乎。\n但是，这种合作有一个严重的问题：同一时间内，只能有一个人在工作。你和同事其中一个人写代码的时候，另一个人不能做事，必须等着他把工作做完，代码 push 到 GitHub 以后，自己才能把 push 上去的代码 pull 到自己的本地。而如果同时做事，就会发生冲突：当一个人先于另一个人 push 代码（这种情况必然会发生），那么后 push 的这个人就会由于中央仓库上含有本地没有的提交而导致 push 失败。因为 Git 的push 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库含有本地没有的 commits 的时候，push （如果成功）将会导致远端的 commits 被擦掉。这种结果当然是不可行的，因此 Git 会在 push 的时候进行检查，如果出现这样的情况，push 就会失败。\n解决push冲突 在现实的团队开发中，全队是同时并行开发的，所以必然会出现当一人 push 代码时，中央仓库已经被其他同事先一步 push 了的情况。为了不让文段显得太过混乱，这里我就不带着你一步步模拟这个过程了。如果你希望模拟的话，这里是步骤：\n 切换到worker1，做一个 commit，然后 push 到 GitHub 切换到worker2，做一个不一样的 commit。  这个时候，远端中央仓库已经有了别人 push 的 commit，现在你如果 push 的话，由于 GitHub 的远端仓库上含有本地仓库没有的内容，所以这次 push 被拒绝了。\n这种冲突的解决方式其实很简单：先用 pull 把远端仓库上的新内容取回到本地和本地合并，然后再把合并后的本地仓库向远端仓库推送。这次的 git pull 操作并没有像之前的那样直接结束，而是进入了上图这样的一个输入提交信息的界面。这是因为当 pull 操作发现不仅远端仓库包含本地没有的 commits，而且本地仓库也包含远端没有的 commits 时，它就会把远端和本地的独有 commits 进行合并，自动生成一个新的 commit ，而上图的这个界面，就是这个自动生成的 commit 的提交信息界面。另外，和手动的 commit 不同，这种 commit 会自动填入一个默认的提交信息，简单说明了这条 commit 的来由。你可以直接退出界面来使用这个自动填写的提交信息，也可以修改它来填入自己提交信息。在退出提交信息的界面后，这次 pull 就完成了：远端仓库被取到了本地，并和本地仓库进行了合并。在这个时候，就可以再 push 一次了。由于现在本地仓库已经包含了所有远端仓库的 commits，所以这次 push 不会再失败。\n补充：这种“把不同的内容进行合并，生成新的提交”的操作，叫做合并，它所对应的 Git 指令是 merge。事实上，git pull 这个指令的内部实现就是把远程仓库使用 git fetch 取下来以后再进行 merge 操作的。\n总结 多人协作的基本工作模式如下：\n 写完所有的 commit 后，不用考虑中央仓库是否有新的提交，直接 push 就好 如果 push 失败，就用 pull 把本地仓库的提交和中央仓库的提交进行合并，然后再 push 一次  到此为止，这个工作模型已经是一个最简单的可用的工作模型了。一个小团队如果对版本管理没有什么要求的话，这个工作模型已经可以让团队用来合作开发了。复杂的版本管理还会设计branch，不过对于新人上手，应该先掌握以上内容就基本可以应付日常操作了。\n进阶1：HEAD、master 与 branch 引用：commit 的快捷方式 首先使用“git log”查看一些提交信息：第一行的 commit 后面括号里的 HEAD -\u0026gt; master, origin/master, origin/HEAD ，是几个指向这个 commit 的引用。在 Git 的使用中，经常会需要对指定的 commit 进行操作。每一个 commit 都有一个它唯一的指定方式——它的 SHA-1 校验和，也就是上图中每个黄色的 commit 右边的那一长串字符。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 commit，也可以只使用它的前几位来指代它（例如第一个 78bb0ab7d541…16b77，你使用 78bb0ab 甚至 78bb 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 commit，作为操作 commit 时的快捷方式。\nHEAD：当前 commit 的引用 这个括号里的 HEAD 是引用中最特殊的一个：它是指向当前 commit 的引用。所谓 当前 commit 这个概念很简单，它指的就是当前工作目录所对应的 commit。\n当前 commit 就是第一行中的那个最新的 commit。每次当有新的 commit 的时候，工作目录自动与最新的 commit 对应；而与此同时，HEAD 也会转而指向最新的 commit。事实上，当使用 checkout、reset 等指令手动指定改变当前 commit 的时候，HEAD 也会一起跟过去。\n总之，当前 commit 在哪里，HEAD 就在哪里，这是一个永远自动指向当前 commit 的引用，所以你永远可以用 HEAD 来操作当前 commit。\nbranch HEAD 是 Git 中一个独特的引用，它是唯一的。而除了 HEAD 之外，Git 还有一种引用，叫做 branch（分支）。HEAD 除了可以指向 commit，还可以指向一个 branch，当它指向某个 branch 的时候，会通过这个 branch 来间接地指向某个 commit；另外，当 HEAD 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 branch 一起移动。\n“git log”显示结果中，HEAD -\u0026gt; master 中的 master 就是一个 branch 的名字，而它左边的箭头 -\u0026gt; 表示 HEAD 正指向它（当然，也会间接地指向它所指向的 commit）。如果我在这时创建一个 commit，那么 HEAD 会带着 master 一起移动到最新的。\n     master:默认的 branch 上面的这个 master ，其实是一个特殊的 branch：它是 Git 的默认 branch（俗称主 branch / 主分支）。\n所谓的「默认 branch」，主要有两个特点：\n 新创建的 repository（仓库）是没有任何 commit 的。但在它创建第一个 commit 时，会把 master 指向它，并把 HEAD 指向 master。 当有人使用 git clone 时，除了从远程仓库把 .git 这个仓库目录下载到工作目录中，还会 checkout （签出） master（checkout 的意思就是把某个 commit 作为当前 commit，把 HEAD 移动过去，并把工作目录的文件内容替换成这个 commit 所对应的内容）。       另外，需要说一下的是，大多数的开发团队会规定开发以 master 为核心，所有的分支都在一定程度上围绕着 master 来开发。这个在事实上构成了 master 和其它分支在地位上的一个额外的区别。 branch 的通俗化理解 尽管在 Git 中，branch 只是一个指向 commit 的引用，但它有一个更通俗的理解：你还可以把一个 branch 理解为从初始 commit 到 branch 所指向的 commit 之间的所有 commits 的一个「串」。这种理解方式比较符合 branch 这个名字的本意（branch 的本意是树枝，可以延伸为事物的分支），也是大多数人对 branch 的理解。不过如果你选择这样理解 branch，需要注意下面两点：\n 所有的 branch 之间都是平等的，如下图，branch1 是 1 2 5 6 的串，而不要理解为 2 5 6 或者 5 6 。其实，起点在哪里并不是最重要的，重要的是你要知道，所有 branch 之间是平等的，master 除了上面我说的那几点之外，并不比其他 branch 高级。这个认知的理解对于 branch 的正确使用非常重要。        branch 包含了从初始 commit 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。如下图，master 在合并了 branch1 之后，从初始 commit 到 master 有了两条路径。这时，master 的串就包含了 1 2 3 4 7 和 1 2 5 6 7 这两条路径。而且，这两条路径是平等的，1 2 3 4 7 这条路径并不会因为它是「原生路径」而拥有任何的特别之处。       branch 的创建、切换和删除 创建 branch： 如果你想在某处创建 branch ，只需要输入一行 git branch 名称。例如“git branch feature1”\n     切换 branch： 新建的 branch 并不会自动切换，你的 HEAD 在这时依然是指向 master 的。你需要用 checkout 来主动切换到你的新 branch 去“git checkout feature1”。（也可以使用git checkout -b 名称 来把上面两步操作合并执行）\n     在切换到新的 branch 后，再次 commit 时 HEAD 就会带着新的 branch 移动了：      而这个时候，如果你再切换到 master 去 commit，就会真正地出现分叉了：      删除 branch： 删除 branch 的方法非常简单：git branch -d 名称。例如要删除 feature1 这个 branch：“git branch -d feature1”\n需要说明的有三点：\n HEAD 指向的 branch 不能删除。如果要删除 HEAD 指向的 branch，需要先用 checkout 把 HEAD 指向其他地方。 由于 Git 中的 branch 只是一个引用，所以删除 branch 的操作也只会删掉这个引用，并不会删除任何的 commit。（不过如果一个 commit 不在任何一个 branch 的「路径」上，或者换句话说，如果没有任何一个 branch 可以回溯到这条 commit（也许可以称为野生 commit？），那么在一定时间后，它会被 Git 的回收机制删除掉。） 出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败（因为怕你误删掉「未完成」的 branch 啊），这种情况如果你确认是要删除这个 branch （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 -d 改成 -D，小写换成大写，就能删除了。  引用的本质 所谓「引用」（reference），其实就是一个个的字符串。这个字符串可以是一个 commit 的 SHA-1 码（例：c08de9a4d8771144cd23986f9f76c4ed729e69b0），也可以是一个 branch（例：ref: refs/heads/feature3）。\nGit 中的 HEAD 和每一个 branch 以及其他的引用，都是以文本文件的形式存储在本地仓库 .git 目录中，而 Git 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。\n总结  HEAD 是指向当前 commit 的引用，它具有唯一性，每个仓库中只有一个 HEAD。在每次提交时它都会自动向前移动到最新的 commit 。 branch 是一类引用。HEAD 除了直接指向 commit，也可以通过指向某个 branch 来间接指向 commit。当 HEAD 指向一个 branch 时，commit 发生时，HEAD 会带着它所指向的 branch 一起移动。 master 是 Git 中的默认 branch，它和其它 branch 的区别在于：  新建的仓库中的第一个 commit 会被 master 自动指向； 在 git clone 时，会自动 checkout 出 master。   branch 的创建、切换和删除：  创建 branch 的方式是 git branch 名称 或 git checkout -b 名称（创建后自动切换）； 切换的方式是 git checkout 名称； 删除的方式是 git branch -d 名称。    进阶2：push的本质 在之前的内容里，我粗略地说过，push 指令做的事是把你的本地提交上传到中央仓库去，用本地的内容来覆盖掉远端的内容。这个说法其实是不够准确的，但 Git 的知识系统比较庞大，在你对 Git 了解比较少的时候，用「上传本地提交」来解释会比较好理解；而在你知道了 branch，并且明白了 branch 的具体含义以后，我就可以告诉你 push 到底是什么了。\npush：把 branch 上传到远端仓库 实质上，push 做的事是：把当前 branch 的位置（即它指向哪个 commit）上传到远端仓库，并把它的路径上的 commits 一并上传。\n例如，我现在的本地仓库有一个 master ，它超前了远程仓库两个提交；另外还有一个新建的 branch 叫 feature1，远程仓库还没有记载过它。这时我执行 git push，就会把 master 的最新位置更新到远端，并且把它的路径上的 5 6 两个 commits 上传：\n     而如果这时候我再切到 feature1 去后再执行一次 push，就会把 feature1 以及它的 commit 4 上传到远程仓库。 1 2  git checkout feature1 git push origin feature1   这里的 git push 和之前有点不同：多了 origin feature1 这两个参数。其中 origin 是远程仓库的别名，是你在 git clone 的时候 Git 自动帮你起的；feature1 是远程仓库中目标 branch 的名字。这两个参数合起来指定了你要 push 到的目标仓库和目标分支，意思是「我要 push 到 origin 这个仓库的 feature1 分支」。\n在 Git 中（2.0 及它之后的版本），默认情况下，你用不加参数的 git push 只能上传那些之前从远端 clone 下来或者 pull 下来的分支，而如果需要 push 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同），就像上面这样。你也可以通过 git config 指令来设置 push.default 的值来改变 push 的行为逻辑，例如可以设置为「所有分支都可以用 git push 来直接 push，目标自动指向 origin 仓库的同名分支」（对应的 push.default 值：current）。\n     细心的人可能会发现，在 feature1 被 push 时，远程仓库的 HEAD 并没有和本地仓库的 HEAD 一样指向 feature1。这是因为，push 的时候只会上传当前的 branch 的指向，并不会把本地的 HEAD 的指向也一起上传到远程仓库。事实上，远程仓库的 HEAD 是永远指向它的默认分支（即 master，如果不修改它的名称的话），并会随着默认分支的移动而移动的。 总结  push 是把当前的分支上传到远程仓库，并把这个 branch 的路径上的所有 commits 也一并上传。 push 的时候，如果当前分支是一个本地创建的分支，需要指定远程仓库名和分支名，用 git push origin branch_name 的格式，而不能只用 git push；或者可以通过 git config 修改 push.default 来改变 push 时的行为逻辑。 push 的时候上传当前分支，并不会上传 HEAD；远程仓库的 HEAD 是永远指向默认分支（即 master）的。  进阶3：merge commits 含义和用法 merge 的意思是「合并」，它做的事也是合并：指定一个 commit，把它合并到当前的 commit 来。具体来讲，merge 做的事是： 从目标 commit 和当前 commit （即 HEAD 所指向的 commit）分叉的位置起，把目标 commit 的路径上的所有 commit 的内容一并应用到当前 commit，然后自动生成一个新的 commit。merge命令为“git merge branch1”。如下图，Git 会把 5 和 6 这两个 commit 的内容一并应用到 4 上，然后生成一个新的提交，并跳转到提交信息填写的界面，merge 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 merge 就算完成了。\n     适用场景  合并分支： 当一个 branch 的开发已经完成，需要把内容合并回去时，用 merge 来进行合并。 pull 的内部操作： 之前说过，pull 的实际操作其实是把远端仓库的内容用 fetch 取下来之后，用 merge 来合并。  特殊情况 1：冲突 为什么产生冲突 merge 在做合并的时候，是有一定的自动合并能力的：如果一个分支改了 A 文件，另一个分支改了 B 文件，那么合并后就是既改 A 也改 B，这个动作会自动完成；如果两个分支都改了同一个文件，但一个改的是第 1 行，另一个改的是第 2 行，那么合并后就是第 1 行和第 2 行都改，也是自动完成。\n     但，如果两个分支修改了同一部分内容，merge 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。直白点说就是，你的两个分支改了相同的内容，Git 不知道应该以哪个为准。如果在 merge 的时候发生了这种情况，Git 就会把问题交给你来决定。具体地，它会告诉你 merge 失败，以及失败的原因。这时候需要做两件事：决掉冲突，手动commit 一下。 解决冲突 Git 虽然没有帮你完成自动 merge，但它对产生冲突的文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用符号标记出了它们的边界以及它们的出处。打开文件会发现文件内容标记为 HEAD 中的的内容和 feature1 中的内容。这两个内容 Git 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 HEAD 的修改，那么只要删除掉 feature1 的修改，再把 Git 添加的那三行 \u0026laquo;\u0026lt; = \u0026raquo;\u0026gt; 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。\n手动提交 解决完冲突以后，就可以进行第二步—— commit 了（需要先add）。提交后可以看到，被冲突中断的 merge，在手动 commit 的时候依然会自动填写提交信息。这是因为在发生冲突后，Git 仓库处于一个「merge 冲突待解决」的中间状态，在这种状态下 commit，Git 就会自动地帮你添加「这是一个 merge commit」的提交信息。\n放弃解决冲突，取消 merge？ 同理，由于现在 Git 仓库处于冲突待解决的中间状态，所以如果你最终决定放弃这次 merge，也需要执行一次 merge \u0026ndash;abort 来手动取消它：“git merge \u0026ndash;abort”。输入这行代码，你的 Git 仓库就会回到 merge 前的状态。\n特殊情况 2：HEAD 领先于目标 commit 如果 merge 时的目标 commit 和 HEAD 处的 commit 并不存在分叉，而是 HEAD 领先于目标 commit，那么 merge 就没必要再创建一个新的 commit 来进行合并操作，因为并没有什么需要合并的。在这种情况下， Git 什么也不会做，merge 是一个空操作。\n     特殊情况 3：HEAD 落后于 目标 commit——fast-forward 而另一种情况：如果 HEAD 和目标 commit 依然是不存在分叉，但 HEAD 不是领先于目标 commit，而是落后于目标 commit，那么 Git 会直接把 HEAD（以及它所指向的 branch，如果有的话）移动到目标 commit。这种操作有一个专有称谓，叫做 \u0026ldquo;fast-forward\u0026rdquo;（快速前移）。\n     一般情况下，创建新的 branch 都是会和原 branch （例如上图中的 master ）并行开发的，不然没必要开 branch ，直接在原 branch 上开发就好。但事实上，上图中的情形其实很常见，因为这其实是 pull 操作的一种经典情形：本地的 master 没有新提交，而远端仓库中有同事提交了新内容到 master。那么这时如果在本地执行一次 pull 操作，就会由于 HEAD 落后于目标 commit （也就是远端的 master）而造成 \"fast-forward\"。      简单解释一下上图中的 origin/master 和 origin/HEAD 是什么鬼：它们是对远端仓库的 master 和 HEAD 的本地镜像，在 git pull 的「两步走」中的第一步——git fetch 下载远端仓库内容时，这两个镜像引用得到了更新，也就是上面这个动图中的第一步：origin/master 和 origin/HEAD 移动到了最新的 commit。而 git pull 的第二步操作 merge 的目标 commit ，是远端仓库的 HEAD，也就是 origin/HEAD ，所以 git pull 的第二步的完整内容是“git merge origin/HEAD”。因此 HEAD 就会带着 master 一起，也指向图中绿色的最新 commit 了。 总结  merge 的含义：从两个 commit「分叉」的位置起，把目标 commit 的内容应用到当前 commit（HEAD 所指向的 commit），并生成一个新的 commit； merge 的适用场景：  单独开发的 branch 用完了以后，合并回原先的 branch； git pull 的内部自动操作。   merge 的三种特殊情况：  冲突：  原因：当前分支和目标分支修改了同一部分内容，Git 无法确定应该怎样合并； 应对方法：解决冲突后手动 commit。   HEAD 领先于目标 commit：Git 什么也不做，空操作； HEAD 落后于目标 commit：fast-forward。    进阶4：Feature Branching：最流行的工作流 简介 这种工作流的核心内容可以总结为两点：\n 任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； branch 写完后，合并到 master，然后删掉这个 branch。       这就是这种工作流最基本的模型。从上面的动图来看，这种工作流似乎没什么特别之处。但实质上，Feature Branching 这种工作流，为团队开发时两个关键的问题——代码分享和一人多任务——提供了解决方案。 代码分享 举例说明 假设你在一个叫做「掘金」的团队工作，现在你要开发一个叫做「掘金小册」的功能（呵呵），于是你创建了一个新的 branch 叫做 books，然后开始在 books 上进行开发工作。\n1  git checkout -b books”   在十几个 commits 过后，「掘金小册」的基本功能开发完毕，你就把代码 push 到中央仓库（例如 GitHub）去，然后告诉同事：「嘿，小册的基本功能写完了，分支名是 books，谁有空的话帮我 review 一下吧。」\n1  git push origin books”        然后你的同事小明正好有空，他就从中央仓库拉下来了你的代码开始读 1 2  git pull git chekcout books”。   如果同事没意见 读完以后，小明对你说，嗯我看完了，我觉得不错，可以合并到 master！于是你就把 books 合并到了 master 上去。\n1 2 3  git checkout master git pull # merge 之前 pull 一下，让 master 更新到和远程仓库同步 git merge books        紧接着，你把合并后的结果 push 到了中央仓库，并删掉了 books 这个 branch 1 2 3  git push git branch -d books git push origin -d books # 用 -d 参数把远程仓库的 branch 也删了        如果同事有意见 上面讲的是小明对你的代码没有意见，而假如他在你的代码里看到了问题，例如他跑来对你说：「嘿，你的代码缩进为什么用的是 TAB？快改成空格，不然砍死你哦。」这时，你就可以把你的缩进改成空格，然后做一个新的提交，再 push 上去，然后通知他：「我改完啦！」小明 pull 下来你的新提交看了看：「嗯，这下可以合并了。」\n于是你依照上面的那一套操作，把代码合并进 master，并 push 了上去，然后删掉了 books。瞧，代码在同事竖大拇指之前都不会正式发布到 master，挺方便的吧？\n一人多任务 除了代码分享的便捷，基于 Feature Branch 的工作流对于一人多任务的工作需求也提供了很好的支持。\n安安心心做事不被打扰，做完一件再做下一件自然是很美好的事，但现实往往不能这样。对于程序员来说，一种很常见的情况是，你正在认真写着代码，忽然同事过来跟你说：「内个……你这个功能先放一放吧，我们最新讨论出要做另一个更重要的功能，你来做一下吧。」\n其实，虽然这种情况确实有点烦，但如果你是在独立的 branch 上做事，切换任务是很简单的。你只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上「TODO」），然后回到 master 去创建一个新的 branch 就好了。\n1 2  git checkout master git checkout -b new_feature   如果有一天需要回来继续做这个 branch，你只要用 checkout 切回来，就可以继续了。\n总结  每个新功能都新建一个 branch 来写。 写完以后，把代码分享给同事看；写的过程中，也可以分享给同事讨论。 分支确定可以合并后，把分支合并到 master ，并删除分支。  进阶5：关于 add add . add 指令除了 git add 文件名 这种用法外，还可以使用 add . 来直接把工作目录下的所有改动全部放进暂存。这个用法没什么特别的好处，但就俩个字：方便，不过要注意不要误添加其他文件，不想添加到仓库的要使用.gitignore文件。\nadd 添加文件改动，而非文件名 假如你修改了文件 a.txt，然后把它 add 进了暂存区，然后你又往 a.txt 里写了几行东西。这时候你再 status 一下的话，会发现你的 a.txt 既在 \u0026ldquo;Changes to be commited\u0026rdquo; 的暂存区，又在 \u0026ldquo;Changes not staged for commit\u0026rdquo;。不用觉得奇怪，这是因为通过 add 添加进暂存区的不是文件名，而是具体的文件改动内容。你在 add 时的改动都被添加进了暂存区，但在 add 之后的新改动并不会自动被添加进暂存区。在这时如果你提交，那么你那些新的改动是不会被提交的。\n进阶6：看看我都改了什么 log -p 查看详细历史 -p 是 \u0026ndash;patch 的缩写，通过 -p 参数，你可以看到具体每个 commit 的改动细节，log -p 可以看到每一个 commit 的每一行改动，所以很适合用于代码 review。\nlog \u0026ndash;stat 查看简要统计 如果你只想大致看一下改动内容，但并不想深入每一行的细节（例如你想回顾一下自己是在哪个 commit 中修改了 games.txt 文件），那么可以把选项换成 \u0026ndash;stat。\nshow 查看具体的 commit 如果你想看某个具体的 commit 的改动内容，可以用 show。\n  看当前 commit：直接输入“git show”\n  看任意一个 commit：在 show 后面加上这个 commit 的引用（branch 或 HEAD 标记）或它的 SHA-1 码“git show 5e68b0d8”。\n  看指定 commit 中的指定文件：在 commit 的引用或 SHA-1 后输入文件名”git show 5e68b0d8 shopping\\ list.txt“\n  看未提交的内容：如果你想看未提交的内容，可以用 diff。\n  比对暂存区和上一条提交：使用 git diff \u0026ndash;staged 可以显示暂存区和上一条提交之间的不同。换句话说，这条指令可以让你看到「如果你立即输入 git commit，你将会提交什么」”git diff \u0026ndash;staged/\u0026ndash;cached“。\n  比对工作目录和暂存区:使用 git diff （不加选项参数）可以显示工作目录和暂存区之间的不同。换句话说，这条指令可以让你看到「如果你现在把所有文件都 add，你会向暂存区中增加哪些内容」\u0026ldquo;git diff\u0026rdquo;。\n  比对工作目录和上一条提交：使用 git diff HEAD 可以显示工作目录和上一条提交之间的不同，它是上面这二者的内容相加。换句话说，这条指令可以让你看到「如果你现在把所有文件都 add 然后 git commit，你将会提交什么」不过需要注意，没有被 Git 记录在案的文件（即从来没有被 add 过 的文件，untracked files 并不会显示出来。）”git diff HEAD“（也可以换为其他commit）\n  总结  查看历史中的多个 commit： git log  查看详细改动： git log -p 查看大致改动：git log \u0026ndash;stat   查看具体某个 commit：show  要看最新 commit ，直接输入 git show ；要看指定 commit ，输入 git show commit的引用或SHA-1 如果还要指定文件，在 git show 的最后加上文件名   查看未提交的内容：diff  查看暂存区和上一条 commit 的区别：git diff \u0026ndash;staged（或 \u0026ndash;cached） 查看工作目录和暂存区的区别：git diff 不加选项参数 查看工作目录和上一条 commit 的区别：git diff HEAD    高级1：不喜欢 merge 的分叉？用 rebase 吧 rebase——在新位置重新提交 rebase ，又是一个中国人看不懂的词。这个词的意思，你如果查一下的话是“变基”。（哈？玩个 Git 就弯了？）其实这个翻译还是比较准确的。rebase 的意思是，给你的 commit 序列重新设置基础点（也就是父 commit）。展开来说就是，把你指定的 commit 以及它所在的 commit 串，以指定的目标 commit 为基础，依次重新提交一次。\n1 2  git checkout branch1 git rebase master        可以看出，通过 rebase，5 和 6 两条 commits 把基础点从 2 换成了 4 。通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 rebase 的含义。另外，在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit： 1 2  git checkout master git merge branch1        为什么要从 branch1 来 rebase，然后再切回 master 再 merge 一下这么麻烦，而不是直接在 master 上执行 rebase？从图中可以看出，rebase 后的 commit 虽然内容和 rebase 之前相同，但它们已经是不同的 commits 了。如果直接从 master 执行 rebase 的话，就会是下面这样：\n     这就导致 master 上之前的两个最新 commit 被剔除了。如果这两个 commit 之前已经在中央仓库存在，这就会导致没法 push 了：      所以，为了避免和远端仓库发生冲突，一般不要从 master 向其他 branch 执行 rebase 操作。而如果是 master 以外的 branch 之间的 rebase（比如 branch1 和 branch2 之间），就不必这么多费一步，直接 rebase 就好。（你想保留哪个分支就rebase到哪个分支） 总结 本节介绍的是 rebase 指令，它可以改变 commit 序列的基础点。它的使用方式很简单：\n1  git rebase 目标基础点   需要说明的是，rebase 是站在需要被 rebase 的 commit 上进行操作，这点和 merge 是不同的。\n高级2：刚刚提交的代码，发现写错了怎么办？ 刚提交了一个代码，发现有几个字写错了，怎么修复？当场再写一个修复这几个错别字的 commit？可以是可以，不过还有一个更加优雅和简单的解决方法：commit -—amend。\n\u0026ldquo;amend\u0026rdquo; 是「修正」的意思。在提交时，如果加上 \u0026ndash;amend 参数，Git 不会在当前 commit 上增加 commit，而是会把当前 commit 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 commit，用这个新的 commit 把当前 commit 替换掉。所以 commit \u0026ndash;amend 做的事就是它的字面意思：对最新一条 commit 进行修正。\n1 2  git add demo.txt git commit --amend   Git 会把你带到提交信息编辑界面。可以看到，提交信息默认是当前提交的提交信息。你可以修改或者保留它，然后保存退出。然后，你的最新 commit 就被更新了。\n     总结 这一节的内容只有一点：用 commit \u0026ndash;amend 可以修复当前提交的错误。使用方式：\n1  git commit --amend   需要注意的有一点：commit \u0026ndash;amend 并不是直接修改原 commit 的内容，而是生成一条新的 commit。\n高级3：写错的不是最新的提交，而是倒数第二个？ rebase -i：交互式 rebase 如果不是最新的 commit 写错，就不能用 commit \u0026ndash;amend 来修复了，而是要用 rebase。不过需要给 rebase 也加一个参数：-i。\nrebase -i 是 rebase \u0026ndash;interactive 的缩写形式，意为「交互式 rebase」。所谓「交互式 rebase」，就是在 rebase 的操作执行之前，你可以指定要 rebase 的 commit 链中的每一个 commit 是否需要进一步修改。那么你就可以利用这个特点，进行一次「原地 rebase」。\n例如你是在写错了 commit 之后，又提交了一次才发现之前写错了。\n开启交互式 rebase 过程 现在再用 commit \u0026ndash;amend 已经晚了，但可以用 rebase -i：\n1  git rebase -i HEAD^^   补充说明：在 Git 中，有两个「偏移符号」： ^ 和 ~。\n ^ 的用法：在 commit 的后面加一个或多个 ^ 号，可以把 commit 往回偏移，偏移的数量是 ^ 的数量。例如：master^ 表示 master 指向的 commit 之前的那个 commit； HEAD^^ 表示 HEAD 所指向的 commit 往前数两个 commit。 ~ 的用法：在 commit 的后面加上 ~ 号和一个数，可以把 commit 往回偏移，偏移的数量是 ~ 号后面的数。例如：HEAD~5 表示 HEAD 指向的 commit往前数 5 个 commit。  上面这行代码表示，把当前 commit （ HEAD 所指向的 commit） rebase 到 HEAD 之前 2 个的 commit 上：\n     如果没有 -i 参数的话，这种「原地 rebase」相当于空操作，会直接结束。而在加了 -i 后，就会跳到一个编辑界面。\n     编辑界面：选择 commit 和对应的操作 这个编辑界面的最顶部，列出了将要「被 rebase」的所有 commits，也就是倒数第二个 commit 「增加常见笑声集合」和最新的 commit「增加常见哭声集合」。需要注意，这个排列是正序的，旧的 commit 会排在上面，新的排在下面。\n这两行指示了两个信息： 需要处理哪些 commits； 怎么处理它们。\n你需要修改这两行的内容来指定你需要的操作。每个 commit 默认的操作都是 pick （从图中也可以看出），表示「直接应用这个 commit」。所以如果你现在直接退出编辑界面，那么结果仍然是空操作。但你的目标是修改倒数第二个 commit，也就是上面的那个「增加常见笑声集合」，所以你需要把它的操作指令从 pick 改成 edit 。 edit 的意思是「应用这个 commit，然后停下来等待继续修正」。把 pick 修改成 edit 后，就可以退出编辑界面了。\n修改写错的 commit 修改完成之后，和上节里的方法一样，用 commit \u0026ndash;amend 来把修正应用到当前最新的 commit：\n1 2  git add demo.txt git commit --amend   继续 rebase 过程 在修复完成之后，就可以用 rebase \u0026ndash;continue 来继续 rebase 过程，把后面的 commit 直接应用上去。然后，这次交互式 rebase 的过程就完美结束了，你的那个倒数第二个写错的 commit 就也被修正了.\n1  git rebase --continue        总结  使用方式是 git rebase -i 目标commit； 在编辑界面中指定需要操作的 commits 以及操作类型； 操作完成之后用 git rebase \u0026ndash;continue 来继续 rebase 过程。  高级4：比错还错，想直接丢弃刚写的提交？ 有的时候，刚写完的 commit 写得实在太烂，连自己的都看不下去，与其修改它还不如丢掉重写。这种情况，就可以用 reset 来丢弃最新的提交。\nreset \u0026ndash;hard 丢弃最新的提交 比如你刚写了一个 commit，写完回头看了看，你觉得「不行这得重新写」。那么你可以用 reset \u0026ndash;hard 来撤销这条 commit（HEAD 表示 HEAD^ 往回数一个位置的 commit）。HEAD^ 表示你要恢复到哪个 commit。因为你要撤销最新的一个 commit，所以你需要恢复到它的父 commit ，也就是 HEAD^。那么在这行之后，你的最新一条就被撤销了\n1  git reset --hard HEAD^        不过，就像图上显示的，你被撤销的那条提交并没有消失，只是你不再用到它了。如果你在撤销它之前记下了它的 SHA-1 码，那么你还可以通过 SHA-1 来找到他它。 总结 这一节的内容是撤销最新的提交，方式是通过 reset \u0026ndash;hard：\n1  git reset --hard 目标commit   高级5：想丢弃的也不是最新的提交？ 还没看懂。\n高级6：代码已经 push 上去了才发现写错？ 有的时候，代码 push 到了中央仓库，才发现有个 commit 写错了。这种问题的处理分两种情况：\n出错的内容在你自己的 branch 假如是某个你自己独立开发的 branch 出错了，不会影响到其他人，那没关系用前面几节讲的方法把写错的 commit 修改或者删除掉，然后再 push 上去就好了。不过由于你在本地对已有的 commit 做了修改，这时你再 push 就会失败，因为中央仓库包含本地没有的 commits。但这个和前面讲过的情况不同，这次的冲突不是因为同事 push 了新的提交，而是因为你刻意修改了一些内容，这个冲突是你预料到的，你本来就希望用本地的内容覆盖掉中央仓库的内容。那么这时就不要乖乖听话，按照提示去先 pull 一下再 push 了，而是要选择「强行」push（-f 是 \u0026ndash;force 的缩写，意为「忽略冲突，强制 push」）：\n1  git push origin branch1 -f   这样，在本地修改了错误的 commits，然后强制 push 上去，问题就解决了。\n出错的内容已经合并到 master 这就不能用上面那招了。同事的工作都在 master 上，你永远不知道你的一次强制 push 会不会洗掉同事刚发上去的新提交。所以除非你是人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 master 上强制 push。\n在这种时候，你只能退一步，选用另一种策略：增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。这种事做起来也不算麻烦，因为 Git 有一个对应的指令：revert。\n它的用法很简单，你希望撤销哪个 commit，就把它填在后面：\n1  git revert HEAD^   上面这行代码就会增加一条新的 commit，它的内容和倒数第二个 commit 是相反的，从而和倒数第二个 commit 相互抵消，达到撤销的效果。\n在 revert 完成之后，把新的 commit 再 push 上去，这个 commit 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 commit ：一个原始 commit ，一个对它的反转 commit。\n总结 这节的内容是讲当错误的 commit 已经被 push 上去时的解决方案。具体的方案有两类：\n 如果出错内容在私有 branch：在本地把内容修正后，强制 push (push -f）一次就可以解决； 如果出错内容在 master：不要强制 push，而要用 revert 把写错的 commit 撤销。  高级7：reset 的本质\u0026ndash;不止可以撤销提交 待补充\n高级8：checkout 的本质 介绍 在前面的 branch 的部分，我说到 checkout 可以用来切换 branch。不过实质上，checkout 并不止可以切换 branch。checkout 本质上的功能其实是：签出（ checkout ）指定的 commit。\ngit checkout branch名 的本质，其实是把 HEAD 指向指定的 branch，然后签出这个 branch 所对应的 commit 的工作目录。所以同样的，checkout 的目标也可以不是 branch，而直接指定某个 commit：\n1 2 3 4  git checkout HEAD^^ git checkout master~5 git checkout 78a4bc git checkout 78a4bc^   另外，如果你留心的话可能会发现，在 git status 的提示语中，Git 会告诉你可以用 checkout \u0026ndash; 文件名 的格式，通过「签出」的方式来撤销指定文件的修改。\n总结 这节的内容是对 checkout 的本质进行简述：checkout 的本质是签出指定的 commit，所以你不止可以切换 branch，也可以直接指定 commit 作为参数，来把 HEAD 移动到指定的 commit。\ncheckout 和 reset 的不同 checkout 和 reset 都可以切换 HEAD 的位置，它们除了有许多细节的差异外，最大的区别在于：reset 在移动 HEAD 时会带着它所指向的 branch 一起移动，而 checkout 不会。当你用 checkout 指向其他地方的时候，HEAD 和 它所指向的 branch 就自动脱离了。\n高级9：紧急情况：「立即给我打个包，现在马上！」 介绍 前面在讲 branch 的时候讲到，利用 branch 可以实现一人多任务的需求，从而可以轻松应对「嘿，这个先别做了，给你个新活」的情况。但有时，尤其是在互联网公司，你可能会遇到比这更紧急的情况：你正对着电脑发呆，忽然见到一个同事屁股着着火就跑来找你了：「快快快，立即给我打个包，现在马上，拜托拜托！」\n这种情况和「这个 branch 先放放吧」不同，你没时间、也没必要当场慌慌张张把文件的所有改动做个临时的 commit 然后去救同事的火，救完火再重新把 commit 撤销回来。这时候你只要先把所有文件一股脑扔在一边就可以去给同事打包了，打完包再把刚才扔到一边的文件重新取过来就好。\n这一「扔」一「取」，用的是 Git 的 stash 指令。\nstash：临时存放工作目录的改动 \u0026ldquo;stash\u0026rdquo; 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。在 Git 中，stash 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。具体说来，stash 的用法很简单。当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么你可以”git stash“。\n就这么简单，你的工作目录的改动就被清空了，所有改动都被存了起来。然后你就可以从你当前的工作分支切到 master 去给你的同事打包了打完包，切回你的分支，然后”git stash pop“。你之前存储的东西就都回来了。很方便吧？\n注意：没有被 track 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 `-u` 参数，它是 `\u0026ndash;include-untracked` 的简写。就像这样”git stash -u\n“。\n高级10：branch 删过了才想起来有用？ branch 用完就删是好习惯，但有的时候，不小心手残删了一个还有用的 branch ，或者把一个 branch 删掉了才想起来它还有用，怎么办？\nreflog ：引用的 log reflog 是 \u0026ldquo;reference log\u0026rdquo; 的缩写，使用它可以查看 Git 仓库中的引用的移动记录。如果不指定引用，它会显示 HEAD 的移动记录。假如你误删了 branch1 这个 branch，那么你可以查看一下 HEAD 的移动历史”git reflog“。从移动历史中可以看出 HEAD 的最后一次移动行为是「从 branch1 移动到 master」。而在这之后，branch1 就被删除了。所以它之前的那个 commit 就是 branch1 被删除之前的位置了，也就是第二行的 c08de9a。所以现在就可以切换回 c08de9a，然后重新创建 branch1。\n1 2  git checkout c08de9a git checkout -b branch1   这样，你刚删除的 branch1 就找回来了。\n注意：不再被引用直接或间接指向的 commits 会在一定时间后被 Git 回收，所以使用 reflog 来找回删除的 branch 的操作一定要及时，不然有可能会由于 commit 被回收而再也找不回来。\n查看其他引用的 reflog reflog 默认查看 HEAD 的移动历史，除此之外，也可以手动加上名称来查看其他引用的移动历史，例如某个 branch ”git reflog master“。\n额外说点：.gitignore——排除不想被管理的文件和目录 在 Git 中有一个特殊的文本文件：.gitignore。这个文本文件记录了所有你希望被 Git 忽略的目录和文件。\n如果你是在 GitHub 上创建仓库，你可以在创建仓库的界面中就通过选项来让 GitHub 帮你创建好一个符合项目类型的 .gitignore 文件，你就不用再自己麻烦去写一大堆的配置了。不过如果你不是在 GitHub 上创建的项目，或者你对 GitHub 帮你创建的 .gitignore 文件有一些额外的补充，那么你可以自己来编辑这个文件。\n.gitignore大概长这样（#是注释内容，*是通配符）：\n# ignore file type1 *.o *.elf tmp.s # ignore file type2 bin/ gen/ out/file1/ 总结 写给读者 Git 内容非常多，这本小册我已经尽量克制，可是还是写了二十多节出来。尽管这样，有些很有用的内容我依然没有写出来。因为我写这本小册的目的是解决大部分人「学不会 Git」和「用了很久却总用不好 Git」这两个问题，所以我在这本小册里重点讲的也是 Git 的学习和使用中那些既重要又困难的关键点。\n如果你在整个阅读过程中是边读边练的，相信读到这里，你对 Git 已经有一个较为全面和深刻的认识了。接下来你只要在平时使用 Git 的过程中多留心一些，找机会把这本小册中的内容应用在实战，很快就可以成为众人眼中的「Git 高手」了。当然，到时候你也许也会发现，其实大家眼中的「Git 高手」远没有那么神秘，并不一定比别人懂很多，只是更加了解 Git 的工作原理和一些关键概念罢了。\n几个「不难但却很有用」的 Git 技能点 除了这本小册里讲到的那些「关键点」，还有些 Git 的相关知识虽然也比较有用，但属于稍微研究一下就可以学会的内容，我就不讲了，只在这里做一个简单的列举，你在平时使用 Git 的时候记得抽空学习一下就好。\n tag：不可移动的 branch。tag 是一个和 branch 非常相似的概念，它和 branch 最大的区别是：tag 不能移动。所以在很多团队中，tag 被用来在关键版本处打标记用。 cherry-pick：把选中的 commits 一个个合并进来。cherry-pick 是一种特殊的合并操作，使用它可以点选一批 commits，按序合并。 git config： Git 的设置。git config 可以对 Git 做出基础设置，例如用户名、用户邮箱，以及界面的展示形式。内容虽然多，但都不难，整体看一遍，把 Git 设置成你最舒服的样子，从此就再也不用管它了。属于「一次付出，终身受用」的高性价比内容。 Git Flow：复杂又高效的工作流。除了前面讲到的 \u0026ldquo;Feature Branching\u0026rdquo;，还有一个也很流行的工作流：Git Flow。Git Flow 的机制非常完善，很适合大型团队的代码管理。不过由于它的概念比较复杂（虽然难度并不高），所以并不适合新手直接学习，而更适合在不断的自我研究中逐渐熟悉，或者在团队合作中慢慢掌握。基于这个原因，我最终也没有在这本小册里讲 Git Flow，但我推荐你自己在有空的时候了解一下它。  更多内容 更多内容可到Git官网查看详细文档。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":18,"section":"docs","tags":["Git"],"title":"Git原理详解及实用指南","uri":"https://www.wenhui.space/docs/06-linux-skills/tools-skills/git_introduction_and_userguide/"},{"content":"本文 主要介绍将网页内容保存到本地的几个方法。\n   版本 说明     0.1 初版发布    网页另存为 浏览器对网页都有一个另存为的功能，右键选择另存为或快捷键Ctrl-s。网页另存为是将整个网页以静态网页形式下载到本地。下载的文件包含个文件夹和html文件，文件夹内包含js（JavaScript）文件，css（Cascading Style Sheets）文件，以及一些图标文件等，总之文件夹内的内容是对网页显示进行渲染，而html文件是网页主要内容和框架文件，会调用文件夹内一些文件。以上是非专业的解释，总之有文件夹内的内容网页就相当于是彩色的，没有就变成黑白的了，而且还会丢失一些图标显示。对于使用者将文件夹和html文件通通保留，使用浏览器打开html文件即可。\n使用网页另存为的方式保存网页内容，是可以高度还原的，换句话说只不过将服务器的网页内容下载到了本地。\n网页打印 谷歌浏览器（可能还有别的浏览器）提供了网页打印功能。打开网页，右键选择打印或快捷键Ctrl-p，其中可以直接使用打印机进行打印，还可以使用另存为pdf。另存为pdf就很实用了，相当于将网页内容进行扫描保存在pdf文件，另外还可以自定义页数。除此之外，还可以选择保存到谷歌云端，保存到云端就相当于自己备份了内容，即便网页源内容删除了，自己还可以通过谷歌云端查看；类似的功能firefox可以保存到pocket，不过这个pocket是本地和云端同步的，也就是说除了备份了内容你还可以离线查看。\n网页截图 firefox提供了网页截图功能，不同于电脑自带的截图工具，它可以对整个网页进行截图。相当于手机中的长截图功能。截图的好处就是，如果你想将网页内容分享给其他人，但是又想隐藏部分内容，那就可以通过网页截图，再使用图片编辑工具进行截图，既能截去部分内容，还可以保持图片内容基本的清晰度（相对于缩小页面在通过自带截图工具截图）。\n另一种无耻做法 浏览的网页内容，往往我们只是对部分内容感兴趣，我们可以将部分内容保存截图，当然这不是一个好的方法，最好的方法是将需要的内容提取出来，保存到自己的文档中。一般会有以下几种情况：\n 有的网页是支持文字复制的，那就直接复制即可，这里就有个小技巧了，如果不想复制字体格式颜色等等，可以右键选择只复制文本，如果还行不通的话，可以临时打开一个txt文件，将复制内容粘贴到txt文档，再次复制粘贴到文档中。 有的网页出于各种原因（主要是知识产权和会员权限），不支持复制功能，这时候就需要其他方法了，可以使用图片文字识别工具，截图后上传到该工具，识别为文字。这里推荐使用迅捷工具，可以选择txt，直接复制粘贴识别的文字，也可以选择doc或docx，只不过识别的文字需要下载文件。其他功能请自行探索。 如果是视频呢，怕是我们只能依赖图片识别工具了。 迅捷图片文字识别工具网页版 迅捷工具具有一系列功能： 文档转换如pdf转doc，文档处理如分割pdf，文档翻译，图片文字识别，以及语音识别。 友情提示： 如果采用他人知识产物，请注明出处，这是对作者的尊重。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":19,"section":"docs","tags":null,"title":"如何保存网页内容到本地","uri":"https://www.wenhui.space/docs/05-windows-skills/save_web_content_to_local/"},{"content":"本文 主要记录对版本控制工具Git的基本使用命令。\n   版本 说明     0.1 初版发布    学习资源  Git 完整命令手册地址 菜鸟教程-Git教程 廖雪峰-Git教程  新手入门 建立仓库 使用Git前，需要先建立一个仓库(repository)。（如果自己练习，你需要建立一个仓库，如果在工作中，往往已经有人创建好仓库）\n 使用您当前目录作为Git仓库，我们只需使它初始化。   git init  使用我们指定目录作为Git仓库。   git init newrepo  如果是别人已经创建好的仓库，我们需要克隆到本地（url是仓库的网址，可以是ssh格式也可以是http格式）。   git clone url 添加新文件  已经建立了一个空仓库（如果是已有仓库，可在指定目录下创建自己的文件然后添加到仓库），可以使用add命令添加文件。   git add filename  可以使用git add一次添加多个文件，也可以使用git add依次添加。（也可以是文件夹）   git add filename1 git add filename2 ... 提交版本 已经将文件进行了添加，我们希望它们能够真正被保存在Git仓库。为此，我们将它们提交到仓库。-m后是注释内容\ngit commit -m \u0026quot;Adding files\u0026quot; 如果您不使用-m，会出现编辑器来让你写自己的注释信息。\n发布版本 现在已经对新加或修改的文件进行了添加和提交，此时文件已经记录在本地仓库，现在可以进行推送到远程服务器。\ngit push 内容更新 由于项目是多人开发，每个人都可以进行提交，为了将别人提交的修改内容更新到自己的本地仓库，需要使用如下命令：\ngit pull 注意，如果在更新之后，又有人进行了更新，此时自己也进行了修改个提交，这时候会发生冲突，因为你不是在最新的版本上进行更新的，或者说你当前的提交会覆盖掉其他人最新的修改，所以是不允许的，解决冲突的方法后续再讲，这里需要提示的是，在修改和提交之前，一定要记得先pull。\n基本使用命令 新建仓库 在选择github、码云或gitlab等网页，完成新建仓库操作，主要会涉及设置仓库名、私有or公开等信息。\n将远程仓库克隆到本地 1 2  # repo_url 是远程仓库网址，可以是http格式，也可以是ssh格式(需要设置ssh秘钥) git clone repo_url   在本地新建分支 1  git branch new_branch_name   在本地切换分支 1  git checkout branch_name   新建加切换一步操作：\n1  git checkout -b new_branch_name   查看分支状态 前面代表本地分支，带remotes/origin/的是远程分支，*号代表当前所在的本地分支。\n1  git branch -a   查看当前状态 可以查看到当前所在分支，当前文件修改状态和新添加的文件。\n1  git status   添加至git追踪 当查看修改状态后，可以将某些修改添加至git追踪，换句话说，没有添加的文件，后面提交时则不会被提交。\n可以多次add后，最后统一提交。\nadd对象后可以是文件，也可以是文件夹，如果是文件夹，会将该文件夹下的所有修改文件和新文件添加至git追踪。\n1  git add filename   本地提交 已经将文件进行了添加，我们希望它们能够真正被保存在Git仓库。为此，我们将它们提交到仓库。-m后是注释内容\ngit commit -m \u0026quot;Adding files\u0026quot; 推送到远程仓库 git push 将远程分支更新到本地并切换 有时候新clone的git库，本地只有master分支，希望将远程分支更新到本地。\n1  git checkout -t origin/分支名   将本地分支push到远程 1  git push origin 本地分支名   删除本地分支 1  git branch -d 本地分支名   删除远程分支 1  git push --delete origin 远程分支名   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":20,"section":"docs","tags":["Git"],"title":"Git的基本使用命令","uri":"https://www.wenhui.space/docs/06-linux-skills/tools-skills/git-use-tips/"},{"content":"本文 主要记录SV与UVM的一些知识点，每日一问，每日一记。\n   版本 说明     0.1 初版发布    写在前头 本文非原创，内容来自路科验证，整理成文并持续更新。\n每日一问 在一些头文件(.svh) 中， 会有typedef class X， 这是什么意思?  回答： 首先这需要与常见的typedef enum/struct\u0026hellip;x_t的类型定义区别；真正的类的定义依然是利用“Xextends\u0026hellip;”的方式实现， 而这里则是为了编译时能够让编译器识别class X采取的“占坑”方法， 即先“声明”类X的存在，并且在后续将X的定义字段“Xextends\u0026hellip;”进行补充编译。 关键词： typedef class 避坑指南： typedef class常常用来解决两个类之间的互相引用问题，即在A中使用B，且在B中使用A。  在enum/struct类型声明时， 添加typedef与否的差别是什么?  回答： 如果不添加typedef， 例如enum(NO， YES) bool，那么bool为枚举类型“变量”， 而“enum(NO， YES) ” 按照“匿名类型”(implicit type)来理解；如果添加typedef， 例如typedef enum(NO， YES) bool_t， 那么bool_t为枚举类型， 即通过typedef将匿名类型“显式”(explicitly) 定义为bool_t， 并且接下来可重复利用bool_t来声明多个变量。 关键词： enum，struct， typedef 避坑指南： 对于重复使用的enum/struct定义， 默认添加typedef先定义类型， 再利用该类型声明变量。  Interface的mod port和clocking block如何使用?  回答： 这两个概念得需要独立看待。Mod port是将interface中的信号列表按类分簇(grouping)，便于模块之间、模块与TB之间的连线管理； clocking block并非interface的专属产物， 不过多见于interface使用它进行数据信号采样或者驱动， 继而有效避免delta cycle问题，并通过波形上的可见延迟帮助理解仿真时序。 关键词： interface，mod port， clocking block 避坑指南： mod port和clocking在连接时方向不要混淆，在它们中只需对若干已声明信号再次声明方向即可。  Module中的Initial额always执行先后顺序是否与它们的代码位置有关?  回答： Module中的initial和always执行先后顺序是always在综合逻辑中， 以及initial在初始化激励序列中，彼此过程块之间都是“并行”的，这是从模拟硬件执行角度来理解“并行”；同时，仿真器即便要处理这些过程块语句，也需要从软件语句执行着手，这意味着同一个仿真时刻执行的并行语句，也需要由仿真器安排它们的执行顺序，这是从仿真软件执行角度来理解“顺序”。 关键词： 执行顺序， initial， always 避坑指南： 不对多个initial执行顺序做假设。如果要按照顺序执行， 可将逻辑放置在同一个initial块， 或者使用event实现线程间同步。  组合型数组和非组合型数组如何做赋值?  回答： 组合型数组之间赋值时可以将不同维度、不同元素数量的数组直接做赋值(注意位宽默认补全或者截取)；非组合型数组之间赋值有严格要求必须相同维度且各维度元素数量须相等，可直接赋值，但如果不满足该条件则只能对数组中的元素做逐一赋值。 关键词： 组合型，非组合型，赋值 避坑指南： 组合型数组可直接赋值；非组合型数组直接赋值要求繁多，逐一赋值最安全。  类中的成员变量在声明时初始化或者在new函数中初始化是否有区别?  回答： 从实现结果来看都可以对成员变量在对象创建时完成初始化，但如果两个动作均发生了，那么应该注意变量声明初始化执行在前(空间开辟动作)，而new函数对成员变量初始化在后(构建函数体内部对成员变量做初始化操作) 关键词： 变量声明，构建函数，初始化 避坑指南： 搞清楚两者的执行顺序，按照代码习惯只选择一种即可。  组合型(packed)数组和非组合型数组(unpacked)怎么区分?  回答： 数组维度声明在数组变量名左侧的为组合型数组，例如byte[3：0] [1：0] array 1为组合型4*2二维数组。数组维度声明在数组变量名右侧的为非组合型数组，例如bytearray 2[5：0] [7：0] 为非组合型6*8二维数组。混合型数组byte[3：0] [1：O] array 3[5：O] [7：0] 为6*8*4*2的四维混合数组。 关键词： 组合型，非组合型 避坑指南： 数组维度从高到低是先看数组名右侧(从左到右)，再看数组名左侧(人左到右)o  include和import的差别在哪里?  回答： SV常会用\u0026rsquo;include将多个文件“平铺”(flatten) 置于某个域中(scope) ， 这个域可能是package/ module/ interface等， 简单理解`include就是将对应文本的  内容“平铺”到当前域的字段中。import则是从包(package) 中引用某些需要的数据类型，例如class/parameter/enum到当前域中， 以帮助编译器能够识别被亏用的类型。\n 关键词： `include， import 避坑指南： `include部分会由编译器编译， import部分会由编译器从库中查找导出。  在哪里应该使用`include?  回答： `include使用的地方多见于在包(package) 文件中将多个其它类文件“平铺”于其中，从而在编译时能够将多个文件中定义的类置于这个包中，形成一种逻辑上的包含关系； 同时， 在module文件也可能会使用`include， 使其“平铺”一些宏定义文件或者接口文件。 关键词： include 避坑指南： 一个包通过include包含多个文件， 在编译该包后， 不再需要对被＼include文件做额外编译。  module和interface之间可以相互例化吗?  回答： module可以例化module， 也可以例化interface；interface可以例化interface， 但是不可以例化module。就硬件实现逻辑而言， module之间的嵌套、interface之间的嵌套以及module嵌套interface都符合设计理念， 而interface不需要(也不应该) 例化module。 关键词： module， interface 避坑指南： interface可以例化interface， 但无法例化module。  方法中的参数的默认方向如何辨别?  回答： 关注于系统验证思想和前沿验证资讯，为IC从业人员提供技术食粮。对于function/task， 如果其参数的方向未声明， 那么它的方向为input方向， 如果声明了方向， 那么该参数以及其后续的参数方向均相同。例如function void foo(A， B， output C， D) 中， A和B由于为声明方向， 为input， C和D为声明后的方向，即output。 关键词： 参数方向，默认方向 避坑指南： 对每一个参数都应该声明方向。  return的使用场景有哪些?  回答： return可在function和task中使用。在返回值为void的function， 或者task中调用return， 即会立即退出该方法； 如果function返回值非void， 那么在退出function的同时还会返回数值。 关键词： return， function， task 避坑指南： 在task中也可以使用return立即退出。  task与function的联系差另在哪里?  回答： 二者均可在module、interface、package和class中定义， 并实现一些功能。function执行须即刻返回，无法内置阻塞等待语句，在声明时需指定返回值(包括void) 。task执行无须即刻返回， 可以内置阻塞等待语句(wait、#、@) ， 返回数值只能依靠参数列表中的参数。 关键词： task， function 避坑指南： function可以调用function， 但无法调用task； task既可以调用task， 也可以调用function。  {}操作符号的使用场景有哪些?  回答： 第一，可作为并置运算符“串联”其一些向量或者字符串，例如{a,b}； 第二，可作为复制运算符，例如{4{w}}中内嵌的一对{}； 第三，对组合型数组赋值时，可采用{}，对非组合型数组赋值时，可采用\u0026rsquo;{} (注意单撇号)； 第四，在描述覆盖点和仓时使用{}； 第五，在定义enum/struct时， 使用{} 。 关键词： 花括号，() 避坑指南： SV中应该使用begin\u0026hellip;end的字段切勿使用{}去替代。  方法中的参数如果具有默认值该如何使用?  回答： 方法中参数默认值是实用方式(不建议使用参数默认方向和默认数值类型)。在调用方法并传递参数过程中可按位置或按名称传递参数。在更常见的按位置传递参数过程中，如果某个参数可采用其默认值，那么需要为它留好“空的位置”，除非该默认参数的位置在参数列表的最后。 关键词： 参数默认值，参数传递 避坑指南： 将所有带有默认值的参数声明均放在参数列表的最后，便于外部调用方法时的参数省略。  方法中形式参数的方向描述符inout和ref的差别?  回答： inout方向会在方法调用中完成入口处由外部变量到形式参数的拷贝，以及在方法退出时，由形式参数到外部变量的拷贝， 即一共2次值的拷贝； ref则是将外部变量本身传递进入，即不再发生形式参数的值拷贝过程， ref也可理解为指针(reference) 。 关键词： 形式参数方向， in out， ref 避坑指南： 如果要对某个外部变量进行持续“跟踪”那么应该使用ref方向描述符， 并且在task中对其跟踪。  package中可以定义什么类型?  回答： package中可以定义数据变量、方法(task/function) 、DPI方法声明、class、parameter、cover group和property(断言属性) 等。 关键词： package 避坑指南： package中不可以包含(或编译)module和interface哦~  持续更新\n","description":"","id":21,"section":"docs","tags":["SystemVerilog","UVM"],"title":"每日一问","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/sv-uvm-daily-question/"},{"content":"本文 主要介绍一个基于ARM的bootloader程序框架，其结构和功能都比较简单，主要作为CPU验证中裸机程序代码框架使用。\n   版本 说明     0.1 初版发布    背景 在CPU验证中，出于各种原因，经常需要通过汇编程序来实现定向测试，不管是TOP验证环境还是UT验证环境，都有这样的需求。\nTOP环境中，需要提供elf文件并生成二进制码存入指令存储器，然后指定复位地址，启动后整个CPU就可以运行起来了。通过编写汇编程序并编译为elf文件，可实现CPU的定向测试。有了elf文件只是解决了激励的问题，关于功能正确性的保证还需要ARM提供的仿真模型fastmodel。\nUT环境中，有些dut是与指令耦合度比较高的模块，使用汇编程序的方式实现定向测试也是非常必要的。这里与指令耦合度高是指，容易从指令码转换为模块接口信号，比如DPU模块。DPU前接IFU模块，IFU对指令码进行预译码后交给DPU，所以只需要将IFU的预译码逻辑植入DPU验证环境，就可以实现将指令码转为DPU的接口信号，从而实现以汇编程序实现DPU的定向测试。\n编译工具  A64：aarch64-linux-gnu A32：armv8l-linux-gnueabihf  下载网址： https://releases.linaro.org/components/toolchain/binaries/\nBootloader需要做什么 我对Linux Kernel的了解比较粗浅，所以下文内容仅供参考。\n 初始化系统寄存器 设置异常向量表 初始化栈和堆 检查和初始化外设 初始化内存管理、开启mmu和cache \u0026hellip;\u0026hellip;  此bootloader框架主要作为CPU验证中裸机程序代码框架使用，所以只需要完成系统寄存器的初始化和异常向量表，如果会用到c程序则需要初始化栈，其他功能在此bootloader框架中并未实现。\n文件结构 simple_bootloader ├── a32_test │ ├── a32_test.s │ ├── link.lds │ ├── Makefile │ ├── your_testcode.s │ └── thumb_test.inc ├── a64_test │ ├── a64_test.s │ ├── link.lds │ ├── Makefile │ └── your_testcode.s ├── link.lds ├── Makefile ├── Makefile.def └── system ├── asmlib.inc ├── evt.inc ├── Makefile ├── start.s └── sysregs_init.inc 整个代码环境分为三个部分：System、A64_test、A32_test。\n System：整个程序执行流程的控制。 A64_test：A64指令类型的测试程序。 A32_test：A32以及Thumb类型的测试程序。  AArch64与AArch32混合编程 ARMv8中，AArch64和AArch32是通过异常进行切换的。而A32和T32是通过bx指令进行切换的。如下图：\n     也就是CPU启动是在EL3，处于AArch64，在EL3设置EL2的架构为AArch32，设置好返回地址，通过ERET指令，切换到EL2，就可以执行A32指令了。\n这里会有一个问题，AArch64和AArch32的编译链接工具不同，无法进行混合的链接。解决办法是将A32测试程序生成elf文件再生成bin文件，在链接时链接A32的bin文件。这里干脆把A64的测试程序也使用bin文件链接的方式，而顶层只保留系统文件，这样结够更加清晰。另外A64测试程序、A32测试程序、系统程序相互独立，可以在单独的环境进行编译调试。\nsystem目录 system目录下的文件主要实现对指令执行流程的控制、系统寄存器的配置、异常向量表和异常等级切换、A64和A32执行状态切换等内容。\nstart.s文件 start.s是主程序，也是整个程序的入口，主要功能是整个程序执行流程的控制，执行流程如下：\n 程序启动时处于A64状态，在EL3异常等级。 关闭多核，仅开启cpu0运行。 系统寄存器配置。 设置栈空间和进行栈指针初始化。 切换至EL0状态。 （可配置编译选项）在EL0下执行A64测试程序，并打印执行结果（TEST PASSED / FAILED）。 通过SVC指令切换至EL1状态。 （可配置编译选项）在EL1下执行A64测试程序，并打印执行结果（TEST PASSED / FAILED）。 通过HVC指令切换至EL2状态。 （可配置编译选项）在EL2下执行A64测试程序，并打印执行结果（TEST PASSED / FAILED）。 通过SMC指令切换至EL3状态。 （可配置编译选项）在EL3下执行A64测试程序，并打印执行结果（TEST PASSED / FAILED）。 （可配置编译选项）设置scr_el3，通过异常返回，切换至A32状态，并执行A32测试程序以及Thumb测试程序。 程序执行结束。  以下是代码内容：\n global声明标号为全局，这样其他文件程序可以直接使用该标号 这里通过svc hvc smc来产生异常，改变exception level，来实现在不同level下测试程序，注意这里exception level的改变需要配合异常处理程序来实现。 start程序就是整个程序的入口，并在这里调用其他子程序。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  .global _start _start: bl _disable_mp bl _sysregs_init bl _stack_init bl _el3_to_el0_ns //---------------------------- .global _sys_a64_test _sys_a64_test: //el0 test .if TEST_A64_EL0==1 bl _a64_test bl _print_result .endif //el1 test svc #0x0  .if TEST_A64_EL1==1 bl _main_test bl _print_result .endif //el2 test hvc #0x0  .if TEST_A64_EL2==1 bl _main_test bl _print_result .endif //el3 test smc #0x0  .if TEST_A64_EL3==1 bl _main_test bl _print_result .endif //---------------------------- //---------------------------- .if TEST_A32==1 //el3 to usermode mov x9, #0x30 //RES1  orr x9, x9, #(1 \u0026lt;\u0026lt; 0) //non-secure  orr x9, x9, #(1 \u0026lt;\u0026lt; 8) //HVC enable  orr x9, x9, #(1 \u0026lt;\u0026lt; 10) //set aarch32 el2  msr scr_el3, x9 mov x9, #0x1d0  msr spsr_el3, x9 adr x9, _a32_test msr elr_el3, x9 eret //run a32 test .endif .global _back_from_a32 _back_from_a32: bl _print_result //---------------------------- bl _end_cpu b . .include \u0026#34;./asmlib.inc\u0026#34; .include \u0026#34;./sysregs_init.inc\u0026#34; .include \u0026#34;./evt.inc\u0026#34;   asmlib.inc文件 asmlib.inc是各个子程序的集合，通过start.s中bl实现子程序调用，包含如下：\n 关闭多核，仅开启cpu0运行（目的是使fastmodel的trace信息中只保留主核）。 栈的初始化（初始化栈之后才可以使用c语言）。 打印pass或fail（通过x0来判断是否fail）。 结束程序执行。 el3切换到el0。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  //{{{ 关闭非主核 .global _disable_mp _disable_mp: mrs x9, mpidr_el1 and x9, x9, #0xff  cbnz x9, _cpu_sleep ret _cpu_sleep: wfi b _cpu_sleep //}}} //{{{ 初始化栈 .global _stack_init _stack_init: //STACK_TOP_ADDR = BOARD_BASE_ADDR + BOARD_MEM_SIZE - RESERVE_MEM_TOP // = RVBAR + 2G - 1M //EACH_STACK_SIZE = 64M ldr x9, =RVBAR ldr x10, =0x7ff00000 add x0, x9, x10 //x9: STACK_TOP_ADDR ldr x1, =0x04000000 //x1: EACH_STACK_SIZE mrs x9, CurrentEL cmp x9, #(0b11 \u0026lt;\u0026lt; 2)  b.eq 3f cmp x9, #(0b10 \u0026lt;\u0026lt; 2)  b.eq 2f cmp x9, #(0b01 \u0026lt;\u0026lt; 2)  b.eq 1f b . //系统启动不会在el0状态，这里设置个死循环 3: mov sp, x0 //sp_el3 sub x0, x0, x1 2: msr sp_el2, x0 sub x0, x0, x1 1: msr sp_el1, x0 sub x0, x0, x1 0: msr sp_el0, x0 ret //}}} //{{{ 打印测试结果 .global _print_result _print_result: .if PRINT_RESULT==1 and x9, x0, #0xff  sub x9, x9, #0xff  cbz x9, _test_fail b _test_pass .else ret .endif _test_pass: ldr x9, =0x13000000 //Tube address adr x10, _pass_message_ ldrb w11, [x10], #1 _loop_print_pass: strb w11, [x9] ldrb w11, [x10], #1  cbnz w11, _loop_print_pass ret _test_fail: ldr x9, =0x13000000 //Tube address adr x10, _fail_message_ ldrb w11, [x10], #1 _loop_print_fail: strb w11, [x9] ldrb w11, [x10], #1  cbnz w11, _loop_print_fail ret .align 2 _pass_message_: .asciz \u0026#34;*** TEST PASSED ***\\n\u0026#34; _fail_message_: .asciz \u0026#34;*** TEST FAILED ***\\n\u0026#34; //}}} .align 2 //{{{ 结束CPU .global _end_cpu _end_cpu: mov w9, #0x04  ldr x10, =0x13000000 //Tube address strb w9, [x10] dsb sy ret //}}} //{{{ el3切换到el0_ns .global _el3_to_el0_ns _el3_to_el0_ns: ldr x9, =0x000002c0 msr spsr_el3, x9 adr x9, _sys_a64_test msr elr_el3, x9 eret //}}}   sysregs_init.inc文件 sysregs_init.inc文件主要是对系统寄存器进行初始化配置，这里要结合设计进行适配，使设计和程序运行状态保持一致。具体相关寄存器的含义请查看ARM手册。\n以下是代码内容：\n 注意：这里 \u0026ldquo;b.eq 1f\u0026rdquo; 的用法，1是指标号，f代表向下寻找，这属于常用的汇编技巧。 注意：系统寄存器配置后需要使用isb指令隔离命令，是因为系统寄存器可能存在多个备份来解决负载问题，使用isb指令可以实现各个副本的更新，使其保持一致。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  //{{{ 初始化系统寄存器 .global _sysregs_init _sysregs_init: mrs x9, CurrentEL cmp x9, #(0b11 \u0026lt;\u0026lt; 2)  b.eq 3f cmp x9, #(0b10 \u0026lt;\u0026lt; 2)  b.eq 2f cmp x9, #(0b01 \u0026lt;\u0026lt; 2)  b.eq 1f b . //系统启动不会在el0状态，这里设置个死循环 3: //scr_el3 ldr x9, =0x0000000000000430 //rtl默认的初始值 msr scr_el3, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, scr_el3 bfi x9, x10, #8, #1 // set scr_el3.hce to 1  bfi x9, x10, #0, #1 // set scr_el3.ns to 1  bfi x9, x10, #10, #1 // set scr_el3.rw to 1  msr scr_el3, x9 //cptr_el3 ldr x9, =0x0000000000000000 //rtl默认的初始值 msr cptr_el3, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, cptr_el3 bfi x9, x11, #10, #1 // set scr_el3.tfp to 0  msr scr_el3, x9 //sctlr_el3 ldr x9, =0x0000000000c50838 //rtl默认的初始值 msr sctlr_el3, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el3 msr vbar_el3, x9 2: //hcr_el2 ldr x9, =0x0000000080000002 //rtl默认的初始值 msr hcr_el2, x9 mov x10, #0x1  mov x11, #0x0  mrs x9, hcr_el2 bfi x9, x10, #34, #1 // set hcr_el2.e2h to 1  bfi x9, x11, #27, #1 // set hcr_el2.tge to 0  bfi x9, x10, #31, #1 // set hcr_el2.rw to 1  msr hcr_el2, x9 //cptr_el2 ldr x9, =0x00000000000033ff //rtl默认的初始值 msr cptr_el2, x9 mov x10, #0x3  mov x11, #0x0  mrs x9, cptr_el2 bfi x9, x10, #20, #2 // set cptr_el2.fpen to 11  bfi x9, x11, #10, #1 // set cptr_el2.tfp to 0  msr cptr_el2, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el2 msr vbar_el2, x9 1: //cpacr_el1 ldr x9, =0x0000000000000000 //rtl默认的初始值 msr cpacr_el1, x9 mov x10, #0x3  mov x11, #0x0  mrs x9, cpacr_el1 bfi x9, x10, #20, #2 // set cpacr_el1.fpen to 11  msr cpacr_el1, x9 // exception entry vector addr ldr x9, =_vector_table_route_to_el1 msr vbar_el1, x9 //barrier instr and Synchronize the sysregs isb dsb sy ret //}}}   evt.inc文件 evt.inc文件主要设置异常向量表，以及设置一些异常处理行为这些异常处理行为仅仅为了实现此测试环境的程序执行控制，并没有具体实际含义。关于异常向量表的详细描述，可以浏览之前的博客《AArch64之异常处理》，以及ARM手册。\n以下是代码内容：\n 注意：每一级异常向量要2K对齐，因为VBAR_EL3/2/1寄存器低11bit是reserve的。 注意：sync异常处理没有进行异常返回，而是使用ret返回elr，这样配合svc hvc smc指令来实现el0 -\u0026gt; el1 -\u0026gt; el2 -\u0026gt; el3。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491  /* Vector offsets from vector table base address |--------------------------------------------------------------------------------------------------| | Exception taken from | Offset for exception type | | | Synchronous | IRQ or vIRQ | FIQ or vFIQ | SError or vSError| |*************************************|*************|*************|*************|******************| | Current Exception level with SP_EL0.| 0x000 | 0x080 | 0x100 | 0x180 | |-------------------------------------|-------------|-------------|-------------|------------------| | Current Exception level with SP_ELx,| 0x200 | 0x280 | 0x300 | 0x380 | | x\u0026gt;0. | | | | | |-------------------------------------|-------------|-------------|-------------|------------------| | Lower Exception level, where the | 0x400 | 0x480 | 0x500 | 0x580 | | implemented level immediately lower | | | | | | than the target level is using | | | | | | AArch64. | | | | | |-------------------------------------|-------------|-------------|-------------|------------------| | Lower Exception level, where the | 0x600 | 0x680 | 0x700 | 0x780 | | implemented level immediately lower | | | | | | than the target level is using | | | | | | AArch32. | | | | | |--------------------------------------------------------------------------------------------------| */ //{{{异常路由至el1 .global _vector_table_route_to_el1 .balign 0x1000 //2K对齐，因为VBAR_EL1寄存器低11bit是reserve的 _vector_table_route_to_el1: //offset: 0x000 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el1_current_withspel0_sync //offset: 0x080 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el1_current_withspel0_irq //offset: 0x100 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el1_current_withspel0_fiq //offset: 0x180 //route_to_el1 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el1_current_withspel0_serror //offset: 0x200 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el1_current_withspelx_sync //offset: 0x280 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el1_current_withspelx_irq //offset: 0x300 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el1_current_withspelx_fiq //offset: 0x380 //route_to_el1 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el1_current_withspelx_serror //offset: 0x400 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el1_LoA64toHi_sync //offset: 0x480 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el1_LoA64toHi_irq //offset: 0x500 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el1_LoA64toHi_fiq //offset: 0x580 //route_to_el1 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el1_LoA64toHi_serror //offset: 0x600 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el1_LoA32toHi_sync //offset: 0x680 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el1_LoA32toHi_irq //offset: 0x700 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el1_LoA32toHi_fiq //offset: 0x780 //route_to_el1 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el1_LoA32toHi_serror //}}} //{{{异常路由至el2 .global _vector_table_route_to_el2 .balign 0x1000 //2K对齐，因为VBAR_EL2寄存器低11bit是reserve的 _vector_table_route_to_el2: //offset: 0x000 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el2_current_withspel0_sync //offset: 0x080 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el2_current_withspel0_irq //offset: 0x100 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el2_current_withspel0_fiq //offset: 0x180 //route_to_el2 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el2_current_withspel0_serror //offset: 0x200 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el2_current_withspelx_sync //offset: 0x280 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el2_current_withspelx_irq //offset: 0x300 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el2_current_withspelx_fiq //offset: 0x380 //route_to_el2 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el2_current_withspelx_serror //offset: 0x400 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el2_LoA64toHi_sync //offset: 0x480 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el2_LoA64toHi_irq //offset: 0x500 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el2_LoA64toHi_fiq //offset: 0x580 //route_to_el2 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el2_LoA64toHi_serror //offset: 0x600 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el2_LoA32toHi_sync //offset: 0x680 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el2_LoA32toHi_irq //offset: 0x700 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el2_LoA32toHi_fiq //offset: 0x780 //route_to_el2 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el2_LoA32toHi_serror //}}} //{{{异常路由至el3 .global _vector_table_route_to_el3 .balign 0x1000 //2K对齐，因为VBAR_EL3寄存器低11bit是reserve的 _vector_table_route_to_el3: //offset: 0x000 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; Sync .balign 0x80 b _rt2el3_current_withspel0_sync //offset: 0x080 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; IRQ .balign 0x80 b _rt2el3_current_withspel0_irq //offset: 0x100 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; FIQ .balign 0x80 b _rt2el3_current_withspel0_fiq //offset: 0x180 //route_to_el3 \u0026amp; Current \u0026amp; with SP_EL0 \u0026amp; SERROR .balign 0x80 b _rt2el3_current_withspel0_serror //offset: 0x200 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; Sync .balign 0x80 b _rt2el3_current_withspelx_sync //offset: 0x280 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; IRQ .balign 0x80 b _rt2el3_current_withspelx_irq //offset: 0x300 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; FIQ .balign 0x80 b _rt2el3_current_withspelx_fiq //offset: 0x380 //route_to_el3 \u0026amp; Current \u0026amp; with SP_ELx \u0026amp; SERROR .balign 0x80 b _rt2el3_current_withspelx_serror //offset: 0x400 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; Sync .balign 0x80 b _rt2el3_LoA64toHi_sync //offset: 0x480 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; IRQ .balign 0x80 b _rt2el3_LoA64toHi_irq //offset: 0x500 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; FIQ .balign 0x80 b _rt2el3_LoA64toHi_fiq //offset: 0x580 //route_to_el3 \u0026amp; LoA64toHi \u0026amp; SERROR .balign 0x80 b _rt2el3_LoA64toHi_serror //offset: 0x600 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; Sync .balign 0x80 b _rt2el3_LoA32toHi_sync //offset: 0x680 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; IRQ .balign 0x80 b _rt2el3_LoA32toHi_irq //offset: 0x700 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; FIQ .balign 0x80 b _rt2el3_LoA32toHi_fiq //offset: 0x780 //route_to_el3 \u0026amp; LoA32toHi \u0026amp; SERROR .balign 0x80 b _rt2el3_LoA32toHi_serror //}}} //{{{异常路由至el1-子程序 //-------------------------------------------------------- //rt2el1_current_withspel0 _rt2el1_current_withspel0_sync: // eret and x9, x1, #0xff  sub x9, x9, #0xff  cbz x9, 1f mrs x30, elr_el1 ret 1: adr x10, _back_from_a32 mov x30, x10 ret _rt2el1_current_withspel0_irq: eret _rt2el1_current_withspel0_fiq: eret _rt2el1_current_withspel0_serror: eret //rt2el1_current_withspelx _rt2el1_current_withspelx_sync: // eret and x9, x1, #0xff  sub x9, x9, #0xff  cbz x9, 1f mrs x30, elr_el1 ret 1: adr x10, _back_from_a32 mov x30, x10 ret _rt2el1_current_withspelx_irq: eret _rt2el1_current_withspelx_fiq: eret _rt2el1_current_withspelx_serror: eret //rt2el1_LoA64toHi _rt2el1_LoA64toHi_sync: // eret and x9, x1, #0xff  sub x9, x9, #0xff  cbz x9, 1f mrs x30, elr_el1 ret 1: adr x10, _back_from_a32 mov x30, x10 ret _rt2el1_LoA64toHi_irq: eret _rt2el1_LoA64toHi_fiq: eret _rt2el1_LoA64toHi_serror: eret //rt2el1_LoA32toHi _rt2el1_LoA32toHi_sync: // eret and x9, x1, #0xff  sub x9, x9, #0xff  cbz x9, 1f mrs x30, elr_el1 ret 1: adr x10, _back_from_a32 mov x30, x10 ret _rt2el1_LoA32toHi_irq: eret _rt2el1_LoA32toHi_fiq: eret _rt2el1_LoA32toHi_serror: eret //}}} //{{{异常路由至el2-子程序 //rt2el2_current_withspel0 _rt2el2_current_withspel0_sync: // eret mrs x30, elr_el2 ret _rt2el2_current_withspel0_irq: eret _rt2el2_current_withspel0_fiq: eret _rt2el2_current_withspel0_serror: eret //rt2el2_current_withspelx _rt2el2_current_withspelx_sync: // eret mrs x30, elr_el2 ret _rt2el2_current_withspelx_irq: eret _rt2el2_current_withspelx_fiq: eret _rt2el2_current_withspelx_serror: eret //rt2el2_LoA64toHi _rt2el2_LoA64toHi_sync: // eret mrs x30, elr_el2 ret _rt2el2_LoA64toHi_irq: eret _rt2el2_LoA64toHi_fiq: eret _rt2el2_LoA64toHi_serror: eret //rt2el2_LoA32toHi _rt2el2_LoA32toHi_sync: // eret mrs x30, elr_el2 ret _rt2el2_LoA32toHi_irq: eret _rt2el2_LoA32toHi_fiq: eret _rt2el2_LoA32toHi_serror: eret //}}} //{{{异常路由至el3-子程序 //rt2el3_current_withspel0 _rt2el3_current_withspel0_sync: // eret mrs x30, elr_el3 ret _rt2el3_current_withspel0_irq: eret _rt2el3_current_withspel0_fiq: eret _rt2el3_current_withspel0_serror: eret //rt2el3_current_withspelx _rt2el3_current_withspelx_sync: // eret mrs x30, elr_el3 ret _rt2el3_current_withspelx_irq: eret _rt2el3_current_withspelx_fiq: eret _rt2el3_current_withspelx_serror: eret //rt2el3_LoA64toHi _rt2el3_LoA64toHi_sync: // eret mrs x30, elr_el3 ret _rt2el3_LoA64toHi_irq: eret _rt2el3_LoA64toHi_fiq: eret _rt2el3_LoA64toHi_serror: eret //rt2el3_LoA32toHi _rt2el3_LoA32toHi_sync: // eret mrs x30, elr_el3 ret _rt2el3_LoA32toHi_irq: eret _rt2el3_LoA32toHi_fiq: eret _rt2el3_LoA32toHi_serror: eret //}}}   Makefile Makefile定义了System目录下文件的编译规则，目的是得到start.o文件。其实这里就只有start.s文件，其他文件通过include方式添加到start.s文件。\nMakefile.def是一些编译参数的定义。\n1 2 3 4 5 6 7  include ../Makefile.def build: $(ASM_A64) -march=$(MARCH) $(DEFINES) -c start.s -o start.o clean: rm -f *.o   a64_test目录 a64_test目录下的文件主要是a64类型测试程序，如果需要，这里可以一同编译没有外部依赖的c程序。\na64_test.s文件 a64_test.s是a64类型测试程序，可以跳转至c函数，也可以嵌入your_testcode.s测试程序。check code是程序自检的一种实现，设置x0为ff时，将print出\u0026quot;TEST FAILED\u0026rdquo;，设置x0为其他值时，将print出\u0026quot;TEST PASSED\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  .global _a64_test _a64_test: stp x29, x30, [sp, #-16]! //Push lr to stack  //test code is here //---------------------------------- //bl main // c function .include \u0026#34;./your_testcode.s\u0026#34; //---------------------------------- //check code is here //---------------------------------- // pass : x0=0x11 // fail : x0=0xff mov x0, #0xff  mov x0, #0x11  //---------------------------------- ldp x29, x30, [sp], #16 //Pop lr from stack  ret   link.lds文件 link.lds是链接脚本，编译是文件各自独立的，编译后还需要将各个编译后的文件链接在一起，链接脚本就是用来指定链接规则，或者说为各个编译后的文件指定存储位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  OUTPUT_FORMAT(\u0026#34;elf64-littleaarch64\u0026#34;) OUTPUT_ARCH(aarch64) SECTIONS { . = 0x0;  .setup : { a64_test.o } .text : { * (.text) } .data : { * (.data) } .bss : { * (.bss) } }   your_testcode.s文件 your_testcode.s文件是自定义的a64类型测试程序，将其独立出来，为了避免使用者不小心更改Bootloader程序框架。\nMakefile Makefile定义了a64_test目录下文件的编译规则，目的是得到a64_test.bin文件。主要经过以下几步：\n 将a64_test目录下所有.s和.c文件编译为.o文件。 根据link.lds描述的链接规则，链接为elf文件。 将elf文件转换为bin文件。  Makefile.def是一些编译参数的定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  include ../Makefile.def SRC_C = $(wildcard *.c) SRC_S = $(wildcard *.s) OBJ_C = $(patsubst %.c, %.o, $(notdir $(SRC_C))) OBJ_S = $(patsubst %.s, %.o, $(notdir $(SRC_S))) build: $(OBJ_S) $(OBJ_C) $(LD_A64) -T link.lds $(DEFINES) $^ -o a64_test.elf $(OBJCOPY_A64) -O binary a64_test.elf a64_test.bin $(OBJDUMP_A64) -D a64_test.elf \u0026gt; a64_test.dis %.o: %.s $(ASM_A64) -march=$(MARCH) $(DEFINES) -c $^ -o $@ %.o: %.c $(CC_A64) -c $^ -o $@ -nostdlib clean: rm -f *.o *.dis *.bin *.elf   a32_test目录 a32_test目录下的文件主要是a32类型测试程序，如果需要，这里可以一同编译没有外部依赖的c程序。\na32_test.s文件 a32_test.s是a32类型测试程序，可以跳转至c函数，也可以嵌入your_testcode.s测试程序。check code是程序自检的一种实现，设置r0为ff时，将print出\u0026quot;TEST FAILED\u0026rdquo;，设置r0为其他值时，将print出\u0026quot;TEST PASSED\u0026rdquo;。\n \u0026ldquo;.code 32\u0026quot;声明为a32类型程序。 \u0026ldquo;.text\u0026quot;声明为程序段。 通过跳转至\u0026rdquo;_t32_test +1\u0026quot;的地址，可以切换至Thumb状态。 从Thumb状态返回，是通过异常返回实现的，这里设置r1为ff，是配合异常处理程序完成程序执行控制。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  .code 32 .text .global _a32_test _a32_test: //Push stack for lr push {r7, lr} sub sp, #8  add r7, sp, #0  //===================================== //add your test code //bl main //c function .include \u0026#34;./your_testcode.s\u0026#34; //add your check code mov r0, #0x11  mov r0, #0xff  //===================================== //Pop stack for lr adds r7, #8  mov sp, r7 pop {r7, pc} //a32 to thumb //===================================== .if TEST_THUMB==1 adr r8, _t32_test add r8, r8, #0x1  blx r8 .endif //===================================== //usermode to el1 //===================================== mov r1, #0xff //for evt Judgemen  eret //===================================== .include \u0026#34;./thumb_test.inc\u0026#34;   thumb_test.inc文件 thumb_test.inc文件是thumb类型执行程序，\n \u0026ldquo;.code 16\u0026quot;声明为thumb类型程序。 \u0026ldquo;.syntax unified\u0026quot;是一个指示，说明下面的指令是ARM和THUMB通用格式的8字节对齐，可以提高访问速度。 通过跳转至\u0026rdquo;_t32_test +1\u0026quot;的地址，可以切换至Thumb状态；通过\u0026quot;bx lr\u0026quot;返回a32状态。 为了避免使用者不小心更改bootloader程序框架，也可以在此通过include方式添加独立的thumb测试程序。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  .code 16 .syntax unified .global _t32_test _t32_test: //================================ // add your test code moval r5, #0  //================================ //================================ _t16_test: // add your test code movs r5, #0  //================================ bx lr   link.lds文件 link.lds是链接脚本，编译是文件各自独立的，编译后还需要将各个编译后的文件链接在一起，链接脚本就是用来指定链接规则，或者说为各个编译后的文件指定存储位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  OUTPUT_FORMAT(\u0026#34;elf32-littlearm\u0026#34;) OUTPUT_ARCH(arm) SECTIONS { . = 0x0;  .setup : { a32_test.o } .text : { * (.text) } .data : { * (.data) } .bss : { * (.bss) } }   your_testcode.s文件 your_testcode.s文件是自定义的a32类型测试程序，将其独立出来，为了避免使用者不小心更改Bootloader程序框架。\nMakefile Makefile定义了a32_test目录下文件的编译规则，目的是得到a32_test.bin文件。主要经过以下几步：\n 将a64_test目录下所有.s和.c文件编译为.o文件。 根据link.lds描述的链接规则，链接为elf文件。 将elf文件转换为bin文件。  Makefile.def是一些编译参数的定义。注意，这里使用的编译工具与a64_test下的不同，具体可查看Makefile.def。\n注意：a32 编译支持浮点和SIMD，需要添加编译参数 \u0026ldquo;-mfpu=neon-fp-armv8\u0026rdquo;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  include ../Makefile.def SRC_C = $(wildcard *.c) SRC_S = $(wildcard *.s) OBJ_C = $(patsubst %.c, %.o, $(notdir $(SRC_C))) OBJ_S = $(patsubst %.s, %.o, $(notdir $(SRC_S))) build: $(OBJ_S) $(OBJ_C) $(LD_A64) -T link.lds $(DEFINES) $^ -o a64_test.elf $(OBJCOPY_A64) -O binary a64_test.elf a64_test.bin $(OBJDUMP_A64) -D a64_test.elf \u0026gt; a64_test.dis %.o: %.s $(ASM_A64) -march=$(MARCH) $(DEFINES) -mfpu=neon-fp-armv8 -c $^ -o $@ %.o: %.c $(CC_A64) -c $^ -o $@ -nostdlib clean: rm -f *.o *.dis *.bin *.elf   simple_bootloader目录 simple_bootloader目录是整个程序框架的根目录，主要内容是通过Makefile和link.lds将system、a64_test、a32_test下生成的bin文件，链接到一起，合并成一个elf文件，并通过Makefile.def实现环境的参数化。\nlink.lds文件  \u0026ldquo;ENTRY(_start)\u0026quot;，将_start设置为程序入口，_start在start.s内定义。 指定链接顺序，start.o在最前，其次是a64_test.bin，最后是a32_test.bin。 \u0026ldquo;. = RVBAR;\u0026ldquo;设置reset地址为当前地址，也就是最开始的_start位置。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  OUTPUT_FORMAT(\u0026#34;elf64_littleaarch64\u0026#34;) OUTPUT_ARCH(aarch64) TARGET(binary) ENTRY(_start) INPUT(./a64_test.bin) INPUT(./a32_test.bin) SECTIONS { . = RVBAR;  .setup : { start.o } .text : { * (.text) } _a64_test = .;  .a64_test : { a64_test.bin } _a32_test = .;  .a32_test : { a32_test.bin } .data : { * (.data) } .bss : { * (.bss) } }   Makefile.def Makefile.def定义了环境的编译参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  #=============================================== RVBAR = 0x0 MARCH = armv8.2-a+crypto+fp16+dot COMPILER_A64 = \u0026#34;aarch64-linux-gnu\u0026#34; COMPILER_A32 = \u0026#34;aarch32-linux-gnu\u0026#34; FNAME = your_testcode DEFINES += --defsym RVBAR=$(RVBAR) DEFINES += --defsym TEST_A64_EL0=1 DEFINES += --defsym TEST_A64_EL1=1 DEFINES += --defsym TEST_A64_EL2=1 DEFINES += --defsym TEST_A64_EL3=1 DEFINES += --defsym TEST_A32=1 DEFINES += --defsym TEST_THUMB=1 DEFINES += --defsym PRINT_RESULT=1 #===============================================  #=============================================== ASM_A64 = $(COMPILER_A64)-as CC_A64 = $(COMPILER_A64)-gcc LD_A64 = $(COMPILER_A64)-ld OBJDUMP_A64 = $(COMPILER_A64)-objdump OBJCOPY_A64 = $(COMPILER_A64)-objcopy ASM_A32 = $(COMPILER_A32)-as CC_A32 = $(COMPILER_A32)-gcc LD_A32 = $(COMPILER_A32)-ld OBJDUMP_A32 = $(COMPILER_A32)-objdump OBJCOPY_A32 = $(COMPILER_A32)-objcopy PROJ_PATH = $(shell pwd) SYS = $(PROJ_PATH)/system/ A64 = $(PROJ_PATH)/a64_test/ A32 = $(PROJ_PATH)/a32_test/ #===============================================   Makefile文件 Makefile文件主要调用system、a64_test、a32_test下的Makefile分别进行编译，最后根据总的link.lds进行链接，合成总的elf文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  include ./Makefile.def #=======================================  build: sys a64 a32 $(LD_A64) -T link.lds $(DEFINES) start.o a32_test.bin a64_test.bin -o $(FNAME).elf $(OBJCOPY_A64) -O binary $(FNAME).elf $(FNAME).bin $(OBJDUMP_A64) -D $(FNAME).elf \u0026gt; $(FNAME).dis a64: make -C $(A64) build cp $(A64)/a64_test.bin $(PROJ_PATH)/ a32: make -C $(A32) build cp $(A32)/a32_test.bin $(PROJ_PATH)/ sys: make -C $(SYS) build cp $(SYS)/start.o $(PROJ_PATH)/ clean: make -C $(A64) clean make -C $(A32) clean make -C $(SYS) clean rm *.o *.dis *.bin *.elf -f   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":22,"section":"docs","tags":["ARM"],"title":"一个简易bootloader框架","uri":"https://www.wenhui.space/docs/09-arm/bootloader/"},{"content":"本文 主要介绍AArch64的一些异常基础知识，异常向量表的设定，以及AArch64的异常处理。\n   版本 说明     0.1 初版发布    关于异常的基础知识 什么是异常？ 对于AArch64而言，exception是指cpu的某些异常状态或者一些系统的事件（可能来自外部，也可能来自内部），这些状态或者事件可以导致cpu去执行一些预先设定的，具有更高执行权利的软件（也叫exception handler）。执行exception handler可以进行异常的处理，从而让系统平滑的运行。exception handler执行完毕之后，需要返回发生异常的现场。\n异常等级（exception level） AArch64有四个 exception level：\n EL0 normal用户应用程序 EL1 操作系统内核 EL2 Hypervisor(vm 虚拟化) EL3 底层固件，包括secure monitor  之前说到异常发生后系统将切换到具有更高执行权限的状态，在AArch64是通过exception level来实现的。AArch64最多支持EL0～EL3四个exception level，EL0的execution privilege最低，EL3的execution privilege最高。当发生异常的时候，系统的exception会迁移（route）到更高的exception level或者维持不变，但是绝不会降低。此外，不会有任何的异常会去到EL0。而AArch32，cpu没有异常等级，而是采用processor mode模式，例如User、FIQ、IRQ、Abort、Undefined、System，这些不同的mode对应privilege（其他mode）和no-privilege（User mode）。\n关于AArch64的exception level比较复杂，一般会有如下几种情况：\n 不支持security state，不支持虚拟化： AArch64有2个exception level，分别是：EL0（对应user mode的application），EL1（guest OS）。 不支持security state，支持虚拟化： AArch64有3个exception level，分别是：EL0（对应user mode的application），EL1（guest OS）和EL2（Hypervisor）。 支持security state，不支持虚拟化： AArch64有3个exception level，分别是：EL0（对应trusted service），EL1（trusted OS kernel）和EL3（Secure monitor）。 支持security state，支持虚拟化： AArch64有4个exception level，分别是：（对应trusted service），EL1（trusted OS kernel），EL2（Hypervisor）和EL3（Secure monitor）。  如下图：\n     异步异常和同步异常   异步异常（asynchronous exception）:\n 异步异常可以理解为中断，CPU是不可预知的。 异常和CPU执行的指令无关。 返回地址是硬件保存下来并提供给handler，以便进行异常返回现场的处理。（程序也有可能不返回，跟中断处理程序有关，比如正在发送邮件，突然点击取消发送，原发送程序不再执行【个人理解，不一定准确】） 根据这个定义IRQ、FIQ和SError interrupt属于asynchronous exception。    同步异常（synchronous exception）：\n 同步异常的产生是和cpu core执行的指令异常或试图改变执行权限引起的异常 返回地址是硬件保存下来并提供给handler，以便进行异常返回现场的处理。 同步异常分两种，一是abort类，例如未定义的指令、data abort、prefetch instruction abort、SP未对齐异常，debug exception等等。另一种是正常指令执行造成的，包括SVC/HVC/SMC指令，这些指令的使命就是产生异常，改变执行权限。    什么是精确异常 先来说说什么是非精确异常：在多发射乱序执行的流水线 CPU 上，从指令进入流水线到异常事件的发生，期间要经过若干流水级，此时 PC 的值已指向其后的某条指令，在实现非精确异常的 CPU 上就把此时的 PC 值作为引起异常指令的所在，也就是记录异常指令的PC并非真正的引起异常的指令所在，而是其后面的某条指令所在。\n精确异常（precise exception），也就是记录异常指令的PC并非真正的引起异常的指令所在，而是其后面的某条指令所在。实现精确异常的 CPU，在最后指令提交时 (commit) 按指令流的顺序提交，异常的抛出也在该指令提交时，这样就能精确计算出引起异常的指令相对于当前 PC 的偏移，从而保证精确异常。不管是何类异常，记录异常指令的PC之前的所有指令都会被执行完成 (commit)，之后的指令不会被执行。\n在AArch64中，除了SError interrupt这种exception，其他的exception都是precise exception。\n异常处理流程 AArch64 state异常处理流程：    流程 说明     1、保存PSTATE 数据到SPSR_ELx,(x = 1,2,3) 异常返回时需要从SPSR_ELx中恢复PSTATE   2、保存异常进入地址到ELR_ELx，同步异常（und/abt等）是当前地址，而异步异常（irq/fiq等）是下一条指令地址 64位架构LR和ELR是独立分开的，这点和32位架构有所差别   3、保存异常原因信息到ESR_ELx ESR_ELx.EC代表Exception Class，关注这个bit   4、PE根据目标EL的异常向量表中定义的异常地址强制跳转到异常处理程序 跳转到哪个EL使用哪个向量偏移地址又路由关系决定   5、堆栈指针SP的使用由目标EL决定 (SPSR_ELx.M[0] == 1) ？ h（ELx）: t（EL0）    AArch32 state异常处理流程    流程 说明     1、PE根据异常类型跳转到对应的异常模式x,x = {und/svc/abt/irq/fiq/hyp/mon} PE跳转到哪一种模式通常由路由关系决定   2、保存异常返回地址到LR_x，用于异常返回用 LR也是对应模式的R[14]_x寄存器，32位系统下LR和ELR是同一个寄存器，而64位是独立的   3、备份PSTATE 数据到SPSR_x 异常返回时需要从SPSR_x恢复PSTATE   4、PSTATE 操作：PSTATE.M[4:0]设置为异常模式x; PSTATE.{A,I,F} = 1; PSTATE.T = 1，强制进入A32模式; PSTATE.IT[7：2] = “00000” PSTATE.M[4]只是对32位系统有效，64为下是保留的，因为64位下没有各种mode的概念. 异常处理都要切换到ARM下进行；进入异常时需要暂时关闭A,I,F中断；   5、据异常模式x的向量偏移跳转到进入异常处理 各个mode有对应的Vector base addr + offset    AArch64异常向量表偏移量    exception level迁移情况 Synchronous exception的offset值 IRQ和vIRQ exception的offset值 FIQ和vFIQ exception的offset值 SError和vSError exception的offset值     同级exception level迁移，使用SP_EL0。例如EL1迁移到EL1 0x000 0x080 0x100 0x180   同级exception level迁移，使用SP_ELx。例如EL1迁移到EL1 0x200 0x280 0x300 0x380   ELx迁移到ELy，其中y\u0026gt;x并且ELx处于AArch64状态 0x400 0x480 0x500 0x580   ELx迁移到ELy，其中y\u0026gt;x并且ELx处于AArch32状态 0x600 0x680 0x700 0x780    注：每个异常等级都有一个关联的 Vector Base Address Register (VBAR),它定义了每个异常等级向量表的基址\nAArch64异常返回：  用ELR_ELx恢复PC值 SPSR_ELx恢复PSTATE值  AArch64异常相关寄存器 EL3异常层级系统寄存器控制：    SCR_EL3 SCTLR_EL3 MDCR_EL3     NS:决定了EL1和EL0的安全状态； {A, SA}:使能对齐检查，A-EL3访问数据时做对齐检查；SA-EL3对SP做对齐检查； {EPMAD, EDAD}：使能外部debugger访问；   RW:决定了低一级的异常等级运行状态； {M, C, I, WXN}：内存系统控制位； {SPME, SDD, SPD32}：安全debug控制；   {EA, FIQ, IRQ}：EA-SError和同步Aborts切换到EL3；FIQ-物理FIQ切换到EL3；IRQ-物理IRQ切换到EL3; EE:定义了端； {TDOSA, TDA, TPM}：陷阱控制   SMD:禁用SMC；     HCE:使能Hypervisor call异常；     ST:使能secure EL1访问secure timer;     SIF:安装指令获取，当secure state禁止从non secuer内存取指；     TWI:陷入WFI;     TWE:陷入WFE      EL2异常层级系统寄存器控制：    HCR_EL2 SCTLR_EL2 MDCR_EL2 HSTR_EL2     RW:决定了低一级的异常等级运行状态； {A, SA}:使能对齐检查 {TDRA, TDOSA, TDA} Tn, for values of n in the set {0-3, 5-13, 15}   {AMO, IMO, FMO}:路由物理中断到EL2 {M, C, I, WXN}：内存系统控制位； TDE:路由从非安全EL0 EL1 EL2来的debug异常    {VSE, VI, VF}:设置虚拟中断pending; EE:定义了端； {TPM, TPMCR}：陷阱控制；    VM:  HPMN:    {SWIO, PTW, FB, BSU, DC, CD, ID}:      HCD Hypervisor Call Disable      {TRVM, TDZ, TVM, TTLB, TPU, TPC, TSW, TACR, TIDCP, TSC, TID1, TID2, TID3, TWE, TWI}:      TGE: Trap General Exceptions       EL1异常层级系统寄存器控制：    TLR_EL1 MDSCR_EL1     {A, SA}:使能对齐检查 {MDE, SS}   {M, C, I, WXN}：内存系统控制位； KDE：   EE:定义了端；E0E:EL0端；UMA:非特权mask访问 TDCC：   {SED, ITD, CP15BEN}：     同步异常 同步异常类型    异常类型 描述     Undefined Instruction 未定义指令异常   Illegal Execution State 非法执行状态异常   System Call 系统调用指令异常（SVC/HVC/SMC）   Misaligned PC/SP PC/SP未对齐异常   Instruction Abort 指令终止异常   Data Abort 数据终止异常   Debug exception 软件断点指令/断点/观察点/向量捕获/软件单步 等Debug异常    同步异常迁移 如果HCR_EL2.TGE为1，None-secure EL0下的异常不会传递给None-secure EL1，而是直接传递给EL2\n异步异常 异步异常类型    类型 描述     SError or vSError 系统错误类型，包括外部数据终止   IRQ or vIRQ 外部中断 or 虚拟外部中断   FIQ or vFIQ 快速中断 or 虚拟快速中断    异步异常迁移 这里描述的是el2和el3都实现的情况：\n 若SCR_EL3.{EA, FIQ, IRQ} == 1，则所有相应的SError\\FIQ\\IRQ 中断都被路由到EL3; 若HCR_EL2.{AMO, IMO, FMO} == 1，则EL1/EL0所有对应的SError\\FIQ\\IRQ中断都被路由到EL2,同时使能对应的虚拟中断VSE,VI,VF; 若HCR_EL2.TGE == 1，那么会忽略HCR_EL2.{AMO, IMO, FMO}的具体值，直接当成1处理，则EL1/EL0所有对应的SError\\FIQ\\IRQ中断都被路由到EL2，同时禁止所有虚拟中断  注意： SCR_EL3.{EA, FIQ, IRQ}bit的优先级高于HCR_EL2.{AMO, IMO, FMO} bit优先级，路由优先考虑SCR_EL3\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":23,"section":"docs","tags":null,"title":"AArch64之异常处理","uri":"https://www.wenhui.space/docs/09-arm/aarch64-execption/"},{"content":"本文 主要介绍为什么AArch64没有LDM和STM指令了，而是用LDP跟STP。\n   版本 说明     0.1 初版发布    写在前头 AArch32 指令集中包含多数据传输指令LDM、STM，也就是单条指令可以传输多个寄存器的值与内存交互，这对于发生异常时将当前寄存器压入栈很有用，通过单条指令STM可以实现此操作，出栈时同样使用LDM即可。但是到了AArch64里面就取消了多数据传输指令LDM、STM，而是使用LDP和STP，固定的一次最多只能取2个值。原因如何呢？请看下文。\n关于CPU内部微操作的拆分 对于复杂功能指令的实现，出于指令功能复杂以及读取和写回寄存器端口资源的限制，CPU内部会对指令进行微操作拆分。比如CPU内部流水线中单拍最多读取3个64bit寄存器和写回两个64bit寄存器，对于LDM和STM这种多数据传输操作，实际在CPU执行过程中会进行微操作的拆分。换句话说，LDM和STM只不过是对多个LD和ST的打包，在CPU里还是分多条微操作执行，LDM和STM指令除了方便软件工程师使用，而对CPU并没有提高执行效率。既然可以方便软件工程师使用，毕竟还是有利的，那为什么在AArch64还是取消了该指令呢？继续看下文。\nCPU对LD和ST的操作 当前CPU的LD和ST，大多分为两个独立的流水线，也就是说配合多发射就可能在一个cycle内同时执行两条（一个ldr、一个str）指令。这里如果执行一条LDM，会使LD Pipe处于持续工作状态，而ST Pipe是空闲状态，执行一条STM情况类似。所以为了最大化利用LD和ST独立流水线的特性，在软件使用层面上，应尽量减少这种突发的多LD和多ST事件，而使用间隔的LD和ST可以利用双pipeline实现该两条指令并发执行，提高执行效率。所以，也就没有LDM和STM指令的必要性了。\nLDP/STP  32bit模式下也是有LDRD跟STD指令的，但是在64bit模式下任意的两个整型寄存器都是可以读或者写的 数据的读写是内存里面的连续位置的 地址模式更严格：只能base + offset的模式进行访存，offset范围是正负127范围（7bit） 与32bit的LDRD跟STD指令不同的是：64bit模式下支持非对齐访问 LDP是支持SIMD 详细信息请看ARM手册。  LDNP/STNP  LDNP跟STNP是Armv8才有的机制，non-temporal代表读取的数据是不会存保存到cache。比如我只要2byte的数据，通常系统会加载1个cache line进来，但是使用LDNP指令，系统不会加载整个cache line进了，而是只加载2byte，从而减少总线流量，进而可能减少取数据的时间。因此LDNP这种指令只适合读取数据量少且不常访问的情况。 non-temporal加载和存储能够放松对访存顺序的要求，LDNP可能比LDR要提前执行（因为LDNP不需要进行cache line fill操作，而是流式读），但是这样顺序错了，因此要加barriar来保证执行顺序。（如果两个内存读之间存在地址依赖关系,第二个读指令是LDNP产生的，然后在没有任何其他屏障机制来保证顺序的情况下，这个可能就会乱序执行的！）   1 2 3 4 5 6 7 8  //错误的用法 LDR x0, [x3] LDNP x2, x1, [x0] //正确用法 LDR x0, [x3] DSB nshld LDNP x2, x1, [x0]    简单理解就是：LDNP指令会告诉memory子系统，我是流式访存，这个数据我暂时只用一次，因此不用读取至cache。  总结  在Arm v8-A架构里面因为有两个分别独立的ld、st pipeline，因此交叉使用LDP、STP指令可以并行使用pipeline，增大吞吐（因为armv7一般是单个加载存储单元，因此LDM、STM更有效） LDNP、STNP是流式处理数据的，不会进行cache line fill操作，因此适合少量数据处理的情形，减少总线流量，比如堆栈恢复的时候，堆栈就几个字节的数据，常规操作是要加载一个cache line，不仅占用cahche空间，还增大总线流量，因此用LDNP更有效，不过在与LDR存在依赖时，要使用数据隔离。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":24,"section":"docs","tags":["ARM"],"title":"为什么AArch64没有LDM和STM指令","uri":"https://www.wenhui.space/docs/09-arm/aarch64-no-ldm-stm/"},{"content":"本文 主要对涉及CPU的一些基本知识和概念进行简单描述，作为科普知识。\n   版本 说明     0.1 初版发布    参考 各种网络资源。\nCPU和SOC的区别 SoC = System on Chip。芯片的发展方向：从CPU到SoC，现在已经没有纯粹的CPU了，都是SoC，ARM出卖的内核其实就是CPU（当然还需要总线），各种外设是半导体厂商自己添加的。\n外设就是外部设备。SoC中外设大部分都跑进去了，芯片设计的趋势是更大集成度，在SoC内做成单芯片解决方案。\nRISC和CISC  complex instruction set computer复杂指令集CPU。CISC体系的设计理念是用最少的指令来完成任务（譬如计算乘法只需要一条MUL指令即可），因此CISC的CPU本身设计复杂、工艺复杂，但好处是编译器好设计。CISC出现较早，至今Intel还一直采用CISC设计。 Reduced Instruction-Set Computer精简指令集CPU。RISC的设计理念是让软件来完成具体的任务，CPU本身仅提供基本功能指令集。因此RISC CPU的指令集中只有很少的指令，这种设计相对于CISC，CPU的设计和工艺简单了，但是编译器的设计变难了。 发展趋势：没有纯粹的RISC或CISC，发展方向是RISC与CISC结合，形成一种介于2者之间的CPU类型。  统一编址和独立编址？ 内存通过CPU的地址总线来寻址定位，然后通过CPU数据总线来读写。CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围是一定的，而内存是需要占用CPU的寻址空间的。内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。\nIO指的是与CPU连接的各种外设。CPU访问各种外设有2种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存相同的方式来操作外设，叫IO与内存统一编址方式；另一种是使用专用的CPU指令来访问某种特定外设，叫IO与内存独立编址。\nIO与内存统一编址方式，优势是IO当作内存来访问，编程简单；缺点是IO也需要占用一定的CPU地址空间，而CPU的地址空间是有限资源。IO与内存独立编织方式，优势是 不占用CPU地址空间，缺点是CPU设计变复杂了。\n冯诺依曼结构和哈佛结构  程序与数据：  程序是我们写好的源代码经过编译、汇编之后得到的机器码，这些机器码可以拿给CPU去解码执行，CPU不会也不应该去修改程序，所以程序是只读的。 数据是程序运行过程中定义和产生的变量的值，是可以读写的，程序运行实际就是为了改变数据的值。   冯诺依曼结构和哈佛结构：  程序和数据都放在内存中，且不彼此分离的结构称为冯诺依曼结构。冯诺依曼结构中程序和数据不区分的放在一起，因此安全和稳定性是个问题，好处是处理起来简单。 程序和数据分开独立放在不同的内存块中，彼此完全分离的结构称为哈佛结构。哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件处理复杂一些（需要统一规划链接地址等）    外部存储和内部存储器 从冯诺依曼的存储程序工作原理以来，计算机就分为了运算器、控制器、存储器和输入输出设备，这里的存储器就是指内部存储器，简称内存。而外部存储器是作为辅助存储的，比如硬盘、U盘、光盘等，准确来说它们属于外设/输入输出设备。内存与地址空间直接映射，这里也就是物理地址，可以通过地址\u0026amp;数据总线与CPU直接相连，而外部存储器和CPU连接不是通过地址\u0026amp;数据总线直接相连，因为地址空间不够用，一般都是通过专门的接口来连接的。在CPU运行时，需要先将外存的程序和数据搬移到内存，才能正常执行。直观来说就是外存只能保证你能存更多东西，要想运行速度块，需要增加内存。\n外存和内存根据各自需要，使用不同的存储介质，内存一般使用DDR（Double Data Rate双倍速率同步动态随机存储器），容量小，断电后数据会丢失，单位容量价格较高，访问速度较快（为什么是较高较快，下文解释）；外存使用的种类就比较多了，动态硬盘、机械硬盘、光盘、U盘等等，容量大，单位容量价格低，访问速度慢，断电后数据不会丢失。\n之所以说内存的单位容量价格较高和访问速度较快，是因为还有缓存（cache），缓存一般使用SRAM（Static Random-Access Memory）静态随机存储器，之所以说静态与动态相比只要保持供电不需要刷电就能一直保存数据（与具体晶体管实现方式不同），SRAM访问速度最快，可以接近CPU的运行速度（内存和CPU运行速度相差近三个量级），但是单位容量价格最贵，单位容量占用芯片面积最多。\n虚拟地址和物理地址 地址空间 地址空间其实是一个比较抽象的概念，我们可以把它想象成一个长的数组，每个数组元素占一个字节。那么这个数组的长度就由地址空间长度来决定。例如：我们32位的系统的地址空间就是我们的2^32字节(4GB),而64位的地址空间大小就是2^64个字节。这也就解释了在我们32位的操作系统，为什么最大只能支持4GB的有效内存。\n物理地址 物理地址：物理地址空间是实在的存在于计算机中的一个实体，在每一台计算机中保持唯一独立性。我们可以称它为物理内存；如在32位的机器上，物理空间的大小理论上可以达到2^32字节(4GB)，但如果实际装了512的内存，那么其物理地址真正的有效部分只有512MB = 512 * 1024 KB = 512 * 1024 * 1024 B（0x00000000~0x1fffffff）。其他部分是无效的。\n虚拟地址 虚拟地址：虚拟地址并不真实存在于计算机中。每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间。理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF。每个进程都有自己独立的虚拟地址空间。这样每个进程都能访问自己的地址空间，这样做到了有效的隔离。\n为什么要设置虚拟地址 在早期的计算机中，程序是直接运行到物理内存（可以理解为内存条上的内存）上的。也就是说，程序运行的时候直接访问的就是物理地址。如果，我们的一个计算机只运行一个程序，那么只有这个程序所需要的内存空间不超过物理内存空间的大小，就不会有问题。但是，我们正在希望的是在某个时候同时运行多个程序。那么这个时候，就会有个一个问题，计算机如何把有限的物理内存分配给多个程序使用呢？\n某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110。计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B。这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多。\n问题1：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。\n问题2：内存使用效率低。在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。\n问题3：程序运行的地址不确定。当内存中的剩余空间可以满足程序C的要求后，操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。但是我们的某些硬件是需要在固定的地址上去开始运行的，但是如果这个地址后边被我们的程序占有，那么我们对这块内存的修改，就可能导致某些硬件不可用了。\n为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果。\n虚拟地址和物理地址的映射 虚拟地址和物理地址之间的映射是通过MMU（内存管理单元）来完成的。具体映射机制，这里不进行描述了，本文作为科普，更深入的分析留在其他章节。\ncpu与核心  物理CPU：物理CPU是相对于虚拟CPU而言的概念，指实际存在的CPU处理器，安装在PC主板或服务器上。需要注意的是这个CPU可能有多个核心。 物理核：CPU中包含的物理内核（核心）个数，比如多核CPU，单核CPU（古老的CPU）。这个多核或者单核已经集成在CPU内部了。 逻辑核和虚拟核：所谓的4核8线程，4核指的是物理核心。用Intel的超线程技术(HT)将物理核虚拟而成的逻辑处理单元,现在大部分的主机的CPU都在使用HT技术，用一个物理核模拟两个虚拟核，即每个核两个线程，总数为8线程。这样在操作系统看来是8个核，但是实际上是1个物理CPU中的4个物理内核。通过超线程技术可以实现单个物理核实现线程级别的并行计算，但是性能比不上两个物理核，因为两个线程共享一套运算资源。  进程和线程 概念 进程是操作系统进行资源（包括cpu、内存、磁盘IO等）分配的最小单位。线程是cpu调度和分配的基本单位。\n举例说明： 我们打开的聊天工具，浏览器都是一个进程。进程可能有多个子任务，比如聊天工具要接受消息，发送消息，这些子任务就是线程。资源分配给进程，线程共享进程资源。\n对比    对比 进程 线程     定义 序运行的一个实体的运行过程，是系统进行资源分配和调配的一个独立单位 线程是进程运行和执行的最小调度单位   系统开销 创建撤销切换开销大，资源要重新分配和收回 仅保存少量寄存器的内容，开销小，在进程的地址空间执行代码   拥有资产 资源拥有的基本单位 基本上不占资源，仅有不可少的资源（程序计数器，一组寄存器和栈）   调度 的基本单位 独立调度分配的单位   安全性 互独立，互不影响 线程共享一个进程下面的资源，可以互相通信和影响   地址空间 系统赋予的独立的内存地址空间 由相关堆栈寄存器和和线程控制表TCB组成，寄存器可被用来存储线程内的局部变量    线程的切换 cpu给线程分配时间片(也就是分配给线程的时间)，执行完时间片后会切换都另一个线程。切换之前会保存线程的状态，下次时间片再给这个线程时才能知道当前状态。从保存线程A的状态再到切换到线程B时，重新加载线程B的状态的这个过程就叫上下文切换。而上下切换时会消耗大量的cpu时间。\n串行，并发与并行  串行：多个任务，执行时一个执行完再执行另一个。比如一边吃饭一边看视频。 并发：多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。比如一会跑去厨房吃饭，一会跑去客厅看视频。 并行：每个线程分配给独立的核心，线程同时运行。比如一边吃饭一边看视频。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":25,"section":"docs","tags":null,"title":"CPU相关的科普知识","uri":"https://www.wenhui.space/docs/10-polular-science/cpu-knowledge/"},{"content":"本文 主要介绍ARM体系结构与汇编指令，这里的体系结构指ARMv7及以前版本，ARMv8相对之前的版本区别较大，不过熟悉以前的体系结构对ARMv8的理解也有帮助，何况ARMv8本身也支持aarch32。\n   版本 说明     0.1 初版发布    参考 参考自《朱有鹏老师嵌入式linux核心课程》。\nARM的工作模式   7种工作模式：\n User : 非特权模式，大部分任务执行在这种模式 FIQ : 当一个高优先级（fast) 中断产生时将会进入这种模式 IRQ : 当一个低优先级（normal) 中断产生时将会进入这种模式 Supervisor :当复位或软中断指令执行时将会进入这种模式 Abort : 当存取异常时将会进入这种模式 Undef : 当执行未定义指令时会进入这种模式 System : 使用和User模式相同寄存器集的特权模式    注意：\n 除User（用户模式）是Normal（普通模式）外，其他6种都是Privilege（特权模式）。 Privilege中除Sys模式外，其余5种为异常模式。 各种模式的切换，可以是程序员通过代码主动切换（通过写CPSR寄存器）；也可以是CPU在某些情况下自动切换。 各种模式下权限和可以访问的寄存器不同。    CPU为什么设计这些模式？\n CPU是硬件，OS是软件，软件的设计要依赖硬件的特性，硬件的设计要考虑软件需要，便于实现软件特性。 操作系统有安全级别要求，因此CPU设计多种模式是为了方便操作系统的多种角色安全等级需要。    ARM的寄存器 37个寄存器  ARM共有37个寄存器，都是32位长度。 37个寄存器中30个为“通用”型，1个（r15）固定用作PC，一个固定用作CPSR，5个固定用作5种异常模式下的SPSR。 ARM寄存器编号为r0～r15，其中r13作为栈指针sp，r14作为链接寄存器lr，r15作为程序计数器pc。 ARM每个工作模式下都有自己独有的寄存器和共用的寄存器，而当前模式只见r0～r15。  举例如下：\n  当前模式为Usr      当前模式为Abort    所以，ARM（aarch32）的寄存器好比影子，每个模式都映射出当前模式下的r0～r15，注意System和User共有一套寄存器。由此可以发现，虽然ARM有37个寄存器，但对软件可见的只有r0~r15和cpsr。\n     CPSR当前状态寄存器        条件位：\n N = Negative result from ALU Z = Zero result from ALU C = ALU operation Carried out V = ALU operation oVerflowed    Q 位：\n 仅ARM 5TE/J架构支持 指示饱和状态    J 位\n 仅ARM 5TE/J架构支持 J = 1: 处理器处于Jazelle状态（对Jave的优化处理）    中断禁止位：\n I = 1: 禁止 IRQ. F = 1: 禁止 FIQ.    T Bit\n T = 0: 处理器处于 ARM 状态 T = 1: 处理器处于 Thumb 状态    Mode位：\n 处理器模式位    注意：\n CPSR中各个bit位表明了CPU的某些状态信息，这些信息非常重要，这与汇编指令息息相关。 CPSR中的I、F位和开中断、关中断有关。 CPSR中的mode位（bit4～bit0共5位）决定了CPU的工作模式，在uboot代码中会使用汇编进行设置。    PC（r15）程序控制寄存器  PC（Program control register）为程序指针，PC指向哪里，CPU就会执行哪条指令（所以程序跳转时就是把目标地址代码放到PC中）。 整个CPU中只有一个PC（CPSR也只有一个，但SPSR有5个）。  ARM的异常处理方式 什么是异常  正常工作之外的流程都叫异常。 异常会打断正在执行的工作，并且一般我们希望异常处理完成后继续回来执行原来的工作。 中断是异常的一种。  异常向量表  所有的CPU都有异常向量表，这是CPU设计时就设定好的，是硬件决定的。 当异常发生时，CPU会自动动作（PC跳转到异常向量处处理异常，有时伴有一些辅助动作） 异常向量表是硬件向软件提供的处理异常的支持。  ARM的异常处理机制  当异常产生时, ARM core完成以下操作：  拷贝 CPSR 到 SPSR_ 设置适当的 CPSR 位： 改变处理器状态进入 ARM 态（如果当前在Thumb状态下） 改变处理器模式进入相应的异常模式 设置中断禁止位禁止相应中断 (如果需要) 保存返回地址到 LR_ 设置 PC 为相应的异常向量   返回时, 异常处理需要:  从 SPSR_恢复CPSR 从LR_恢复PC   Note:这些操作只能在 ARM 态执行. 关于保存返回地址到 LR_，这时候分同步异常和异步异常，比如软中断指令引发的异常，属于同步异常，返回地址为该指令的下一条指令位置，而数据异常属于异步异常，返回地址为该指令位置。  总结  异常处理中有一些是硬件自动做的，有一些是程序员需要自己做的。需要搞清楚哪些是需要自己做的，才知道如何写代码。 以上说的是CPU设计时提供的异常向量表，一般成为一级向量表。有些CPU为了支持多个中断，还会提供二级中断向量表，处理思路类似于这里说的一级中断向量表。  指令集 两个概念：指令与伪指令  （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串10组成的机器码，可以由CPU读取执行。 （汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码。  两种不同风格的ARM指令  ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如： LDR R0, [R1] GNU风格的ARM汇编：指令一般用小写字母、linux中常用。如：ldr r0, [r1] 一般交叉编译都使用GNU风格的ARM汇编，编译器下载地址如下： https://releases.linaro.org/components/toolchain/binaries/。  ARM汇编的特点  ARM采用RISC架构，CPU本身不能直接处理内存数据，而需要先将内存数据加载入CPU中通用寄存器中才能被CPU处理。  ldr（load register）指令将内存内容加载入通用寄存器。 str（store register）指令将寄存器内容存入内存空间中。 ldr/str组合用来实现 ARM CPU和内存数据交换。   8种寻址方式：  寄存器寻址 mov r1, r2 立即寻址 mov r0, #0xFF00 寄存器移位寻址 mov r0, r1, lsl #3 寄存器间接寻址 ldr r1, [r2] 基址变址寻址 ldr r1, [r2, #4] 多寄存器寻址 ldmia r1!, {r2-r7, r12} 堆栈寻址 stmfd sp!, {r2-r7, lr} 相对寻址 beq flag   指令后缀:  B（byte）功能不变，操作长度变为8位 H（half word）功能不变，长度变为16位 S（signed）功能不变，操作数变为有符号 如 ldr ldrb ldrh ldrsb ldrsh S（S标志）功能不变，影响CPSR标志位 如 mov和movs\tmovs r0, #0   条件执行后缀:       数据传输和跳转指令  数据处理指令：  数据传输指令 mov mvn 算术指令 add sub rsb adc sbc rsc 逻辑指令 and orr eor bic 比较指令 cmp cmn tst teq 乘法指令 mvl mla umull umlal smull smlal 前导零计数 clz   cpsr访问指令：  mrs用来读psr，msr用来写psr CPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr   跳转(分支)指令：  b \u0026amp; bl \u0026amp; bx b 直接跳转（就没打开算返回） bl branch and link，跳转前把返回地址放入lr中，以便返回，以便用于函数调用 bx跳转同时切换到ARM模式，一般用于异常处理的跳转。   访存指令：  单个字/半字/字节访问 ldr/str 多字批量访问 ldm/stm （为什么设有多字批量访问指令，比如发生异常时需要将现场寄存器压入栈，而返回时出栈以回到异常前的现场，这里多字批量访问指令对多个寄存器压入和弹出栈很有用） 数据交换：swp r1, r2, [r0]   立即数：  合法立即数与非法立即数 ARM指令都是32位，除了指令标记和操作标记外，本身只能附带很少位数的立即数。因此立即数有合法和非法之分。 合法立即数：经过任意位数的移位后非零部分可以用8位表示的即为合法立即数 一般使用伪指令 ldr r0, 0x123456 可以不必关心立即数的合法性，编译器会自动完成   软中断指令：  swi（software interrupt） 软中断指令用来实现操作系统中系统调用    协处理器和协处理器指令  协处理器cp15操作指令：  mrc用于读取CP15中的寄存器 mcr用于写入CP15中的寄存器   什么是协处理器：  SoC内部另一处理核心，协助主CPU实现某些功能，被主CPU调用执行一定任务。 ARM设计上支持多达16个协处理器，但是一般SoC只实现其中的CP15.（cp：coprocessor） 协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关。   MRC \u0026amp; MCR的使用方法：  mcr{} p15, \u0026lt;opcode_1\u0026gt;, , , , {\u0026lt;opcode_2\u0026gt;} mrc p15, 0, r0, c1, c0, 0 opcode_1：对于cp15永远为0 Rd：ARM的普通寄存器 Crn：cp15的寄存器，合法值是c0～c15 Crm：cp15的寄存器，一般均设为c0 opcode_2：一般省略或为0   关于协处理器的操作不必深究，一般通过协处理器访问系统寄存器，不过大多处理器已经取消了协处理器。  ldm/stm与栈的处理  为什么需要多寄存器访问指令：  ldr/str每周期只能访问4字节内存，如果需要批量读取、写入内存时太慢，解决方案是stm/ldm ldm(load register mutiple) stm（store register mutiple） 如：stmia sp, {r0 - r12} ，将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入该地址；然后地址再+4（指向0x30001008），将r2存入该地址······直到r12内容放入（0x3001030），指令完成。一个访存周期同时完成13个寄存器的读写   8种后缀：  ia（increase after）先传输，再地址+4 ib（increase before）先地址+4，再传输 da（decrease after）先传输，再地址-4 db（decrease before）先地址-4，再传输 fd（full decrease）满递减堆栈 ed（empty decrease）空递减堆栈 fa（full ascending） 满递增堆栈 ea（empty ascending）空递增堆栈   四种栈：  空栈：栈指针指向空位，每次存入时可以直接存入然后栈指针移动一格；而取出时需要先移动一格才能取出 满栈：栈指针指向栈中最后一格数据，每次存入时需要先移动栈指针一格再存入；取出时可以直接取出，然后再移动栈指针 增栈：栈指针移动时向地址增加的方向移动的栈 减栈：栈指针移动时向地址减小的方向移动的栈   ！的作用：  ldmia\tr0, {r2 - r3} ldmia\tr0！, {r2 - r3} 感叹号的作用就是r0的值在ldm过程中发生的增加或者减少最后写回到r0去，也就是说ldm时会改变r0的值。   ^的作用：  ldmfd\tsp!, {r0 - r6, pc} ldmfd\tsp!, {r0 - r6, pc}^ ^的作用：在目标寄存器中有pc时，会同时将spsr写入到cpsr，一般用于从异常模式返回。   总结：  批量读取或写入内存时要用ldm/stm指令 各种后缀以理解为主，不需记忆，最常见的是stmia和stmfd 谨记：操作栈时使用相同的后缀就不会出错，不管是满栈还是空栈、增栈还是减栈 提供这么多种栈的模式，实际使用最多的是满减栈，而且编译器默认使用满减栈。    伪指令  伪指令的意义：  伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码。 伪指令的意义在于指导编译过程。 伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令。   gnu汇编中的一些符号：  @, // , /* */用来做注释。（不同编译器可能不同，根据实际情况为准） ：以冒号结尾的是标号 . 点号在gnu汇编中表示当前指令的地址 # 立即数前面要加#，表示这是个立即数   常用gnu伪指令：  .global _start // 给_start外部链接属性 .section .text // 指定当前段为代码段 .ascii .byte .short .long .word .quad .float .string // 定义数据 .align 4 // 以16字节对齐 .balignl 16 0xabcdefgh // 16字节对齐填充   偶尔使用的gnu伪指令：  .end // 标识文件结束 .include // 头文件包含 .arm / .code32 // 声明以下为arm指令 .thumb / .code16 // 声明以下为thubm指令   最重要的几个伪指令:  ldr 大范围的地址加载指令 adr 小范围的地址加载指令 nop 空操作 ARM中有一个ldr指令，还有一个ldr伪指令，一般都使用ldr伪指令实现立即数赋值和长跳转   adr与ldr：  adr编译时会被1条sub或add指令替代，而ldr编译时会被一条mov指令替代或者文字池方式处理 adr总是以PC为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里，ldr加载的地址和链接时给定的地址有关，由链接脚本决定    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":26,"section":"docs","tags":null,"title":"ARM(a32)体系结构与汇编指令","uri":"https://www.wenhui.space/docs/09-arm/arm-and-assemb/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 UVM学习笔记 部分第三篇，主要介绍UVM的组件，包括：uvm_driver, uvm_monitor, uvm_sequencer, uvm_agent, uvm_scoreboard, uvm_env, uvm_test。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《UVM实战》 张强 书籍    专业术语与缩略语    缩写 全称 说明           组件家族  SV环境中的验证组件按照功能需要，被称之为激励器(stimulator)、监测器(monitor)和检查器(checker)。 这三个核心组件与验证环境的三个关键特性对应，即激励、监测和检查。在过往那么多验证方法学中，都有与其对应的组件(component)。 UVM组件家族是从UVM基类继承的一个核心分支即uvm_component类。  uvm_driver 概述  从该类会从uvm_sequencer中获取事务(transaction)，经过转化进而在接口中对DUT进行时序激励。 任何继承于uvm_driver的类需要注意的是，该类是参数化类，因此在定义时需要声明参数的类型。首先看uvm_driver类的定义：   1  class uvm_driver#(type REQ=uvm_sequence_item，type RSP=REQ) extends uvm_component;    用户在定义新的driver类时，应当声明该类所需要获取的事务参数REQ类型，默认情况下，RSP参数类型同REQ类型保持一致。 uvm_driver在uvm_component基础上没有扩展新的函数，而只是扩展了一些用来通信的端口和变量：   1 2 3 4  uvm_seq_item_pull_port#(REQ, RSP)seq_item_port; uvm_analysis_port#(RSP)rsp_port; REQ req; RSP rsp;    driver类与sequencer类之间的通信就是为了获取新的事务对象，这一操作是通过pull的方式实现的：   1 2  driver.seq_item_port.connect(sequencer.seq_item_export) ; driver.rsp_port.connect(sequencer.rsp_export) ;   示例 1 2 3 4 5 6 7 8 9 10  class dut_driver extends uvm_driver#(basic_transaction) ;//sequence item类型（默认req和rsq相同，这里都是basic_transaction）  virtual chip_if vif; //virtual interface  bit[7:0] addr,data; `uvm_component_utils(dut_driver) //在factory中注册dut_driver  function new(string name, uvm_component parent) ; super.new(name, parent) ; endfunction:new extern task run_phase(uvm_phase phase) ; //在运行过程中自动执行的run_phase endclass:dut_driver   uvm_monitor 概述  从名字来看，这个类是为了监测接口数据，而任何需要用户自定义数据监测行为的monitor都应当继承于该类。 虽然uvm_monitor与它的父类相比， 并没有增添新的成员和方法，但将新定义的monitor类继承于uvm_monitor类会有助于实现父类uvm_monitor的方法和特性。 通常所执行的功能包括：  观测DUT的interface，并且收集总线信息 永远保持PASSIVE模式，即永远不会驱动DUT 在总线协议或者内部信号协议观察时，可以做一些功能和时序的检查 对于更加复杂的检查要求，它们可以将数据发送至其它验证组件，例如scoreboard、reference model或者coverage collector。    示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class serial_monitor extends uvm_monitor; virtual serial_if.monitor mi; //virtual interface + modport  `uvm_component_utils(serial_monitor) function new(string name，uvm_component parent) ; super.new(name，parent) ; endfunction:new function void build_phase(uvm_phase phase) ; super.build_phase(phase) ; endfunction:build_phase extern task run_phase(uvm_phase) ; endclass:serial_monitor task serial_monitor::run_phase(uvm_phase) ; serial_transaction tr; forever begin tr=new; //每次发送都创建新的实例  wait(mi.rts) ; @(neg edge mi.line) ; #(bit period/2) ; for(inti=0; i\u0026lt;=7; i++) begin #(bit_period) ; tr.parity_error ^= mi.line; tr.data[il = mi.line; //监测数据  end #(bit_period) assert(mi.line==1\u0026#39;b1) else //检查协议  `uvm_warning(*MON”,W Framing error”) ... end endtask:run phase   uvm_sequencer 概述  从名uvm_sequencer就如同一个管道，从这个管道中会产生连续的激励事务，并最终通过TLM端口送至driver一侧。 如果需要的话，uvm_sequencer也可以从uvm_driver那里获取随后的RSP对象来得知数据通信是否正常。 uvm_sequencer恐怕是这些组件中技能最超凡的一个成员了，单从它的继承层级就可见一斑。 从uvm_sequencer类的定义来看，它也同uvm_driver一样是个参数类，需要在定义sequencer时声明REQ的类型。 从名uvm_sequencer与uvm_component之间还多了两个中间类uvm_sequencer_base类和uvm_sequencer_param_base类。 sequencer既管理着sequence，同时也将sequence中产生的transaction item传送到driver一侧，可以说是整个激励环节中的“路由器” 而就sequence、sequencer与driver之间的缠绵悱恻的故事，我们将在序列的部分中详细分析。  示例 1 2 3 4 5 6 7  class my_sequencer extends uvm_sequencer#(basic_transaction) ;//sequence_item类型  `uvm_component_utils(uvm_sequencer) //在factory中注册my_sequencer  function new(string name，uvm_component parent) ; super.new(name，parent) ; endfunction:new endclass:my_sequencer    可以看得出来， uvm_sequencer的注册和构建函数new()与其它的uvm_component在定义时没有什么区别。  uvm_agent 概述  uvm_agent本身不具备什么神技，但它却是一个标准的验证环境“单位”。这样的一个标准单位通常包含一个driver、一个monitor以及一个sequencer。这三个小伙伴经常是聚在一起，组成一个小团伙agent。 同时为了复用，有的时候uvm_agent中只需要包含一个monitor，而不需要driver和sequencer，这就需要通过一个变量来进行有条件的例化。   1  uvm_active_passive_enum is_active=UVM_ACTIVE;    is_active是agent的一个成员，缺省值是UVM_ACTIVE，这表示处在active模式的agent需要例化driver、monitor和sequencer；而如果is_active的值是UVM_PASSIVE，这表示agent是passive模式，只可以例化monitor。active模式的agent既有激励功能也有监测功能，passive模式的agent只具有监测功能。 active模式对应着DUT的接口暴露给agent且需要激励的场景，而passive模式对应着DUT的接口已经与其它设计连接而只需要监测的场景。 通过is_active变量，agent需要在build_phase()和connect_phase()等函数中通过选择语句来对driver和sequencer进行有条件的例化和连接，下面这段例码是如何对agent内三个组件进行有条件例化的参考。 Agent的存在是为了验证环境的复用。 按照总线的传输方向划分，可以分为master和slave。Master agent是用来向DUT发起transaction。Slave agent是用来响应DUT的events。  示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class my_agent extends uvm_agent; //agent中所包含的常见组件  my_sequencer m_sqr; my_driver m_drv; my_monitor m_mon; dut_if vif; `uvm_component_utils(my_agent) //决定agent内部结构的变量is_active  uvm_active_passive_enum is_active=UVM_ACTIVE; ... extern function void build_phase(uvm_phase phase) ; extern function void connect_phase(uvm_phasephase) ; endclass:my_agent function void template_master_agent::build() ; super.build() ; monitor=template_master_monitor::type_id::create(\u0026#34;monitor\u0026#34;， this) ; if(is_active==UVM_ACTIVE) begin sequencer=template_master_sequencer::type_id::create(\u0026#34;sequencer\u0026#34;, this) ; driver=template_master_driver::type_id::create(\u0026#34;driver\u0026#34;， this) ; end endfunction:build function void template_master_agent::connect() ; if(is_active==UVM_ACTIVE) begin driver.seq_item_port.connect(sequencer.seq_item_export) ; end endfunction:connect   uvm_scoreboard 概述  从名字来看，uvm_scoreboard担任着同SV中checker一样的功能，即进行数据比对和报告。 uvm_scoreboard本身也没有添加额外的成员变量和方法，但UVM建议用户将自定义的scoreboard类继承于uvm_scoreboard类，这便于子类在日后可以自动继承于可能被扩充到uvm_scoreboard类中的成员。 在实际环境中，uvm_scoreboard会接收来自于多个monitor的监测数据，继而进行比对和报告。 正由于uvm_scoreboard通用的比较数据特性，UVM自带的其它两个用来做数据比较的类其实很少被使用到：uvm_in_order_comparator#(type T)和uvm_algorithm_comparator#(type BEFORE，type AFTER，type TRANSFORMER) 【作为了解】uvm_in_order_comparator是一个参数类，并且它有两个端口before_export和after_export分别从DUT的输入端monitor和输出端monitor获取观测到的数据事务。这些数据事务是将多个时钟周期内的数据整合为更高抽象级的数据对象，而且要求前后端监测到数据事务类型应该相同。 【作为了解】uvm_algorithm_comparator也是一个参数类，它的参数数目要更多，这是为了贴合在更多实际场景中，DUT的输入端监测数据格式不同于输出端数据格式，因此type BEFORE与type AFTER两个事务类可以不相同，同时用户也应该提供用来将BEFORE类转换为AFTER类的转换类type TRANSFORMER。  示例  在scoreboard中通常会声明TLM端口以供monitor传输数据。 简易比较的方法， 可以采用UVM预定义的comparator。 对于复杂的设计， 参考SV模块中的做法， 可以在scoreboard中分别创建reference model和comparator。 以此为例，也需要注意的是，如果一个组件中有子一级的组件，应该考虑它们的创建、连接和通信问题。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class cpu_scoreboard extends uvm scoreboard; uvm_analysis_export #(bus_xact) in_export; uvm_analysis_export #(bus_xact) out_export; typedef uvm_in_order_comparator #(bus_xact) comp_t; //预先定义一个类型  comp_t m_comp; //使用预先定义的类型进行声明  ... function void build_phase(uvm_phase phase) ; super.build_phase(phase) ; in_export=new(\u0026#34;in_export\u0026#34;, this) ; //端口也要例化  out_export=new(\u0026#34;out_export\u0026#34;, this) ; m_comp=comp_t::type_id::create(\u0026#34;m_comp\u0026#34;, this) ; endfunction function void connect_phase(uvm_phase phase) ; super.connect_phase(phase) ; in_export.connect(m_comp.before_export) ; out_export.connect(m_comp.after_export) ; endfunction endclass:cpu_scoreboard   uvm_env 概述  从环境层次结构而言，uvm_env可能包含多个uvm_agent和其它component。 这些不同组件共同构成一个完整的验证环境，而这个环境在将来复用中可以作为子环境被进一步集成到更高的环境中。 下面的验证结构中，就定义了一个高层的环境，它里面包含sub_env、agent、scoreboard。        uvm_env的角色就是一个结构化的容器， 它可以容纳其它组件同时它也可以作为子环境在更高层的集成中被嵌入。 在实际使用中， 用户容易混淆uvm_env与uvm_agent之间的嵌套关系，而且容易在创建对象阶段出现错误，建议的嵌套关系是：  uvm_agent作为一个标准单元， 在更上层的集成中应该被例化到uvm_env。 uvm_env在更高层的复用中， 可以被其它uvm_env所嵌套。    示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class top_env extends uvm_env; sub_env m_se; my_agent m_agt; my_scoreboard m_sb; `uvm_component_utils(top_env) extern function new(string name, uvm_component parent) ; function void build_phase(uvm_phase) ; m_se = sub_env::type_id::create(\u0026#34;m_se\u0026#34;,this) ; m_agt=my_agent::type_id::create(\u0026#34;m_agt\u0026#34;,this) ; m_sb=my_scoreboard::type_id::create(\u0026#34;m_sb\u0026#34;,this) ; endfunction ... endclass:top_env   uvm_test 概述  从uvm_test类本身没有什么新成员，但是作为测试用例的“代言人”它不但决定着环境的结构和连接关系，也决定着使用哪一个测试序列。 如果没有这个代言人，整个环境都无从建立， 所以uvm_test是验证环境建立的唯一入口，只有通过它才能正常运转UVM的phase机制。 我们从下面的示例看到，在一个顶层test中可以例化多个组件，譬如uvm_env或者uvm_agent，而在仿真时通过uvm_test可以实现验证环境的运转。 我们推荐在uvm_test中只例化一个顶层uvm_env，这便于提供一个唯一环境节点以形成树状的拓扑结构，而这种树状环境结构也会对应着一种树状配置结构。  示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class env extends uvm env; `uvm_component_utils(env) ... endclass class agent extends uvm_agent; `uvm_component_utils(agent) ... endclass class test1 extends uvm_test; `uvm_component_utils(test1) env e1, e2; agent a1; ... function void build phase(uvm phase phase) ; e1 = env::type_id::create(\u0026#34;e1\u0026#34;,this) ; e2 = env::type_id::create(\u0026#34;e2\u0026#34;,this) ; a1 = agent::type_id::create(\u0026#34;al\u0026#34;,this) ; endfunction endclass   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":27,"section":"docs","tags":["UVM"],"title":"UVM学习笔记（三）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/uvm-study-note-three/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 UVM学习笔记 部分第二篇，主要介绍核心基类、phase机制、config机制和消息管理。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《UVM实战》 张强 书籍    专业术语与缩略语    缩写 全称 说明           核心基类 uvm_object  UVM世界中的类最初都是从一个uvm_void根类(root class) 继承来的，而实际上这个类并没有成员变量和方法。 uvm_void只是一个虚类(virtual class)，还在等待将来继承于它的子类去开垦。在继承于uvm_void的子类中，有两个类， 一个为uvm_object类，另外一个为uvm_port_base类 。 在UVM世界的类库地图中除了事务接口(transaction interface)类继承于uvm_port_base，其它所有的类都是从uvm_object类一步步继承而来的。 从uvm_object提供的方法和相关的宏操作来看，它的核心方法主要提供与数据操作的相关服务：  Copy Clone Compare Print Pack/Unpack   在SV模块的学习中，懂得了什么是句柄拷贝和对象拷贝。因此，无论是copy或者clone，都需要确保在操作的过程中，需要有source object和target object。  域的自动化(field automation)  从UVM通过域的自动化，使得用户在注册UVM类的同时也可以 声明今后会参与到对象拷贝、克隆、打印等操作的成员变量 。 域的自动化解放了verifier的双手，这使得在使用uvm_object提供的一些预定义方法时，非常便捷，而无需再实现自定义方法。 在了解了 域的自动化常用的宏 之后，用户需要考虑哪些成员变量在注册UVM类(`uvm_{component/object}_utils) 的时候，也一并将它们归置到对应的域列表中，以便为稍后的域方法提供可以自动实现的基础。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name = \u0026#34;box\u0026#34;; //域自动化声明变量  //备注：红宝书P275，域的自动化宏列表  `uvm_object_utils_begin(box) `uvm_field_int(volume, UVM_ALL_ON) `uvm_field_enum(color_t, color, UVM_ALL_ON) `uvm_field_string(name, UVM_ALL_ON) `uvm_object_utils_end ... endclass box b1, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;); b1.volume = 80; b1.color = BLACK; b2 = new(); b2.copy(b1); //把b1里的成员变量数据拷贝到b2  b2.name = \u0026#34;box2\u0026#34;; end    从这个域的自动化宏的例子来看，在注册box的同时，也声明了将来会参与到uvm_object数据操作的成员变量。 凡是声明了的成员变量，都将在数据操作时自动参与进来。 如果有一些数据没有通过域的自动化来声明的话，它们也将不会自动参与到数据的拷贝、打印等操作，除非用户自己去定义这些数据操作方法。 所以对于新手，请养成习惯，即：  在注册component或者object的时候，使用`uvm_{component/object}_utils_begin和`uvm_{component/object}_utils_end来配对包裹接下来的域的自动化。 域的自动化为了尽量识别多数的变量，以及做相应的处理，对应的宏的种类非常多，但是也不需要额外的担心，你可以使用红宝书来查各种域的自动化时所对应的宏。 域的自动化的相关宏都是`uvm_field_{int/object/string/enum/event/real\u0026hellip;}{ARG，FLAG}。ARG表示成员变量，FLAG表示用来标记的数据操作。 FLAG的具体表示可以参照红宝书的表10.3，初学者只需要默认采取UVM_ALL_ON或者UVM_DEFAULT，即将所有的数据操作方法都打开。 常见的数据操作方法，包括之前所介绍的copy，compare，print，record，pack和其它。将在接下来的部分逐一介绍这些数据操作方法。    拷贝（copy）  在UVM的数据操作中，需要 对copy和clone加以区分 。前者默认已经创建好了对象，只需要对数据进行拷贝；后者则会自动创建对象并对source object进行数据拷贝，再返回target object句柄。 无论是copy或者clone，都需要对数据进行复制。 但是如果数据成员包括句柄，那么拷贝的时候，是否只拷贝该成员句柄本身，还是也额外创建新的对象，拷贝该句柄指向的对象? 从示例可以看到，在进行copy时，默认进行的是深拷贝(deep copy) ，即会执行copy()和do_copy() 。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  class ball extends uvm_object; int diameter = 10; color_t color = RED; `uvm_object_utils_begin(ball) `uvm_field_int(diameter, UVM_DEFAULT) `uvm_field_enum(color_t, color, UVM_NOCOPY)//不参与copy  `uvm_object_utils_end ... function void do_copy(uvm_object rhs);//copy的回调函数  ball b; $cast(b, rhs) ; $display(\u0026#34;ball::do_copy entered..\u0026#34;); if(b.diameter \u0026lt;= 20) begin diameter = 20; end endfunction endclass class box extends uvm_object; int volume = 120; color_t color = WHITE; string name=\u0026#34;box\u0026#34;; ball b; `uvm_object_utils_begin(box) `uvm_field_int(volume, UV_ALL_ON) `uvm_field_enum(color_t, color, UVM_ALL_ON) `uvm_field_string(name, UVM_ALL_ON) `uvm_field_object(b, UVM_ALL_ON) `uvm_object_utils_end ... endclass box bl, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b1.volume = 80; b1.color = BLACK; bl.b.color = WHITE; b2 = new() ; b2.copy(b1) ; b2.name = \u0026#34;box2\u0026#34;; $display(\u0026#34;%s\u0026#34;, b1.sprint() ) ; $display(\u0026#34;%s\u0026#34;, b2.sprint() ) ; end //输出结果： //ball::do_copy entered.. //------------------------------- //Nama Type size Value //------------------------------- //box1 box - @336 // volume integral 32 \u0026#39;h50 // color color_t 32 BLACK // name string 4 box1 // b ball - @337 // diameter integral 32 \u0026#39;ha // color color_t 32 WHITE // //box2 box - @338 // volume integral 32 \u0026#39;h50 // color color_t 32 BLACK // name string 4 box2 // b ball - @340 // diameter integral 32 \u0026#39;h14 // color color_t 32 RED    新添加了一个类ball，并且在box中例化了一个ball的对象。在拷贝过程中，box的其它成员都正常拷贝了，但对于box::b的拷贝则通过了ball的深拷贝方式进行。 即先执行自动拷贝copy()，来拷贝允许拷贝的域，由于ball::color不允许拷贝，所以只拷贝了ball::diameter。 接下来，再执行do_copy()函数，这个函数是需要用户定义的回调函数(callback function) ，即在copy()执行完后会执行do_copy() 。 如果用户没有定义该函数，那么则不会执行额外的数据操作。从ball::do_copy()函数可以看到，如果被拷贝对象的diameter小于20，那么则将自身的diameter设置为20。因此，最后对象b2.b的成员与b1.b的成员数值不同。  比较（compare） 1  function bit compare (uvm_object rhs, uvm_comparer comparer=null);    默认情况下，如果不对比较的情况作出额外配置，用户可以在调用compare()方法时，省略第二项参数，即采用默认的比较配置。 比较方法经常会在两个数据类中进行。例如从generator产生的一个transaction(数据类) ，和在设计输出上捕捉的transaction(数据类) ，如果它们为同一种类型，除了可以自定义数据比较之外，也可以直接使用uvm_object::compare()函数来实现数据比较和消息打印。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name=\u0026#34;box\u0026#34;; `uvm_object_utils_begin(box) ... `uvm_object_utils_end ... endclass //============================ box b1, b2; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b1.volume = 80; b1.color = BLACK; b2 = new(\u0026#34;box2\u0026#34;) ; b2.volume = 90; if(!b2.compare(b1)) begin `uvm_info(\u0026#34;COMPARE\u0026#34;, \u0026#34;b2 compared with b1 failure\u0026#34;, UVM LOW) end else begin `uvm_info(\u0026#34;COMPARE\u0026#34;, \u0026#34;b2 compared with b1 success\u0026#34;, UVM LOW) end end //========================== //输出结果： //UVM_INFO @O: reporter[MISCMP] Miscompare for box2.volume:lhs=\u0026#39;h5a:rhs=\u0026#39;h50 //UVM_INFO @0: reporter[MISCMP| Miscompare(s) for object box1@336 vs.box2@337 //UVM_INFO @O: reporter[COMPARE] b2 comapred with bl failure    在上面的两个对象比较中，会将每一个自动化的域进行比较，所以在执行compare()函数时，内置的比较方法也会将比较错误输出。 从结果来看，比较发生了错误，返回0值。那么，b1.color和b2.color虽然不相同，为什么没有比较错误的信息呢? 原因在于，默认的比较器，即uvm_package::uvm_default_comparer最大输出的错误比较信息是1，也就是说当比较错误发生时，不会再进行后续的比较。 实际上，在uvm_object使用到的方法compare()、print()和pack()，如果没有指定数据操作配置对象作为参数时，会使用在uvm_pkg中例化的全局数据操作配置成员。  全局对象  在uvm_pkg中例化了不少全局对象，而在本节中我们会使用到的全局配置对象包括有uvm_default_comparer，uvm_default_printer和uvm_default_packer。 如果用户不想使用默认的比较配置，而是想自己对比较进行设定，可以考虑创建一个uvm_comparer对象，或者修改全局的uvm_comparer对象。  打印（print）  打印方法是核心基类提供的另外一种便于开发和调试的功能。 通过field automation，使得声明之后的各个成员域会在调用uvm_object::print()函数时自动打印出来。 相比于在仿真中设置断点，逐步调试，打印是另外一种调试方式。它的好处在于可以让仿真继续进行， 会在最终回顾执行过程中，从全局理解执行的轨迹和逻辑 。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class box extends uvm_object; int volume = 120; color_t color = WHITE; string name = \u0026#34;box\u0026#34;; `uvm_object_utils_begin(box) ... `uvm_object_utils_end endclass //================================== box b1; uvm_table_printer local_printer; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; local_printer = new() ; $display(\u0026#34;default table printer format\u0026#34;) ; b1.print() ; $display(\u0026#34;default line printer format\u0026#34;) ; uvm_default_printer = uvm_default_line_printer; b1.print(); $display(\u0026#34;default tree printer format\u0026#34;) ; uvm_default_printer = uvm_default_tree_printer; b1.print() ; $display(\u0026#34;customized printer format\u0026#34;) ; local_printer.knobs.full_name = 1; b1.print(local_printer) ; end //==================================== //输出结果（只是显示格式不同而已）： //default table printer format //Name Type size Value // box1 box - @336 // volume integral 32 \u0026#39;h78 // color color_t 32 WHITE // name string 4 box1 // //default line printer format //box1: (box@336) {volume：\u0026#39;h78 color; WHITE name: box1} // //default tree printer format //box1: (box@336) { // volume: \u0026#39;h78 // color: WHITE // name: box1 //} // //customized printer format //Name Type size Value //box1 box - @336 // box1.volume integral 32 \u0026#39;h78 // box1.color color_t 32 WHITE // box1.name string 4 box1    只要在field automation中声明过的域，在稍后的print()函数执行时，都将打印出它们的类型、大小和数值。如果用户不对打印的格式做出修改，那么在打印时，UVM会按照uvm_default_printer规定的格式来打印。 uvm_pkg所包含的用于打印的全局对象，它们分别是：  uvm_default_tree_printer：可以将对象按照树状结构打印。 uvm_default_line_printer：可以将对象数据打印到一行上面。 uvm_default_table_printer：可以将对象按照表格的方式打印。 uvm_default_printer：UVM环境默认的打印设置，该句柄默认指向了uvm_default_table_printer。   通过给全局打印uvm_default_printer赋予不同的打印句柄，就可以在调用任何uvm_object的print()方法时，得到不同的打印格式。  打包和解包（pack \u0026amp; unpack） 1 2  function int pack(ref bit bitstream[], input uvm_packer packer=null); function int unpack(ref bit bitstream[], input uvm_packer packer=null);    pack是为了将自动化声明后的域(标量) 打包为比特流(bit stream) 。即将各个散乱的数据，整理到bit数据串中，类似于struct packed的整理方式，但又能充分利用数据空间，也更容易与硬件之间进行数据传递和比对。 unpack与pack相反，即将串行数据解包变为原有的各自域。该操作适用于从硬件一侧接收串行数据，进行校验之后，还原为软件一侧对象中各自对应的成员变量。 pack与unpack在通常的UVM环境中使用较少，但是 当与外界环境，例如System C发生大规模数据传递，该方法是首选 ，因为可以通过简单数据流实现精确的数据传输，另外，在UVM与FPGA、emulator之间进行数据交换时，该方法也由于简便得到了青睐。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class box extends uvm_object; int volume = 120; int height = 20; color_t color = WHITE; `uvm_object_utils_begin(box) ... `uvm_object_utils_end endclass box b1, b2; bit packed_bits[]; initial begin b1 = new(\u0026#34;box1\u0026#34;) ; b2 = new(\u0026#34;box2\u0026#34;) ; b1.volume = 100; b1.height = 40; b1.color = RED; b1.print(); b1.pack(packed_bits); $display(\u0026#34;packed bit stream size is %d \\n\u0026#34;, packed_bits.size()) ; b2.unpack(packed_bits) ; b2.print() ; end //================================ //输出结果： //Name Type Size Value //box1 box - @336 // volume integral 32 \u0026#39;h64 // height integral 32 \u0026#39;h28 // color color_t 32 RED //packed bits stream size is 96 //box2 box - @337 // volume integral 32 \u0026#39;h64 // height integral 32 \u0026#39;h28 // color color_t 32 RED   phase机制 写在前头  SV的验证环境构建中，传统的硬件设计模型在仿真开始前，已经完成例化和连接了；而SV的软件部分对象例化则需要在仿真开始后执行。 虽然对象例化通过调用构建函数new()来实现，但是单单通过new()函数无法解决一个重要问题，那就是 验证环境在实现层次化时，如何保证例化的先后关系，以及各个组件在例化后的连接 。 如果需要实现高级功能，例如在顶层到底层的配置时，SV也无法在底层组件例化之前完成对底层的配置逻辑。 因此UVM在验证环境构建时，引入了phase机制，通过该机制我们可以很清晰地 将UVM仿真阶段层次化 。 这里的层次化， 不单单是各个phase的先后执行顺序，而且处于同一phase中的层次化组件之间的phase也有先后关系 。 如果暂时抛开phase的机制剖析，对于UVM组件的开发者而言，他们主要关心各个phase执行的先后顺序。 在定义了各个phase虚方法后，UVM环境会按照phase的顺序分别调用这些方法。     phase 函数/任务 执行顺序 功能 典型应用     build 函数 自顶向下 创建和配置测试平台的结构 创建组件和寄存器模型，设置或者获取设置   connect 函数 自底向上 建立组件之间的连接 连接TLM的接口，连接寄存器模型和adapter   end_of_elaboration 函数 自底向上 测试环境的微调 显示环境结构、打开文件，为组件添加额外配置   start_of_simulation 函数 自底向上 准备测试环境的仿真 显示环境结构、设置断点，设置初始运行时的配置值   run 任务 自底向上 激励设计 提供激励、采集数据、数据比较   extract 函数 自底向上 从测试环境中收集数据 从测试平台提取剩余数据，从设计观察最终状态   check 函数 自底向上 检查任何不期望的行为 检查不期望的数据   report 函数 自底向上 报告测试数据 报告测试结果，并将其写入文件中   final 函数 自顶向下 完成测试活动、结束仿真 关闭文件，结束联合仿真引擎    执行机制  源码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  class subcomp extends uvm_component; `uvm_component_utils(subcomp) function new(string name, uvm_component parent) ; super.new(name, parent); endfunction function void build_phase(uvm_phase phase); `uvm_info(\u0026#34;build_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void connect_phase(uvm_phase phanse); `uvm_info(\u0026#34;connect_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void end_of_elaboration_phase(uvm_phase phase); `uvm_info(\u0026#34;end_of_elaboration_phase\u0026#34;, UVM_LOW) endfunction function void start_of_simulation_phase(uvm_phase phase); `uvm_info(\u0026#34;start_of_simulation_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction task run_phase(uvm_phase phase); `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endtask function void extract_phase(uvm_phase phase); `uvm_info(\u0026#34;extract_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void check_phase(uvm_phase phase); `uvm_info(\u0026#34;check_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void report_phase(uvm_phase phase); `uvm_info(\u0026#34;report_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction function void final_phase(uvm_phase phase); `uvm_info(\u0026#34;final_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) endfunction endclass class topcomp extends subcomp; subcomp cl, c2; ... function void build_phase(uvm_phase phase); uvm_info(\u0026#34;build_phase\u0026#34;, \u0026#34;\u0026#34;, UVM_LOW) c1 = subcomp::type_id::create(\u0026#34;c1\u0026#34;, this); c2 = subcomp::type_id::create(\u0026#34;c2\u0026#34;, this); endfunction endclass class test1 extends uvm_test; topcomp t1; ... function void build_phase(uvm_phase phase) ; t1 = topcomp::type_id::create(\u0026#34;t1\u0026#34;,this); endfunction endclass    输出结果   UVM_INFO @0: uvm_test_top.t1 [build_phase] UVM_INFo @0: uvm_test_top.t1.c1 [build_phase】 UVM_INFO @0: uvm_test_top.t1.c2 [build_phase] UVM_INFO @0: uvm_test_top.t1.cl [connectJphase] UvM_INFO @0: uvm_test_top.t1.c2 [connect_phase] UVM_INFO @0: uvm_test_top.t1 [connect_phase] UVM_INFO @0: uvm_test_top.t1.c1 [end_of_elaboration_phase] UVM_INFO @0: uvm_test_top.t1.c2 [end_of_elaboration_phase] UVM_INFO @0: uvm_test_top.t1 [end_of_elaboration_phase] UVM_INFO @O: uvm_test_top.t1.c1 [start_of_simulation_phase] UVM_INFO @0: uvm_test_top.t1.c2 [start_of_simulation_phase] UVM_INFO @0: uvm_test_top.t1. [start_of_simulation_phase] UVM_INFO @O: uvm_test_top.t1.c1 [run_phase] UVM_INFO @0: uvm_test_top.t1.c2 [run_phase] UVM_INFO @0: uvm_test_top.t1. [run_phase] UVM_INFO @O: uvm_test_top.t1.c1 [extract_phase] UVM_INFO @0: uvm_test_top.t1.c2 [extract_phase] UVM_INFO @0: uvm_test_top.t1. [extract_phase] UVM_INFO @O: uvm_test_top.t1.c1 [check_phase] UVM_INFO @0: uvm_test_top.t1.c2 [check_phase] UVM_INFO @0: uvm_test_top.t1. [check_phase] UVM_INFO @O: uvm_test_top.t1.c1 [report_phase] UVM_INFO @0: uvm_test_top.t1.c2 [report_phase] UVM_INFO @0: uvm_test_top.t1. [report_phase] UVM_INFO @O: uvm_test_top.t1.c1 [final_phase] UVM_INFO @0: uvm_test_top.t1.c2 [final_phase] UVM_INFO @0: uvm_test_top.t1. [final_phase] 9个主要phase  上面的九个phase对于一个测试环境的生命周期而言，是有固定的先后执行顺序的；同时对于同一个phase中的组件，执行也会按照层次的顺序或者自顶向下、或者自底向上来执行。 对于 build phase，执行顺序按照自顶向下 ，这符合验证结构建设的逻辑。因为只有先例化高层组件，才会创建空间来容纳低层组件。 只有uvm_component及其继承于uvm_component的子类，才会按照phase机制将上面的九个phase先后执行完毕。 常用的phase包括build、connect、run和report，它们分别完成了组件的 建立、连接、运行和报告 。这些phase在uvm_component中通过_phase的后缀完成了虚方法的定义，比如build_phase()可以定义一些 组件例化和配置的任务 。 在所有phase中， 只有run_phase方法是一个可以耗时的任务，这意味着该方法可以完成一些等待、激励、采样的任务。对于其它phase对应的方法都是函数， 必须立即返回(0耗时) 在run_phase中， 用户如果要完成测试， 通常需要组织下面的激励序列：  上电 复位 寄存器配置 发送主要测试内容 等待DUT完成测试    12个分之phase  在用户发送激励的 一种简单方式是，在run_phase中完成上面所有的激励；另外一种方式是，如果用户可以将上面几种典型序列划分到不同区间，让对应的激励按区间顺序发送的话，可以让测试更有层次 。因此run_phase又可以分为下面12个phase：  pre_reset_phase reset_phase post_reset_phase pre_configure_phase configure_phase post_configure_phase pre_main_phase main_phase post_main_phase pre_shutdown_phase shutdown_phase post_shutdown_phase   实际上run_phase任务和上面细分的12个phase是 并行 的，即在start_of_simulation_phase任务执行以后，run_phase和reset_phase开始执行，而在shutdown_phase执行完成之后，需要等待run_phase执行完才可以进入extract_phase。       UVM编译和运行顺序      UVM仿真开始  要在仿真开始时建立验证环境，用户可以考虑选择下面几种方式：  可以通过全局函数(由uvm_pkg提供) run_test() 来选择性地指定要运行哪一个uvm_test。这里的test类均继承于uvm_test。这样的话， 指定的test类将被例化并指定为顶层的组件。一般而言，run_test()函数可以在合适的module/program中的initial进程块中调用。 如果没有任何参数传递给run_test()，那么用户可以在仿真时通过传递参数 +UVM_TEST NAME=\u0026lt;test_name\u0026gt; ，来指定仿真时调用的uvm_test。当然，即便run_test()函数在调用时已经有test名称传递，在仿真时+UVM_TEST NAME=\u0026lt;test_name\u0026gt;也可以从顶层覆盖已指定的test。这种方式使得仿真不需要通过再次修改run_test()调用的test名称和重复编译，就可以灵活选定test。   无论上面哪一种方式，都必须在顶层调用全局函数run_test()，用户可以考虑不传递test名称作为参数，而在仿真时通过传递参数+UVM_TESTNAME=\u0026lt;test_name\u0026gt;来选择test。 全局函数run_test()的重要性，正是从uvm_root创建了一个UVM世界 。  UVM世界的\u0026quot;诞生\u0026rdquo; 1 2 3 4 5 6 7  task run_test(string test_name=\u0026#34;\u0026#34;); uvm_root top; uvm_coreservice_t cs; cs=uvm_coreservice_t::get(); top=cs.get_root(); top.run_test(test_name); endtask    UVM顶层类uvm_root。 该类也继承于uvm_component ，它也是UVM环境结构中的一员，而它可以作为顶层结构类。 它提供了一些像run_test()的这种方法，来充当了UVM世界中的核心角色。 在uvm_pkg中， 有且只有一个顶层类uvm_root所例化的对象，即uvm_top 。 uvm_top（也就是uvm_root）承担的核心职责包括：  作为隐形的UVM世界顶层，任何其它的组件实例都在它之下，通过创建组件时指定parent来构成层次。 如果parent设定为null，那么它将作为uvm_top的子组件。 phase控制。控制所有组件的phase顺序。 索引功能。通过层次名称来索引组件实例。 报告配置。通过uvm_top来全局配置报告的繁简度(verbosity) 。 全局报告设备。由于可以全局访问到uvm_top实例， 因此UVM报告设备在组件内部和组件外部(例如module和sequence) 都可以访问。   通过uvm_top调用方法run_test(test_name)，uvm_top做了如下的初始化：  得到正确的test_name。 初始化objection机制（控制仿真退出）。 创建uvm_test_top实例。 调用phase控制方法，安排所有组件的phase方法执行顺序。 等待所有phase执行结束， 关闭phase控制进程。 报告总结和结束仿真。    UVM仿真结束  UVM-1.1之后， 结束仿真的机制有且只有一种，那就是利用objection挂起机制来控制仿真结束 。 uvm_objection类提供了一种供所有component和sequence共享的计数器。 如果有组件来挂起 *objection，那么它还应该记得落下objection 。 参与到objection机制中的组件，可以独立的各自挂起objection，来防止run phase退出，但是只有这些组件都落下objection后，uvm_objection共享的counter才会变为0，这意味run phase退出的条件满足，因此可以退出run phase。 对于uvm_objection类，用来反停止的控制方法包括：  raise_objection(uvm_object obj=null, string description=\u0026rdquo;\u0026quot;, int count=1) 挂起objection drop_objection(uvm_object obj=null, string description=\u0026rdquo;\u0026quot;, int count=1) 落下objection set_drain_time(uvm_object obj=null, time drain) 设置退出时间   对这几种方法，在实际应用中的建议有：  对于component()而言，用户可以在run_phase()中使用phase.raise_objection()/phase.drop_objection()来控制run phase退出。 用户最好为description字符串参数提供说明，这有利于后期的调试。 应该使用默认count值。 对于uvm_top或者uvm_test_top应该尽可能少地使用set_drain_time() 。    objection防止仿真退出 1 2 3 4 5 6 7 8 9 10  class test1 extends uvm_test; ... task run_phase(uvm_phase phase) ; phase.raise_objection(this) ; `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;entered..\u0026#34;, UVM_LOW) #1us; `uvm_info(\u0026#34;run_phase\u0026#34;, \u0026#34;exited..\u0026#34;, UVM_LOW) phase.drop_objection(this); endtask endclass    如果要在component中挂起objection，建议在一进入run_phase()后就挂起，保证objection counter及时被增加。 另外，用户需要习惯在sequence中挂起objection，由于sequence不是uvm_component类，而是uvm_object类，因此它只有body()方法，而没有run_phase()方法。 所以在sequence中使用objection机制时，可以在body()中的首尾部分挂起和落下objection。  config机制 写在前头  在验证环境的创建过程build phase中， 除了组件的实例化，配置也是必不可少的 。 为了验证环境的复用性，通过外部的参数配置，使得环境在创建时可以根据不同参数来选择创建的组件类型、组件实例数目、组件之间的连接以及组件的运行模式等。 在更细致的环境调节(environment tuning)中有更多的变量需要配置，例如for-loop的阈值、字符串名称、随机变量的生成比重等。 比起重新编译来调节变量，如果在仿真中可以通过变量设置来修改环境，那么就更灵活了，而UVM config机制正提供了这样的便捷。 在UVM提供了uvm_config_db配置类以及几种方便的变量设置方法来实现仿真时的环境控制，常见的uvm_config_db类的使用方式包括：  传递virtual interface到环境中 设置单一变量值，例如int、string、enum等 传递配置对象(config object)到环境     1 2  uvm_config_db#(T)::set(uvm_component cntxt, string inst_name, string field_name, T value); uvm_config_db#(T)::get(uvm_component cntxt, string inst_name, string field_name, inout T value);   interface传递  interface传递可以很好地解决了连接硬件世界和软件世界。 而在之前SV验证模块中，虽然SV可以通过层次化的interface的索引来完成了传递，但是这种方式不利于软件环境的封装和复用。 UVM的uvm_config_db使得接口的传递和获取彻底分离开来。 在实现接口传递的过程中需要注意：  接口传递应该发生在run_test()之前 。这保证了在进入build phase之前，virtual interface已经被传递到uvm_config_db中。 用户应当把interface与virtual interface的声明区分开来，在 传递过程中的类型应当为virtual interface ，即实际接口的句柄。     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  interface intf1; logic enable = 0; endinterface class comp1 extends uvm_component; `uvm component_utils(comp1) virtual intf1 vif; ... function void build_phase(uvm_phase phase) ; if(!uvm_config_db#(virtual intf1)::get(this, \u0026#34;\u0026#34;, \u0026#34;vif\u0026#34;, vif) ) begin `uvm_error(\u0026#34;GETVIF\u0026#34;, \u0026#34;no virtual interface is assigned\u0026#34;) end `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;vif.enable is %b before set\u0026#34;, vif.enable), UVM_LOW) vif.enable = 1; `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;vif.enable is tb after set\u0026#34;, vif.enable), UVM_LOW) endfunction endclass //=================================== class test1 extends uvm_test; `uvm_component_utils(test1) comp1 cl; ... endclass //=================================== intf1 intf(); initial begin uvm_config_db#(virtual intf1)::set(uvm_root::get() , \u0026#34;uvm_test_top.c1\u0026#34;, \u0026#34;vif\u0026#34;, intf); run_test(\u0026#34;test1\u0026#34;); end //=================================== //输出结果： //UVM_INFO @O: reporter[RNTST] Running test test 1... //UVM_INFO @O: uvm_test_top.c1 [SETVAL] vif.enable is O before set //UVM_INFO @o: uvm_test_top.c1 [SETVAL] vif.enable is 1 after set   变量设置  在各个test中，可以在build_phase对底层组件变量加以配置，进而在环境例化之前完成配置，使得环境可以按照预期运行。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class comp1 extends uvm_component; uvm_component_utils(comp1) int val1=1; string str1=\u0026#34;null\u0026#34;; function void build_phase(uvm_phase phase); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;val1 is %d before get\u0026#34;, val1), UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;str1 is %s before get\u0026#34;, str1), UVM_LOW) uvm_config_db#(int)::get(this, \u0026#34;\u0026#34;, \u0026#34;val1\u0026#34;, vall); uvm config_db#(string)::get(this, \u0026#34;\u0026#34;, \u0026#34;str1\u0026#34;, str1); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;val1 is·%d after get\u0026#34;, v al1) , UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;str1 is %s after get\u0026#34;, str1) , UVM_LOW) endfunction endclass //===================================== class test1 extends uvm_test; `uvm_component_utils(test1) comp1 cl; ... function void build_phase(uvm_phase phase); uvm_config_db#(int)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;val1\u0026#34;, 100); uvm_config_db#(string)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;str1\u0026#34;, \u0026#34;comp1\u0026#34;) ; c1 = comp1::type_id::create(\u0026#34;c1\u0026#34;, this); endfunction endclass //===================================== //输出结果： // UVM_INFO @O: uvm_test_top.c1 [SETVAL] val1 is 1 before get // UVM_INFO @O: uvm_test_top.c1 [SETVAL] str1 is null before get // UVM_INFO @O: uvm_test_top.c1 [SETVAL] val1 is 100 after get // UVM INFO @O: uvm test_top.c1 [SETVALl str1 is comp1 after get    注意细节： 先传递后创建  object传递  在test配置中，需要配置的参数不只是数量多，而且可能还分属于不同的组件。 那么如果对这么多层次中的变量做出类似上面的变量设置，那会需要更多的代码，容易出错还不易于复用，甚至底层组件的变量被删除后， 也无法通过uvm_config_db::set()得知配置是否成功。 然而如果将每个组件中的变量加以整合，首先放置到一个uvm_object中，再对中心化的配置对象进行传递，那么将会更有利于整体环境的修改维护。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class config1 extends uvm_object; int val1 = 1; int str1 = \u0026#34;null\u0026#34;; `uvm_object_utils(config1) ... endclass //================================= class comp1 extends uvm_component; uvm_component_utils(comp1) config1 cfg; ... function void build_phase(uvm_phase phase) ; uvm_object tmp; uvm_config_db#(uvm_object)::get(this, \u0026#34;\u0026#34;, \u0026#34;cfg\u0026#34;, tmp); void\u0026#39;($cast(cfg, tmp)); `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;cfg.val1 is %d after get\u0026#34;, cfg.val1), UVM_LOW) `uvm_info(\u0026#34;SETVAL\u0026#34;, $sformatf(\u0026#34;cfg.str1 is %s after get\u0026#34;, cfg.str1) , UVM_LOW) endfunction endclass //================================= class test1 extends uvm_test; `uvm_component_utils(test1) comp1 c1, c2; config1 cfg1, cfg2; ... function void build_phase(uvm_phase phase); cfg1 = config1::type_id::create(\u0026#34;cfg1\u0026#34;); cfg2 = config1::type_id::create(\u0026#34;cfg2\u0026#34;); cfg1.val1 = 30; cfgl.strl = \u0026#34;c1\u0026#34;; cfg2.val1 = 50; cfg2.str1 = \u0026#34;c2\u0026#34;; uvm_config_db#(uvm_object)::set(this, \u0026#34;c1\u0026#34;, \u0026#34;cfg\u0026#34;, cfg1) ; uvm_config_db#(uvm_object)::set(this, \u0026#34;c2\u0026#34;, ”cfg”, cfg2) ; c1 = comp1::type_id::create(\u0026#34;c1\u0026#34;, this); c2 = comp1::type_id::create(\u0026#34;c2\u0026#34;, this); endfunction endclass   总结  在使用uvm_config_db::set()/get()时，实际发生了这些后台操作：  uvm_config_db::set()通过层次和变量名，将这些信息放置到uvm_pkg唯一的全局变量uvm_pkg::uvm_resources. 全局变量uvm_resources用来存储和释放配置资源信息(resource information) 。uvm_resources是uvm_resource_pool类的全局唯一实例，该实例中有两个resource数组用来存放配置信息，这两个数组中一个由层次名字索引，一个由类型索引，通过这两个关联数组可以存放通过层次配置的信息。 同时，底层的组件也可以通过层次或者类型来取得来自高层的配置信息。这种方式使信息的配置和获取得到剥离，便于调试复用。 在使用uvm_config_db::get()方法时，通过传递的参数构成索引层次，然后在uvm_resource已有的配置信息池中索引该配置，如果索引到，方法返回1，否则返回0。    建议  在使思set()/get()方法时，传递的参数类型应当上下保持一致。对于uvm_object等实例的传递如果get型与set类型不一致，应当首先通过$cast()完成类型转换，再对类型转换后的对象进行操作。 set()/get()方法传递的参数可以使用通配符“*”来表示任意的层次，类似于正则表达式的用法。同时用户需要懂得“*.comp1”与“*comp1”的区别，前者表示在目前层次以下所有名称为“comp1”的组件，而后者表示包括当前层次及当前层次以下所有名为“comp1”的组件。 在module环境中如果要使用uvm_config_db::set()，则传递的第一个参数uvm_component_cntxt参数用来表示当前的层次。如果当前的层次为最高层，用户可以设置为null，也可以设置为uvm_root::get()来表示uvm_root的全局顶层实例。 在使用配置变量时，应当确保先进行uvm_config_db::get()操作，在获得了正确的配置值以后再使用。 应当尽量确保uvm_config_db::set()方法在相关配置组件创建前调用。这是因为只有先完成配置，相关组件在例化前才可以得到配置值继而正确地例化。 在set()方法第一个参数使用当前层次的前提下，对于同一组件的同一个变量，如果有多个高层组件对该变量进行设置，那么较高层组件的配置会覆盖较低层的配置，但是如果是同一层次组件对该变量进行多次配置时，应该遵循后面的配置会覆盖前面的配置。 用户应该在使用uvm_config_db::get()方法时， 添加便于调试的语句，例如通过UVM报告信息得知get()方法中的配置变量是否从uvm_confog_db获取到，如果没有获取，是否需要采取其他措施。  消息管理 写在前头  在一个好的验证系统应该具有消息管理特性，它们是：  通过一种标准化的方式打印信息 过滤(重要级别)信息 打印通道   这些特性在UVM中均有支持， UVM提供了一系列丰富的类和方法来生成和过滤消息：  消息方法 消息处理 消息机制    消息方法  在UVM环境中或者环境外，只要有引入uvm_pkg，均可以通过下面的方法来按照消息的严重级别和冗余度来打印消息。   1 2 3 4 5 6 7  function void uvm_report_info(string id, string message, int verbosity=UVM MEDIUM, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm_report_warning(string id, string message, int verbosity=UVM_MEDIUM, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm report error(string id, string message, int verbosity=UVM_LOW, string filename=\u0026#34;\u0026#34;, int line=0) ; function void uvm_report_fatal(string id, string message, int verbosity=UVM_NONE, string filename=\u0026#34;\u0026#34;, int line=0) ;    四个消息函数有若干共同的信息，它们是 严重级别(severity) 、冗余度(verbosity) 、消息ID、消息、文件名和行号 ：  严重级别：从函数名本身也可以得出，这四个严重级别分别是UVM_INFO、UVM_WARNING、UVM_ERROR、UVM_FATAL。不同的严重级别在打印的消息中也会有不同的指示来区别，同时仿真器对不同严重级别消息的处理方式也不一样。例如对于UVM_FATAL的消息，默认情况下仿真会停止。 消息ID：该ID可以是任意的字符串，用来标记该消息。这个标记会同消息本身打印出来，同时不同的标记也可以用来进行消息处理。 消息：即消息文本的主体。 冗余度：冗余度与消息处理中的过滤直接相关。冗余度的设置如果低于过滤的开关，那么该消息会打印出来，否则不会被打印出来。但是无论信息是否会被打印出来，这都与对消息采取的其它措施没有关系，例如仿真停止。 文件名和行号：这些信息用来提供消息发生时所在的文件和行号。用户可以使用默认值， 而UVM后台会自动填补它们原本的文件名和行号， 同时也在打印时将文件名和行号输出。    消息处理  与每一条消息对应的是如何处理这些消息。通常情况下，消息处理的方式是同消息的严重级别对应的。如果用户有额外的需求，也可以修改对各个严重级别的消息处理方式。     处理方式 说明     NO_ACTION 不做任何处理   UVM_DISPLAY 将消息输出到标准输出端口   UVM_LOG 将消息写入到文件   UVM_COUNT 增加退出计算变量quit_count，达到一定数值时则停止仿真   UVM_EXIT 立刻停止仿真   UVM_CALL_HOOK 调用对应的回调函数   UVM_STOP 停止仿真     不同的严重级别消息，用户可以使用默认的消息处理方式     严重级别 默认处理方式     UVM_INFO UVM_DISPLAY   UVM_WARNING UVM_DISPLAY   UVM_ERROR UVM_DISPLAY \u0026amp; UVM_COUNT   UVM_FATAL UVM_DISPLAY \u0026amp; UVM_EXIT    消息宏  如果要做自定义的消息处理方式，用户可以通过uvm_report_object类提供的方法进行配置。 uvm_report_object类是间于uvm_object类与uvm_component类之间的中间类，它的主要功能是完成消息打印和管理。 UVM也提供了一些宏来对应上面的消息方法，用户也可以使用这些宏来处理消息。     方法调用 宏调用     uvm_report_info() `uvm_info(ID, MESSAGE, VERBOSITY)   uvm_report_warning() `uvm_warning(ID, MESSAGE)   uvm_report_error() `uvm_error(ID, MESSAGE)   uvm_report_fatal() `uvm_fatal(ID, MESSAGE)    消息机制  消息处理是由uvm_report_handler类来完成的，而每一个uvm_report_object类中都有一个uvm_report_handler实例。 上面的uvm_report_object消息处理方法或者uvm_component消息处理方法， 都是针对于这些uvm_report_handler做出的配置。 除了上面的常见使用方法，用户还可以做出更高级的消息控制。例如，当UVM_ERROR出现之后，仿真默认会停止，这是由于设置了UVM_ERROR的处理方式是UVM_COUNT数量达到上限(默认为1)，即停止仿真。可以通过set_max_quit_count来修改UVM_COUNT值。  回调函数  消息用户在处理信息时还希望做出额外的处理，这时回调函数就显得很有必要了，uvm_report_object类提供了下面的回调函数满足用户更多的需求：   1 2 3 4 5 6 7 8 9  function bit report_hook(string id, string message, int verbosity, string filename, int line ); function bit report_info_hook(string id, string message, int verbosity, string filename, int line ); function bit report_warning_hook(string id, string message, int verbosity, string filename, int line ); function bit report_error_hook(string id, string message, int verbosity, string filename, int line ); function bit report_fatal_hook(string id, string message, int verbosity, string filename, int line );    report_hook(函数通过结合消息管理时的UVM_CALL_HOOK参数，结合用户自定义的回调函数，就可以实现更丰富的配置。 这样用户在调用回调函数时，首先会调用report_hook()函数，接下来才按照severity级别来选择更细致的回调函数report_SEVERITY_hook() 。 默认情况下，report_hook()函数返回值为1，进而再转入severity hook函数。 如果report_hook()函数由用户自定义且返回0的话，那么后续report_SEVERITY_hook()函数不会执行。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class test1 extends uvm_test; integer f; `uvm_component_utils(test1) ... function void build_phase(uvm_phase phase) ; set_report_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_CALL_HOOK); set_report_verbosity_level(UVM_LOW) ; endfunction task run_phase(uvm_phase phase) ; uvm_report_info(\u0026#34;RUN\u0026#34;, \u0026#34;infol\u0026#34;, UVM_MEDIUM) ; uvm_report_info(\u0026#34;RUN\u0026#34;, \u0026#34;info2\u0026#34;, UVM_LOW) ; uvm_report_warning(\u0026#34;RUN\u0026#34;, \u0026#34;warning1\u0026#34;, UVM_LOW) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error1\u0026#34;, UVM LOW) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error2\u0026#34;, UVM_HIGH) ; uvm_report_error(\u0026#34;RUN\u0026#34;, \u0026#34;error3\u0026#34;, UVM_LOW) ; endtask function void report_phase(uvm_phase phase) ; $fclose(f) ; endfunction function bit report_hook(string id, string message, int verbosity, string filename, int line) ; uvm_report_info(\u0026#34;RPTHOOK\u0026#34;, $sformatf(\u0026#34;%s: %s\u0026#34;, id, message), UVM_LOW) ; return 1; endfunction function bit report_error_hook(string id, string message, int verbosity, string filename, int line) ; uvm_report_info(\u0026#34;ERRHOOK\u0026#34;, $sformatf(\u0026#34;%s: %s\u0026#34;, id, message) , UVM LOW) ; return 1; endfunction endclass   消息管理  report_hook() 函数通过结合消息管理时的UVM_CALL_HOOK参数，结合用户自定义的回调函数，就可以实现更丰富的配置。 这样用户在调用回调函数时，首先会调用report_hook()函数，接下来才按照severity级别来选择更细致的回调函数report_SEVERITY_hook() 。 默认情况下，report_hook()函数返回值为1，进而再转入severity hook函数。 如果report_hook()函数由用户自定义且返回0的话，那么后续report_SEVERITY_hook()函数不会执行。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":28,"section":"docs","tags":["UVM"],"title":"UVM学习笔记（二）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/uvm-study-note-two/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 UVM学习笔记 部分第一篇，主要介绍验证方法学、类库地图、工厂机制和覆盖方法。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《UVM实战》 张强 书籍    专业术语与缩略语    缩写 全称 说明           类库地图 写在前头  在SV模块中，验证环境整体的构建，是从底层模块的验证组件搭建到通信和激励生成。 这些元素无论是软件对象的创建、访问、修改、配置，还是组件之间的通信等都是通过用户自定义的方式来实现的。 UVM验证方法学作为之前所有方法学的融合版本， 从自身初衷而言，就是将验证过程中可以重用和标准化的部分都规定在其方法学的类库当中，通过标准化的方式减轻了验证人员构建环境的负担。  对验证环境的共同需求  在可以看到对验证环境的共同需求是：  组件的创建和访问 环境的结构创建、组件之间的连接和运行 不同阶段的顺序安排 激励的生成、传递和控制 测试的报告机制   由于软件环境中对象的生成是动态的，验证环境中的组件也需要UVM提供底层功能来完成对象的创建和访问。 在组件创建之外，UVM也需要提供环境上下层次中 创建、连接和运行 组件的顺序控制方法，只有在底层机制上有效地保证这一点，才会避免可能发生的句柄悬空问题。 在组件通信中， UVM也提供了功能更丰富的TLM(Transaction Level Model) 接口，这可以保证相邻组件的通信不再通过显式句柄引用，而是独立于组件的通信方式。 对于测试序列(sequence) 的生成和传输也是利用了TLM传输在sequence和driver之间完成。而对于不同sequence的发送顺序控制， 也类似于SV测试MCDF子系统的要求， 需要实现sequence之间的灵活调度。 为了便于验证环境的调试， UVM的报告机制可以将来自于不同组件不同级别的信息并且加以过滤.最终生成测试报告。  UVM世界观       UVM类库地图按照UVM的核心机制将地图进行了分块 ：  核心基类 工厂(factory) 类 事务(transaction) 和序列(sequence) 类 结构创建(structure creation) 类 环境组件(environment component) 类 通信管道(channel) 类 信息报告(message report) 类 寄存器模型(register model) 类 线程同步(thread synchronization) 类 事务接口(transaction interface) 类    验证方法学 所处的验证时代  国内验证起步较晚，历史包袱不重，在验证整合的尾期才开始发育，因此 验证技术的更替较少 。 超过20年的IC公司，存在几代的验证结构和较难彼此复用的测试代码，由于项目复用和进度的考虑，这些本该淘汰的技术依然在使用中，这对工程师造成了额外的负担。 原有的HDL描述语言受限于静态例化，无法随着仿真场景做动态变换。同时，天生地随机约束短板也让后期发展的功能覆盖率驱动验证方式没有可以依靠的专用验证语言。 平台限定性语言在一开始符合IC研发的封闭生态特点，但验证工程师们的交流远甚于设计工程师(DVC on、SNUG、CDN Live等)，而且在技术交流和人员流动的过程中，逐渐提出了统一验证语言的要求。 SystemVerilog从早先的Accellera 2002年的SystemVerilog 3.0标准逐步发展到IEEE-1800 SystemVerilog 2017标准， 经历了十五年的更新和完善，已经全面雄起为IC验证领域的霸主。 上层的高级验证方法学也在2011年2月份之后逐步得到了融合，即UVM(Universal Verification Methodology)1.0的发布。 现在步入芯片验证，可以躲过AVM、VMM、OVM的学习， 而直接学习融合以后的验证方法学UVM。 UVM融合的积极意义在于， 打通了各个EDA公司和IC设计公司的验证技能通道，便于验证技术交流和人才流动，也方便了IC设计公司的技术及工具选择。 用户不再受限于使用何种仿真器、使用哪一家的验证IP，而只需要将主要精力着眼于设计的功能验证，由此也提升了验证效率。 SV的核心特性包括面向对象、随机约束、线程通信、功能覆盖率收集等，这些特性也为建立一个验证环境提供了足够多的便利。 UVM方法学的验证方法学通过吸取eRM(Spec man/e验证方法学) ， AVM， OVM， UVM等之前不同方法学的优点， 可谓集众家之所长。  UVM的优势  所有的验证方法学服务目的都在于 提供一些可以重用的类来减轻在项目之间水平复用和垂直复用的工作量 ，而同时对于验证新人又能提供一套可靠的框架，帮助他们摆脱搭建房子构思图纸的苦恼。 UVM面向所有数字设计，涵盖了从模块级到芯片级，ASIC到FPGA，以及控制逻辑、数据通路到处理器验证对象的全部场景。 UVM中的Universal(通用) 的含义代表的是该方法学可以适用于大多数的验证项目，而它自身提供的 基础类库(basic class library) 和基本验证结构 可以让具有不同软件编程经验的verifier们能够快速构建起一个结构可靠的验证框架。 UVM自定义的框架构建类和测试类能够帮助verifier 减轻环境构建的负担 ，进而 将更多的精力集中在如何制定验证计划和创建测试场景 。  UVM的发展历程  2010年， 发布了UVM 1.0EA(Early Adopter) 版本。 目前已经发展到UVM 1.2， 并且在2017年被IEEE宣布为正式标准， 即IEEE 1800.2 UVM1.1之前的演变进化更多地是在于汲取OVM的方法学框架以及创建UVM的寄存器模型。 在UVM1.2版本的重要变化是UVM的消息机制更新和transaction记录能力的增强。  UVM的学习  在UVM的演变发展历史中， 在新版本虫新的构建平台方式和测试方式可以同旧的方法并存。UVM的新版本在兼容老版本用法的同时，也注毁了一些之前的陈旧用法。 在探索UVM世界时， 我们会遵循着下面的结构来帮助读者全面认识业界统一的验证方法学：  认识UVM世界的版图(类库) 和核心机制 学习核心的UVM组件和层次构建方式 了解常见的UVM组件间的通信方式 深入UVM测试场景的构成 UVM的寄存器模型应用    工厂机制 写在前头  工厂(factory) 机制是UVM的真正魅力所在。 工厂机制也是软件的一种典型设计模式(design pattern)。  工厂的意义  UVM工厂的存在就是 为了更方便地替换验证环境中的实例或者注册了的类型 ，同时工厂的注册机制也带来了 配置的灵活性 。 这里的实例或者类型替代，在UVM中称作 覆盖(override) ，而被用来替换的对象或者类型，应该满足注册(registration) 和多态(polymorphism) 的要求。 UVM的验证环境构成可以分为两部分， 一部分构成了环境的层次 ，这部分代码是通过uvm_component类完成， 另外一部分构成了环境的属性(例如配置)和数据传输 ，这一部分通过uvm_object类完成。 这两种类的集成关系从UVM类库地图可以看到，uvm_component类继承于uvm_object类，而这两种类也是进出工厂的主要模具和生产对象。 之所以称为模具，是因为通过注册，可以利用工厂完成对象创建。 之所以对象由工厂生产，也是利用了工厂生产模具可灵活替代的好处，这使得在不修改原有验证环境层次和验证包的同时，实现了对环境内部组件类型或者对象的覆盖。  uvm_component和uvm_object  uvm_component和uvm_object将会伴随着整个UVM的学习。 参照SV模块学习中的组件概念，即验证环境的不动产，大致包含：  generator stimulator monitor agent checker/reference model environment test   这些组件在uvm_component的子类中均有对应的组件。 SV中的非固定资产即那些TLM transaction，从generator流向stimulator的数据包，而这些类在UVM中统一由uvm_object表示。  uvm_{component/object}的例化  每一个uvm_{component/object} 在例化的时候都应该给予一个名字(string)。 “fullname”指的是component所处的完整层次结构。 在每个层次中例化的组件名称，应该独一无二(unique) 。 创建component或者object的方法如下：   1 2 3 4  //创建uvm_component对象时: comp_type::type_id::create(string name, uvm_component parent); //创建uvm_object对象时: object_type::type_id::create(string name);   工厂提供的便利\u0026ndash;创建（create） 1 2 3 4 5 6 7 8 9 10  class comp1 extends uvm_component; `uvm_component_utils(comp1) //固定注册格式  function new(string name=\u0026#34;comp1\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;%s is created\u0026#34;, name)); endfunction:new function void build_phase(uvm_phase phase); super.build_phase(phase); endfunction:build_phase endclass   1 2 3 4 5 6 7  class obj1 extends uvm_object; uvm_object_utils(obj1) function new(string name=\u0026#34;obj1\u0026#34;); super.new(name); $display($sformatf(\u0026#34;%s is created\u0026#34;, name)); endfunction：new endclass   1 2 3 4 5 6 7 8 9 10 11 12  comp1 c1, c2; obj1 o1, o2； initial begin //SV的创建方式  cl=new(\u0026#34;cl\u0026#34;); o1=new(\u0026#34;o1\u0026#34;); //UVM工厂的创建方式  c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); o2=obj1::type_id::create(\u0026#34;o2\u0026#34;); end    c2和o2的例化方式也是最后通过调用new() 函数实现的。毕竟对于任何对象的例化，最终都要通过new()构建函数来实现的。 一般来说运用factory的步骤可分为：  将类注册到工厂 在例化前设置覆盖对象和类型(可选的) 对象创建   在两种类comp1和objl的注册中，分别使用了UVM宏uvm_component_utils和uvm_object_utils。 这两个宏做的事情就是 将类注册到factory中 。在解释注册函数之前，我们需要懂得在整个仿真中，factory是独有的，即有且只有一个，这保证了所有类的注册都在一个“机构”中。  uvm_coreservice_t类  该类内置了UVM世界核心的组件和方法， 它们主要包括  唯一的uvm_factory， 该组件用来注册、覆盖和例化 全局的report_server， 该组件用来做消息统筹和报告 全局的tr_database， 该组件用来记录transaction记录 get_root() 方法用来返回当前UVM环境的结构顶层对象   而在UVM-1.2中， 明显的变化是通过uvm_coreservice_t将最重要的机制(也是必须做统一例化处理的组件)都放置在了uvm_core serice_t类中。 该类并不是uvm_component或者uvm_object， 它也并没有例化在UVM环境中， 而是独立于UVM环境之外的。 uvm_coreservice_t只会被UVM系统在仿真开始时例化一次。用户无需，也不应该自行再额外例化该核心服务组件。 这个核心组件如同一个随时待命的仆人，做好服务的准备。 理论上，用户可以获取核心服务类中的任何一个对象，例如uvm_default_factory对象， 继而直接利用factory来实现创建和覆盖。当然，创建和覆盖也可以由其它方式完成。  注册宏`uvm_{component/object}_utils  `uvm_component_utils用来注册组件类uvm_component `uvm_object_utils用来注册核心基类uvm_object 利用工厂注册机制的细节请参考红宝书P265，而对于验证工程师会使用uvm工厂注册是必要的，而具体实现机制细节不是必要的。 无论对于uvm_component或者uvm_object，在UVM世界中， 请养成习惯使用注册宏`uvm_component/object_utils 对于注册，并不是真正地将一个抽象的类型(空壳)放置在什么地方，而是通过例化该类的对象来完成。 由于一种类型在通过宏调用时只注册一次，那么在不考虑覆盖的情况下，uvm_default_factory就将每一个类对应的对象都放置到了factory的字典当中。 uvm_default_factory::create_component_by_type() 经过代码简化，读者可以看到关键语句，它们首先检查处在该层次路径中需要被例化的对象，是否受到了“类型覆盖”或者“实例覆盖”的影响，进而将最终类型对应的对象句柄(正确的产品模板)交给工厂。 有了正确的产品模板，接下来就可以通过uvm_component_registry::create_component() 来完成例化。  注册后的对象创建  uvm_component和uvm_object在创建时虽然都需要调用create()函数， 但最终创建出来的uvm_component是会表示在UVM层次结构中的， 而uvm_object则不会显示在层次中。 这一点也可以从uvm_component::new(name, parent) 和uvm_object::new(name) 中看得出来。 uvm_component::new(name, parent) 保留两个参数， 就是为了通过类似“钩子”的做法，一层层由底层勾住上一层，这样就能够将整个UVM结构串接起来了。 uvm_object::new(name) 则没有parent参数， 因此也不会显示在UVM层次中， 只能作为configuration或者transaction等用来做传递的配置结构体或者抽象数据传输的数据结构体，成为uvm_component的成员变量。 创建对象时，需要结合工厂的注册和覆盖机制来决定，应该使用哪一个类型来创建。       工厂创建compon/obiect的方法  除了使用component/object来创建实例， 也可以利用factory来创建：  create_component_by_name() create_component_by_type() create_obj eat_by_name() create_object_by_type()   为了避免不必要的麻烦， 我们在使用宏`uvm_component_utils和`uvm_object_utils注册类型时， 宏内部就将类型T作为类型名Tname=‘T’注册到factory中去。这就使得通过上面的任何一种方法在创建对象时，不会受困于类型与类型名不同的苦恼。  component/object与工厂有关的方法  配合工厂的注册、创建和覆盖的相关方法：  create() create_component() get() get_type_name() set_inst_override() set_type_override()   每一个uvm_component的类在注册时， 会定义一个新的uvm_component_registry类， 其如同一个外壳， 一个包装模板的纸箱， 在factory中注册时， 该纸箱中容纳的是被注册类的“图纸”，并没有一个“实例”。  建议 对于创建对象的方法，以上有工厂提供的创建对象的方法，有组件提供的创建对象的方法，并不需要全部掌握，而只需要记住 工厂提供的便利\u0026ndash;创建（create） ，之所以讲这么多是在看到别人的环境中出现这些方法时，要知道是做什么的。\n1 2  c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); o2=obj1::type_id::create(\u0026#34;o2\u0026#34;);   覆盖方法 工厂提供的便利\u0026ndash;覆盖(override)  覆盖机制可以将其原来所属的类型替换为另外一个新的类型。 在覆盖之后，原本用来创建原属类型的请求，将由工厂来创建新的替换类型。  无需再修改原始代码，继而保证了原有代码的封装性。 新的替换类型必须与被替换类型相兼容，否则稍后的句柄赋值将失败，所以 新的类型要继承于原有的类型 。   做顶层修改时，非常方便!  允许灵活的配置，例如 可使用子类来覆盖原本的父类 可使用不同的对象来修改其代码行为   要想实现覆盖特性， 原有类型和新类型均需要注册 。 当使用create()来创建对象时：  工厂会检查，是否原有类型被覆盖。 如果是，那么它会创建一个新类型的对象。 如果不是，那么它会创建一个原有类型的对象。   覆盖发生时，可以使用 “类型覆盖”或者“实例覆盖”  类型覆盖指，UVM层次结构下的所有原有类型都被覆盖类型所替换。 实例覆盖指，在某些位置中的原有类型会被覆盖类型所替换。    set_type_override() 替换类型 1  static function void set_type_override(uvm_object_wrapper override_type, bit replace=1);    uvm_object_wrapper override_type 这是什么? 并不是某一个具体实例的句柄，实际上是注册过后的某一个类在工厂中注册时的句柄。怎么找到它呢? 就使用new_type::get_type() 。 bit replace=1  1： 如果已经有覆盖存在，那么新的覆盖会替代旧的覆盖。 0： 如果已经有覆盖存在，那么该覆盖将不会生效。   set_type_override是一个静态函数   1 2  ori_type::type_id::set_type_override(new_type::get_type()) //---typedef------|----静态函数-------|------静态函数--------|   set_inst_override() 替换实例 1  static function void set_inst_override(uvm_object_wrapper override_type, string inst_path, uvm_component parent=null);    string inst_path指向的是组件结构的路径字符串 uvm_component parent=null 如果缺省，表示使用inst_path内容为绝对路径，如果有值传递，则使用(parent.get_full_name()， \u0026lsquo;.', inst_path)来作为目标路径。 set_type_override是一个静态函数   1 2  ori_type::type_id::set_inst_override(new_type::get_type(), \u0026#34;ori_inst_path\u0026#34;) //----typedef-----|------静态函数-----|------静态函数-------|   如何使用覆盖相关的函数  首先需要知道， 有不止一个类提供与覆盖有关的函数，然而名称与参数列表可能各不相同 ：  uvm_component::set_{type/inst}_override{_by_type} uvm_component_registry::set_{type/inst}_override uvm_object_registry::set_{type/inst}_override uvm_factory::set_{type/inst}_override   因此，想要实现类型替换，也有不止一种方式。包括上述给的例子中通过ori_type::type_id来调用覆盖函数，还可以在uvm_component的域中直接调用，或者使用uvm_factory来做覆盖。  覆盖实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  module factory_override; import uvm_pkg::*; `include \u0026#34;uvm_macros.svh\u0026#34; class comp1 extends uvm_component; `uvm_component_utils(comp1) function new(string name=\u0026#34;comp1\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;comp1:: %s is created\u0026#34;, name)); endfunction:new virtual function void hello(string name); $display($sformatf(\u0026#34;comp1:: %s said hello!\u0026#34;, name)) ; endfunction endclass class comp2 extends comp1; // 必须继承于comp1  `uvm_component_utils(comp2) function new(string name=\u0026#34;comp2\u0026#34;, uvm_component parent=null); super.new(name, parent); $display($sformatf(\u0026#34;comp2:: %s is created\u0026#34;, name) ); endfunction:new function void hello(string name); $display($sformatf(\u0026#34;comp2:: %s said hello!\u0026#34;, name)); endfunction endclass //c1 c2 都是comp1 comp1 c1, c2; initial begin // 覆盖  comp1::type_id::set_type_override(comp2::get_type()); // 两种例化方式  c1=new(\u0026#34;c1\u0026#34;); c2=comp1::type_id::create(\u0026#34;c2\u0026#34;, null); //调用hello函数  c1.hello(\u0026#34;c1\u0026#34;); c2.hello(\u0026#34;c2\u0026#34;); end endmodule //输出结果 // comp1:: c1 is created // comp1:: c2 is created // comp2:: c2 is created // comp1:: c1 said hello! // comp2:: c2 said hello!  //可见new例化的对象没有实现覆盖， create例化的对象实现了覆盖   确保正确覆盖的代码要求  将UVM环境中 所有的类都注册到工厂中， 并通过工厂来创建对象 。 在使用某些类的时候，确保该类已经被 导入(import) 到当前域(scope) 中 。 通过工厂创建对象时， 句柄名称应该同传递到create()方法中的字符串名称相同 。无论是通过层次路径名称来覆盖还是配置，将例化组件的句柄名称同创建时create()方法中的字符串名称保持一致。 由于覆盖是采用 parent wins模式 ，也就是高层次的替换优先级高，因此要注意在同一个顶层build_phase()中 覆盖方法应发生在对象创建之前 。 为了尽量保证运行时覆盖类可以替换原始类， 覆盖类最好是原始类的子类，而调用成员方法也应当声明为虚方法 。 另外一种确保运行时覆盖类型句柄正确使用的方式，需要通过$cast()进行动态类型转换。  总结  一旦把那些组件装载盒子注册之后，接下来的UVM环境搭建就变得更加容易、更方便日后维护了。 整个UVM世界的构建， 离不开factory的三个核心要素： 注册、创建和覆盖 。  `uvm_{component/object} _utils uvm_{component/object}::type_id::create() set_{type/inst} _override{_by_type}()   UVM学习中的一大阻碍就是，实现某一种效果的方法有很多种，但是对于初学者，你只需要掌握最常用的一种实现方式，就足够了!  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":29,"section":"docs","tags":["UVM"],"title":"UVM学习笔记（一）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/uvm-study-note-one/"},{"content":"本文 主要内容向大家推荐一款hugo主题，是目前我见过的所有主题中最完美的一个，名字叫zdoc。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.63 extend  主题介绍 之所以说它完美，主要是支持了文档结构的多层目录，可实现博客文章的多级分类，并且支持了搜索功能和评论功能，简单易用，配置文件内容非常清楚，可以开箱即用。话不多说，github地址为： https://github.com/zzossig/hugo-theme-zdoc。\n使用效果和安装步骤readme中都有说明，这里不再说明。后面会对我操作过程中遇到的问题简单记录。\n注意事项  hugo版本需要0.60或以上版本，并且必须是extend版本。 实现多级分类： 只需要创建多级目录，在每一个层级目录下存放一个_index.md文件，代表该级页面。 需要先添加自己的语言环境，包括theme内的i18n目录。  我的配置 具体内容不再介绍了，这里提供一个我整体配置后的模板，可参考，如有具体问题可邮箱联系。另外，主题一直在保持更新，意味着会有不断的新功能添加进来，注意及时追踪。\n分享如下： 链接：https://pan.baidu.com/s/1s3BWpKNKi1QpgaXruvLx7w 密码：3ryh 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":30,"section":"docs","tags":["hugo"],"title":"推荐一款hugo主题","uri":"https://www.wenhui.space/docs/04-build-blog-site/hugo_theme_zdoc/"},{"content":"本文 主要介绍一款emacs插件\u0026ndash;epa(emacs-application-framework)。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  github网址：https://github.com/manateelazycat/emacs-application-framework/blob/master/README.zh-CN.md  什么是epa？ EPA 是一个全新的图形应用框架，通过扩展Emacs的多媒体能力，最终达到 Live in Emacs 的终极目标。换句话说，也就是用emacs做一切。\n如何安装？ 安装过程请参考如上链接，这里只对安装时遇到的问题列出来，供大家参考。\n解决pip3安装网络慢问题 可以使用国内源，如 sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pack_name\n其他还有地址：\n 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/  安装dbus前先安装依赖 sudo apt-get install libdbus-glib-1-dev\nemacs不支持dbus 这是在编译安装时没有对dbus做支持，可能设置了without\u0026ndash;dbus，这时候需要重新编译安装emacs，使其支持dbus功能。\n为什么使用epa？ 暂时还没体会到epa的有利之处，初次安装，就是尝试使用，也许后面会发现更多好处吧，待使用后再对使用场景进行总结。\n这里罗列一下epa目前支持的功能：\n   应用名称 启动命令     浏览器 `M-x eaf-open-browser` 在浏览器中打开或搜索    `M-x eaf-open-browser-with-history` 搜索历史或者打开URL   HTML邮件渲染 `M-x eaf-open-mail-as-html` 在 `gnus`，`mu4e`，`notmuch` 等邮件客户端中执行   PDF阅读器 `M-x eaf-open` 输入PDF文件   视频播放器 `M-x eaf-open` 输入视频文件   图片浏览器 `M-x eaf-open` 输入图片文件   Markdown预览 `M-x eaf-open` 输入Markdown文件   Org预览 `M-x eaf-open` 输入Org文件   摄像头程序 `M-x eaf-open-camera`   终端模拟器 `M-x eaf-open-terminal`   二维码下载文件 `M-x eaf-file-sender-qrcode` or `eaf-file-sender-qrcode-in-dired`   二维码上传文件 `M-x eaf-file-receiver-qrcode`   无线分享 `M-x eaf-open-airshare` 输入要分享给手机的字符串   RSS新闻阅读器 `M-x eaf-open-rss-reader`   演示程序 `M-x eaf-open-demo`    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":31,"section":"docs","tags":["emacs"],"title":"emacs插件之多媒体应用","uri":"https://www.wenhui.space/docs/02-emacs/emacs_epa_package/"},{"content":"本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。\n   版本 说明     0.1 初版发布    参考 参考自文彬师兄的UVM培训资料。\n初识UVM 什么是UVM？  VMM(Verification Methodology Manual)，Synopsys在2006年推出的，VMM当中集成了寄存器解决方案RAL(Register Abstraction Layer)。 OVM(Open Verification Methodology)，Cadence和Mentor在2008年推出的，它引进了factory机制，功能非常强大，但是没有寄存器解决方案。 UVM(Universal Verification Methodology)，即通用验证方法学，其正式版本在2011年2月由Accellera推出的，UVM几乎完全继承了OVM，同时又采纳了VMM中的寄存器解决方案。  什么是UVM验证平台？  UVM是基于System Verilog的一种验证方法学，也可以看成是一个库，提供一系列的接口，可以利用UVM搭建验证平台，用于验证数字逻辑电路的正确性。 注意，UVM本身并不是一个验证平台，他只是一个库，而一个验证平台引入了UVM相关库，称为基于UVM的验证平台，或者简称为UVM验证平台。 支持UVM的EDA厂商：Cadence、Synopsys、Mentor\u0026hellip;  UVM基础 一个基于SV的简单验证平台 注：这里“基于SV”指平台仅仅使用SystemVerilog语言搭建。\n     一个基于UVM的简单验证平台      基于UVM验证平台原则  类： UVM中几乎所有的东西都是用类(class)来实现的，所以，搭建uvm平台第一条原则，所有的组件都用类来完成。 基于UVM类： 当要实现一个功能时，首先应该想到的是从UVM的某个类派生出一个新的类来实现期望功能，所以，搭建uvm平台第二条原则，所有的组件应该派生自uvm类。  UVM中两大最重要基类  uvm_object： 它是UVM最基本的类，几乎所有的类都派生自uvm_object，它的拓展性是最好的，当然能力也是最差的。它主要构成了环境的属性（例如配置）和数据传输。 uvm_component： 它派生自uvm_object ，却拥有自己独有的强大特性，它有两大独有特点，一是通过new形成树形结构，二是自动执行phase。它主要构成了环境的层次。  UVM中常用类的继承关系      什么是UVM Factory 所谓Factory就是工厂，是通过一个字符串（类名）创建一个此字符串所代表的的类的一个实例，并且能够自动调用其phase执行的机制，也就相当于加工工厂。理解上可能比较抽象，我们举例来说明。\n如下图，一个汽车工厂好比我们的验证平台，支持宝马和奔驰两条生产线，两位老板只需下令生产奔驰还是宝马，工厂按照生产线自动加工，最终产出汽车，这里指令（奔驰/宝马）就是上述中的字符串，生产线就是调用其phase执行的机制，整个验证平台也就相当于工厂，这就是UVM Factory。\n     我们的工厂可以支持生产哪些“汽车”，是由验证平台决定的，如果向验证平台输入不支持的指令，比如指定工厂生产“永久自行车”，会被视为错误指令。\n     如果就想生产“永久自行车”，我们需要添加永久自行车生产线:\n     然后我们就可以向工厂输入指令，生产“永久自行车”了。\n     总结 ：\n run_test()语句会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的phase，但是前提是你已经注册了这个类。 对于uvm_component类，注册是通过uvm_component_utils宏来进行的。所有派生自uvm_component以及其派生类都应使用uvm_component_utils来注册 对于uvm_object类，注册是通过uvm_object_utils宏来进行的。所有派生自uvm_object以及其派生类(除uvm_component外)都应使用uvm_object_utils来注册 由上述例子可以看出：run_test()是启动整个验证平台的UVM库函数。  UVM验证平台启动执行流程      搭建UVM验证平台 UVM验证平台基本组成      一个只有driver的测试平台 driver代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class my_driver extends uvm_driver; //继承uvm库中的uvm_driver类  `uvm_component_utils(my_driver) //将my_driver类注册到factory  virtual my_if vif; //声明driver的interface, interface my_if的定义这里不再介绍  extern virtual function void build_phase(uvm_phase phase); extern virtual task void main_phase(uvm_phase phase); endclass function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, \u0026#34;\u0026#34;, \u0026#34;vif\u0026#34;, vif)) `uvm_fatal(\u0026#34;my_driver\u0026#34;, \u0026#34;virtual interface must be set for vif !!!\u0026#34;) endfunction task void my_driver:: main_phase(uvm_phase phase); //略去 endtask   top_tb代码示例： 1 2 3 4 5 6 7 8 9 10  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top\u0026#34;, \u0026#34;vif\u0026#34;, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  run_test(\u0026#34;my_driver\u0026#34;); //实例化my_driver类，实例的名字是uvm_test_top，并执行类my_driver中的main_phase任务  end endmodule   注意: uvm_test_top是run_test产生的my_driver类的实例化对象名字，run_test(“my_driver”)可以简单的看成:\n1 2  my_driver uvm_test_top; uvm_test_top.main_phase();   这里，任何被run_test()实例化的类的对象的名字都会被UVM平台默认成uvm_test_top，这个被实例化的类也就是整个uvm平台的顶层，而且只允许有一个顶层，即一个验证平台只调用一个run_test()。\ntop_tb顶层与uvm树形结构的交互：  uvm_config_db   1 2 3 4 5  function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, \u0026#34;\u0026#34;, \u0026#34;vif\u0026#34;, vif)) `uvm_fatal(\u0026#34;my_driver\u0026#34;, \u0026#34;virtual interface must be set for vif !!!\u0026#34;) endfunction   top_tb顶层与uvm树形结构的交互为什么要用这种看起来很怪的uvm_config_db方式获得top_tb的interface，不能直接调用得到吗？ 按道理来讲，是可以的，uvm本来就是基于sv的函数库，其底层肯定也是有sv去实现的，既然uvm将其封装为uvm_config_db，建议统一使用此方法，使用uvm提供的函数也是最好的避免出错的办法。\n top_tb顶层与uvm树形结构：        如果将top_tb中的第3点去掉，请回答以下问题：  top_tb如何获取dut内部信号？答：通过top_tb.my_dut.xxx可以获取。 top_tb如何获取右侧树形结构的内部信息？答：通过top_tb.uvm_test_top.xxx是不可行的，因为run_test实例化了一个脱离了top_tb层次结构的实例对象，建立了一个新的层次，所以不能通过top_tb.uvm_test_top.xxx直接访问。所以针对这种情况，UVM引入了config_db的机制，也就是前面分别在top_tb和my_driver类中build_phase提到的:     1 2  uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top\u0026#34;, \u0026#34;vif\u0026#34;, input_if) uvm_config_db# (virtual my_if)::get(this, \u0026#34;\u0026#34;, \u0026#34;vif\u0026#34;, vif)   这样我们通过uvm_config_db将top_tb顶层与uvm树形结构打通。\n top_tb与树形结构中driver的交互流：       注意：top_tb与树形结构之间的交互用虚线，是因为my_driver.interface.output_xxx不是直接给top_tb.interface.input_xxx传值，而是在采用了config_db机制后，类似于两边在操作同一个指针地址，即改变my_driver.interface.output_xxx的值，就等于直接改变了top_tb.interface.input_xxx中变量的值。另外：uvm_config_db将top_tb顶层与uvm树形结构打通，我们可以将top_tb与树形结构任意组件进行交互，而不仅限于driver和monitor。\n     树形结构构造 目前，一个只含有driver驱动的UVM验证平台已经形成，那么接下来要考虑树形结构的构造，即添加新部件并使其层次化。\ndriver、monitor、agent和env：      注意：此时树形结构的顶层变成了my_env, 所以在top_tb中run_test(“my_driver”)应改成run_test(“my_env”)，之前讲过,run_test(“my_driver”)实例化之后对象的名字是uvm_test_top, 那么run_test(“my_env”)实例化之后顶层对象的名字是什么？答案是仍然为uvm_test_top。树形结构发生了层次改变，此时top_tb怎么和my_driver交互？如下top_tb代码：\n1 2 3 4 5 6 7 8 9 10 11 12  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin // uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top\u0026#34;, \u0026#34;vif\u0026#34;, input_if)  uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top.agt.drv\u0026#34;, \u0026#34;vif\u0026#34;, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  // run_test(\u0026#34;my_driver\u0026#34;)  run_test(\u0026#34;my_env\u0026#34;); //实例化my_env类，实例的名字是uvm_test_top，并执行类my_env中的phase  end endmodule   加入checker：      注意：这里的checker是将reference model和scoreboard统一看成一个整体。reference model和scoreboard的定义和其他component的方式一样，这里不再赘述。\n 树形结构通信通道       加入sequencer：      这里sequencer是一个固定组件，sequencer主要将激励承接给driver，my_transaction是一个数据包，也就是测试激励，这里还要有一个sequence概念，sequence里存放一组trans，提供给sequencer，可见sequencer属于component类，sequence和trans属于object类。关于sequencer、sequence和trans，还有这样一个比喻，trans好比子弹，sequence好比弹夹，而sequencer是枪。\n加入transaction：       transaction使用`uvm_object_utils注册。 transaction可以看成是数据包，把数据打包传输，便于交互。 在组件之间(driver,checker,monitor等)的信息传递都是基于transaction。  加入transaction后driver的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class my_driver extends uvm_driver #(my_transaction); //uvm_driver是参数化类，参数类型为my_transaction  `uvm_component_utils(my_driver) virtual my_if vif; …… endclass task void my_driver:: main_phase(uvm_phase phase); 将： vif.data \u0026lt;= 8\u0026#39;b1; 改成： req = new(“req”); //等价于my_transaction tr; tr = new(“tr”);  req.data = 8’b1; //等价于tr.data = 8’b1;  vif.data \u0026lt;= req.data; //等价于vif.data \u0026lt;= tr.data; endtask    req是父类uvm_driver中变量，类型是传递给uvm_driver的参数，这里传递的参数是my_transaction，所以父类uvm_driver中的req类型就是my_transaction。 my_driver继承了uvm_driver类，所以可以直接使用uvm_driver中的req，而不需要在my_driver中声明定义req。  加入sequence： 前面所示代码中激励都是在driver产生的，正常情况driver只是传递激励，而不是产生激励，所以要将激励产生从driver中移除，从外界获得激励，那driver的激励应该从哪里产生呢？这就是sequencer要做的事情，也就是说sequencer要提供req(这里为my_transaction)给my_driver。那么sequencer的transaction从哪里来？\n     `uvm_do(my_trans)实现了以下操作:\n 创建一个my_transaction的实例my_trans 将其随机化 最终将其传送给my_sequencer(此宏不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer)  sequence工作机制：\n      对于1， my_sequencer等待。 对于2， my_sequencer等待。 对于3， my_sequencer将my_sequence中的my_trans发送给my_driver。  待解决问题：\n my_driver如何向my_sequencer发送transaction接收请求？ my_sequence如何向my_sequencer发送transaction？  my_driver向my_sequencer发送申请：      注意：\n seq_item_port是uvm_driver中的成员变量。 seq_item_export是uvm_sequencer中的成员变量。  my_sequence向my_sequencer发送my_transaction： 前面提到， my_sequence中的`uvm_do不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer，所以需要额外启动连接，以在当前顶层my_env中手工启动为例(一般都是在顶层启动)：\n1 2 3 4 5  task void my_env:: main_phase(uvm_phase phase); my_sequence seq; seq = my_sequence::type_id::create(\u0026#34;seq\u0026#34;); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask        my_sequence自动启动机制default_sequence： 前面my_sequence是在my_env中手工启动的，default_sequence可以自动启动my_sequence 。\n1 2 3 4 5 6 7 8 9 10  task void my_env:: main_phase(uvm_phase phase); 将下列代码去掉： my_sequence seq; seq = my_sequence::type_id::create(\u0026#34;seq\u0026#34;); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask virtual function void my_env::build_phase(uvm_phase phase); uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endtask   树形结构通信通道变化： 原始：\n     现在：\n     注意：\n 蓝色部分: top_tb与树形结构的连接 紫色部分: transaction在my_checker和monitor之间的通信通道 红色部分: transaction在my_sequence,my_sequencer和my_driver之间的通信通道 单箭头虚线部分: 实际没有显性直接通道，均通过上一层connect实现 双箭头虚线部分: 代表同一模块  截至目前的树形结构：      目前，树形结构除my_case0顶层之后，均已构建完成，并全部打通。后面要添加my_case0。\n加入base_test：      base_test.sv代码:\n1 2 3 4 5 6 7 8 9 10  class base_test extends uvm_test; `uvm_component_utils(base_test) my_env env; //my_env会在base_test中实例化,base_test取代env称为顶层。 endclass function void base_test::build_phase(uvm_phase phase); //my_sequence需要在顶层启动连接,因为base_test变成顶层,所以从my_env中移到此处  uvm_config_db# (uvm_object_wrapper)::set(this, \u0026#34;env.agt.sqr.main_pahse\u0026#34;, \u0026#34;default_sequence\u0026#34;, my_sequence::type_id::get()); endfunction   top_tb.sv代码:\n1 2 3 4 5 6 7 8 9 10  module tob_tb initial begin // 将： // uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top.agt.drv\u0026#34;, \u0026#34;vif\u0026#34;, input_if) // run_test(\u0026#34;my_env\u0026#34;); // 改成：  uvm_config_db# (virtual my_if)::set(null, \u0026#34;uvm_test_top.env.agt.drv\u0026#34;, \u0026#34;vif\u0026#34;, input_if) run_test(\u0026#34;base_test\u0026#34;); end endmodule   加入my_case0：      1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下重载了base_test中的my_sequence的启动，注意bast_test中的仍保留。  uvm_config_db# (uvm_object_wrapper)::set(this, \u0026#34;env.agt.sqr.main_pahse\u0026#34;, \u0026#34;default_sequence\u0026#34;, my_sequence::type_id::get()); endfunction   注意：\n my_case0是继承了base_test的一个子类, 是base_test的一个更具体的实现，也就从这里形成了testcase的概念，这个testcase的名字就是my_case0。 my_case0没有改变激励产生的方式，即仍然是启动了my_sequence，并利用my_sequence中`uvm_do(my_trans)来全随机产生激励。  加入my_case0_sequence： my_case0_sequence.sv代码:\n1 2 3 4 5 6 7 8  class my_case0_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8\u0026#39;hff;}) endtask endclass   注意：\n my_case0_sequence是继承了my_sequence的一个子类, 是my_sequence的一个更具体的实现。 my_case0_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’hff的数据激励。  my_case0.sv代码:\n1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下将my_case0_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, \u0026#34;agt.sqr.main_pahse\u0026#34;, \u0026#34;default_sequence\u0026#34;, my_case0_sequence::type_id::get()); endfunction   注：\n 这里制造了一个用例my_case0，此用例每个transaction产生8’hff数据的激励。 这里my_case0成为新的顶层。  将顶层base_test替换成my_case0： 1 2 3 4 5 6 7 8  module tob_tb initial begin // 将： // run_test(\u0026#34;base_test\u0026#34;); // 改成：  run_test(\u0026#34;my_case0\u0026#34;); end endmodule   run_test()作用：它会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的main_phase。\nrun_test给我们最初的印象是构建了一个脱离了top_tb的树形结构，并完成了所有内部需要交互部件的打通。现在我们需要改变一下思维，这里当调用run_test(“my_case0”)时，不再考虑树形结构，我们用一个更抽象的概念来描述run_test的行为，那就是：它执行一个用例my_case0，而且只有一个用例在执行，这条用例每个transaction都在产生数值为8’hff的数据。我们平时所谓的跑各种各样的用例，这些用例其实都是基于这个去构造和命名的(在uvm平台中)。\n用例构造 构造另一个用例my_case1:\n my_case1_sequence.sv:   1 2 3 4 5 6 7 8  class my_case1_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8\u0026#39;haa;}) endtask endclass   注意：my_case1_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’haa的数据激励。\n my_case1.sv:   1 2 3 4 5 6 7 8 9  class my_case1 extends base_test; `uvm_component_utils(my_case1) endclass function void my_case1::build_phase(uvm_phase phase); //以下将my_case1_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, \u0026#34;agt.sqr.main_pahse\u0026#34;, \u0026#34;default_sequence\u0026#34;, my_case1_sequence::type_id::get()); endfunction   注意：这里制造了一个用例my_case1，此用例每个transaction产生8’haa数据的激励； 如果想要运行这个用例，那my_case1将成为新的顶层，也就是将top_tb中的 run_test(“my_case0”) 改为 run_test(“my_case1”)\nUVM测试用例启动 由于run_test在top_tb中只能调用一次，所以每次跑新的用例，都要手动改一下run_test()的参数名字，试想我们有10000个用例，如果都手动改，那肯定是不可行的，所以UVM提供了另外一种启动方式。\n1 2 3 4 5  module top_tb initial begin run_test(); end endmodule   此方式将run_test()中的参数去掉，并利用UVM_TESTNAME从命令行中获得测试用例的名字，例如:\n\u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case0 \u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case1 注：sim command为eda厂商提供的仿真命令，后面会有介绍。\nUVM验证平台启动和封装 非基于uvm验证平台仿真启动 注意：.f文件里分别是验证环境和设计的代码文件列表。\n sysnopsys:  编译：vcs –f env_vcs.f –f design_vcs.f –verdi_compile_option –coverage_compile_option …… 仿真：./simv –verdi_rrun_option –coverage_run_option ……   cadence:  编译：irun –f env_irun.f –f design_irun.f –verdi_compile_option –coverage_compile_option …… 仿真：irun –verdi_irun_option –coverage_run_option …… 编译：xrun –f env_xrun.f –f design_xrun.f –verdi_compile_option –coverage_compile_option …… 仿真：xrun –verdi_run_option –coverage_run_option ……    基于uvm验证平台仿真启动  sysnopsys:  编译：vcs –f env_vcs.vf –f design_vcs.f –verdi_compile_option –coverage_compile_option –ntb_opts uvm …… 仿真：./simv –verdi_rrun_option –coverage_run_option +UVM_TESTNAME=my_case0 ……   cadence:  编译：irun –f env_irun.vf –f design_irun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：irun –verdi_irun_option –coverage_run_option +UVM_TESTNAME=my_case0 …… 编译：xrun –f env_xrun.vf –f design_xrun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：xrun –verdi_run_option –coverage_run_option +UVM_TESTNAME=my_case0 ……    注意：需要在env.vf中包含uvm的库文件：\n$UVM_HOME/src/uvm_macros.svh $UVM_HOME/src/uvm.sv $UVM_HOME/src/uvm_pkg.sv $UVM_HOME/dpi/uvm_dpi.sv +incdir+$UVM_HOME/src 对于vcs和irun/xrun还有一点需要注意：\n 对于vcs,使用uvm库时需: include ”uvm_pkg.sv” 对于irun/xrun,使用uvm库时需: import uvm_pkg::*  基于uvm验证平台的封装 为什么要对验证平台封装？ 到目前为止，我们就可以利用基于uvm的验证平台跑用例进行验证了。经历了漫长痛苦的uvm环境开发之后，当我们在自己独立开发的uvm验证环境中，成功跑完第一条用例my_case0仿真用例的那一刻，发现之前的付出都是值得的，当我们利用自己制造的人生第一条用例my_case0找到人生第一个设计bug的那一刻，发现人生已经达到了巅峰。但是作为一名优秀的验证工程师，我们的成就不仅如此，因为我们的目的不仅仅是找到bug，而是快速高效的找到bug。\n当基本验证平台可以使用，进入初期验证阶段之后，你会发现，可能会有不同的验证工程师在此验证环境中开发新的功能，可能会有不同的设计人员在此验证环境中复现bug，也可能包括自己在内的工程师需要在此验证环境中运行各种各样配置的用例，如果每次都需要自己去改变底层仿真命令或者告诉其它人怎么改底层仿真命令，你会发现整个人都不好了。而且如果所有人都自己去手动改环境底层代码跑用例，到最后整个验证平台也会变得非常杂乱，非常不好维护，并且就实际情况，大部分设计工程师是不接受每次跑用例都需要自己手动改代码的。\n为了解决这些问题，使环境变得更加整洁高效，维护简单，便于扩展，我们将环境进行封装。\n封装的原则是什么？  对自己白盒： 所有的底层运行验证环境的编译选项和仿真选项都要自己维护开发；所有的新的开发需求需要自己来指定结构和位置；所有的内部uvm固有部件骨架都要自己维护开发。 对验证工程师灰盒： 熟悉整体环境运行原理；熟悉各编译和仿真选项含义，验证过程中知道如何增减选项；在指定的结构和位置开发新的功能；不需要对此uvm环境固有骨架进行全面掌握。 对设计工程师黑盒： 不需要知道任何环境内部构造，只需要按照验证工程师提供的脚本命令运行用例即可。  如何对验证平台封装？ 环境采用脚本封装，一般只需提供命令和接口选项，脚本可以使用Makefile，python，perl，shell等。以python脚本封装为例。\n 仿真命令： ./runtest.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim  seed : 提供仿真种子号 -dump : 产生波形 -cov : 打开code coverage收集 -funcov : 打开function coverage收集 -debug : 仿真结束后自动弹出波形 -covermerge : 仿真结束后自动merge coverage数据 simpath : 指定生成log的文件夹    上述接口选项最终都会呈现在底层编译和仿真命令中，使用者可以根据需求打开关闭提供选项，而不必需要知道环境内部的细节。如果有新的需求，开发完毕后提供对应的接口即可，大大减少了使用的低效性。\n封装脚本的构造 封装脚本一般分为两部分： 单条用例运行脚本 和 回归用例运行脚本。\n  单条用例运行脚本：\n 用户提供testcase list。 根据脚本提供用例名字在tclist找到对应的用例属性，包括uvm中提供的test名字(如my_case0),用例所在路径等。 在sim下创建以用例名字+种子号命名的文件夹，后面生成的这条用例的所有相关信息，包括log和波形等都会存放在这里。 根据脚本提供选项进行整个环境的编译工作。 根据脚本提供选项进行整个环境的仿真运行。 用例运行结束后，根据仿真产生的log，得到并打印出pass还是fail的信息，方便使用者进行快速判断。 使用者到对应的sim/testcase_name_seed/下查找所有相关log和波形，进行相关debug。 添加其它功能，例如coverage的merge，但是一般只有回归才会涉及到merge的工作，所以这部分功能可以放到回归脚本中。    回归用例运行脚本：\n 识别脚本提供的tclist中提供的回归组名，将所有指定组的用例进行仿真回归。 内部调用单条用例脚本，并将回归用例脚本输入参数全部转换为单条用例脚本输入参数需要的格式。 监测每条用例的仿真结果，并累加计数得到总的tc数，总pass tc数，总fail tc数，和总的没有产生仿真log的tc数。 判断是否所有用例运行结束，并打印最终回归报告。 如果打开coverge merge选项，会自动merge所有回归用例的coverage数据。 回归结束后在sim下生成pass，fail的tclist, 同样每条用例的结果也都存在以用例名字+种子号命名的文件夹中，可以实时查看。    跑单条用例命令： ./rt.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim\n  跑回归用例命令： ./rt.py –regress –rgr_group=my_regression -seedrand –dump –cov –funcov –covmerge simpath=./sim\n  UVM验证平台的优化 优化目的是什么？  针对平台结构优化： 使环境结构简洁，清晰明了，重用性好，移植性强，拓展性高，让新的用户和开发者能够快速切入。 针对平台性能优化： 使环境运行速度提升，提高验证效率  如何优化验证平台？   针对平台结构优化：\n 加入readme，包含运行方法等必要信息。 加入setup脚本，所需一切配置均在此一键完成。 环境中用到所有路径宏均统一管理，方便更改和移植。 运行中间文件统一管理，方便查看和删除。 目录结构清晰，文件夹命名需简洁易懂。 删除开发过程中的无效代码和目录。 加入必要信息打印开关，方便读取层次结构。 撰写平台使用手册，进行环境详细说明。    针对平台性能优化：\n 检查变量定义，减少存储空间占用，如需要超大容量数组时，需使用关联数组。 检查哪些任务可以并行执行，改成fork_join*多线程机制。 检查是否transaction约束过多，如过多速度会明显变慢。 检查dut文件列表，去掉不必要文件，减少环境编译时间。 检查是否有不必要打印，关掉以减少log输出占用的时间。 检查model，checker，driver中是否有过多占用时间的函数，重新考虑是否有高效替代方案。 利用第三方工具得到平台各个部件的时间占用分布，分析占用最多的几个部件原因，寻找解决方案。    uvm验证平台目录组织结构 verif/my_ut/env下文件：\n agents/ ： agent文件目录，内含一个或多个agent，agent包含driver、sequencer、monitor组件，agent从行为上可以理解为与dut交互的模块或组织。 coverage/ ： coverage文件目录，内含一个或多个模块的覆盖率文件，也就是covergroup。 checker/ ： checker文件目录，也就是reference model和scoreboard文件，不过有时候会将两者融合成一个checker文件。 include/ ： include文件，一些环境路径的宏定义以及其他include文件存放在这里。 interface/ ： interface文件目录，内含一个或多个接口文件。 script/ ： script文件目录，一些验证平台封装的脚本文件存放在这里。 setup/ ： setup文件目录，一些平台初始化文件存放在这里，如环境变量的初始化和工具的配置。 tests/ ： tests文件目录，所有测试用例存放在这里。 readme ： readme文件，对环境和使用的说明文件。 tb.v ： tb文件，顶层testbench。 env_vcs.f ： env_vcs.f文件，针对vcs工具的filelist文件，包含设计和验证平台的文件列表。 env_xrun.f ： env_xrun.f文件，针对xrun工具的filelist文件，包含设计和验证平台的文件列表。 tc.list ： tc.list文件，包含所有测试用例信息，可为测试用例设定分组，方便回归测试。 my_env_cfg.sv ： my_env_cfg.sv文件，整个验证平台的配置文件，内含静态变量，可传递至平台任意模块，完成验证平台的配置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":32,"section":"docs","tags":["UVM"],"title":"UVM与验证环境","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/uvm-and-verify-env/"},{"content":"本文 主要介绍一种有效解决RTL编译时依赖关系问题的方法。\n   版本 说明     0.1 初版发布   0.2 修正对-y的理解，-y只是指定库文件目录   0.3 使用-y对覆盖率收集的影响    关于include 一般在文件中会用include来加载依赖的文件，其效果就好比将依赖文件的内容复制粘贴至此。当然你可以将所有依赖文件都进行include，也就是不仅仅是宏定义文件和函数文件，还包含子模块的文件，这样层层include，自然形成一个完整的编译顺序，而只需要给工具指定最顶层的文件和提供include路径即可。但是并不建议这样实现，因为除了影响代码整洁性（可能某模块子模块众多），还会使代码难以维护。所以我们一般只include宏定义文件和函数文件，这样指定的include路径也会很清楚。\n有时候一个文件可能会被多个文件include，为了防止被重复编译，往往会加上ifdef判断条件。虽然重复编译不一定带来问题，但毕竟也影响了编译效率，所以还是要尽量消除重复编译。方法如下：\n1 2 3 4 5 6 7 8  `ifndef __file_name `define __file_name  //....... //File content...... //.......  `endif   在文件的开头和结尾添加如上内容后，当第一次编译该文件时，不会有“__file_name”的宏定义，所以编译文件内容，当再次编译该文件时，已经定义“__file_name”，ifndef的判断会使该文件不被重复编译。这样的方法是被推荐的，建议所有文件的头尾都添加如上内容。\n关于filelist 一般工程中都会用filelist文件来进行维护，这也是最方便的。filelist文件描述的顺序，就是编译顺序，所以这里要小心，要将最底层模块定义到前列，优先编译，否则编译其他模块时找不到其依赖模块，会报编译错误。这里提供两个技巧：\n 较大设计中，分割子模块，定义各个子模块的的filelist，在上层filelist中采用“-f path/xxx_subfilelist”的形式引入子模块filelist（注意要指明路径），这样由子模块的设计师维护子模块的filelist，待合并系统时，再合并filelist。 可以使用“-y”指定库文件目录，其原理是在源文件中找不到子文件时会去库文件目录查找，所以不必关心编译顺序（注意，要求库文件中的module名与文件名一致）。使用方法为：  “+libext+.v+.sv”（指明加载后缀为.v和.sv的文件） “-y file_path”（指定库文件目录）   “-y” 的使用其实是指定库文件，为了不将设计扁平化，需要在verdi打开时添加“-ssy”，这样可以保持设计的层次化。 include路径必须添加在filelist前部。  示例：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/top_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 “+define+”是传入define参数。  总结 对于编写flist的几个建议\n 使用“+incdir+”详尽的列出include path 使用“-y”指明详尽的库文件目录 指明加载的顶层文件，由于指明了库文件目录和include path，工具会自动按需加载。 目录要使用参数，方便移植。  补充问题 使用-y对覆盖率收集的影响 经过实践，使用-y指定库路径的方式，避免了罗列详细的filelist，虽然与详细的filelist相比，编译仿真实现一致，但是对于覆盖率收集时，却无法实现由-y加载模块的代码覆盖率收集（cadence imc工具）。\n所以，最终还是选择项目初期使用-y来加载子模块，避免设计人员添加或删除设计文件，导致验证环境需要对filelist不断更新，如果能够直接引用设计的filelist也可以，但是往往设计的filelist是对整个top去维护的，不方便UT验证环境直接引用，所以我还是习惯自己维护一个filelist。待设计成熟后，不会有模块文件的添加和删减，可以更新为详细的filelist，同时展开回归测试和收集覆盖率工作。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":33,"section":"docs","tags":["Verilog"],"title":"如何更好的解决RTL编译时依赖关系问题","uri":"https://www.wenhui.space/docs/07-ic-verify/tips/resolve-file-dependencies-for-rtl-compile/"},{"content":"本文 主要介绍一款自动插入英文翻译的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  Emacs: 自动插入翻译后的字符串 Github：insert-translated-name  补充说明： 这个英文补全的emacs插件是基于google翻译的，可能需要先安装google翻译才可以使用，由于安装此自动插入英文翻译的插件时已经安装google翻译，所以并未考证。如果需要安装google翻译，请参考我的另一篇帖子 GoldenDict的安装 中 添加google翻译这一节。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":34,"section":"docs","tags":["emacs"],"title":"emacs插件之自动插入英文翻译","uri":"https://www.wenhui.space/docs/02-emacs/emacs_insert_english_translate/"},{"content":"本文 主要介绍debug工具Verdi的使用，并对自己使用过程中的经验进行总结。\n   版本 说明     0.1 初版发布    参考  Verdi and Siloti Command Reference Verdi (Premier) Training  百度网盘分享资源 链接：https://pan.baidu.com/s/1h5xm8-poxOwjL14MzBH4pw 密码：4kb6\n专业术语与缩略语    缩略语 全称 含义     RMB Right Mouse Button 鼠标右键   MMB Middle Mouse Button 鼠标中键   LMB Left Mouse Button 鼠标左键   DC Double-click 双击   D\u0026amp;D Drag and Drop 拖拽   KDB Knowledge Database 知识数据库   FSDB Fast Signal Database 快速信号数据库   TFV Temporal Flow View 时序界面   BA Behavior Analysis 行为分析    Set Up the Environment 指定路径和环境变量  Binary File：   1 2  setenv NOVAS_INST_DIR \u0026lt;Path to Novas installation\u0026gt; set path = ($NOVAS_INST_DIR/bin $path)    License File：   1 2  setenv NOVAS_LICENSE_FILE \u0026lt;license_file\u0026gt;:$NOVAS_LICENSE_FILE   添加符号库  为什么使用符号库：  符号库提供了源代码到逻辑单元的映射，没有符号库，原理图将仅显示正方形而不是逻辑单元。\n 创建符号库：  syn2SymDB:适用于 ASCII格式的Synopsys logic library(.lib) map2SymDB:适用于已有的map file 参考\u0026lt;verdi_install\u0026gt;/doc/Symbol_Library.pdf   设置符号库环境变量：   1 2  setenv NOVAS_LIBS\u0026#34;LIB ROOT#1\u0026gt;\u0026lt;LIB ROOT#\u0026gt;…\u0026#34; setenv NOVAS_LIBPATHS\u0026#34;\u0026lt;Directory#1\u0026gt;\u0026lt;Directory#2\u0026gt;…\u0026#34;    通过GUI设置符号库：  菜单栏点击Tools–\u0026gt;Preferences 在打开的子窗口中 Find一栏 查找 Schematic \u0026ndash;\u0026gt;Symbol Library 填写Symbol Library Name 填写Symbol Library Path 保存，然后设置将被保存到novas.rc 源文件中。    使用Setup文件 novas.rc  指定路径：  setenv NOVAS_RC /novas.rc 直接通过命令行命令 -rcFile 来进行设置   搜索顺序：  -rcFile 命令行选项 NOVAS_RC环境变量 ./novas.rc $HOME/novas.rc /etc/novas.rc    首选项 通过Tools–\u0026gt;Preferences打开窗口，所有设置将被保存在novas.rc文件中，在Find窗口栏中根据关键字搜索。比如设置字体大小和颜色，在find栏搜索font，找到相关项，设置完毕后保存为novas.rc，可添加为Verdi的Setup文件，一劳永逸。\nFSDB   什么是FSDB文件：\n 压缩的二进制文件格式，包含仿真信号数据。 开放文件格式，其他的供应商工具可以dump波形，比如Verisity，Vera，Ikos，etc. 利用System Task来帮助dump。    常用的系统任务：\n fsdbDumpfile： 指定FSDB文件名和限制文件大小(单位MB，若超出限制只保留最新，也可不限制大小)，如 “$fsdbDumpfile(\u0026ldquo;top.fsdb, 500\u0026rdquo;);” 。 fsdbDumpvars： Dump指定变量，可以指定dump特定的实例和层次深度，可以指定FSDB文件名，以及指定其他option参数，如 “$fsdbDumpvars(0, top.dut1.u1, \u0026ldquo;+fsdbfile+u1.fsdb\u0026rdquo;, \u0026ldquo;+all\u0026rdquo;);”，也可以使用“$fsdbDumpvarsToFile(\u0026ldquo;dump.list\u0026rdquo;);”。 fsdbDumpon/fsdbDumpoff： 打开和关闭fsdb Dumping，如 “#0; #50000 $fsdbDumpvars; #50000 $fsdbDumpoff; #50000 $fsdbDumpon; #50000 $finish;”，指保存50000~100000和150000~200000时间段波形。 提示：更多信息请查看文档linking_dumping.pdf。    为FSDB dumping 链接Novas Object文件  创建环境变量：   1 2 3 4 5 6 7 8  #Setup license file for simulator setenv LM_LICENSE_FILE \u0026lt;simulator_license_file\u0026gt; #Setup path for simulator setenv \u0026lt;Simulator\u0026gt;_INST_DIR \u0026lt;simulator_tool_install\u0026gt; #Setup path for Novas tool setenv NOVAS_INST_DIR \u0026lt;Novas_install_path\u0026gt; #Setup LD_LIBRARY_PATH to specify the appropriate shared object files setenv LD_LIBRARY_PATH ${NOVAS_INST_DIR}/share/PLI/\u0026lt;simulator\u0026gt;/\u0026lt;platform\u0026gt;   FSDB文件处理  vfast： 将VCD文件转化为FSDB文件。 fsdb2vcd： 将FSDB文件转化为VCD文件。 fsdbextract： 在已经存在的fsdb文件中提取信号，范围，时间周期，而不用重新进行仿真。 fsdbmerge： 将多个文件进行合并。 fsdbreport： 针对一个特定的信号，将值得变化情况生成report。 提示： 使用 “ -h” 查找帮助，或参阅《 Verdi Command Reference》。  Import Design 命令行导入设计 1 2 3 4  verdi -f \u0026lt;file_list\u0026gt; +define+GETTHEMOSTOUTOFYOURTIME verdi -f \u0026lt;file_list\u0026gt; -top TopBlock verdi \u0026lt;source_file1.v\u0026gt; -sv \u0026lt;source_file2.sv\u0026gt;… verdi system.v ... alu.v -v lib.v -y ../special -ssv -ssy   推荐使用命令： “verdi -f run.f -ssv -ssy” ，其中run.f内容如下：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/other_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -ssv和-ssy是对-v导入的库文件和-y指定的路径中的模块被视为普通模块，而不是库单元，如果库单元的话会无法显示Hierarchy。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 +define+是传入define参数。  图形化界面上导入设计  命令行输入verdi ，打开verdi 图形化界面。 菜单栏File-\u0026gt;Import Design 或 菜单栏上的Import Design符号 导入设计。 选择language、run file或源文件，不建议使用VHDL。  Debug in Source Code View Open nTrace Window  导入设计后，Verdi会自动打开nTrace窗口。 nTrace窗口包含三个可调整大小的子窗口：左侧Hierarchy Browser Pane，右侧Source Code Pane，下方Message Pane。  Search and Collapse Hierarchy Browser  折叠全部区域： 在hierarchy browser pane，点击鼠标右键选择Collapse All Scopes 折叠和展开选中项： 在hierarchy browser pane，点击所选项的“+”即展开，“-”即折叠。 搜索： 在hierarchy browser pane，点击鼠标右键选择Show Navigation TextField（快捷键Ctrl+s）。  在搜索框输入通配符字符串并回车即可，如CH*，可匹配CHILD1、CHILD2、CHILD3\u0026hellip; 搜索框右侧提供了prev和next操作，并且可以选择搜索记录。 在Filter搜索框输入通配符字符串，选择匹配项（模块、函数、任务、类\u0026hellip;），回车显示所有匹配结果   所选项（一般指module）鼠标双击，即可显示Source Code 所选项鼠标右键可选择Copy Full Path（或快捷键Ctrl-H），这对验证环境中需要引用信号需要全路径时非常有用。 所选项鼠标右键可选择Set/Unset Bookmark，可设置和取消书签，在在hierarchy browser pane右键选择Manage Bookmarks可快速回到书签标记项。 Instance显示层级关系，也可以选择Declaration，将所有模块平铺显示，搜索功能与上文描述相同。 快捷键Shift-S打开Find Scope窗口，可以查找模块、任务、函数等，列出模块名和例化列表（全路径）， 查找模块推荐使用此方法 。  Traverse Source Code  快速搜索信号、实例或实例端口： 使用快捷键Shift-A打开Find窗口，编辑框内显示当前打开的Source Code模块全路径，如果此模块内查找则保留全路径，在最后编辑通配符字符串，如果全设计中搜索，则删除全路径，直接编辑通配符字符串， 查找信号推荐使用此方法 。 查找字符串： Source Code窗口上方工具栏有搜索框，编辑通配符字符串即可全文搜索，支持Prev和Next，以及历史记录（注：通配符为*，可代表任意字符串）。 使用书签： Source Code窗口上方工具栏有书签图形，点击可将当前Source Code的当前行设置/取消书签（也可使用快捷键Ctrl-F2），在菜单栏Source选中Manage Bookmarks打开Source书签管理窗口，可快速跳转至某书签位置。 多文件调试时推荐使用此方法 。 模块的层次跳转： Source Code窗口上方工具栏有向上直角箭头和向下直角箭头两个图标，向上箭头代表跳转到当前模块的例化语句，向下箭头代表进入此例化模块（选中例化名）/双击亦可。 双击模块名： 双击Source Code窗口打开的模块名，跳转到上层模块例化当前模块的语句，并且在message窗口列出例化此模块的文件全路径、文件名以及行号，双击message信息可跳转至该模块被例化语句。 撤销操作： Source Code窗口上方工具栏有向左箭头和向右箭头两个图标，代表操作的回退和前进。  Operate on Signals  信号的Driver and Loads： Source Code窗口上方工具栏有“D”和“L”图标和向上箭头和向下箭头图标，选中信号，D代表查看driver，L代表查看load，箭头代表Prev和Next，双击信号也可以达到查看Driver效果。 选中信号并右键可选择Copy Signal\u0026rsquo;s Full Path，这对验证环境中需要引用信号需要全路径时非常有用。 Load Simulation Results： 菜单栏File -\u0026gt; Load Simulation Results 加载FSDB文件，也可以在打开verdi时命令行添加参数-ssf nova.fsdb。 Source Code窗口显示信号值： 当加载FSDB文件后，光标停留在Source Code窗口，使用快捷键x，可以在代码中显示信号值，当前仿真时间在上方工具栏显示，且可调整，可选择信号下/上一个值变化（沿）来跳转模拟时间，注意信号值与波形窗口光标所在模拟时间保持一致，建议通过波形窗口来控制模拟时间的跳转。 将信号添加到波形窗口： 选中信号（按住Ctrl可选择多个信号），鼠标右键选择Add Signal(s) to Waveform， 建议使用快捷键Ctrl+w 。 选中信号鼠标右键选择Signal，可以设置Radix，默认十六进制。  Debug in Waveform View Open nWave Window  选择Tools -\u0026gt; New Waveform 或者 点击菜单栏波形窗口图标。 加载FSDB文件后，选中信号，使用快捷键Ctrl+w，将信号添加到波形窗口，工具会自动打开波形窗口。 使用命令行如“verdi –f run.f –ssf nova.fsdb”启动verdi时，会自动打开波形窗口。 在波形窗口也可以加载FSDB文件，波形窗口菜单栏File -\u0026gt; Open 或 使用工具栏打开文件图标。  Add Signals  Source Code窗口选中信号使用快捷键Ctrl+w可以添加信号到波形窗口。 波形窗口菜单栏Signal选择Get Signals 或 使用工具栏信号图标，将打开添加信号窗口，可以选择当前模块的输入、输出、寄存器、线网等信号，或搜索信号，添加至波形窗口。 提示： debug时往往边分析代码边查看波形，使用场景更多是一个个添加追踪，所以大多使用Ctrl+w； 而波形窗口菜单栏添加信号，往往在查看输入输出信号x态时使用，统一添加所有输入输出端口信号，而无需一一添加。  Organize Signals  创建信号组： RMB -\u0026gt; Group Operations -\u0026gt; Add Group to add groups； RMB -\u0026gt; Group Operations -\u0026gt; Insert Subgroup。 修改组名： 选中组，RMB -\u0026gt; Rename。 跳转至信号组： RMB -\u0026gt; Go To， 菜单栏也可操作。 折叠与展开组： 双击\u0026quot;+\u0026rdquo;/\u0026quot;-\u0026quot;。 添加空白分隔行： RMB -\u0026gt; Add Blank。  Operate on Signals  信号移动： 信号列表中金色标线代表移动至此，可通过鼠标中键调整金色标线位置，选中对应信号后，使用快捷键m，即可将信号移动至金色标线位置，并且金色标线移动至添加信号的下方（按住Ctrl或下拉可选择多个信号，按选择顺序添加）。 信号复制： RMB -\u0026gt; Copy， 快捷键Ctrl+P。 信号粘贴： RMB -\u0026gt; Paste， 快捷键Insert（粘贴至金色标线位置）。 删除信号： 选中信号按delet键（选中可以使用按住Ctrl或下拉选中多个信号）。 右键可复制信号全路径。 bus总线可以双击展开单bit信号显示，也可双击折叠。 bus总线可以分组显示，RMB -\u0026gt; Bus Operation -\u0026gt; Expand as Sub-bus， 可以设置每组bit数。 可将多个单比特信号组合为bus显示： RMB -\u0026gt; Bus Operation -\u0026gt; Create Bus。 可以添加注释： RMB -\u0026gt; Add Comment，添加注释行，在波形注释行右键可选择添加注释文本框，且文本框箭头可拖拽指向位置（个人觉得debug时使用不多，在做PPT展示讲解时很有必要）。 信号沿追踪和搜索信号值： 菜单栏有沿选择（任何变化、上升沿、下降沿、总线值等），左右操作图标（可向前跳转和向后跳转），当选择总线值时，左即向前搜索，右即向后搜索。 保存信号列表： 菜单栏File -\u0026gt; Save Signal，或快捷键Shift+s，打开Save Signal窗口，在默认路径后输入文件名（路径可修改），无需写文件后缀，默认后缀为“.rc”。注意：如果信号中有使用参数化表示范围，请在Options选项取消Events的选择，这样当参数变化时波形信号保持一致。 加载信号列表： 菜单栏File -\u0026gt; Restore Signal，如果在命令行则使用“–sswr .rc”。  Manipulate Waveform Display  设置标记： 菜单栏Waveform -\u0026gt; Marker 或 快捷键Shift+m，打开Marker窗口，可设置名称、时间、颜色、线的形状等，可对标记进行添加、删除、修改（标记也会保存至Signal文件），在debug时对信号的追踪使用标记很有用，可标记关键节点。 修改信号值显示进制： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Radix，可更改显示进制。 设置信号值显示别名： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Edit Alias，打开Alias Editor窗口，可为数值设置别名，以及颜色（这对状态机State信号显示特别有用）， 使用apply可应用已设置的alias。 显示毛刺： View -\u0026gt; Display Glitch。 event报告： 选中信号，View -\u0026gt; Signal Event Report，可以显示信号信息，包括上升沿数量、下降沿数量、翻转频率，可选择统计起始和结束时间，这对统计某时间段clk（或其他信号）翻转数很有用，好像只能统计单比特信号。 添加网格： View -\u0026gt; Grid Options 打开Grid Options窗口，可以根据所选信号的上升/下降沿添加网格，也可以自定义周期在特定时间范围内添加网格，当波形窗口信号较多时添加参考网格非常有用。 选择一段时间： 鼠标中间设置起始位置， 鼠标左键设置终止位置。 选择无翻转信号： 首先选择一段时间，然后快捷键Ctrl+s，快速选择选择时间内无翻转信号。 波形显示窗口： Ctrl+鼠标滚轮，缩放窗口；鼠标拖拽选中区域填充整个窗口；Shift+鼠标滚轮，波形左右移动（时间前后）。  Debug in Schematic View 待补充\nDebug in FSM View 待补充\nDebug in Temporal Flow View 待补充\nFrequently Used Preferences 打开TCL命令窗口  Preferences -\u0026gt; General -\u0026gt; Enable TCL Command Entry Form(将其切换为选中状态)。 可以在TCL Command窗口输入TCL命令来执行，同时在Verdi中执行的任何操作，其对应TCL命令都将记录在此处（换句话说，你可以通过图形化操作来找到对应的TCL命令）。  Source Code 相关  关于Source Code窗口，最常用的设置无非是字体的大小，可以在这里找到，或直接搜索Font，找到Source Code的Font设置选项。  Waveform 相关  General： 可以设置以不同的颜色显示输入/输出信号。、 View Options： 可以设置进制、信号值与别名等。 Color / Font / Pattern： 可以设置外观和字体颜色大小等。  其他 关于首选项，可设置参数挺多的，不过一般不会使用到，也不建议做太多更改，我使用最多的就是对字符大小的更改，方便浏览代码。\n其他使用记录  快速添加模块端口信号以确认输入无x态：在源代码窗口上方工具栏右键 -\u0026gt; Signal List(打开信号列表窗口) -\u0026gt; 选择Input -\u0026gt; 右键选择 Select All in Current Page -\u0026gt; 右键 Add Signals to Waveform (Ctrl-W)  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":35,"section":"docs","tags":["EDA工具"],"title":"Verdi使用总结","uri":"https://www.wenhui.space/docs/07-ic-verify/tools/verdi_userguide/"},{"content":"本文 主要分享我摘自微博的关于美食系列漫画，作者为 心壹绘画 。\n展示   美食漫画1      美食漫画2      美食漫画3      美食漫画4      美食漫画5      美食漫画6      美食漫画7      美食漫画8      美食漫画9      美食漫画10      美食漫画11      美食漫画12      美食漫画13      美食漫画14      美食漫画15      美食漫画16      美食漫画17      美食漫画18      美食漫画19      美食漫画20      美食漫画21      美食漫画22      美食漫画23      美食漫画24      美食漫画25      美食漫画26      美食漫画27      美食漫画28      美食漫画29      美食漫画30      美食漫画31      美食漫画32      美食漫画33      美食漫画34      美食漫画35      美食漫画36      美食漫画37      美食漫画38      美食漫画39      美食漫画40      美食漫画41      美食漫画42      美食漫画43      美食漫画44      美食漫画45      美食漫画46      美食漫画47      美食漫画48      美食漫画49      美食漫画50      美食漫画51      美食漫画52      美食漫画53      美食漫画54      美食漫画55      美食漫画56      美食漫画57      美食漫画58      美食漫画59      美食漫画60      美食漫画61      美食漫画62    分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1elUURr8CgDQ4c91EEpZX3w 密码：1cz1\n","description":"","id":36,"section":"docs","tags":["美食"],"title":"我的收藏之美食漫画","uri":"https://www.wenhui.space/docs/03-life/food-comics/"},{"content":"本文 主要分享我收藏的中国烹饪古籍丛刊，文件为电子扫描版PDF格式。\n介绍 中国烹饪古籍丛刊是由中国商业出版社出版的，好像最早是1984年9月出版第一种《易牙遗意》，最晚是1993年出版的《太平御览·饮食部》，但始终不知总目，不知出版了多少种，我这里收藏的有33种。这些烹饪古籍，都是古代人智慧的结晶，也许对现在物质如此丰富且与时俱进的社会，不会有太多借鉴之道，但是由此可以了解到古人文人对吃文化的追求，以及关于吃的闲文趣事。\n我收藏的中国烹饪古籍丛刊共计33本，名录如下：\n 中国烹饪古籍丛刊 01 云林堂饮食制度集_11199761 中国烹饪古籍丛刊 02 易牙遗意_11404103 中国烹饪古籍丛刊 03 中馈录_11414100 中国烹饪古籍丛刊 04 醒园录_11131465 中国烹饪古籍丛刊 05 随园食单_11132930 中国烹饪古籍丛刊 06 素食说略_11132919 中国烹饪古籍丛刊 07 吕氏春秋本味篇_10508261 中国烹饪古籍丛刊 08 养小录_11404102 中国烹饪古籍丛刊 09 千金食治 食疗方_10807464 中国烹饪古籍丛刊 10 清异录（饮食部分）_10826528 中国烹饪古籍丛刊 11 闲情偶寄_10122795 中国烹饪古籍丛刊 12 齐民要术（饮食部分）_11122013 中国烹饪古籍丛刊 13 食宪鸿秘_11138805 中国烹饪古籍丛刊 14 随息居饮食谱_10093750 中国烹饪古籍丛刊 15 饮馔服食笺_11404150 中国烹饪古籍丛刊 16 饮食须知_10094041 中国烹饪古籍丛刊 17 能改斋漫录（饮食部分）_11476167 中国烹饪古籍丛刊 18 先秦烹饪史料选注_11476279 中国烹饪古籍丛刊 19 吴氏中馈录 本心斋疏食谱 （外四种）_11404172 中国烹饪古籍丛刊 20 居家必用事类全集（饮食类）_10508260 中国烹饪古籍丛刊 21 造洋饭书_11404173 中国烹饪古籍丛刊 22 菽园杂记（饮食部分）、升庵外集（饮食部分） 、 饮食绅言（饮食部分）_11404158 中国烹饪古籍丛刊 23 粥谱（二种）_10762172 中国烹饪古籍丛刊 24 山家清供_11046668 中国烹饪古籍丛刊 25 调鼎集_11550671 中国烹饪古籍丛刊 26 筵款丰馐依祥调鼎新录_11476281 中国烹饪古籍丛刊 27 饮膳正要_11500655 中国烹饪古籍丛刊 28 浪迹丛谈四种（饮食部分）_11622664 中国烹饪古籍丛刊 29 陆游饮食诗选注_11419091 中国烹饪古籍丛刊 30 随园食单补证_11473106 中国烹饪古籍丛刊 31 清嘉录_11622981 中国烹饪古籍丛刊 32 食疗本草_10444356 中国烹饪古籍丛刊 33 东京梦华录 都城纪胜 西湖老人繁胜录 梦粱录 武林旧事_10162520  分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1ald33jJK8y91vS7wwMNWYw 密码：srgf\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":37,"section":"docs","tags":["美食","读书"],"title":"我的收藏之中国烹饪古籍丛刊","uri":"https://www.wenhui.space/docs/03-life/ancient_chinese_cooking_books/"},{"content":"本文 主要介绍了一些verilog的编码风格准则。\n   版本 说明     0.1 初版发布    参考  RTL Coding Styles That Yield Simulation and Synthesis Mismatches（链接：https://pan.baidu.com/s/16fD72mrvHfSIA531h33J2A 密码：vzrl） VERILOG CODING STYLES FOR IMPROVED SIMULATIONEFFICIENCY (链接：https://pan.baidu.com/s/1r8RETSe3ehe2T%5FK5brZbjQ 密码：t2hp)  写在前头 本文主要从三个角度来对verilog编码风格进行说明：\n 利于模拟的编码风格：可以加快模拟速度或减少模拟占用内存。 利于综合的编码风格：可以减少综合前后模拟不一致问题。 利于维护的编码风格：有利于设计的维护、交互与修改，提高设计效率。  利于模拟的编码风格  多条件下尽量使用 case 语句，不使用嵌套 if-else if-else 语句，两者占用内存差不多，但模拟速度 case 比 if 要快。 不使用多余的 begin-end， always 或 if 语句中只有一条语句，是不需要使用 begin-end 的，多余的 begin-end 会占用更多内存和减缓模拟速度。 时钟信号产生，使用 always 语句描述模拟速度更快，如下代码：   1 2 3  reg clk; initial clk = 0; always #(`CYCLE/2) clk = ~clk;    尽量避免将赋值语句分散到多个 always 块，如寄存器的赋值，建议尽量将多个寄存器描述在一个 always 块语句，而不是将每个寄存器都用一个 always 块语句来描述，这样可以减少内存和提高模拟速度。 尽量减少模块的端口数，模块端口数越多，模拟速度越慢，因此需要对设计合理划分模块。 加载测试向量时，避免在时钟的上下沿变化，而是在延时一个时间单位后，这样更能够模拟真实电路的行为，为了便于维护，可以定义CYCLE数值，延时单位采用 “0.1*`CYCLE” 形式。 显示非阻塞赋值语句的变量值，使用 $strobe ，而不是 $display 和 $write 。下面介绍一下两者的区别，举例如下：   1 2 3 4 5 6 7  initial begin a = 0; $display(a); // displays 0 $strobe(a); // displays 1 ... a = 1; // ... 因为这条语句 end   可见 $strobe 是在整个块语句结束后执行的，而 $display 是在程序位置执行的。这里是一个顺序执行的块语句，而对于非阻塞赋值语句不是顺序执行的，所以在需要显示非阻塞赋值语句的变量值时，使用 $strobe ，确保能够取到稳定的赋值后的值。\n以上是公认的编码原则，强烈建议遵循，而下面内容，仅供参考：\n 尽量减少设计层次，层次越多模拟速度越慢。 parameter 比 define 更占用内存，但模拟速度相当。 `timescale 精度越高，模拟速度越慢。 $time 等系统调用程序非常影响模拟速度，可以使用但不要滥用。 不建议设计文件中写 `timescale ，建议写在单独文件，统一进行 `include ，或在仿真工具中参数化输入。  利于综合的编码风格  顶层模块不要有粘连逻辑，顶层模块甚至次顶层模块只用来例化和连接子模块，这样不仅可以节省顶层的编译时间，还有利于布局布线的实施。 减少不必要的设计层次，更多的层次会降低综合性能，当然也可以先使用工具将设计层次铺平，如 dc 的 ungroup 。 组合逻辑与时序逻辑尽量分开描述，换句话说，寄存器always语句描述中应该只有赋值，而无其他运算。 将不同类的逻辑分散到不同模块，这样综合工具可以针对不同的逻辑类型采用适当的优化技术。 相关的组合逻辑不要拆散到不同模块，否则会限制综合工具的优化力度，好的设计就是所有输出都是寄存器输出，对于组合逻辑分散到不同模块，虽然通过工具在综合前将设计铺平的方法可以缓解问题，但作为设计师还是尽量遵循此原则。 所有输出都是寄存器，这样所有组合逻辑都在前端，最后寄存输出，这也是所说的 “cloud-register原则” ，这样既可以得到更好的综合结果，而且简化了综合的约束设计。 敏感列表要完整，当然现在可以使用*代替，或者使用 SystemVerilog 的 always_comb 。 注意阻塞赋值的语句顺序。 避免 if/case 条件不完整，否则会产生 latch，可以使用 Systemverilog 中的 always_comb、always_latch、always_ff 语句，编译时会严格检查，也可以在块描述语句 if/case 前对信号赋初值。 用 always 语句描述组合逻辑使用阻塞赋值 = 。 描述 latch 时使用阻塞赋值 = 。 描述时序逻辑使用非阻塞赋值 \u0026lt;= 。 在同一个块语句中不要混用两种赋值方式。 不要使用 #0 延迟赋值。 FSM 中的状态名应该使用 parameter。 FSM 计算下一状态的组合逻辑应该放在一个单独的 always 块。 FSM 计算下一状态的组合逻辑应该使用 case 语句。 每个 FSM 使用单独的 module 描述。  利于维护的编码风格  每个项目都使用相同的目录结构，相同的目录结构有利于脚本移植，以及增加复用性和可维护性，同时利于工作交接。 项目中每个设计都保持类似的目录结构，理由同上。 项目内脚本尽量使用相对路径，需要全路径名称则使用环境变量。 对 `include 加载的文件尽量使用完整相对路径，方便设计的集成和移植，或者对所有设计的 include 文件规范命名规则。 每个文件只包含一个 module 。 文件名和模块名保持一致。 测试文件名与被测试模块名相对应，添加 _tb 后缀。 每个文件都添加头信息：版权声明、文件描述、创建时间、修改时间、原始作者信息、当前作者信息。 注释描述代码功能，而不是行为。 每个 parameter 声明后要注释。 function 要加注释。 每个主要逻辑段落要加注释。 信号名要有实际意义，并且输入输出信号名信息中要包含输入输出模块。 废代码删掉，而不是注释。 每个模块逻辑代码尽量不要超过400行，可读性可调试性强。 每级缩进建议四个空格，并且不建议使用TAB缩进，不同编辑器对TAB支持不同，可能会导致代码显示乱掉。 每行最多72个字符，在恰当的地方换行，并保持对齐。 控制流嵌套不超过三级。 每行只写一条语句。 连续声明语句对齐，并且每行只声明一个。 句尾的注释尽量对齐。 多次使用的逻辑使用 function 。 操作符周围使用一个空格与其他项隔开。 所有信号名尽量使用小写字母，并且用下划线将单词分隔开。 常数定义和宏定义使用大写字母。 模块的名字要体现层次结构。 模块的例化名与模块名基本保持一致，不过例化名可不体现层次结构，加 “i_” 或 “inst_” 前缀。 信号名要有意义，至少5个字符。 模块根据功能命名，不要依据类型或作者命名。 项目内命名要规范，避免模块重名。 根据功能或逻辑顺序声明端口，而不是方向。 低电平有效信号加后缀 “_n” ，如复位信号 “rst_n” 。 建议时钟信号统一加前置 “clk_” 。 建议复位信号统一加前缀 “rst_” 。 建议寄存器信号统一加后缀 “_ff” ，下一拍寄存器加载的值信号添加后缀 “_nxt” 。 总线范围定义为 “N-1:0” 。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":38,"section":"docs","tags":["Verilog"],"title":"verilog的编码风格","uri":"https://www.wenhui.space/docs/08-ic-design/rtl-coding/verilog-coding-styleguide/"},{"content":"本文 主要介绍Verilog语法中case，casex，casez的区别，以及建议使用方法。\n   版本 说明     0.1 初版发布    关于case  代码：   1 2 3 4 5 6 7 8 9  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 g default   xx g default   x0 c x0   1z f 1?   z1 g default    可见，case语法对四值0 1 X Z是严格匹配的，并且语义中“？”代表Z值。\n关于casez  代码   1 2 3 4 5 6 7 8 9  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 f 1?   xx g default   x0 c x0 (would have matched with z0(item 5) if item 3 is not present.)   1z d 1x (would have matched with z0(item 5) \u0026amp; 1?(item 6) also.)   z1 b 01 (would have matched with 1?(item 6) also.)    首先，casez的匹配顺序是从上到下。根据上面casez的匹配列表，可见casez语法将表达式的“z/?”与输入的任意值（0 1 X Z）匹配，而表达式的“x 0 1”和输入的“x 0 1”还是严格匹配。所以，一般我们对于不关心的信号位使用casez语句，并在选项中将该位设为\u0026quot;z/？\u0026quot;。这也是最推荐的写法。\n关于casex  代码   1 2 3 4 5 6 7 8 9  casex (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 d 1x (would have matched with 1? also)   xx a 00 (would have matched with all)   x0 a 00 (would have matched with all items except 01)   1z c x0 (would have matched with all items except 00,01)   z1 b 01 (would have matched with 1x, 1? also)    同样，casex的匹配顺序也是从上到下。根据上面casex的匹配列表，可见casex语法将将表达式中“z/?/x”与输入的任意值（0 1 X Z）匹配，而表达式中的“0 1”与输入的“0 1”严格匹配。\n总结      总结如下：\n case、casex、casez的匹配顺序都是从上到下。 case严格匹配，casez中表达式z/?代表不关心该位的状态值(最好使用？)，casex中表达式x/z/?代表不关心该位的状态值。 case、casex、casez都是可综合的，不过在case中综合电路无法解析x/z/?，会将其认为不关心，这样会使RTL语义和综合电路间产生偏差，所以case语句表达式中不建议使用x/z/?。 尽量不使用casex，因为在初始条件下，控制信号可能存在大量x，使用casex会对电路的选择功能造成混乱，隐藏选择信号x值对电路功能的影响。  推荐使用casez，代码格式如下：\n1 2 3 4 5 6  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b1?: y = c; default : y = d; endcase   代码功能等同于：\n1 2 3 4 5 6  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b10,2\u0026#39;b11: y = c; default : y = d; endcase   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":39,"section":"docs","tags":["Verilog"],"title":"关于Verilog中的case、casex、casez","uri":"https://www.wenhui.space/docs/08-ic-design/rtl-coding/about-verilog-case/"},{"content":"本文 主要介绍一些我生活中做的小菜，以及做菜的小心得，为自己的美好生活做个记录，同时与有兴趣的人一起分享。\n背景 为什么喜欢做菜呢？ 还不是为了嘴嘛！ 做自己喜欢吃的菜是一件多么愉悦的事，为自己爱的人做喜欢吃的菜又是一件多么幸福的事。\n西红柿炒鸡蛋 西红柿炒鸡蛋可以说是我的第一个菜。西红柿炒鸡蛋是最家常的菜了，也正是因为家常，所以每家的西红柿炒鸡蛋都有其独特的味道。\n材料 材料需要两个西红柿、两个鸡蛋、少许葱白、少许香葱末/青椒末、少许番茄沙司、盐、糖、油。其实我自己炒一人份的话，要败家一点，一个西红柿两个鸡蛋，咱这收入水平做不到财富自由，总能做到鸡蛋自由吧，想吃就吃。\n对于材料，这里要强调两点：\n 必须是葱白，用葱叶爆香是不好吃的，西红柿鸡蛋吃的是葱白的香甜味。 是番茄沙司不是番茄酱，番茄沙司是用水和糖调过味的，而番茄酱只是番茄酱，加入番茄沙司会使西红柿的味道更浓郁。  制作  西红柿顶部用刀轻划十字，开水锅里滚两下，然后冲凉，用手剥去外皮。 西红柿切块，不要太小，葱白切末，香葱/青椒切末。 打两个鸡蛋，如果想要颜色好看，可以使用柴鸡蛋或者多加一个蛋黄，用筷子朝一个方向打散。 坐锅烧油，油可以略多点，油热煎鸡蛋，待鸡蛋成熟打碎成块，同样不要太小，鸡蛋熟后取出待用。 不用刷锅，继续使用煎鸡蛋留下的底油，低油温放入葱白末，煸炒爆香。 葱白煸香后放入西红柿，快速翻炒，适当加一点点水，防止葱白炒糊，同时放入适量番茄沙司翻炒。 调味，放入盐和糖，糖多放一点，中和西红柿的酸味。 西红柿炒透出汁后，放入鸡蛋，继续慢慢翻炒，使鸡蛋吸满之水。 最后放入青椒末，翻炒两三下，如果是香葱末则在出锅后撒入即可。  心得  西红柿最好去皮，一是为了口感，二是去皮的西红柿更容易出汁水，更容易炒透，三是西红柿皮在炒熟过程中会打卷，影响美观。 如果西红柿成熟度不好，可以在切之前轻揉几下，这样更容易炒透。 鸡蛋一定要打散，使蛋清蛋黄充分融合，打散的蛋液炒起来更容易蓬松。 鸡蛋可以放一点点盐或不放，放盐会使炒出的鸡蛋稍稍发黑不黄亮。 炒鸡蛋油温一定要够，大概六七成，这样会使鸡蛋迅速蓬松起来，并且不要急于搅动，否则鸡蛋易碎而不成块状，待定型成熟至饼状时将其打散成块状。 鸡蛋炒的稍老会更香，蓬松的鸡蛋才能更好的吸收汁水。 鸡蛋打散成块状的时机也很重要，早了鸡蛋易碎不成块状，晚了容易产生焦边，影响颜色，最好的时候就是鸡蛋成熟至饼状时打散，然后快速翻炒几下，不至于边缘受热过度。 取出鸡蛋时要取干净，尤其边缘部分，否则煸炒葱白时残留鸡蛋容易糊，或者清洗锅后重新烧热，将鸡蛋滤出部分油淋入锅中，也可以避免此问题。 葱白要在低油温时下锅煸炒，大概三成油温时即可，并且尽量在锅底处煸炒，否则容易糊，出葱香味后放入西红柿，这时可以将火调小一点或者稍加一点点水，防止葱白在翻炒时烧糊。 西红柿出水后大火翻炒，一定要将西红柿炒熟炒透，但也切忌过度翻动，否则会将西红柿翻碎不成型。 西红柿炒透后进行调味，然后加入鸡蛋，加入鸡蛋后一定要大火快速翻炒，这样可以快速收汁，小火慢炖的话会是西红柿出太多汁水。 青椒末一定要在锅中翻炒几下，熟的青椒末才有香气，香葱末不要翻炒，成菜时撒入即可，否则会影响美观，其实香菜梗末也可以，或者黄瓜根部切圈，可以多尝试，找到自己最喜欢的味道，搭配点绿色成菜也更漂亮。 如何保证味道呢，一个诀窍就是尝一尝，缺啥加啥。 个人觉得，西红柿炒鸡蛋拌米饭才是最佳。  成品 成品效果主要有以下几个特点：\n 成菜红黄搭配，绿色点缀，颜色鲜亮。 鸡蛋黄亮，块大，吸足汁水。 西红柿炒透，无硬心，并且成块有口感。 成菜略有汁水，但不太多。 味道甜酸咸适中，先甜后咸。  图片待补充：\n声明 以上仅代表个人口味和心得，仅供参考。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":40,"section":"docs","tags":["美食"],"title":"我的美食拙作","uri":"https://www.wenhui.space/docs/03-life/my_cooking_dishes/"},{"content":"本文 主要介绍WPS如何使用文档模板。编辑文档时使用模板是一个好习惯，不仅能够使工作中的文档格式统一，还节省排版时间。Windows word创建模板操作应该类似。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 deppin版本： Deepin GNU/Linux 15.11 WPS版本：WPS Office 2019  写在前面 由于本人的办公系统基本已经从Windows转向了Linux，而且文档编写已经转向emacs org格式，但是与同事间交互时还是避免不了使用传统文档文件。典型的文档编辑器就是Windows Office word，但是Linux环境并不支持word，幸好WPS有Linux版本。有人说WPS不如word好用，两个工具来对比，其实功能基本完全对等，只是操作不同，可能大部分人习惯了word吧，还有就是彼此兼容略有问题，建议WPS完成的文档转为PDF格式再交付，这样可以避免兼容的问题。\n创建我的模板 由于网上并没有找到合适的模板，所以就根据自己的工作习惯，创建一个自己的模板，我对文档格式的需求主要有如下几点：\n 标题页面，需要有标题名称，作者信息，时间和版本信息。 目录页面，包括文档目录、图目录和表目录。 页码，前文页码为罗马数字，正文页码为阿拉伯数字。 正文第一项，文档介绍，需要介绍文档目的和参考文献。 水印为可选项，可加可不加。  根据以上需求，我完成了我的文档模板，分享给大家，仅供参考。网盘资源分享链接： 链接：https://pan.baidu.com/s/19C-LCnAOpcN0RBXoCGocPg 密码：27ys 。\n简单描述一下文档模板如何创建，其实和编写文档一样，设置完以上内容，通过 另存为 可选择输出为模板文件。\n如何使用模板文件 新建文档时选择 本机上的模板 ，一般这里只会显示空白模板，选中导入模板，在本地找到模板文件，即可使用模板创建新的文档。如果想在 本机上的模板 中显示自己的模板，请将模板文件移动到WPS的模板文件夹内，这里给出Linux下的路径： ~/.local/share/Kingsoft/office6/templates/wps/zh_CN 。\n其他使用技巧 关于水印 选择 插入-*水印*，可以选择去除水印或右键编辑水印。\n关于图表 文档中免不了会使用图表，选中插入的图表，选择 引用-题注-图 或 表 ，这里一般有几个重要参数，编号格式和是否包含章节编号，我一般选择默认的数字和包含章节编号，一般包含一级标题编号即可，另外一个参数是 位置 ，一般习惯上表格的题注在上方，图的题注在下方。\n关于目录 文档目录模板中已经添加好，可双击选择更新；图表目录需要删除后，将光标置于合适位置，选择 引用-插入表目录 ，选择图或表，即可自动插入目录。（如果需要添加公式目录，操作类似）\n关于操作符 这里操作符是指换行符等在文档中不可见的符号，在模板中添加了若干换行符、分页符和分节符等，若想显示它们，点击左上角的 文件-选项-视图-段落标记 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":41,"section":"docs","tags":["Office"],"title":"WPS如何使用文档模板","uri":"https://www.wenhui.space/docs/05-windows-skills/create_wps_tepmlate/"},{"content":"本文 主要介绍一款关于英文自动补全的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  基于 Company 的英文助手 Github：company-english-helper  补充说明： 这个英文补全的emacs插件是基于Company插件的，可能需要先安装Company插件才可以使用，由于安装此英文补全插件时已经安装Company插件，所以并未考证。如果需要安装Company插件，请参考我的另一篇帖子 emacs如何安装插件。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":42,"section":"docs","tags":["emacs"],"title":"emacs插件之英文自动补全","uri":"https://www.wenhui.space/docs/02-emacs/emacs_company_english/"},{"content":"本文 主要介绍数字电路设计中X-Propagation问题以及其解决方案。\n   版本 说明     0.1 初版发布   0.2 添加EDA工具的使用   0.3 添加verilog X-Prop插件VRQ介绍   0.4 添加综合后代码以及仿真结果    参考  文献1：《X-Propagation Woes: Masking Bugs at RTL and Unnecessary Debug at the Netlist》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YV%5FuOM1ech1zVkPMcqQ51w 密码：09wu 文献2：《X-propagation能在RTL仿真中发现X态问题》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YP3ZfIDgmX%5FmWFaOzkFKeQ 密码：3hq3  什么是 X-Propagation 问题? 什么是 X 状态？ SystemVerilog 标准中定义了四种逻辑状态，即“0”、“1”、“X”、“Z”，“0”代表低电平，“1”代表高电平，“X”代表不定态，“Z”代表高阻态。低电平和高电平很容易理解，而不定态和高阻态只有在模拟仿真时才会出现，真实电路中是不存在“X”和“Z”的。“X”和“Z”都代表不确定是“0”还是“1”的情况，比如未复位前的寄存器，在模拟仿真时是“X”状态，未赋值的悬空信号，在模拟仿真时是“Z”状态。\nX 状态的来源有哪些？ 数字电路中 X 状态的来源主要有以下几种：\n 未复位的寄存器和锁存器。 输入信号为 X 状态。 总线竞争。 地址越界。 跨时钟域逻辑（虽然在模拟仿真中不会直观看到X状态，但实际电路中由于跨时钟域是有采样到非理想值的风险，需要关注）。 多驱动（虽然在RTL编码中多驱动认为是一种错误，但实际电路中是有多驱动的技术的）。  总的来说，模拟仿真中 X 的状态更多来自未复位的寄存器和锁存器，尽管可以通过复位信号进行初始化解决这一问题，但是复位信号由于空间和延迟等布线的限制，也并非能够完全做到这一点。尤其现在低功耗设计，电路的睡眠和唤醒机制，对寄存器的初始化设计又带来了复杂性，同时也增加了隐藏 bug 的风险。但是需要注意的是，X 状态在真实电路中是不存在的，要么是“0”，要么是“1”。\n什么是 X-Optimism？ RTL 仿真中，对 X 状态是乐观处理的，什么是乐观处理呢？直观来说就是会将一个未知值在电路逻辑中传递为已知值。举例说明：\n if-else语句   1 2 3 4 5  always@(*) if (sel) out = a; else out = b;   结果如下：\n   sel out     1 a   0 b   x b    在if-else 的选择电路中，当选择信号为 X 时，判断 if 条件不满足，则会执行 else语句，所以 out 值为 b（如果没有 else 语句，则会产生锁存器，保持先前值）。这里补充一下，Z 状态同样会产生相同问题，只不过设计中很少存在 Z 状态，不再讨论。\n case语句   1 2 3 4 5  always@(*) case (sel) 1: out = a; 0: out = b; endcase   结果如下：\n   sel out     1 a   0 b   x prev    当选择信号为 X 时，非 0 非 1，不符合 case 语句中任何选项，则保持先前值，这也是将未知状态传递为已知状态的乐观处理。\n可见模拟仿真中对 X 状态的乐观处理，与实际电路是有差异的，这样比较容易隐藏功能bug。不过在门级网表仿真中是可以发现这些问题的，门级仿真对 X 状态是悲观处理的，会引入更多无效X状态，而且门级编译和仿真速度很慢，调试也是极其麻烦，将X-Propagation问题放到门级仿真来解决并不是一个好的选择。\n什么是 X-Pessimism？ 门级网表仿真中，对 X 状态是悲观处理的，什么是悲观处理呢？直观来说就是会将一个已知值在电路逻辑中传递为未知值。举例说明（这里只以assign语句为例，其实所有逻辑综合后都等效为门级电路，换句话说所有逻辑语句在门级电路仿真时都是悲观处理的）：\n1  assign out = (a \u0026amp;\u0026amp; selector) || (b \u0026amp;\u0026amp; ~selector);   结果如下：\n   selector a b out     X 0 0 X   X 0 1 X   X 1 0 X   X 1 1 X    以上是一个选择器逻辑，当 a 和 b 为相同值时，out结果应该与选择信号无关，也就是当 a和 b 都为“1”时，无论 selector 值为何，其结果值都应该为“1”。而实际门级仿真的悲观处理，在selector为X时，会将结果输出为“X”。\n可见门级仿真中对 X 状态的处理是悲观的，这样就会出现不必要的 X 值，与实际电路是有差异的，虽然不会隐藏功能 bug（因为 X 都会暴露出来），但是由此带来的门级仿真和RTL 仿真的差异，必须解决，带来了额外的工作量。\n关于clk的X-Prop 以上对选择逻辑的X-Prop问题进行了描述，而对于寄存器来说，clk的X态同样会带来问题，举例如下：\n 源代码：   1 2  always@(posedge clk) q \u0026lt;= d;    RTL仿真结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 0   0-\u0026gt;X or X-\u0026gt;1 1 0 1   0-\u0026gt;X or X-\u0026gt;1 1 1 1     真实电路结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 1     门级仿真结果：  （注意：猜测结果如下，未进行证实）\n   clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 x   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 x     总结：  可见对于寄存器关于clk的x态处理，也存在乐观和悲观问题。\n结论 通过上面内容，已经知道 X 状态的含义和来源，以及 RTL 仿真对 X 状态的乐观处理和门级仿真对 X 状态的悲观处理，总之由于 X 状态的存在，不同的处理方式，在 RTL 仿真、门级仿真和真实电路之间产生了差异，RTL 仿真的乐观处理，带来了隐藏功能 bug 的风险，门级仿真的悲观处理，当发现 X 状态时首先要确认是真实的 X 状态还是由悲观处理产生的，这带来了额外的工作量，尤其网表调试是极其麻烦的。综上，这就是关于 X-Propagation 问题。\n我的测试程序 RTL测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  module xprop_tb; reg clk; reg sel; reg a0,a1; reg b0,b1; reg din; /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire out1; // From i_xprop of xprop.v wire out2; // From i_xprop of xprop.v wire out3; // From i_xprop of xprop.v wire out4; // From i_xprop of xprop.v // End of automatics  initial begin //Two options have the same value  #0 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //Two options have the different value  #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //test clk  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;bx; #1 $display(out4); #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;bx; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;b1; #1 $display(out4); #10 $finish; end xprop i_xprop(/*AUTOINST*/ // Outputs  .out1 (out1), .out2 (out2), .out3 (out3), .out4 (out4), // Inputs  .clk (clk), .sel (sel), .a0 (a0), .a1 (a1), .b0 (b0), .b1 (b1), .din (din)); endmodule // xprop_tb  module xprop (/*AUTOARG*/ // Outputs out1, out2, out3, out4, // Inputs clk, sel, a0, a1, b0, b1, din ); input clk; input sel; input a0; input a1; input b0; input b1; input din; output out1; output out2; output out3; output out4; wire out1; reg out2; reg out3; reg out4; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule // xprop   综合后代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  ///////////////////////////////////////////////////////////// // Created by: Synopsys DC Expert(TM) in wire load mode // Version : O-2018.06-SP5 // Date : Mon Feb 24 10:57:14 2020 /////////////////////////////////////////////////////////////  module xprop ( out1, out2, out3, out4, clk, sel, a0, a1, b0, b1, din ); input clk, sel, a0, a1, b0, b1, din; output out1, out2, out3, out4; wire out3, n4, n5; assign out2 = out3; assign out1 = out3; DFFX1_LVT out4_reg ( .D(din), .CLK(clk), .Q(out4), .QN() ); MUX21X1_LVT U7 ( .A1(n4), .A2(n5), .S0(sel), .Y(out3) ); AND2X1_LVT U8 ( .A1(a1), .A2(a0), .Y(n5) ); OR2X1_LVT U9 ( .A1(b0), .A2(b1), .Y(n4) ); endmodule   RTL测试结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:03 2020 x00 x00 000 111 111 111 111 111 0 1 0 1 $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180 V C S S i m u l a t i o n R e p o r t Time: 180 CPU Time: 0.370 seconds; Data structure size: 0.0Mb Mon Feb 24 17:03:52 2020 门级仿真结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:02 2020 xxx xxx 000 111 xxx xxx 111 111 0 x 0 x $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180000 V C S S i m u l a t i o n R e p o r t Time: 180000 ps CPU Time: 0.360 seconds; Data structure size: 0.0Mb Mon Feb 24 17:02:33 2020 总结  使用工具为VCS。 对于综合，无论是三目运算符还是if-else还是case，综合工具都将其转为相同的选择逻辑电路，也就是无论选择RTL何种表达方式，都不影响门级仿真悲观处理的问题，与综合工具也无关，而是仿真工具解析电路的悲观处理导致的。 对于模拟仿真，RTL仿真中if-else和case语句确实存在逻辑乐观处理的问题，而关于三目运算符的结果更符合真实的电路行为； 门级仿真是悲观处理的。  我们的需求是什么？ 验证工程师 对于验证工程师，需求是在 RTL 综合之前尽早消除设计中所有 X 传播问题，使其不会隐藏功能 bug，并且不至于在门级仿真中花费大量时间调试 X 传播问题。\n这里说明一下为什么在门级仿真中调试 X 传播问题需要消耗大量时间和精力。\n 综合后的网表不同于 RTL，难以调试定位问题。 由于门级仿真的悲观处理，增加了更多的 X 状态，而且大多是无害的，难以甄别。 门级仿真中发现 X 问题通常体现在输出的功能错误，而抓到错误与实际的 X 产生节点相隔可能多个周期，对调试增加了难度。 门级仿真速度慢.  设计工程师 对于设计工程师，更关心 X 源在设计中的位置，以及 X 在逻辑中的传播，更早的避免、发现和解决 X 传播问题，减少设计代码的迭代，并且最好不需要重新编码以及其他辅助性代码，这样可以依靠工具对代码结构进行静态检查，准确报告有可能存在 X 传播问题的代码信息。当然，对于复杂的低功耗设计，可能会带来更多的 X 传播问题，更有可能隐藏 bug，保证电路功能的正确性是他们最关心的，但对于验证难度也是非常大的。\n以往的解决方法 模拟仿真  波形调试工具：波形调试工具会显示 X 状态，在 RTL 仿真和门级仿真不一致时，可以通过波形工具进行调试分析 X 传播问题，当然这是最基础的手动调试方法，除了要排除悲观处理产生的不必要的 X 状态外，在表现为错误的节点和实际产生 X 乐观处理的电路间可能存在多个时钟节拍和复杂的电路层级，这对手动调试都带来了不小的工作，更别说大量的 X 传播问题的存在情况。 RTL X 乐观处理的检测：有些仿真工具可以对 X 乐观处理进行检测，当选择条件为 X 状态时，它将驱动 X 状态为 1’b1 和 1’b0，并在两种情况下输出结果不同时报错。这也同  样存在问题，首先是消耗更多的仿真时间，其次是很难保证所有组合状态都已覆盖。\n 随机初始化值：有些仿真工具支持设置寄存器的初始化值，这样通过初始化值随机化，可以减少大部分的 X 状态，这对于检测悲观处理是个好方法，但对于乐观处理，以及电路正确的初始化，不是一个好方法，首先会掩盖正确初始化的功能验证，其次是如果并未产生导致问题的初始值组合，依然无法发现功能 bug，通过多次随机仿真，不仅消耗了大量的仿真时间，但仍不能保证无隐藏的功能 bug。  代码结构分析 代码检查工具如 Lint，会对代码结构进行分析，以识别潜在的问题，并提醒设计人员可能导致 X 传播问题的危险信息。从代码结构分析来讲，工具会检测逻辑中是否使用了未驱动的信号，诸如这些可能导致 X 传播问题情况。但是代码检查工具并不能确定是否存在真正的问题，这样就需要设计人员去逐个分析。不过好在通过代码检查工具可以定位可能的X源以及与其敏感的电路信号，在发现功能bug时，根据代码检查报告快速定位问题。\n形式化验证  等价性检查：很多人都误以为等价性检查会捕获 X 传播问题，而实际并非如此。等价性检查是用于将设计的两个版本（或 RTL 和网表）验证为功能等效。其原理是基于端口信号、黑盒边界以及寄存器初始值的二进制状态空间的遍历。 注：对于此结论并没有完全理解，疑问是形式化验证工具是否对门级网表进行了悲观处理。 模型检查：设计或验证人员使用 SVA 语言编写设计属性，通过形式化验证是状态空间遍历，支持四态的验证工具会验证所有 X 值上无论是“0”还是“1”，都符合设计属性，从而解决 X 乐观和 X 悲观问题。但是需要设计或验证人员编写设计属性，工作量是一方面，还有设计属性描述的完备性以及大规模设计的状态空间爆炸问题难以解决。 符号模型仿真：符号模型仿真可以通过检查输出是否保持一致（无论是否存在 X）来彻底验证设计，并且可以提供反例，显示导致错误的信号状态。但是符号模型仿真也具有局限性，对于大规模的设计会导致内存迅速消耗。同时，设计中可能存在非法输入，可能提供假的反例。 注：对于什么是符号模型仿真本人暂时还不清楚，个人理解为支持X精确的抽象模型。  准确的代码编写 解决 X 传播问题最直接的方法就是准确代码编写，比如双目运算符（？：）是不会被仿真器乐观处理的，可以代替 if-else 和 case，但是它的可读性不强，并且没有避免 X 的悲观处理。那么什么是严格的代码编写呢？举例如下：\n X-optimistic Coding：当 sel 为 X 时，输出 g 为 2’b01。   1 2 3 4 5  always @(*) if (sel==1’b0) g = 2’b00; else g = 2’b01;    X-pessimistic Coding：当 sel 为 X 时，输出 g 为 2’bxx。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’bxx; else g = 2’b01;    X-accurate Coding：当 sel 为 X 时，输出 g 为 2’b0x（准确处理的话应该同时包含 Z 的处理，这里没有体现）。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’b0x; else g = 2’b01;   通过上面的描述感觉问题迎刃而解，仅仅是在编码时追求准确代码编写而已，但是对于赋值语句，很少是常量值，而是复杂的表达式。虽然通过悲观的编码方式可以解决 RTL 仿真的乐观处理问题，但对于门级仿真的悲观处理还是没有解决。\nverilog X-Prop插件VRQ 什么是VRQ？ Vrq是一个Verilog工具框架，带有用于处理源代码的各种插件。支持但不完全支持verilog 2005 语法规则。\n如何安装？  官网下载地址：https://altlinux.pkgs.org/sisyphus/autoimports-i586/vrq-1.0.130-alt1%5F4.i586.rpm.html 百度网盘分享资源： 链接：https://pan.baidu.com/s/11PXGNyhhFk3n9H5CtNQh9g 密码：3j40 ，其中包含安装包和可执行程序，可以直接使用可执行程序，也可以自行安装，安装方法参考readme文件。  如何使用？ Vrq支持的插件功能很多，这里仅以X-Prop为例，使用命令为： “vrq -tool xprop source.v -o target.v” 。这里也就是将source.v源代码进行X-Prop处理，处理完毕后的代码输出至target.v。效果如下：\nvrq xprop处理前：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module top_module (); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0,a1; reg b0,b1; reg out4; reg din; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule   vrq xprop处理后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //**************************************** // Warning! This file is machine generated //****************************************  module top_module(); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0; reg a1; reg b0; reg b1; reg out4; reg din; assign out1=sel ? a0\u0026amp;a1 : ~sel ? b0|b1 : 1\u0026#39;hx; always @* if(sel==1\u0026#39;b1) begin out2 = a0\u0026amp;a1; end else if(~(sel==1\u0026#39;b1)) begin out2 = b0|b1; end else begin out2 = 1\u0026#39;hx; end always @* case(sel) 1\u0026#39;b1: begin out3 = a0\u0026amp;a1; end default: begin case(sel) 1\u0026#39;b0, 1\u0026#39;b1: begin out3 = b0|b1; end default: begin out3 = 1\u0026#39;hx; end endcase end endcase always @(posedge clk) out4 \u0026lt;= din; endmodule //**************************************** // Warning! This file is machine generated //****************************************   可见vrq xprop插件自动完成了将常规逻辑语句准确的xprop语句，简化了工程师的编码工作。关于vrq的xprop的详细功能，可通过“vrq \u0026ndash;help”或“man vrq” 查看。\n其他功能 vrq支持的verilog源代码处理插件很多，可通过“vrq \u0026ndash;help”或“man vrq” 查看。由于其他功能没有亲自实践，这里不再描述，待后续补充。\n最新EDA工具的支持 VCS 的 X-Propagation 功能 VCS X-Prop 的介绍 X-Propagation 是 VCS 开发的用于 RTL 阶段发现 X 态问题的新增特性。该特性主要有两种使用模式：T-merge 和 X-merge。T-merge 采用的算法是：当所有可能值不同时，结果为 X；X-merge采用的算法是：无条件的结果为 X（门级仿真的悲观处理）。下面对 T-merge 和 X-merge 举例说明：\n1 2 3 4 5  always@(*) if (select) out \u0026lt;= a; else out \u0026lt;= b;   看一下 T-merge 和 X-merge 的对比：\n   select a b T-Merge X-Merge     X 0 0 0 X   X 0 1 X X   X 1 0 X X   X 1 1 1 X    使用方法 只需在 VCS 仿真中添加-xprop 或者-xprop=xmerge 选项，默认是 T-merge 模式。也可以通过配置文件指定哪些模块使用 X-propagation 功能，以及指定使用哪种模式，其使用方法为： vcs -xprop=xp_config_file\u0026hellip; 配置文件内容格式如下：\ntree {bridge} {xpropOff}; instance{top.bridge.cpu}{xpropOn}; module {sram,cache}{xpropOff}; merge = tmerge; 另外boundscheck 的使用可以抓到数组下标不合法问题，不合法的下标分两类，下标越界和下标为 X。使用方法是在编译时添加-boundscheck 选项，运行仿真时会检查下标问题，输出报告。\n结论  X-Propagation 简单易用。 使用 T-merge 可以让各种语法结构中的 X 态问题有效传播，其效果可以代替门级仿真，但仿真速率要优于门级仿真。 建议使用方法为：先使用 T-merge 模式，当回归 pass 后再使用 X-merge 模式，如果 pass 则 OK，如果 fail 需要检查是否无效 fail。 使用 X-Propagation 对仿真性能影响可接受，T-merge 模式影响更小（注：与Cadence相反，待考证）。 对于低功耗设计由于其电源控制的复杂性，更有必要使用 X-Propagation。  INCISIVE 的 X-Propagation 功能 INCISIVE X-Prop 的介绍 INCISIVE13.1及更高版本，开始支持X-prop的功能，该功能通过命令行上的\u0026rsquo;-xprop \u0026lt;F / C\u0026gt;'选项启用。\nX-Prop工具目的是在RTL仿真中尽早的发现并解决X问题，其特点如下：\n 两种X-Prop模式  FOX模式 (“Forward only X”) CAT模式 (“Compute as Ternary”)   这两种模式可以区别LRM（Language Reference Manual）的行为 不需要更改现有的设计 减少门级调试  测试代码：\n1 2  if( sel) out = a; else out = b;   两种模式结果对比：\n   sel a b out(verilog LRM) out(FOX model) out(CAT model)     x 0 0 0 x 0   x 0 1 1 x x   x 1 0 0 x x   x 1 1 1 x 1    使用方法 只需要在 INCISIVE 仿真中添加-xprop选项，该选项包含在xrun中，命令为“xrun –xprop F|C”，这里F代表FOX模式，C代表CAT模式。而且可以提供配置文件以在选定的层次结构/实例上启用X-Prop，这也是最推荐的方式，命令为“xrun –xfile \u0026lt;file_name\u0026gt;”，Xfile格式如下：\n//在CAT模式下，在testbench以及其子模块中启用xprop SCOPE testbench… C //在FOX模式下，在testbench.dut以及其子模块中启用xprop SCOPE testbench.dut… F 为了降低调试的难度，在较大设计中，可以为少量模块添加X-Prop，这可以在Xfile中实现：\nSCOPE TB.DUT_TOP.AHB_MOD1…C SCOPE TB.DUT_TOP.CPU… C SCOPE TB.DUT_TOP.APB_MOD2… C SCOPE TB.DUT_TOP.AHB3… C 运行仿真时可以使用tcl命令控制开启和关闭X-Prop：\nxrun\u0026gt; xprop -off // Disable X-Propagation xrun\u0026gt; run 10ns xrun\u0026gt; xprop -on // Enable X-Propagation 结论  FOX模式比CAT模式仿真速度更快，因为FOX模式对x强制传播，无额外判断。 关于发现X bug，使用CAT模式更依赖于输入激励的质量，有可能由于判断逻辑选择值相同而继续被掩盖。 FOX模式更近似于门级仿真的行为。 建议从单元级模块运行X-Prop，待单元级模块清除X-Prop问题，然后在系统级运行X-Prop。 建议先使用CAT模式，将真实的X-Prop问题处理完毕后，再使用FOX模式。  JasperGold 的 X-Propagation 功能 JasperGold X-Prop APP 的功能  检查时钟和复位，以确保无Xs。 检查赋值逻辑，以确保无Xs 检查控制逻辑，以查看Xs可以传播到哪些区域。 检查输出信号，以查看Xs是否可以传播到设计之外。 检查黑盒输入，以查看Xs是否可以传播到黑盒上层模块。 可使用 assume-guarantee 的方法，使对X-Prop问题的证明尽可能收敛。  启动命令 jg -xprop\n待补充 以目前的了解，JasperGold X-Prop是需要工程师选定X源，然后工具为其进行0 1状态遍历，检查输出是否一致，若不一致则证明X传播至设计外部，可能存在设计bug，需要工程师去调试分析。形式化验证工具的好处就是工具自动采用状态空间全遍历的引擎，这对一个设计的完整验证似乎更有保证，防止模拟仿真中测试激励质量的问题而隐藏bug，但是形式化验证更适合单元级模块，较大模块会带来状态空间爆炸的问题，无法证明完全。这里另外说明一下可能的X源，其中最主要的就是输入信号和未复位状态的寄存器，如果选择输入信号作为可能的X源，我想不应该必然会影响设计输出吗？\n至于JasperGold X-Prop对X源的设定和分析，工具如何使用和调试，以及其工作原理，本人并未实际使用过，待通过工程实践后再补充。\n总结 X-Prop问题一直存在，由于现在设计规模越来越大，功耗控制技术越来越复杂，X-Prop问题显得更为重要，从以往的解决办法中，认为准确的代码编写最为有效，而且有工程师为其开发的脚本工具，但是个人认为不能很好的解决悲观问题，不过好在模拟工具都对X-Prop做了很好的支持，我们只要用好工具就能做到事半功倍。\n另外，如有兴趣欢迎详细交流和分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":43,"section":"docs","tags":["Verilog"],"title":"关于X-Propagation问题","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/x-propagation/"},{"content":"本文 主要介绍了我的美食地图，大部分是旅行中亲自品尝并值得推荐的美食，还列为TODO的美食清单。写本帖子的目的是对自己生活的一个美好记录，再有就是为志同道合之人（美食爱好者）提供参考。\n吃的信仰 这里借用一句黑面大叔陈晓卿的名言，那就是“ 最好吃的是人 ”。我十这句话，这就是我关于吃的信仰。这句话的理解要从两方面去理解：\n 所谓美食，并不仅仅是入口那一瞬间带来的精神快感，背后的人文，更耐。 所谓美食，和谁吃远远比吃什么重要的多。  一个真正的美食爱好者，绝不仅仅是满足于入口的这一瞬间。比如我长沙出去的一个牛肉粉馆，虽然吃的是一碗粉，但是会想到材料是什么，做法是什么，当地人喜欢吃扁粉还是圆粉，这个大叔又是做了多少年的粉，一辈子靠粉承担起全家的经济，也许还供养了两个大学生\u0026hellip;\u0026hellip; 如此，从一碗粉，想到材料，想到做法，想到做粉人的生活，耐人寻味，这就是吃背后的人文，这就是所谓最好吃的是人。\n阳记军屯锅盔 阳记军屯锅盔在光华北一街建外SOHO东区9号楼北侧底商，也就是国贸附近了，没想到国贸还有这样的一家小店生存，是一家味道很正的成都小店，老板是一家成都人，比较推荐的是牛肉锅盔和手工酸辣粉。酸辣粉真的是手工制作，有时候你会看到老板在手工打粉，手工粉的区别就是红薯粉成品粗细不一，很弹很滑，但又容易咬断，同时汤的用料又比较猛，味道厚重，麻辣酸爽，真的是很过瘾，如果加一份冒节子，就更美了。再说说锅盔，分牛肉锅盔和猪肉锅盔，锅盔能吃出花椒的麻香和肉香，焦香酥脆，表皮掉渣，配一碗冒节子酸辣粉，真的是绝了，不过油水比较大，热量太高，迫于肥胖的压力，还是偶尔吃一吃比较好。\n  阳记军屯锅盔    延吉餐厅 读了陈晓卿的一篇文章《一个人的面馆》，才知道这家卖朝鲜冷面的延吉餐在延吉餐厅店面挺多，西四北大街有一家，府右街也有一家。下面摘自原文：延吉餐厅的这种面在东北叫黑冷面，用面粉、淀粉加荞麦面混合在一起压制，汤是用葱、姜加酱油外带苹果、梨的汁水一起调成。面出锅先过凉水，再倒入汤，加白醋食用。之所以称为一个人的面馆，还是因为这家朝鲜冷面比较独特，不是人人都喜倒觉得还行，别有一番风味，冷面的汤极其凉，带有果味的酸甜，加上韧劲十足的面条，除了不太好消化，吃起来还是很清爽的。除了冷面，备受人推荐的还有辣牛肉，但是并不便宜，五十多元一小盘，可能类似于辣白菜的做法，能看到较多的辣椒粉粘合在牛肉上，不过我并不喜欢吃，感觉有一些苦涩味，来这里我仅仅是为了这碗冷面而已，另外他家也卖烧烤，没吃过就不评论了。\n  延吉餐厅朝鲜冷面    聚宝源 聚宝源是铜锅涮肉的老字号，牛街是老店，排队排到让你发慌，上午去可能能吃到，我一般去吃花园路店，一般下午五六点去不需要等位。牛街其实就是北京的回民街，有卖牛羊肉的，还有很多回民餐厅，比较有名的是爆肚满，还有洪记小吃，早上有豆泡汤、羊杂汤、糖油饼等等，都是一些传统的老百姓吃食，虽说不上惊艳，但是味道也是不错的，一直听说红烧牛尾不错，但是一直没吃上，关于牛街以后再叙。继续说说聚宝源，聚宝源的铜锅涮肉，最好吃手切羊肉，手切羊肉厚实有嚼劲有口感，聚宝源的肉质比较好，汤中不起浮沫。汤是白水清汤，搭配传统的芝麻酱，配上韭菜花和腐乳汁，个人喜欢再来点辣椒油，不辣但很香。一般点两盘手切羊肉，来个素菜拼盘冻豆腐，配个山楂冻，清爽不油腻，健康又过瘾。聚宝源看家宝是麻酱烧饼，堪称一绝，北京城好真不好找出第二家，芝麻烧饼表皮酥脆，内里绵软松香，没错，重点是绵，再加上特有的香料，能吃出的是孜然的味道，让人流连忘返。说实话，很多人去聚宝源就是为了这口烧饼去的，而我就是其中之一。另外，烧饼是可以外带的，可以多买几个打包分享给家人朋友。\n  聚宝源刷肉    */文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com\n","description":"","id":44,"section":"docs","tags":["美食"],"title":"我的美食地图之北京","uri":"https://www.wenhui.space/docs/03-life/food_map_beijing/"},{"content":"本文 主要介绍了我的美食地图，大部分是旅行中亲自品尝并值得推荐的美食，还列为TODO的美食清单。写本帖子的目的是对自己生活的一个美好记录，再有就是为志同道合之人（美食爱好者）提供参考。\n吃的信仰 这里借用一句黑面大叔陈晓卿的名言，那就是“ 最好吃的是人 ”。我十这句话，这就是我关于吃的信仰。这句话的理解要从两方面去理解：\n 所谓美食，并不仅仅是入口那一瞬间带来的精神快感，背后的人文，更耐。 所谓美食，和谁吃远远比吃什么重要的多。  一个真正的美食爱好者，绝不仅仅是满足于入口的这一瞬间。比如我长沙出去的一个牛肉粉馆，虽然吃的是一碗粉，但是会想到材料是什么，做法是什么，当地人喜欢吃扁粉还是圆粉，这个大叔又是做了多少年的粉，一辈子靠粉承担起全家的经济，也许还供养了两个大学生\u0026hellip;\u0026hellip; 如此，从一碗粉，想到材料，想到做法，想到做粉人的生活，耐人寻味，这就是吃背后的人文，这就是所谓最好吃的是人。\n定家小酥肉 定家小酥肉在大皮院街口，接近广济北街的位置，也就是从鼓楼走向回民街过了西羊市继续直走，到北院门左转进入大皮院路，直行大概五百米（接近北广济街）右手边。这家小酥肉是清真的，牛肉裹面糊，再上锅蒸制，入口绵缠酥软。大概30元左右，满满的一小盆都是牛肉，建议两个人一份肉一个凉菜两碗或一碗米饭就够了。小酥肉肉质很嫩，虽然卖相不太好，但是个人觉得十分美味。不过，写在前头，小酥肉调料味偏重，多胡椒，略偏麻，稍微油腻，如果你是南方人或口味偏轻的女生请慎重尝试，并且服务态度实在不敢恭维。整体来说，褒贬不一吧，不过个人觉得口碑还算不错。贴图如下：\n  定家小酥肉    老米家羊肉泡馍 来到西安，不得不吃的就是羊肉泡馍。西安卖羊肉泡馍的地儿很多很多，不毕竟是旅游城市，如果随意找个地儿吃羊肉泡，又是很容易踩坑的，所以还是建议去回坊。回坊的羊肉泡最出名的是两家，老米家和老孙家，都是不错的。但是回民街无论春夏秋冬，都是摩肩擦踵、人山人海的火热场面，这里推荐一个案板街的老米家羊肉泡馍，清净很多，但是味道也很正宗。案板街离回民街也不远，在钟楼往东，沿着东大街走一二百米路左就是案板街了，走进案板街不远就能看到老米家羊肉泡馍。这里提醒一下，清真场所一定要避免展现非清真的东西。羊肉泡馍的馍是死面馍，半夹生，这样很耐煮，没错，羊肉泡馍就是煮的。一般馍要自己掰，这里不是店家偷懒，而是有意义的。自己掰馍可以掰成喜欢的大小，有人说馍掰的越碎煮着越入味，越好吃，不过个人觉得玉米粒大小刚好，而且，掰馍是一个乐趣，三五好友，放下手机，掰馍聊天，反现代科技的社交方式。听说掰馍时留一口放在碗里，是回民的标志，后厨师傅会给多加片肉，当然这个只是个传说，无从考证，不过有兴趣的可以试一试。羊肉泡一般会配糖蒜和辣椒酱，注意，辣椒酱很咸的，酌量加，糖蒜可以解腻，感觉是最佳搭配。其实一碗羊肉泡还是挺贵的，别听说西安人早上都吃羊肉泡，一碗羊肉泡40元左右，天天吃那得是大户，牛肉泡稍便宜些，但也要30多元，贵虽然贵了点，但味道香的很。回民街深处大皮院路，也有一些泡馍馆，味道也很好，还有小炒泡馍，这里的价格相对外面旅游区就便宜不少，有时间有兴趣的话也可以尝试。下面是贴图：\n  老米家泡馍    */文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com\n","description":"","id":45,"section":"docs","tags":["美食"],"title":"我的美食地图之西安","uri":"https://www.wenhui.space/docs/03-life/food_map_xian/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第八篇，主要介绍一些实验练习中的具体代码解析。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明     MCDF multi-channel data formatter 多通道数据整流器    SV入门练习 基本数据类型  有符号无符号、四状态双状态、枚举类型、结构体   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  module data_type; bit b_signed_vs_unsigned = 1; bit b_bit_vs_logic = 1; bit b_enum_type = 1; bit b_struct_type = 1; // TODO-1: distinguish signed and unsigned type initial begin: signed_vs_unsigned byte b0; bit[7:0] b1; wait(b_signed_vs_unsigned == 1); $display(\u0026#34;signed_vs_unsigned process block started\u0026#34;); b0 = \u0026#39;b1000_0000; $display(\u0026#34;byte variable b0 = %d\u0026#34;, b0); b1 = b0; $display(\u0026#34;bit vector variable b1 = %d\u0026#34;, b1); end // TODO-2: distinguish bit and logic initial begin: bit_vs_logic bit v1; logic v2; wait(b_bit_vs_logic == 1); $display(\u0026#34;bit_vs_logic process block started\u0026#34;); v2 = \u0026#39;b1; $display(\u0026#34;logic variable v2 = %d\u0026#34;, v2); v1 = v2; $display(\u0026#34;bit variable v1 = %d\u0026#34;, v1); v2 = \u0026#39;b0; $display(\u0026#34;logic variable v2 = %d\u0026#34;, v2); v1 = v2; $display(\u0026#34;bit variable v1 = %d\u0026#34;, v1); v2 = \u0026#39;bx; $display(\u0026#34;logic variable v2 = %d\u0026#34;, v2); v1 = v2; $display(\u0026#34;bit variable v1 = %d\u0026#34;, v1); v2 = \u0026#39;bz; $display(\u0026#34;logic variable v2 = %d\u0026#34;, v2); v1 = v2; $display(\u0026#34;bit variable v1 = %d\u0026#34;, v1); end // TODO-3: enum type initial begin: enum_type typedef enum {IDLE, START, PROC, END} state_t; state_t st1, st2; wait(b_enum_type == 1); $display(\u0026#34;enum_type process block started\u0026#34;); st1 = IDLE; $display(\u0026#34;st1 value = %0d (int)\u0026#34;, st1); $display(\u0026#34;st1 value = %s (string)\u0026#34;, st1); // implicit conversion  $display(\u0026#34;st1 value = %s (string)\u0026#34;, st1.name()); st2 = state_t\u0026#39;(1); $display(\u0026#34;st1 value = %0d (int)\u0026#34;, st2); $display(\u0026#34;st1 value = %s (string)\u0026#34;, st2.name()); end // TODO-4: struct type initial begin: struct_type typedef struct { bit[7:0] addr; bit[31:0] data; bit is_write; int id; } trans_t; trans_t t1, t2, t3; wait(b_struct_type == 1); $display(\u0026#34;struct_type process block started\u0026#34;); t1 = \u0026#39;{\u0026#39;h10, \u0026#39;h1122_3344, \u0026#39;b1, \u0026#39;h1000}; $display(\u0026#34;t1 data content is %p\u0026#34;, t1); t2.addr = \u0026#39;h20; t2.data = \u0026#39;h5566_7788; t2.is_write = \u0026#39;b0; t2.id = \u0026#39;h2000; $display(\u0026#34;t2 data content is %p\u0026#34;, t2); t3 = t2; t3.data = \u0026#39;h99AA_BBCC; t3.id = \u0026#39;h3000; $display(\u0026#34;t3 data content is %p\u0026#34;, t3); $display(\u0026#34;t2 data content is %p\u0026#34;, t2); end endmodule   字符串类型  构建字符串和字符串拼接 （一般常用$sformatf函数）   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  module string_type; bit b_string_format = 1; bit b_string_builtin_function = 1; // TODO-1 understand how to formulate a new string initial begin: string_format string s1, s2, s3, s4; wait(b_string_format == 1);$display(\u0026#34;string_format process block started\u0026#34;); s1 = \u0026#34;Welcome\u0026#34;; s2 = \u0026#34;www.rockeric.com\u0026#34;; s3 = {s1, \u0026#34; to \u0026#34;, s2}; // concatenation operator \u0026#39;{...}\u0026#39;  $display(\u0026#34;s3 content: %s\u0026#34;, s3); s4 = $sformatf(\u0026#34;%s to %s\u0026#34;, s1, s2); // system format function  $display(\u0026#34;s4 content: %s\u0026#34;, s4); end // TODO-2 understand how s3 is composed with s1 and s2 initial begin: string_builtin_function string s1, s2, s3; int i1; wait(b_string_builtin_function == 1); $display(\u0026#34;string_builtin_function process block started\u0026#34;); s1 = \u0026#34;RockerIC is established in \u0026#34;; i1 = 2015; s2.itoa(i1); // integer converted to string  s3 = {s1.len()+s2.len(){\u0026#34; \u0026#34;}}; // try to comment this line and check the result  for(int i=0; i\u0026lt;s1.len()+s2.len(); i++) begin s3[i] = i \u0026lt; s1.len() ? s1[i] : s2[i-s1.len()]; end $display(\u0026#34;s3 content: %s\u0026#34;, s3); end endmodule   数组类型  合并非合并、赋值与循环、动态数组、队列、关联数组   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  module array_type; bit b_unpacked_vs_packed = 1; bit b_array_assigment_and_loop = 1; bit b_dynamic_array = 1; bit b_queue_use = 1; bit b_associate_array = 1; // TODO-1 learn the difference between unpacked and packed data storage and // assignment initial begin: unpacked_vs_packed bit [7:0] unpacked_word [3:0]; bit [3:0] [7:0] packed_word; wait(b_unpacked_vs_packed == 1); $display(\u0026#34;unpacked_vs_packed process block started\u0026#34;); // legal assignment  unpacked_word[0] = 10; unpacked_word[1] = 32; unpacked_word[2] = 54; unpacked_word[3] = 76; $display(\u0026#34;unpacked_word = %p\u0026#34;, unpacked_word); // legal assignment with \u0026#39;{}  unpacked_word = \u0026#39;{76, 54, 32, 10}; $display(\u0026#34;unpacked_word = %p\u0026#34;, unpacked_word); // legal assignment  packed_word[0] = 10; packed_word[1] = 32; packed_word[2] = 54; packed_word[3] = 76; $display(\u0026#34;packed_word = %p\u0026#34;, packed_word); // legal assignment with {} but without \u0026#39;  packed_word = {76, 54, 32, 10}; $display(\u0026#34;packed_word = %p\u0026#34;, packed_word); // legal assignment directly like a vector packedt_word[31:0]  packed_word = (76\u0026lt;\u0026lt;24) + (54\u0026lt;\u0026lt;16) + (32\u0026lt;\u0026lt;8) + 10; $display(\u0026#34;packed_word = %p\u0026#34;, packed_word); // illegal assignment  // packed_word = unpacked_word [X]  // unpacked_word = packed_word [X]  // illegal assignment between packed and unpacked array  foreach(packed_word[i]) packed_word[i] = unpacked_word[i]; foreach(unpacked_word[i]) unpacked_word[i] = packed_word[i]; end // TODO-2 learn the array assignment and foreach loop indexing method initial begin: array_assigment_and_loop integer sum [4][2]; // 8*4 size array  wait(b_array_assigment_and_loop == 1); $display(\u0026#34;array_assigment_and_loop process block started\u0026#34;); // concatenation and default value  sum = \u0026#39;{0:\u0026#39;{\u0026#39;h21, \u0026#39;h43}, default:\u0026#39;{default:\u0026#39;x}}; // foreach loop indexing  foreach(sum[i, j]) begin $display(\u0026#34;sum[%0d][%0d] = \u0026#39;h%0x\u0026#34;, i, j, sum[i][j]); end end // TODO-3 learn the dynamic array basics initial begin: dynamic_array int dyn1[], dyn2[]; wait(b_dynamic_array == 1); $display(\u0026#34;dynamic_array process block started\u0026#34;); dyn1 = \u0026#39;{1, 2, 3, 4}; $display(\u0026#34;dyn1 = %p\u0026#34;, dyn1); // copp method option-1  dyn2 = dyn1; $display(\u0026#34;dyn2 = %p\u0026#34;, dyn2); $display(\u0026#34;dyn2 size is %0d\u0026#34;, dyn2.size()); // copp method option-2  dyn2 = new[dyn1.size()](dyn1); $display(\u0026#34;dyn2 = %p\u0026#34;, dyn2); $display(\u0026#34;dyn2 size is %0d\u0026#34;, dyn2.size()); dyn2.delete(); $display(\u0026#34;dyn2 size is %0d\u0026#34;, dyn2.size()); end // TODO-4: learn queue use initial begin: queue_use int que1[$], que2[$]; wait(b_queue_use == 1); $display(\u0026#34;queue_use process block started\u0026#34;); que1 = {10, 30, 40}; $display(\u0026#34;que1 = %p\u0026#34;, que1); que2 = que1; $display(\u0026#34;que2 = %p\u0026#34;, que1); que1.insert(1, 20); $display(\u0026#34;que1 = %p\u0026#34;, que1); que1.delete(3); // delete que1[3]==40  void\u0026#39;(que1.pop_front()); // pop que[0]==10  $display(\u0026#34;que1 = %p\u0026#34;, que1); que1.delete(); $display(\u0026#34;que1 = %p\u0026#34;, que1); end // TODO-5 learn associate array use initial begin: associate_array int id_score1[int], id_score2[int]; // key ID, value SCORE  wait(b_associate_array == 1); $display(\u0026#34;associate_array process block started\u0026#34;); id_score1[101] = 111; id_score1[102] = 222; id_score1[103] = 333; id_score1[104] = 444; id_score1[105] = 555; // associate array copy  id_score2 = id_score1; id_score2[101] = 101; id_score2[102] = 102; id_score2[103] = 103; id_score2[104] = 104; id_score2[105] = 105; foreach(id_score1[id]) begin $display(\u0026#34;id_score1[%0d] = %0d\u0026#34;, id, id_score1[id]); end foreach(id_score2[id]) begin $display(\u0026#34;id_score2[%0d] = %0d\u0026#34;, id, id_score2[id]); end end endmodule   接口的定义与例化  接口里也可以定义方法   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  // TODO-1 understand how the interface is defined and instantied // TODO-2 check how to define methods inside interface and call them internally or externally // TODO-3 understand how to prepare transactions, drive them and monitor them module interface_type; typedef struct { bit[7:0] addr; bit[31:0] data; bit write; int id; } trans_t; // struct print utility function  function void trans_print(trans_t t, string name = \u0026#34;trans\u0026#34;); string s; s = $sformatf(\u0026#34;%s struct content is as below \\n\u0026#34;, name); s = $sformatf(\u0026#34;%s\\taddr = \u0026#39;h%2x \\n\u0026#34;, s, t.addr); s = $sformatf(\u0026#34;%s\\tdata = \u0026#39;h%8x \\n\u0026#34;, s, t.data); s = $sformatf(\u0026#34;%s\\twrite = \u0026#39;b%0b \\n\u0026#34;, s, t.write); s = $sformatf(\u0026#34;%s\\tid = \u0026#39;h%8x \\n\u0026#34;, s, t.id); $display(\u0026#34;%s\u0026#34;, s); endfunction interface intf1; logic [7:0] addr; logic [31:0] data; logic write; int id; // transaction drive task  task drive_trans(trans_t t); addr \u0026lt;= t.addr ; data \u0026lt;= t.data ; write \u0026lt;= t.write; id \u0026lt;= t.id ; endtask // transaction monitor task  task mon_trans(output trans_t t); t.addr = addr ; t.data = data ; t.write = write; t.id = id ; endtask endinterface // interface instantiation  intf1 if1(); initial begin trans_t trans_in[3], trans_mon[3]; // stimulus preparation  trans_in = \u0026#39;{\u0026#39;{\u0026#39;h10, \u0026#39;h1122_3344, \u0026#39;b1, \u0026#39;h1000} ,\u0026#39;{\u0026#39;h14, \u0026#39;h5566_7788, \u0026#39;b0, \u0026#39;h1001} ,\u0026#39;{\u0026#39;h18, \u0026#39;h99AA_BBCC, \u0026#39;b1, \u0026#39;h1002} }; foreach(trans_in[i]) begin #10; // stimulus drive  if1.drive_trans(trans_in[i]); trans_print(trans_in[i], $sformatf(\u0026#34;trans_in[%0d]\u0026#34;,i)); #10; // stimulus monitor  if1.mon_trans(trans_mon[i]); trans_print(trans_mon[i], $sformatf(\u0026#34;trans_mon[%0d]\u0026#34;,i)); // transaction comparison  if(trans_in[i] === trans_mon[i]) $display(\u0026#34;trans_in[%0d] === trans_mon[%0d]\u0026#34;, i, i); else $error(\u0026#34;trans_in[%0d] !== trans_mon[%0d]\u0026#34;, i, i); end end endmodule   类的封装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  module class_encapsulation; bit b_object_instantiation = 1; class chnl_trans; bit[31:0] data[]; int ch_id; int pkt_id; int data_nidles; int pkt_nidles; bit rsp; int obj_id; static int global_obj_id = 0; function new(); global_obj_id++; obj_id = global_obj_id; endfunction function chnl_trans clone(); chnl_trans c = new(); c.data = this.data; c.ch_id = this.ch_id; c.pkt_id = this.pkt_id; c.data_nidles = this.data_nidles; c.pkt_nidles = this.pkt_nidles; c.rsp = this.rsp; return c; endfunction function string sprint(); string s; s = {s, $sformatf(\u0026#34;obj_id = %0d: \\n\u0026#34;, this.obj_id)}; foreach(data[i]) s = {s, $sformatf(\u0026#34;data[%0d] = %8x \\n\u0026#34;, i, this.data[i])}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;rsp = %0d: \\n\u0026#34;, this.rsp)}; return s; endfunction endclass: chnl_trans // TODO-1 learn the object instantiation // TODO-2 learn the handle pointting to an object // TODO-3 learn the class function clone()/sprint() // TODO-4 compare if t1, t2 and t3 are pointting to the same object? // TODO-5 check if the t1 pointted object data is exactly the same with the t3 // pointted object? // TODO-6 learn how to call STATIC member variable/function, and their // difference with local member variable/function initial begin: object_instantiation chnl_trans t1, t2, t3; wait(b_object_instantiation == 1); $display(\u0026#34;b_object_instantiation process block started\u0026#34;); t1 = new(); t1.data = \u0026#39;{1, 2, 3, 4}; t1.ch_id = 2; t1.pkt_id = 100; t2 = t1; $display(\u0026#34;t1 object content is as below:\\n%s\u0026#34;, t1.sprint()); $display(\u0026#34;t2 object content is as below:\\n%s\u0026#34;, t2.sprint()); t3 = t1.clone(); $display(\u0026#34;t3 object content is as below:\\n%s\u0026#34;, t3.sprint()); $display(\u0026#34;t1 object ID is [%0d]\u0026#34;, t1.obj_id); $display(\u0026#34;t2 object ID is [%0d]\u0026#34;, t2.obj_id); $display(\u0026#34;t3 object ID is [%0d]\u0026#34;, t3.obj_id); $display(\u0026#34;the latest chnl_trans object iD is [%0d]\u0026#34;, chnl_trans::global_obj_id); end endmodule   类的继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  module class_inheritance; bit b_member_override = 1; class trans; bit[31:0] data[]; int pkt_id; int data_nidles; int pkt_nidles; bit rsp; function trans clone(trans t = null); if(t == null) t = new(); t.data = data; t.pkt_id = pkt_id; t.data_nidles = data_nidles; t.pkt_nidles = pkt_nidles; t.rsp = rsp; return t; endfunction endclass class chnl_trans extends trans; int ch_id; // new member in child class  // member function override with  // same function name, arguments, and return type  // TODO-1 seperately enable the clone function-1 and function-2, and check  // if both of them works, and compare which is better, and why?  // clone function-1  function trans clone(trans t = null); chnl_trans ct; if(t == null) ct = new(); else void\u0026#39;($cast(ct, t)); ct.data = data; ct.pkt_id = pkt_id; ct.data_nidles = data_nidles; ct.pkt_nidles = pkt_nidles; ct.rsp = rsp; ct.ch_id = ch_id; // new member  return ct; endfunction // clone function-2  // function trans clone(trans t = null);  // chnl_trans ct;  // if(t == null)  // ct = new();  // else  // void\u0026#39;($cast(ct, t));  // void\u0026#39;(super.clone(ct));  // ct.ch_id = ch_id; // new member  // return ct;  // endfunction  endclass initial begin: member_override trans t1, t2; chnl_trans ct1, ct2; wait(b_member_override == 1); $display(\u0026#34;b_member_override process block started\u0026#34;); ct1 = new(); ct1.pkt_id = 200; ct1.ch_id = 2; // t1 pointed to ct1\u0026#39;s trans class data base  t1 = ct1; // t2 copied ct1\u0026#39;s trans class data base  t2 = ct1.clone(); void\u0026#39;($cast(ct2, t2)); // TODO-2 why could not clone t1(-\u0026gt;ct1) to t2?  // t2 = t1.clone(); // ERROR clone call  // void\u0026#39;($cast(ct2, t2));  $display(\u0026#34;ct1.pkt_id = %0d, ct1.ch_id = %0d\u0026#34;, ct1.pkt_id, ct1.ch_id); // TODO-3 uncomment the statement below and consider  // why t1 could not point to ct1.ch_id?  // $display(\u0026#34;ct1.pkt_id = %0d, ct1.ch_id = %0d\u0026#34;, t1.pkt_id, t1.ch_id);  $display(\u0026#34;ct2.pkt_id = %0d, ct2.ch_id = %0d\u0026#34;, ct2.pkt_id, ct2.ch_id); end endmodule   package的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package sky_pkg; class sun; typedef enum {RISE, FALL} state_e; state_e state = RISE; endclass sun apollo = new(); class cloud; endclass endpackage package sea_pkg; class fish; endclass class island; string name; function new(string name = \u0026#34;island\u0026#34;); this.name = name; endfunction endclass island hainan = new(\u0026#34;hainan\u0026#34;); endpackage module package_usage; import sky_pkg::cloud; import sea_pkg::*; import sea_pkg::hainan; // TODO-2 why hainan could not be delcared here?  // island hainan;  initial begin // TODO-1 why sun type is not recognized? how to make it recognizable?  // sun s;  // TODO-2 why hainan could be declared here?  island hainan; // TODO-3 why apollo is not recognized?  // $display(\u0026#34;sun state is %s\u0026#34;, apollo.state);  hainan = new(\u0026#34;HAINAN\u0026#34;); $display(\u0026#34;hainan name is %s\u0026#34;, hainan.name); $display(\u0026#34;sea_pkg::hainan name is %s\u0026#34;, sea_pkg::hainan.name); end endmodule   随机约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  module constrained_random; bit b_system_random_func = 1; bit b_class_randomization = 1; // TODO-1 understand how to use system random function, and its advanced // method such as to generate unique values initial begin: system_random_func int unsigned rval; int unsigned gen_vals[$]; wait(b_system_random_func == 1); $display(\u0026#34;b_system_random_func process block started\u0026#34;); // randomize 10 times, and each rand value doesnot care previous generated  // value  repeat(10) begin rval = $urandom_range(0, 9); $display(\u0026#34;$urandom_range(0, 9) generated rand value is %0d\u0026#34;, rval); end // Do you have other ways to generate unique number each time which should  // not be duplicated with previously generate ones?  repeat(10) begin $display(\u0026#34;gen_vals queue content is %p\u0026#34;, gen_vals); std::randomize(rval) with {foreach(gen_vals[i]) rval != gen_vals[i]; rval inside {[0:9]};}; gen_vals.push_back(rval); $display(\u0026#34;std::randomize with inline constrait generated rand value %0d\u0026#34;, rval); end end class chnl_trans; rand bit[31:0] data[]; rand int ch_id; rand int pkt_id; rand int data_nidles; rand int pkt_nidles; bit rsp; constraint cstr{ data.size inside {[4:8]}; foreach(data[i]) data[i] == \u0026#39;hC000_0000 + (this.ch_id\u0026lt;\u0026lt;24) + (this.pkt_id\u0026lt;\u0026lt;8) + i; ch_id == 1; pkt_id == 1; data_nidles inside {[0:2]}; pkt_nidles inside {[1:10]}; }; endclass // TODO-2 learn basic constraint format, class randomization method, soft // constraint, and how to avolid constraint conflict? initial begin: class_randomization chnl_trans ct1, ct2; wait(b_class_randomization == 1); $display(\u0026#34;b_class_randomization process block started\u0026#34;); ct1 = new(); // is ct1 already randomized?  $display(\u0026#34;ct1.data.size = %0d, ct1.ch_id = %0d, ct1.pkt_id = %0d\u0026#34;, ct1.data.size(), ct1.ch_id, ct1.pkt_id); ct2 = new(); // is ct2 already randomized?  $display(\u0026#34;ct2.data.size = %0d, ct2.ch_id = %0d, ct2.pkt_id = %0d\u0026#34;, ct2.data.size(), ct2.ch_id, ct2.pkt_id); // why ct2.ch_id and ct2.pkt_id kept the same number even though it has been  // randomized several times?  repeat(5) begin void\u0026#39;(ct2.randomize()); $display(\u0026#34;ct2.data.size = %0d, ct2.ch_id = %0d, ct2.pkt_id = %0d\u0026#34;, ct2.data.size(), ct2.ch_id, ct2.pkt_id); end // the randomization with inline constraint would meets randomization  // failure, how to modify?  // if(!ct1.randomize() with {ch_id == 2;})  // $error(\u0026#34;ct1 randomization failure!\u0026#34;);  // else  // $display(\u0026#34;ct1.data.size = %0d, ct1.ch_id = %0d, ct1.pkt_id = %0d\u0026#34;, ct1.data.size(), ct1.ch_id, ct1.pkt_id); end endmodule   线程的同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  module thread_sync; bit b_event_use = 0; bit b_mailbox_use = 1; bit b_mailbox_user_define = 1; // TODO-1.1 event does not new() // TODO-1.2 learn event copy (direct assignment between two events) // TODO-1.3 compare @ operator and triggered() method initial begin: event_use event e1, e2, e3a, e3b; wait(b_event_use == 1); $display(\u0026#34;b_event_use process block started\u0026#34;); e3b = e3a; // event copy, e3b and e3a are the same event  -\u0026gt;e1; // trigger e1 before @e1;  -\u0026gt;e2; // trigger e2 before e2.triggered();  fork begin @e1; $display(\u0026#34;@%0t, @e1 finished\u0026#34; , $time); end begin wait(e2.triggered()); $display(\u0026#34;@%0t, wait(e2.triggered()) finished\u0026#34; , $time); end begin @e3a; $display(\u0026#34;@%0t, @e3a finished\u0026#34;, $time); end begin @e3b; $display(\u0026#34;@%0t, @e3b finished\u0026#34;, $time); end join_none #10ns; -\u0026gt; e3a; #10ns; -\u0026gt; e1; // trigger e1 again end class box; int id; function new(int id); this.id = id; endfunction endclass // TODO-2 learn the parameterized mailbox and general storage method initial begin: mailbox_use mailbox #(int) mb_id; mailbox #(box) mb_handle; box bx[5]; wait(b_mailbox_use == 1); $display(\u0026#34;b_mailbox_use process block started\u0026#34;); // mailbox need new(N) for instantiation  mb_id = new(); mb_handle = new(); // mailbox storage  foreach(bx[i]) begin bx[i] = new(i); mb_id.put(i); mb_handle.put(bx[i]); end $display(\u0026#34;box handles array bx content is %p\u0026#34;, bx); // mailbox extraction  $display(\u0026#34;extracting ID and HANDLE from the TWO mailboxes\u0026#34;); repeat(mb_id.num()) begin int id; box handle; mb_id.get(id); mb_handle.get(handle); $display(\u0026#34;ID:%0d, HANDLE:%p\u0026#34;, id, handle); end // check mailbox size  $display(\u0026#34;ID mailbox size is %0d\u0026#34;, mb_id.num()); $display(\u0026#34;HANDLE mailbox size is %0d\u0026#34;, mb_handle.num()); end // TODO-3 learn how to maximal utilize the mailbox storage with user defined // type, we modify the \u0026#39;mailbox_use\u0026#39; block and give a new block // \u0026#39;mailbox_user_define\u0026#39; typedef struct{ int id; box handle; } mb_pair_element_t; initial begin: mailbox_user_define mailbox #(mb_pair_element_t) mb_pair; box bx[5]; wait(b_mailbox_user_define == 1); $display(\u0026#34;b_mailbox_user_define process block started\u0026#34;); // mailbox need new(N) for instantiation  mb_pair = new(); // mailbox storage  foreach(bx[i]) begin bx[i] = new(i); mb_pair.put(\u0026#39;{i, bx[i]}); end $display(\u0026#34;box handles array bx content is %p\u0026#34;, bx); // mailbox extraction  $display(\u0026#34;extracting ID and HANDLE from the ONE mailbox\u0026#34;); repeat(mb_pair.num()) begin mb_pair_element_t pair; mb_pair.get(pair); $display(\u0026#34;ID:%0d, HANDLE:%p\u0026#34;, pair.id, pair.handle); end // check mailbox size  $display(\u0026#34;PAIR mailbox size is %0d\u0026#34;, mb_pair.num); end endmodule   线程的控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  module thread_control; bit b_fork_join = 1; bit b_fork_join_any = 0; bit b_fork_join_none = 0; class box; int id; function new(int id); this.id = id; endfunction endclass box bx[3]; task automatic thread(int id = 1, int t = 10); $display(\u0026#34;@%0t, thread id:%0d entered\u0026#34;, $time, id); bx[id] = new(id); // allocate space  #(t*1ns); bx[id] = null; // deallocate space  $display(\u0026#34;@%0t, thread id:%0d exited\u0026#34;, $time, id); endtask // TODO-1 learn fork-join thread exited when all sub-thread exit. initial begin: fork_join wait(b_fork_join == 1); $display(\u0026#34;b_fork_join process block started\u0026#34;); bx = \u0026#39;{null, null, null}; $display(\u0026#34;@%0t, fork_join_thread entered\u0026#34;, $time); fork: fork_join_thread thread(0, 10); thread(1, 20); thread(2, 30); join $display(\u0026#34;@%0t, fork_join_thread exited\u0026#34;, $time); $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); #10; b_fork_join = 0; b_fork_join_any = 1; end // TODO-2.1 learn fork-join_any thread exited when just one sub-thread exites, // but all other sub-thread are still running. // TODO-2.2 learn disable BLOCK/fork statement, and check if the running // sub-threads haven been disabled. initial begin: fork_join_any wait(b_fork_join_any == 1); $display(\u0026#34;b_fork_join_any process block started\u0026#34;); bx = \u0026#39;{null, null, null}; $display(\u0026#34;@%0t, fork_join_any_thread entered\u0026#34;, $time); fork: fork_join_any_thread thread(0, 10); thread(1, 20); thread(2, 30); join_any $display(\u0026#34;@%0t, fork_join_any_thread exited\u0026#34;, $time); $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); disable fork_join_any_thread; $display(\u0026#34;@%0t, disabled fork_join_any_thread\u0026#34;, $time); #100ns; $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); #10ns; b_fork_join_any = 0; b_fork_join_none = 1; end // TODO-3.1 learn fork-join_none thread exited directly without calling any // sub-thread, and continue executing other statements. Then the // fork-join_none sub-threads would be still running. // TODO-3.2 learn the wait fork statement, and check the time after it is // satisified. The time should be the point when all fork sub-thread finished. initial begin: fork_join_none wait(b_fork_join_none == 1); $display(\u0026#34;b_fork_join_none process block started\u0026#34;); bx = \u0026#39;{null, null, null}; $display(\u0026#34;@%0t, fork_join_none_thread entered\u0026#34;, $time); fork: fork_join_none_thread thread(0, 10); thread(1, 20); thread(2, 30); join_none $display(\u0026#34;@%0t, fork_join_none_thread exited\u0026#34;, $time); $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); #15ns; $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); wait fork; $display(\u0026#34;@%0t, fork_join_none_thread\u0026#39;s all sub-threads finished\u0026#34;, $time); $display(\u0026#34;@%0t, box handles array is %p\u0026#34;, $time, bx); end endmodule   虚方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  // This example is referred to the lec2/class_inheritance // The purpose is to learn the convenience of virtual method module virtual_methods; class trans; bit[31:0] data[]; int pkt_id; int data_nidles; int pkt_nidles; bit rsp; virtual function trans clone(trans t = null); if(t == null) t = new(); t.data = data; t.pkt_id = pkt_id; t.data_nidles = data_nidles; t.pkt_nidles = pkt_nidles; t.rsp = rsp; return t; endfunction endclass class chnl_trans extends trans; int ch_id; // new member in child class  virtual function trans clone(trans t = null); chnl_trans ct; if(t == null) ct = new(); else void\u0026#39;($cast(ct, t)); void\u0026#39;(super.clone(ct)); ct.ch_id = ch_id; // new member  return ct; endfunction endclass initial begin trans t1, t2; chnl_trans ct1, ct2; ct1 = new(); ct1.pkt_id = 200; ct1.ch_id = 2; // t1 pointed to ct1\u0026#39;s trans class data base  t1 = ct1; $display(\u0026#34;before cloning ct1 object\u0026#34;); $display(\u0026#34;ct1.pkt_id = %0d, ct1.ch_id = %0d\u0026#34;, ct1.pkt_id, ct1.ch_id); // TODO-1 compare with lec2/class_inheritance TODO-2  // why it is legal to call t1.clone() here?  // TODO-2 via this example, please summarize the virtual method  // convenience  t2 = t1.clone(); void\u0026#39;($cast(ct2, t2)); // TODO-3 to access ct2.ch_id, could we directly use t2.ch_id?  // is it possible to add modified virtual before chnl_trans::ch_id, and  // then access it by \u0026#39;t2.ch_id\u0026#39;? and why?  $display(\u0026#34;after cloning ct1 object\u0026#34;); $display(\u0026#34;ct1.pkt_id = %0d, ct1.ch_id = %0d\u0026#34;, ct1.pkt_id, ct1.ch_id); $display(\u0026#34;ct2.pkt_id = %0d, ct2.ch_id = %0d\u0026#34;, ct2.pkt_id, ct2.ch_id); end endmodule   方法（任务与函数） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  module task_and_function; bit b_function_define = 1; bit b_task_define = 1; bit b_inout_vs_ref = 1; function int double_f0(int a); return 2*a; endfunction function void double_f1(input int a, output int b); b = 2*a; endfunction function void double_f2(inout int a); a = 2*a; endfunction function automatic void double_f3(ref int a); a = 2*a; endfunction task double_t1(input int a, output int b); b = 2*a; endtask task double_t2(inout int a); a = 2*a; endtask task automatic double_t3(ref int a); a = 2*a; endtask task double_t2_delay(inout int a); a = 2*a; #10ns; endtask task automatic double_t3_delay(ref int a); a = 2*a; #10ns; endtask // TODO-1 lear the function definition possible ways initial begin: function_define int v1, v2; wait(b_function_define == 1); $display(\u0026#34;b_function_define process block started\u0026#34;); v1 = 10; v2 = double_f0(v1); $display(\u0026#34;v1 = %0d, double function result is %0d\u0026#34;, v1, v2); v1 = 10; double_f1(v1, v2); $display(\u0026#34;v1 = %0d, double function result is %0d\u0026#34;, v1, v2); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_f2(v1)\u0026#34;, v1); double_f2(v1); $display(\u0026#34;v1 is %0d (result) after calling double_f2(v1)\u0026#34;, v1); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_f3(v1)\u0026#34;, v1); double_f3(v1); $display(\u0026#34;v1 is %0d (result) after calling double_f3(v1)\u0026#34;, v1); end // TODO-2 learn the task definition possible ways initial begin: task_define int v1, v2; wait(b_task_define == 1); $display(\u0026#34;b_task_define process block started\u0026#34;); v1 = 10; double_t1(v1, v2); $display(\u0026#34;v1 = %0d, double task result is %0d\u0026#34;, v1, v2); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_t2(v1)\u0026#34;, v1); double_t2(v1); $display(\u0026#34;v1 is %0d (result) after calling double_t2(v1)\u0026#34;, v1); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_t3(v1)\u0026#34;, v1); double_t3(v1); $display(\u0026#34;v1 is %0d (result) after calling double_t3(v1)\u0026#34;, v1); end // TODO-3 compare the inout and ref argument between function and task use initial begin: inout_vs_ref int v1, v2; wait(b_inout_vs_ref == 1); $display(\u0026#34;b_inout_vs_ref process block started\u0026#34;); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_t2_delay(v1)\u0026#34;, v1); fork double_t2_delay(v1); begin #5ns; $display(\u0026#34;@%0t v1 = %0d in task call double_t2_delay(v1)\u0026#34;, $time, v1); end join $display(\u0026#34;v1 is %0d (result) after calling double_t2_delay(v1)\u0026#34;, v1); v1 = 10; $display(\u0026#34;v1 is %0d before calling double_t3_delay(v1)\u0026#34;, v1); fork double_t3_delay(v1); begin #5ns; $display(\u0026#34;@%0t v1 = %0d in task call double_t3_delay(v1)\u0026#34;, $time, v1); end join $display(\u0026#34;v1 is %0d (result) after calling double_t3_delay(v1)\u0026#34;, v1); end endmodule   SV用于设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  module sv_for_design; bit b_always_compare = 1; bit b_compare_operator = 1; bit b_inside_operator = 1; bit b_case_statement = 1; // TODO-1 why l2 != l3 at time 0 ? logic l1 = 0, l2, l3; always @(l1) l2 \u0026lt;= l1; always_comb l3 = l1; initial begin: always_compare wait(b_always_compare == 1); $display(\u0026#34;always_compare process block started\u0026#34;); #0; $display(\u0026#34;@%0t, l2 = %b\u0026#34;, $time, l2); $display(\u0026#34;@%0t, l3 = %b\u0026#34;, $time, l3); #10; l1 \u0026lt;= 1; #1; $display(\u0026#34;@%0t, l2 = %b\u0026#34;, $time, l2); $display(\u0026#34;@%0t, l3 = %b\u0026#34;, $time, l3); end // TODO-2 learn the compare operators\u0026#39; difference initial begin: compare_operator logic [3:0] v1, v2; wait(b_compare_operator == 1); $display(\u0026#34;compare_operator process block started\u0026#34;); v1 = \u0026#39;b111x; v2 = \u0026#39;b1110; if(v1 != v2) // binary logical equality operator  $display(\u0026#34;v1 %b != v2 %b\u0026#34;, v1, v2); else $display(\u0026#34;v1 %b == v2 %b\u0026#34;, v1, v2); $display(\u0026#34;the operator result (v1 != v2) is %b\u0026#34;, (v1 != v2)); if(v1 !== v2) // binary case equality operator  $display(\u0026#34;v1 %b !== v2 %b\u0026#34;, v1, v2); else $display(\u0026#34;v1 %b === v2 %b\u0026#34;, v1, v2); $display(\u0026#34;the operator result (v1 !== v2) is %b\u0026#34;, (v1 !== v2)); end // TODO-3 learn the inside operator initial begin: inside_operator bit [2:0] v1; wait(b_inside_operator == 1); $display(\u0026#34;inside_operator process block started\u0026#34;); v1 = \u0026#39;b100; if(v1 == \u0026#39;b100 || v1 == \u0026#39;b010 || v1 == \u0026#39;b001) $display(\u0026#34;v1: %0b meets onehot vector requirement!\u0026#34;, v1); else $display(\u0026#34;v1: %0b does not meet onehot vector requirement!\u0026#34;, v1); if(v1 inside {\u0026#39;b100, \u0026#39;b010, \u0026#39;b001}) $display(\u0026#34;v1: %0b meets onehot vector requirement!\u0026#34;, v1); else $display(\u0026#34;v1: %0b does not meet onehot vector requirement!\u0026#34;, v1); if($onehot(v1) == 1) $display(\u0026#34;v1: %0b meets onehot vector requirement!\u0026#34;, v1); else $display(\u0026#34;v1: %0b does not meet onehot vector requirement!\u0026#34;, v1); end // TODO-4 learn {unique, priority} case{ ,x, z} statement initial begin: case_statement parameter width_p = 4; bit [width_p-1:0] v_arr[3]; wait(b_case_statement == 1); $display(\u0026#34;case_statement process block started\u0026#34;); v_arr = \u0026#39;{\u0026#39;b1000, \u0026#39;b1111, \u0026#39;b0110}; foreach(v_arr[i]) begin unique case(v_arr[i]) \u0026#39;b0001, \u0026#39;b0010, \u0026#39;b0100, \u0026#39;b1000: $display(\u0026#34;v1: %0b meets onehot vector requirement!\u0026#34;, v_arr[i]); 0: $display(\u0026#34;v1: %0b is ZERO\u0026#34;, v_arr[i]); \u0026#39;b1111: $display(\u0026#34;v1: %0b is ALL ONES\u0026#34;, v_arr[i]); default: $display(\u0026#34;v1: %0b has [2~%0d] ones\u0026#34;, v_arr[i], width_p-1); endcase end end endmodule   SV进阶练习 设计描述 所有SV练习都是针对硬件设计MCDF进行的， 在这里介绍一下它的结构、功能、寄存器和时序。\n该设计我们称之为多通道数据整形器(MCDF， multi-channel data formatter) ， 它可以将上行(uplink) 多个通道数据经过内部的FIFO，最终以数据包(data packet) 的形式送出。由于上行数据和下行数据的接口协议不同，我们也将在后面的接口描述和时序部分进一步讲解。此外，多通道数据整形器也有寄存器的读写接口，可以支持更多的控制功能。\n  MCDF结构      从上图的MCDF结构来看主要可以分为如下几个部分 ：\n 上行数据的通道从端(Channel Slave) ， 负责接收上行数据， 并且存储到其FIFO中。 仲裁器(Arbiter) 可以选择从不同的FIFO中读取数据， 进而将数据进一步传送至整形器(formatter) 。 整形器(Formatter) 将数据按照一定的接口时序送出至下行接收端。 控制寄存器(Control Registers) 有专用的寄存器读写接口， 负责接收命令并且对MCDF的功能做出修改。    接口描述 ：\n  系统信号接口\n   信号名 位宽 方向 说明     clk [0] I 时钟信号   RSTN [0] I 复位信号，低有效    通道从端接口 ：\n   信号名 位宽 方向 说明     CHx_DATA [31:0] I 通道数据输入（x为0/1/2）   CHx_VALID [0] I 通道数据有效标志，高有效   CHx_READY [0] O 通道数据接收信号，高位表示接收成功    整形器接口 ：\n   信号名 位宽 方向 说明     FMT_CHID [1:0] O 整形数据包的通道ID号   FMT_LENGTH [4:0] O 整形数据包的长度信号   FMT_REQ [0] O 整形数据包发送请求   FMT_GRANT [0] I 整形数据包被允许发送的标志   FMT_DATA [31:0] O 数据输出端口   FMT_START [0] O 数据包起始标志   FMT_END [0] O 数据包结束标志    控制寄存器接口 ：\n   信号名 位宽 方向 说明     CMD [1:0] I 寄存器读写命令   CMD_ADDR [7:0] I 寄存器地址   CMD_DATA_IN [31:0] I 寄存器输入端口   CMD_DATA_OUT [31:0] O 寄存器输出端口     接口时序 ：  通道从端接口时序\n  通道从端接口时序    当valid为高时，表示要写入数据。如果该时钟周期ready为高，则表示已经将数据写入；如果该时钟周期ready为低，则需要等到ready为高的时钟周期才可以将数据写入。\n整形器接口时序 ：\n  整形器接口时序    整形器发送数据是按照数据包的形式发送的，可以选择数据包的长度有4、8、16和32。整形器必须完整发送某一个通道的数据包后， 才可以转而准备发送下一个数据包， 在发送数据包期间， fmt_chid和fmt_length应该保持不变， 直到数据包发送完毕。\n在整形器准备发送数据包时， 首先应该将fmt_req置为高， 同时等待接收端的fmt_grant。当fmt_grant变为高时， 应该在下一个周期将fmt_req置为低。fmt_start也必须在接收到fmt_grant高有效的下一个时钟被置为高， 且需要维持一个时钟周期。在fmt_start被置为高有效的同一个周期，数据也开始传送，数据之间不允许有空闲周期，即应该连续发送数据，直到发送完最后一个数据时， fm_tend也应当被置为高并保持一个时钟周期。\n相邻的数据包之间应该至少有一个时钟周期的空闲，即fmt_end从高位拉低后，至少需要经过一个时钟周期，fmt_req才可以被再次置为高。\n控制寄存器接口时序 ：\n  整形器接口时序    在控制寄存器接口上， 需要在每一个时钟解析cmd。当cmd为写指令时， 需要把数据cmd_data_in写入到cmd_addr对应的寄存器中； 当cmd为读指令时， 即需要从cmd_addr对应的寄存器中读取数据， 并在下一个周期， 将数据驱动至cmd_data_out接口。\n 寄存器描述 ：  地址 0x00 通道0控制寄存器32bits读写寄存器\n   位 功能     bit(0) 通道使能信号。1为打开， 0位关闭。复位值为1。   bit(2：1) 优先级。0为最高， 3为最低。复位值为3。   bit(5：3) 数据包长度， 解码对应表为， 0对应长度4，1对应长度8，2对应长度16，3对应长度32，其它数值(4-7)均暂时对应长度32。复位值为0。   bit(31：6) 保留位， 无法写入。复位值为0。    地址 0x04 通道1控制寄存器32bits读写寄存器\n同通道0控制寄存器描述。\n地址0x08通道2控制寄存器32bits读写寄存器\n同通道0控制寄存器描述。\n地址0x10通道0状态寄存器32bits只读寄存器\n   位 功能     bit(7：0) 上行数据从端FIFO的可写余量， 同FIFO的数据余量保持同步变化。复位值为FIFO的深度数   bit(31：8) 保留位，复位值为0    地址0x14通道1状态寄存器32bits只读寄存器\n同通道0状态寄存器描述。\n地址0x18通道2状态寄存器32bits只读寄存器\n同通道0状态寄存器描述。\n 简化版MCDF ：  在了解了MCDF的设计之后，我们接下来的几次实验将首先围绕着MCDF中的子模块channel和arbiter的组合MCDT着手， 暂时不考虑formatter的数据打包功能和寄存器的配置作用。因此我们所选择的MCDF的“片段”MCDT即由三个slave channel和一个arbiter构成。从之前介绍的各个模块功能来看， 这个组合的作用类似于一个高级的“MUX”多路选择器， 只不过这个选择器的无需外部的选择配置， 而是会根据slave channel的数据发起请求来做选择授权， 继而将数据送出。\n  MCDT结构    lab1   从verilog到SV的进场 ：\n 将下面是tb1.v的代码，将文件名修改为tb1.sv后，编译仿真，查看仿真行为是否同tb1.v的仿真行为一致?这说明了什么呢? 将tb1.sv中的信号变量类型由reg或者wire修改为logic类型， 再编译仿真，查看行为是否同修改之前的一致呢?这是为什么?  3）在步骤2) 的基础上， 如果将rstn的类型由logic修改为bit类型，再编译仿真， 行为是否同步骤2)的一致呢?这是为什么?\n   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  `timescale 1ns/1ps module tb1; reg clk; reg rstn; reg [31:0] ch0_data; reg ch0_valid; wire ch0_ready; wire [ 5:0] ch0_margin; reg [31:0] ch1_data; reg ch1_valid; wire ch1_ready; wire [ 5:0] ch1_margin; reg [31:0] ch2_data; reg ch2_valid; wire ch2_ready; wire [ 5:0] ch2_margin; wire [31:0] mcdt_data; wire mcdt_val; wire [ 1:0] mcdt_id; mcdt dut( .clk_i(clk) ,.rstn_i(rstn) ,.ch0_data_i(ch0_data) ,.ch0_valid_i(ch0_valid) ,.ch0_ready_o(ch0_ready) ,.ch0_margin_o(ch0_margin) ,.ch1_data_i(ch1_data) ,.ch1_valid_i(ch1_valid) ,.ch1_ready_o(ch1_ready) ,.ch1_margin_o(ch1_margin) ,.ch2_data_i(ch2_data) ,.ch2_valid_i(ch2_valid) ,.ch2_ready_o(ch2_ready) ,.ch2_margin_o(ch2_margin) ,.mcdt_data_o(mcdt_data) ,.mcdt_val_o(mcdt_val) ,.mcdt_id_o(mcdt_id) ); // clock generation initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end // data test initial begin @(posedge rstn); repeat(5) @(posedge clk); // channel 0 test  chnl_write(0, \u0026#39;h00C0_0000); chnl_write(0, \u0026#39;h00C0_0001); chnl_write(0, \u0026#39;h00C0_0002); chnl_write(0, \u0026#39;h00C0_0003); chnl_write(0, \u0026#39;h00C0_0004); chnl_write(0, \u0026#39;h00C0_0005); chnl_write(0, \u0026#39;h00C0_0006); chnl_write(0, \u0026#39;h00C0_0007); chnl_write(0, \u0026#39;h00C0_0008); chnl_write(0, \u0026#39;h00C0_0009); // channel 1 test  chnl_write(1, \u0026#39;h00C1_0000); chnl_write(1, \u0026#39;h00C1_0001); chnl_write(1, \u0026#39;h00C1_0002); chnl_write(1, \u0026#39;h00C1_0003); chnl_write(1, \u0026#39;h00C1_0004); chnl_write(1, \u0026#39;h00C1_0005); chnl_write(1, \u0026#39;h00C1_0006); chnl_write(1, \u0026#39;h00C1_0007); chnl_write(1, \u0026#39;h00C1_0008); chnl_write(1, \u0026#39;h00C1_0009); // channel 2 test  chnl_write(2, \u0026#39;h00C2_0000); chnl_write(2, \u0026#39;h00C2_0001); chnl_write(2, \u0026#39;h00C2_0002); chnl_write(2, \u0026#39;h00C2_0003); chnl_write(2, \u0026#39;h00C2_0004); chnl_write(2, \u0026#39;h00C2_0005); chnl_write(2, \u0026#39;h00C2_0006); chnl_write(2, \u0026#39;h00C2_0007); chnl_write(2, \u0026#39;h00C2_0008); chnl_write(2, \u0026#39;h00C2_0009); end // channel write task task chnl_write(input reg[1:0] id, input reg[31:0] data); case(id) 0: begin @(posedge clk); ch0_valid \u0026lt;= 1; ch0_data \u0026lt;= data; @(posedge clk); ch0_valid \u0026lt;= 0; ch0_data \u0026lt;= 0; end 1: begin @(posedge clk); ch1_valid \u0026lt;= 1; ch1_data \u0026lt;= data; @(posedge clk); ch1_valid \u0026lt;= 0; ch1_data \u0026lt;= 0; end 2: begin @(posedge clk); ch2_valid \u0026lt;= 1; ch2_data \u0026lt;= data; @(posedge clk); ch2_valid \u0026lt;= 0; ch2_data \u0026lt;= 0; end default: $error(\u0026#34;channel id %0d is invalid\u0026#34;, id); endcase endtask endmodule    方法task和函数function ：  在tb2.sv文件中， 可以看到不同于tb1.sv文件的是，之前产生时钟和发起复位的两个inital过程块语句都被两个task（即clk_gen和rstn_gen）取代了。 在两个intal块中分别调用产生时钟和复位的task，再编译仿真查看时钟信号和复位信号，是否正常? 为什么要将两个task在两个initial块中调用?这是为什么呢?是否可以在一个initial块中调用呢?如果可以，调用它们的顺序是什么? 是否可以读出目前时钟的周期和频率呢?该如何测量呢?如果我们想改进clk_gen()方法， 使其变为可以设置时钟周期的任务clk_gen(int peroid)， 那么该怎么修改目前的任务clk_gen()呢? 修改成功后，请在initial块中调用任务ck_gen(20)，看看波形中的时钟周期是否变为20ns呢? 如果将`timescale 1ns/1ps修改为`timescale 1ps/1ps， 那么仿真中的时钟周期是否发生变化?这是为什么呢?     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  `timescale 1ns/1ps module tb2_ref; logic clk; logic rstn; logic [31:0] ch0_data; logic ch0_valid; logic ch0_ready; logic [ 5:0] ch0_margin; logic [31:0] ch1_data; logic ch1_valid; logic ch1_ready; logic [ 5:0] ch1_margin; logic [31:0] ch2_data; logic ch2_valid; logic ch2_ready; logic [ 5:0] ch2_margin; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i(clk) ,.rstn_i(rstn) ,.ch0_data_i(ch0_data) ,.ch0_valid_i(ch0_valid) ,.ch0_ready_o(ch0_ready) ,.ch0_margin_o(ch0_margin) ,.ch1_data_i(ch1_data) ,.ch1_valid_i(ch1_valid) ,.ch1_ready_o(ch1_ready) ,.ch1_margin_o(ch1_margin) ,.ch2_data_i(ch2_data) ,.ch2_valid_i(ch2_valid) ,.ch2_ready_o(ch2_ready) ,.ch2_margin_o(ch2_margin) ,.mcdt_data_o(mcdt_data) ,.mcdt_val_o(mcdt_val) ,.mcdt_id_o(mcdt_id) ); // clock generation // TODO:: please create task clk_gen(int peroid) task clk_gen(); clk \u0026lt;= 0; forever begin #5 clk\u0026lt;= !clk; end endtask initial begin // generate clk  clk_gen(); end // reset trigger // create task rstn_gen() task rstn_gen(); #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; endtask initial begin // trigger rstn  rstn_gen(); end // data test initial begin @(posedge rstn); repeat(5) @(posedge clk); // channel 0 test  chnl_write(0, \u0026#39;h00C0_0000); chnl_write(0, \u0026#39;h00C0_0001); chnl_write(0, \u0026#39;h00C0_0002); chnl_write(0, \u0026#39;h00C0_0003); chnl_write(0, \u0026#39;h00C0_0004); chnl_write(0, \u0026#39;h00C0_0005); chnl_write(0, \u0026#39;h00C0_0006); chnl_write(0, \u0026#39;h00C0_0007); chnl_write(0, \u0026#39;h00C0_0008); chnl_write(0, \u0026#39;h00C0_0009); // channel 1 test  chnl_write(1, \u0026#39;h00C1_0000); chnl_write(1, \u0026#39;h00C1_0001); chnl_write(1, \u0026#39;h00C1_0002); chnl_write(1, \u0026#39;h00C1_0003); chnl_write(1, \u0026#39;h00C1_0004); chnl_write(1, \u0026#39;h00C1_0005); chnl_write(1, \u0026#39;h00C1_0006); chnl_write(1, \u0026#39;h00C1_0007); chnl_write(1, \u0026#39;h00C1_0008); chnl_write(1, \u0026#39;h00C1_0009); // channel 2 test  chnl_write(2, \u0026#39;h00C2_0000); chnl_write(2, \u0026#39;h00C2_0001); chnl_write(2, \u0026#39;h00C2_0002); chnl_write(2, \u0026#39;h00C2_0003); chnl_write(2, \u0026#39;h00C2_0004); chnl_write(2, \u0026#39;h00C2_0005); chnl_write(2, \u0026#39;h00C2_0006); chnl_write(2, \u0026#39;h00C2_0007); chnl_write(2, \u0026#39;h00C2_0008); chnl_write(2, \u0026#39;h00C2_0009); end // channel write task task chnl_write(input reg[1:0] id, input reg[31:0] data); case(id) 0: begin @(posedge clk); ch0_valid \u0026lt;= 1; ch0_data \u0026lt;= data; @(posedge clk); ch0_valid \u0026lt;= 0; ch0_data \u0026lt;= 0; end 1: begin @(posedge clk); ch1_valid \u0026lt;= 1; ch1_data \u0026lt;= data; @(posedge clk); ch1_valid \u0026lt;= 0; ch1_data \u0026lt;= 0; end 2: begin @(posedge clk); ch2_valid \u0026lt;= 1; ch2_data \u0026lt;= data; @(posedge clk); ch2_valid \u0026lt;= 0; ch2_data \u0026lt;= 0; end default: $error(\u0026#34;channel id %0d is invalid\u0026#34;, id); endcase endtask endmodule    数组的使用 :  如果要求对每一个slave的数据发出100个数， 那么该怎么实现呢? 如果现在要先生成100个数，并对它们按照目前的数值规则进行赋值，那么请创建3个动态数组， 分别放置要发送给3个slave的数据。 接下来利用之前生成的数组数据， 将它们读取并发送给三个channel。     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  `timescale 1ns/1ps module tb3_ref; logic clk; logic rstn; logic [31:0] ch0_data; logic ch0_valid; logic ch0_ready; logic [ 5:0] ch0_margin; logic [31:0] ch1_data; logic ch1_valid; logic ch1_ready; logic [ 5:0] ch1_margin; logic [31:0] ch2_data; logic ch2_valid; logic ch2_ready; logic [ 5:0] ch2_margin; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i(clk) ,.rstn_i(rstn) ,.ch0_data_i(ch0_data) ,.ch0_valid_i(ch0_valid) ,.ch0_ready_o(ch0_ready) ,.ch0_margin_o(ch0_margin) ,.ch1_data_i(ch1_data) ,.ch1_valid_i(ch1_valid) ,.ch1_ready_o(ch1_ready) ,.ch1_margin_o(ch1_margin) ,.ch2_data_i(ch2_data) ,.ch2_valid_i(ch2_valid) ,.ch2_ready_o(ch2_ready) ,.ch2_margin_o(ch2_margin) ,.mcdt_data_o(mcdt_data) ,.mcdt_val_o(mcdt_val) ,.mcdt_id_o(mcdt_id) ); // clock generation initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end logic [31:0] chnl0_arr[]; logic [31:0] chnl1_arr[]; logic [31:0] chnl2_arr[]; // USER TODO // generate 100 data for each dynamic array initial begin chnl0_arr = new[100]; chnl1_arr = new[100]; chnl2_arr = new[100]; foreach(chnl0_arr[i]) begin chnl0_arr[i] = \u0026#39;h00C0_00000 + i; chnl1_arr[i] = \u0026#39;h00C1_00000 + i; chnl2_arr[i] = \u0026#39;h00C2_00000 + i; end end // USER TODO // use the dynamic array, user would send all of data // data test initial begin @(posedge rstn); repeat(5) @(posedge clk); // channel 0 test  // TODO use chnl0_arr to send all data  foreach(chnl0_arr[i]) chnl_write(0, chnl0_arr[i]); // channel 1 test  // TODO use chnl1_arr to send all data  foreach(chnl1_arr[i]) chnl_write(1, chnl1_arr[i]); // channel 2 test  // TODO use chnl2_arr to send all data  foreach(chnl2_arr[i]) chnl_write(2, chnl2_arr[i]); end // channel write task task chnl_write(input reg[1:0] id, input reg[31:0] data); case(id) 0: begin @(posedge clk); ch0_valid \u0026lt;= 1; ch0_data \u0026lt;= data; @(posedge clk); ch0_valid \u0026lt;= 0; ch0_data \u0026lt;= 0; end 1: begin @(posedge clk); ch1_valid \u0026lt;= 1; ch1_data \u0026lt;= data; @(posedge clk); ch1_valid \u0026lt;= 0; ch1_data \u0026lt;= 0; end 2: begin @(posedge clk); ch2_valid \u0026lt;= 1; ch2_data \u0026lt;= data; @(posedge clk); ch2_valid \u0026lt;= 0; ch2_data \u0026lt;= 0; end default: $error(\u0026#34;channel id %0d is invalid\u0026#34;, id); endcase endtask endmodule    验证结构 ：  为了实现清晰的验证结构，我们希望将DUT和激励发生器（stimulator）之间划分。因此，我们可以将激励方法chnl_write()封装在新的模块chnl_initiator中。\n从tb4.sv中可以发现之前的inital语句块channel_write_task已经不见了，在其位置上的变为了三个例化的chnl_initiator实例chnl0_init、chnl1_init和chnl2_init。它们的作用扮演每个channel slave通道对应的stimulator，发送激励，因此我们在其模块chnl_initiator中定义了它的三个方法， 即set_name() 、chnl_write() 和chnl_idle() 。\n chnl_ixle() 要实现一个时钟周期的空闲，在该周期中，ch_valid应为低，ch_data应为0。 chn_write() 要实现一次有效的写数据， 并随后调用chnl_idle()， 实现一个空闲周期，在实现有效写数据时，请考虑如何使用ch_ready信号，结合功能描述的channel slave接口时序来看， 只有当valid为高且ready为高时，数据写入才算成功，如果此时ready为低，那么则应该保持数据和valid信号，直到ready拉高时，数据写入才算成功。 set_name()即设置实例的名称， 在inital过程块“data test”中， 在发送各个channel数据前， 请设置各个channel initiator的实例名称， 这样方便在仿真时各个实例的打印信息可以显示它们各自的名称、数据发送时间和数据内容，便于阅读和调试。 最后，进入了本次实验的最后一个步骤了，之所以提出发送更多的数据，并且发送更紧凑高速的数据， 是为了可以观察到，是否你的三个channel_slave各自的chX_ready信号可以拉低呢？如果拉低了，这代表着什么？那么请你试试看，考虑如何发送更多更快的数据，让M CDT的三个chX_ready信号可以拉低吧。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167  `timescale 1ns/1ps module chnl_initiator( input clk, input rstn, output logic [31:0] ch_data, output logic ch_valid, input ch_ready, input [ 5:0] ch_margin ); string name; function void set_name(string s); name = s; endfunction task chnl_write(input logic[31:0] data); // USER TODO  // drive valid data  // ...  @(posedge clk); ch_valid \u0026lt;= 1; ch_data \u0026lt;= data; @(negedge clk); wait(ch_ready === \u0026#39;b1); $display(\u0026#34;%t channel initial [%s] sent data %x\u0026#34;, $time, name, data); chnl_idle(); endtask task chnl_idle(); // USER TODO  // drive idle data  // ...  @(posedge clk); ch_valid \u0026lt;= 0; ch_data \u0026lt;= 0; endtask endmodule module tb4_ref; logic clk; logic rstn; logic [31:0] ch0_data; logic ch0_valid; logic ch0_ready; logic [ 5:0] ch0_margin; logic [31:0] ch1_data; logic ch1_valid; logic ch1_ready; logic [ 5:0] ch1_margin; logic [31:0] ch2_data; logic ch2_valid; logic ch2_ready; logic [ 5:0] ch2_margin; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i(clk) ,.rstn_i(rstn) ,.ch0_data_i(ch0_data) ,.ch0_valid_i(ch0_valid) ,.ch0_ready_o(ch0_ready) ,.ch0_margin_o(ch0_margin) ,.ch1_data_i(ch1_data) ,.ch1_valid_i(ch1_valid) ,.ch1_ready_o(ch1_ready) ,.ch1_margin_o(ch1_margin) ,.ch2_data_i(ch2_data) ,.ch2_valid_i(ch2_valid) ,.ch2_ready_o(ch2_ready) ,.ch2_margin_o(ch2_margin) ,.mcdt_data_o(mcdt_data) ,.mcdt_val_o(mcdt_val) ,.mcdt_id_o(mcdt_id) ); // clock generation initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end logic [31:0] chnl0_arr[]; logic [31:0] chnl1_arr[]; logic [31:0] chnl2_arr[]; // USER TODO // generate 100 data for each dynamic array initial begin chnl0_arr = new[100]; chnl1_arr = new[100]; chnl2_arr = new[100]; foreach(chnl0_arr[i]) begin chnl0_arr[i] = \u0026#39;h00C0_00000 + i; chnl1_arr[i] = \u0026#39;h00C1_00000 + i; chnl2_arr[i] = \u0026#39;h00C2_00000 + i; end end // USER TODO // use the dynamic array, user would send all of data // data test initial begin @(posedge rstn); repeat(5) @(posedge clk); // USER TODO  // Give unique names to each channel initiator  // ...  chnl0_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl1_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl2_init.set_name(\u0026#34;chnl0_init\u0026#34;); // channel 0 test  // TODO use chnl0_arr to send all data  foreach(chnl0_arr[i]) chnl0_init.chnl_write(chnl0_arr[i]); // channel 1 test  // TODO use chnl1_arr to send all data  foreach(chnl1_arr[i]) chnl1_init.chnl_write(chnl1_arr[i]); // channel 2 test  // TODO use chnl2_arr to send all data  foreach(chnl2_arr[i]) chnl2_init.chnl_write(chnl2_arr[i]); end chnl_initiator chnl0_init( .clk (clk), .rstn (rstn), .ch_data (ch0_data), .ch_valid (ch0_valid), .ch_ready (ch0_ready), .ch_margin(ch0_margin) ); chnl_initiator chnl1_init( .clk (clk), .rstn (rstn), .ch_data (ch1_data), .ch_valid (ch1_valid), .ch_ready (ch1_ready), .ch_margin(ch1_margin) ); chnl_initiator chnl2_init( .clk (clk), .rstn (rstn), .ch_data (ch2_data), .ch_valid (ch2_valid), .ch_ready (ch2_ready), .ch_margin(ch2_margin) ); endmodule   lab2 练习2部分将主要回顾之前接口、仿真结束、类和包的使用，在这一个练习中，将逐渐从使用硬件盒子(module)验证过渡到使用接口和软件盒子(class) 来验证设计。而这一个练习之所以重要也是因为它是硬件验证方式与软件验证方式之间的过渡，同时作为验证环境的启蒙。在本练习的最后一个小节中也能够初步体会到类的继承和层次包含关系，而这些都将作为日后学习高阶UVM知识的重要基础。\n 接口的使用 ：  在lab2的tb1.sv的代码部分承接的是上一次实验的最后代码部分，不过最显著的差别在于，我们将验证组件和DUT之间通过接口来连接，所以验证组件chnl_initiator的端口变得非常*干净”， 即chnl_intf intf。在使用接口之前我们需要定义接口chnl_intf和内部的端口，同时我们也声明了一个时钟块(clocking block) ， 它的功能是为了消除可能存在的竞争(race) 问题，确保时钟驱动数据之间有一定的延迟， 以便于DUT顺利采样。\n因此更新后的代码， 可以发现例化的实例包括了只产生数据的channel generator， 只负责发送数据的channel_initiator以及作为验证组件和DUT之间的接口chnl intf。而例化之后，在inital块中需要通过调用组件的方法完成初始化、名字设置和空闲周期的设置。这里初始化是为了设置ID，名字设置是为了稍后打印时容易区分各个组件，而空闲周期的设置则关系到我们接下来的实验要求：\n 首先观察波形，可以发现channel_initiator发送的数据例如valid和data与时钟clk均在同一个变化沿，没有任何延迟。同我们课程中所讲到的，这种0延迟的数据发送不利于波形查看和阅读， 因此请在已有代码的基础上使用intf.ck的方式来做数据举动，并且再观察波形，查看驱动的数据与时钟上升沿的延迟是多少。 为了更好地控制相邻数据之间的空闲间隔，又引入了一个变量idle_cycles，它表示相邻有效数据之间的间隔。已有代码会使得有效数据之间保持固定的一个空闲周期，需要使用idle_cycles变量，来灵活控制有效数据之间的空闲周期。通过这个方法，在tb的initial块中 通过方法set_idle_cycles()使得三个channel_initiator的空闲周期变为0， 即可以实现有效数据的连续发送。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface module chnl_initiator(chnl_intf intf); string name; int idle_cycles = 1; function automatic void set_idle_cycles(int n); idle_cycles = n; endfunction function automatic void set_name(string s); name = s; endfunction task automatic chnl_write(input logic[31:0] data); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= data; @(negedge intf.clk); wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%t channel initiator [%s] sent data %x\u0026#34;, $time, name, data); // USER TODO 1.2  // Apply variable idle_cycles and decide how many idle cycles to be  // inserted between two sequential data  repeat(idle_cycles) chnl_idle(); endtask task automatic chnl_idle(); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endmodule module chnl_generator; int chnl_arr[$]; int num; int id; function automatic void initialize(int n); id = n; num = 0; endfunction function automatic int get_data(); int data; data = \u0026#39;h00C0_0000 + (id\u0026lt;\u0026lt;16) + num; num++; chnl_arr.push_back(data); return data; endfunction endmodule module tb1_ref; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end initial begin // verification component initializationi  chnl0_gen.initialize(0); chnl1_gen.initialize(1); chnl2_gen.initialize(2); chnl0_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl1_init.set_name(\u0026#34;chnl1_init\u0026#34;); chnl2_init.set_name(\u0026#34;chnl2_init\u0026#34;); chnl0_init.set_idle_cycles(0); chnl1_init.set_idle_cycles(0); chnl2_init.set_idle_cycles(0); end initial begin @(posedge rstn); repeat(5) @(posedge clk); repeat(100) begin chnl0_init.chnl_write(chnl0_gen.get_data()); end chnl0_init.chnl_idle(); end initial begin @(posedge rstn); repeat(5) @(posedge clk); repeat(100) begin chnl1_init.chnl_write(chnl1_gen.get_data()); end chnl1_init.chnl_idle(); end initial begin @(posedge rstn); repeat(5) @(posedge clk); repeat(100) begin chnl2_init.chnl_write(chnl2_gen.get_data()); end chnl2_init.chnl_idle(); end chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_initiator chnl0_init(chnl0_if); chnl_initiator chnl1_init(chnl1_if); chnl_initiator chnl2_init(chnl2_if); chnl_generator chnl0_gen(); chnl_generator chnl1_gen(); chnl_generator chnl2_gen(); endmodule    仿真的结束 ：  tb2.sv中需要课外学习fork join的基本功能和使用方法，了解它的并行运行特性，以此此来区分不同的测试内容，这是由于每一个测试任务的测试目的和要求都不相同，具体要求可以来实现三个chnl_initiator同时发送数据的要求。同时我们又将不同的test也组装到task中，以在代码中查找tb2.sv需要首先移植tb1.sv的要求内容，接下来再完成新的实验要求。\n 可以参考task basic_test()， 来完成burst_test()，它的要求是使得每个chnl_initiator的idle_cycles设置为0，同时发送500个数据， 最后结束测试。 参考task basic_test()来完成task fifo_full_test() 。它的要求是无论采取什么数值的idle_cycles，也无论发送多少个数据，只要各个chnl_initiator的不停发送使得对应的channel缓存变为满标志(ready拉低)，那么可以在三个channel都拉低过ready时(不必要同时拉低，先后拉低即可)，便可以立即结束测试。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface module chnl_initiator(chnl_intf intf); string name; int idle_cycles = 1; function automatic void set_idle_cycles(int n); idle_cycles = n; endfunction function automatic void set_name(string s); name = s; endfunction task automatic chnl_write(input logic[31:0] data); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= data; @(negedge intf.clk); wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%t channel initiator [%s] sent data %x\u0026#34;, $time, name, data); // USER TODO 1.2  // Apply variable idle_cycles and decide how many idle cycles to be  // inserted between two sequential data  repeat(idle_cycles) chnl_idle(); endtask task automatic chnl_idle(); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endmodule module chnl_generator; int chnl_arr[$]; int num; int id; function automatic void initialize(int n); id = n; num = 0; endfunction function automatic int get_data(); int data; data = \u0026#39;h00C0_0000 + (id\u0026lt;\u0026lt;16) + num; num++; chnl_arr.push_back(data); return data; endfunction endmodule module tb2_ref; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end initial begin basic_test(); burst_test(); fifo_full_test(); $display(\u0026#34;*****************all of tests have been finished********************\u0026#34;); $finish(); end // each channel send data with idle_cycles inside [1:3]  // each channel send out 200 data  // then to finish the test  task automatic basic_test(); // verification component initializationi  chnl0_gen.initialize(0); chnl1_gen.initialize(1); chnl2_gen.initialize(2); chnl0_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl1_init.set_name(\u0026#34;chnl1_init\u0026#34;); chnl2_init.set_name(\u0026#34;chnl2_init\u0026#34;); chnl0_init.set_idle_cycles($urandom_range(1, 3)); chnl1_init.set_idle_cycles($urandom_range(1, 3)); chnl2_init.set_idle_cycles($urandom_range(1, 3)); $display(\u0026#34;basic_test initialized components\u0026#34;); wait (rstn === 1\u0026#39;b1); repeat(5) @(posedge clk); $display(\u0026#34;basic_test started testing DUT\u0026#34;); // Please check the SV book for fork-join basic knowledge  // and get understood it is for parallel thread running  fork repeat(100) chnl0_init.chnl_write(chnl0_gen.get_data()); repeat(100) chnl1_init.chnl_write(chnl1_gen.get_data()); repeat(100) chnl2_init.chnl_write(chnl2_gen.get_data()); join fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;basic_test finished testing DUT\u0026#34;); endtask // USER TODO 2.1  // each channel send data with idle_cycles == 0  // each channel send out 500 data  // then to finish the test  task automatic burst_test(); // verification component initializationi  chnl0_gen.initialize(0); chnl1_gen.initialize(1); chnl2_gen.initialize(2); chnl0_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl1_init.set_name(\u0026#34;chnl1_init\u0026#34;); chnl2_init.set_name(\u0026#34;chnl2_init\u0026#34;); chnl0_init.set_idle_cycles(0); chnl1_init.set_idle_cycles(0); chnl2_init.set_idle_cycles(0); $display(\u0026#34;basic_test initialized components\u0026#34;); wait (rstn === 1\u0026#39;b1); repeat(5) @(posedge clk); $display(\u0026#34;basic_test started testing DUT\u0026#34;); // Please check the SV book for fork-join basic knowledge  // and get understood it is for parallel thread running  fork begin repeat(500) chnl0_init.chnl_write(chnl0_gen.get_data()); chnl0_init.chnl_idle(); end begin repeat(500) chnl1_init.chnl_write(chnl1_gen.get_data()); chnl1_init.chnl_idle(); end begin repeat(500) chnl2_init.chnl_write(chnl2_gen.get_data()); chnl2_init.chnl_idle(); end join fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;basic_test finished testing DUT\u0026#34;); endtask // USER TODO 2.2  // The test should be immediately finished when all of channels  // have been reached fifo full state, but not all reaching  // fifo full at the same time  task automatic fifo_full_test(); // verification component initializationi  chnl0_gen.initialize(0); chnl1_gen.initialize(1); chnl2_gen.initialize(2); chnl0_init.set_name(\u0026#34;chnl0_init\u0026#34;); chnl1_init.set_name(\u0026#34;chnl1_init\u0026#34;); chnl2_init.set_name(\u0026#34;chnl2_init\u0026#34;); chnl0_init.set_idle_cycles(0); chnl1_init.set_idle_cycles(0); chnl2_init.set_idle_cycles(0); $display(\u0026#34;fifo_full_test started testing DUT\u0026#34;); fork: fork_all_run forever chnl0_init.chnl_write(chnl0_gen.get_data()); forever chnl1_init.chnl_write(chnl1_gen.get_data()); forever chnl2_init.chnl_write(chnl2_gen.get_data()); join_none $display(\u0026#34;fifo_full_test: 3 initiators running now\u0026#34;); $display(\u0026#34;fifo_full_test: waiting 3 channel fifos to be full\u0026#34;); fork wait(chnl0_init.intf.ch_margin == 0); wait(chnl1_init.intf.ch_margin == 0); wait(chnl2_init.intf.ch_margin == 0); join $display(\u0026#34;fifo_full_test: 3 channel fifos have reached full\u0026#34;); $display(\u0026#34;fifo_full_test: stop 3 initiators running\u0026#34;); disable fork_all_run; $display(\u0026#34;fifo_full_test: set and ensure all agents\u0026#39; initiator are idle state\u0026#34;); fork chnl0_init.chnl_idle(); chnl1_init.chnl_idle(); chnl2_init.chnl_idle(); join $display(\u0026#34;fifo_full_test waiting DUT transfering all of data\u0026#34;); fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;fifo_full_test: 3 channel fifos have transferred all data\u0026#34;); $display(\u0026#34;fifo_full_test finished testing DUT\u0026#34;); endtask chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_initiator chnl0_init(chnl0_if); chnl_initiator chnl1_init(chnl1_if); chnl_initiator chnl2_init(chnl2_if); chnl_generator chnl0_gen(); chnl_generator chnl1_gen(); chnl_generator chnl2_gen(); endmodule    类的例化和类的成员 ：  在这一部分， 将之前用来封装验证功能的硬件盒子(module) 中的数据和内容移植到软件盒子(class) 中来，以通过前后代码的相同点和不同点来比较使用类的时候，需要注意什么地方，同时也可以基本掌握类的例化，类的成员变量访问权限以及类的成员方法如何定义和使用。\n 在将module chnl_initiator和module chnl_generator分别改造为class chnl_initiator和class chnl_generator后，可以发现我们同时定义了一个用来封装发送数据的类chnl_trans。要求需要在inital块中分别例化3个已经声明过的chnl_initiator和3个chnl_generator。 由于每一个chnl_initiator都需要使用接口chnl_intf来发送数据，在发送数据之前我们需要确保chnl_initiator中的接口不是悬空的，即需要由外部被传递。所以接下来的实验要求需要通过调用chnl_initiator的方法来完成接口的传递。 接下来就可以调用已经定义过的三个test任务来展开测试了。 最后是关于类的例化问题，请欢察chnl_generator在例化chnl_trans t 时，有没有不恰当的地方，如果有请指出来现有的代码会造成什么样的潜在问题呢?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface class chnl_trans; int data; int id; int num; endclass class chnl_initiator; local string name; local int idle_cycles; virtual chnl_intf intf; function new(string name = \u0026#34;chnl_initiator\u0026#34;); this.name = name; this.idle_cycles = 1; endfunction function void set_idle_cycles(int n); this.idle_cycles = n; endfunction function void set_name(string s); this.name = s; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task chnl_write(input chnl_trans t); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= t.data; @(negedge intf.clk); wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%t channel initiator [%s] sent data %x\u0026#34;, $time, name, t.data); // USER TODO 1.2  // Apply variable idle_cycles and decide how many idle cycles to be  // inserted between two sequential data  repeat(this.idle_cycles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endclass // USER TODO 3.4 // check if the object use is correct? class chnl_generator; chnl_trans trans[$]; int num; int id; chnl_trans t; function new(int n); this.id = n; this.num = 0; endfunction function chnl_trans get_trans(); t = new(); t.data = \u0026#39;h00C0_0000 + (this.id\u0026lt;\u0026lt;16) + this.num; t.id = this.id; t.num = this.num; this.num++; this.trans.push_back(t); return t; endfunction endclass module tb3_ref; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_initiator chnl0_init; chnl_initiator chnl1_init; chnl_initiator chnl2_init; chnl_generator chnl0_gen; chnl_generator chnl1_gen; chnl_generator chnl2_gen; initial begin // USER TODO 3.1  // instantiate the components chn0/1/2_init chnl0/1/2_gen  chnl0_init = new(\u0026#34;chnl0_init\u0026#34;); chnl1_init = new(\u0026#34;chnl1_init\u0026#34;); chnl2_init = new(\u0026#34;chnl2_init\u0026#34;); chnl0_gen = new(0); chnl1_gen = new(1); chnl2_gen = new(2); // USER TODO 3.2  // assign the interface handle to each chnl_initiator objects  chnl0_init.set_interface(chnl0_if); chnl1_init.set_interface(chnl1_if); chnl2_init.set_interface(chnl2_if); // USER TODO 3.3  // START TESTs  $display(\u0026#34;*****************all of tests have been finished********************\u0026#34;); basic_test(); burst_test(); fifo_full_test(); $finish(); end // each channel send data with idle_cycles inside [1:3]  // each channel send out 200 data  // then to finish the test  task automatic basic_test(); chnl0_init.set_idle_cycles($urandom_range(1, 3)); chnl1_init.set_idle_cycles($urandom_range(1, 3)); chnl2_init.set_idle_cycles($urandom_range(1, 3)); $display(\u0026#34;basic_test initialized components\u0026#34;); wait (rstn === 1\u0026#39;b1); repeat(5) @(posedge clk); $display(\u0026#34;basic_test started testing DUT\u0026#34;); // Please check the SV book for fork-join basic knowledge  // and get understood it is for parallel thread running  fork repeat(100) chnl0_init.chnl_write(chnl0_gen.get_trans()); repeat(100) chnl1_init.chnl_write(chnl1_gen.get_trans()); repeat(100) chnl2_init.chnl_write(chnl2_gen.get_trans()); join fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;basic_test finished testing DUT\u0026#34;); endtask // USER TODO 2.1  // each channel send data with idle_cycles == 0  // each channel send out 500 data  // then to finish the test  task automatic burst_test(); chnl0_init.set_idle_cycles(0); chnl1_init.set_idle_cycles(0); chnl2_init.set_idle_cycles(0); $display(\u0026#34;basic_test initialized components\u0026#34;); wait (rstn === 1\u0026#39;b1); repeat(5) @(posedge clk); $display(\u0026#34;basic_test started testing DUT\u0026#34;); // Please check the SV book for fork-join basic knowledge  // and get understood it is for parallel thread running  fork begin repeat(500) chnl0_init.chnl_write(chnl0_gen.get_trans()); chnl0_init.chnl_idle(); end begin repeat(500) chnl1_init.chnl_write(chnl1_gen.get_trans()); chnl1_init.chnl_idle(); end begin repeat(500) chnl2_init.chnl_write(chnl2_gen.get_trans()); chnl2_init.chnl_idle(); end join fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;basic_test finished testing DUT\u0026#34;); endtask // USER TODO 2.2  // The test should be immediately finished when all of channels  // have been reached fifo full state, but not all reaching  // fifo full at the same time  task automatic fifo_full_test(); chnl0_init.set_idle_cycles(0); chnl1_init.set_idle_cycles(0); chnl2_init.set_idle_cycles(0); $display(\u0026#34;fifo_full_test started testing DUT\u0026#34;); fork: fork_all_run forever chnl0_init.chnl_write(chnl0_gen.get_trans()); forever chnl1_init.chnl_write(chnl1_gen.get_trans()); forever chnl2_init.chnl_write(chnl2_gen.get_trans()); join_none $display(\u0026#34;fifo_full_test: 3 initiators running now\u0026#34;); $display(\u0026#34;fifo_full_test: waiting 3 channel fifos to be full\u0026#34;); fork wait(chnl0_init.intf.ch_margin == 0); wait(chnl1_init.intf.ch_margin == 0); wait(chnl2_init.intf.ch_margin == 0); join $display(\u0026#34;fifo_full_test: 3 channel fifos have reached full\u0026#34;); $display(\u0026#34;fifo_full_test: stop 3 initiators running\u0026#34;); disable fork_all_run; $display(\u0026#34;fifo_full_test: set and ensure all agents\u0026#39; initiator are idle state\u0026#34;); fork chnl0_init.chnl_idle(); chnl1_init.chnl_idle(); chnl2_init.chnl_idle(); join $display(\u0026#34;fifo_full_test waiting DUT transfering all of data\u0026#34;); fork wait(chnl0_init.intf.ch_margin == \u0026#39;h20); wait(chnl1_init.intf.ch_margin == \u0026#39;h20); wait(chnl2_init.intf.ch_margin == \u0026#39;h20); join $display(\u0026#34;fifo_full_test: 3 channel fifos have transferred all data\u0026#34;); $display(\u0026#34;fifo_full_test finished testing DUT\u0026#34;); endtask endmodule    包的定义和类的继承 ：  到了tb4.sv，又进一步引入了新的类chnl_agent、chnl_root_test、chnl_basic_test、chnl_burst_test和chnl_fifo_full_test，同时将所有的类（都是与chanel相关的验证组件类)，封装到专门包裹软件类的容器package chnl_pkg中且完成编译。因此编译后的chnl_pkg会被默认编译到work库中，与其它的module是一同并列放置的。\n关于chnl_agent，将它作为一个标准组件单元，它应该包括generator、driver(initiator)和monitor。在tb4.sv中，在tb4.sv中暂时只有chn_generater和chnl_initiator，因此将它们在agent中例化。同时，将之前用task来实现的测试任务也由类来实现。可以发现，父类是chnl_root_test，而我们已经先移植了chnl_basic_test，接下来需要实现另外两个类。\n 由于将各个类首先封装在了package chnl_pkg中，因此在module tb4中要声明类的句柄，首先应该从chnl_pkg中引入其中定义的类。 可以参考之前已经实现的burst_test()和fifo_full_test()任务，以及已经实现的类chnl_basic_test，按照同样的要求来实现两个新的类chn_burst_test和chnl_fifo_full_test。 例化已经声明过的三个test组件。 完成从test一层的接口传递任务，使得其内部各个组件都可以得到需要的接口。 调用各个test的方法，展开测试。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface package chnl_pkg; class chnl_trans; int data; int id; int num; endclass: chnl_trans class chnl_initiator; local string name; local int idle_cycles; local virtual chnl_intf intf; function new(string name = \u0026#34;chnl_initiator\u0026#34;); this.name = name; this.idle_cycles = 1; endfunction function void set_idle_cycles(int n); this.idle_cycles = n; endfunction function void set_name(string s); this.name = s; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task chnl_write(input chnl_trans t); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= t.data; @(negedge intf.clk); wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%t channel initiator [%s] sent data %x\u0026#34;, $time, name, t.data); // USER TODO 1.2  // Apply variable idle_cycles and decide how many idle cycles to be  // inserted between two sequential data  repeat(this.idle_cycles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); // USER TODO 1.1  // Please use the clocking drv_ck of chnl_intf to drive data  intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endclass: chnl_initiator class chnl_generator; chnl_trans trans[$]; int num; int id; function new(int n); this.id = n; this.num = 0; endfunction function chnl_trans get_trans(); chnl_trans t = new(); t.data = \u0026#39;h00C0_0000 + (this.id\u0026lt;\u0026lt;16) + this.num; t.id = this.id; t.num = this.num; this.num++; this.trans.push_back(t); return t; endfunction endclass: chnl_generator class chnl_agent; chnl_generator gen; chnl_initiator init; local int ntrans; virtual chnl_intf vif; function new(string name = \u0026#34;chnl_agent\u0026#34;, int id = 0, int ntrans = 1); this.gen = new(id); this.init = new(name); this.ntrans = ntrans; endfunction function void set_ntrans(int n); this.ntrans = n; endfunction function void set_interface(virtual chnl_intf vif); this.vif = vif; init.set_interface(vif); endfunction task run(); repeat(this.ntrans) this.init.chnl_write(this.gen.get_trans()); this.init.chnl_idle(); // set idle after all data sent out  endtask endclass: chnl_agent class chnl_root_test; chnl_agent agent[3]; protected string name; function new(int ntrans = 100, string name = \u0026#34;chnl_root_test\u0026#34;); foreach(agent[i]) begin this.agent[i] = new($sformatf(\u0026#34;chnl_agent%0d\u0026#34;,i), i, ntrans); end this.name = name; $display(\u0026#34;%s instantiate objects\u0026#34;, this.name); endfunction task run(); $display(\u0026#34;%s started testing DUT\u0026#34;, this.name); fork agent[0].run(); agent[1].run(); agent[2].run(); join $display(\u0026#34;%s waiting DUT transfering all of data\u0026#34;, this.name); fork wait(agent[0].vif.ch_margin == \u0026#39;h20); wait(agent[1].vif.ch_margin == \u0026#39;h20); wait(agent[2].vif.ch_margin == \u0026#39;h20); join $display(\u0026#34;%s: 3 channel fifos have transferred all data\u0026#34;, this.name); $display(\u0026#34;%s finished testing DUT\u0026#34;, this.name); endtask function void set_interface(virtual chnl_intf ch0_vif, virtual chnl_intf ch1_vif, virtual chnl_intf ch2_vif); agent[0].set_interface(ch0_vif); agent[1].set_interface(ch1_vif); agent[2].set_interface(ch2_vif); endfunction endclass // each channel send data with idle_cycles inside [1:3]  // each channel send out 200 data  // then to finish the test  class chnl_basic_test extends chnl_root_test; function new(int ntrans = 200, string name = \u0026#34;chnl_basic_test\u0026#34;); super.new(ntrans, name); foreach(agent[i]) begin this.agent[i].init.set_idle_cycles($urandom_range(1, 3)); end $display(\u0026#34;%s configured objects\u0026#34;, this.name); endfunction endclass: chnl_basic_test // USER TODO 4.2  // Refer to chnl_basic_test, and extend another 2 tests  // chnl_burst_test, chnl_fifo_full_test  // each channel send data with idle_cycles == 0  // each channel send out 500 data  // then to finish the test  class chnl_burst_test extends chnl_root_test; //USER TODO  function new(int ntrans = 500, string name = \u0026#34;chnl_burst_test\u0026#34;); super.new(ntrans, name); foreach(agent[i]) begin this.agent[i].init.set_idle_cycles(0); end $display(\u0026#34;%s configured objects\u0026#34;, this.name); endfunction endclass: chnl_burst_test // USER TODO 4.2  // The test should be immediately finished when all of channels  // have been reached fifo full state, but not all reaching  // fifo full at the same time  class chnl_fifo_full_test extends chnl_root_test; // USER TODO  function new(int ntrans = 1_000_000, string name = \u0026#34;chnl_fifo_full_test\u0026#34;); super.new(ntrans, name); foreach(agent[i]) begin this.agent[i].init.set_idle_cycles(0); end $display(\u0026#34;%s configured objects\u0026#34;, this.name); endfunction task run(); $display(\u0026#34;%s started testing DUT\u0026#34;, this.name); fork: fork_all_run agent[0].run(); agent[1].run(); agent[2].run(); join_none $display(\u0026#34;%s: 3 agents running now\u0026#34;, this.name); $display(\u0026#34;%s: waiting 3 channel fifos to be full\u0026#34;, this.name); fork wait(agent[0].vif.ch_margin == 0); wait(agent[1].vif.ch_margin == 0); wait(agent[2].vif.ch_margin == 0); join $display(\u0026#34;%s: 3 channel fifos have reached full\u0026#34;, this.name); $display(\u0026#34;%s: stop 3 agents running\u0026#34;, this.name); disable fork_all_run; $display(\u0026#34;%s: set and ensure all agents\u0026#39; initiator are idle state\u0026#34;, this.name); fork agent[0].init.chnl_idle(); agent[1].init.chnl_idle(); agent[2].init.chnl_idle(); join $display(\u0026#34;%s waiting DUT transfering all of data\u0026#34;, this.name); fork wait(agent[0].vif.ch_margin == \u0026#39;h20); wait(agent[1].vif.ch_margin == \u0026#39;h20); wait(agent[2].vif.ch_margin == \u0026#39;h20); join $display(\u0026#34;%s: 3 channel fifos have transferred all data\u0026#34;, this.name); $display(\u0026#34;%s finished testing DUT\u0026#34;, this.name); endtask endclass: chnl_fifo_full_test endpackage: chnl_pkg module tb4_ref; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end // USER TODO 4.1  // import defined class from chnl_pkg  import chnl_pkg::*; chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_basic_test basic_test; chnl_burst_test burst_test; chnl_fifo_full_test fifo_full_test; initial begin basic_test = new(); burst_test = new(); fifo_full_test = new(); // USER TODO 4.4  // assign the interface handle to each chnl_initiator objects  basic_test.set_interface(chnl0_if, chnl1_if, chnl2_if); burst_test.set_interface(chnl0_if, chnl1_if, chnl2_if); fifo_full_test.set_interface(chnl0_if, chnl1_if, chnl2_if); // USER TODO 4.5  // START TESTs  basic_test.run(); burst_test.run(); fifo_full_test.run(); $display(\u0026#34;*****************all of tests have been finished********************\u0026#34;); $finish(); end endmodule    验证结构 ：  请画出来你理解的tb4.sv的验证环境结构。环境结构中需要包含以下要素：\n DUT 接口的名称和数量 不同验证组件的名称、数量以及结构关系  这不单单是一个实验要求，这对于接下来后续练习中不断强调的验证环境构成、模块环境到系统环境的集成都是有很大帮助的，所以务必尝试画出你认为的tb4.sv的验证结构来。尽管目前每个人对环境的认识都有差别，但考虑到绘制验证环境将是日后从事验证工作的基本功，所以无论你的第一幅验证框图是什么样的，至少请你从这个实验开始迈出这一步。\n     lab3 练习3的部分将主要就随机约束和环境结构做实践。在这个练习中，将升级练习2部分中对generator和initiator之间的数据生成和数据传输的处理， 同时也将完善何时结束测试，将其主动权交于generator而不再是test组件。在组件结构实践部分中，将在原有的的initiator，generator、agent和test组件的基础上再认识monitor和checker，并且使其构成一个有机的整体，最终可以通过在线比较数据的方式完成对MCDT的测试。\n 随机约束 ：  为了更早习惯各个验证文件独立放置的原则，已经先将chnl_pkg1.sv文件和tb1.sv文件独立开来，所以tb1需要编译两个文件即chnl_pkg1.sv和tb.sv。在这个练习中会进一步了解随机约束在类中定义方式、如何随机化对象、随机种子的使用方法、对象的产生等等。接下来，请按照要求开始练习吧。\n lab3继承了大部分lab2的代码，包括chnl_basic_test类，而对于这个类所需要生成的数据包提出了新的约束要求。需要注意的是，与lab2不同的是，这次数据类chnl_trans的定义发生了很大的变化，它不再只局限于包含一个数据，而是多个数据，同时跟数据之间时间间隔的控制变量也在该类中声明为随机成员变量， 那么请按照代码中具体的约束来定义chnl_basic_test类，注意该代码的修改需要在chnl_trans类中实现，因为目前的代码结构只有chnl_trans类的更新是较为合适的办法。 需要将原本在chnl_root_test类中用来结束仿真的$finish(变迁到generator中，那么请将它放置到合适的地方，然后由generator来结束仿真吧)。 请尝试着多次重新启动仿真，可以使用“restart”命令来重启，再对比连续两次生成的随机数据，看看它们之间是否相同呢？然后再在仿真器命令行处使用命令\u0026quot;vsim -novopt -solvefaildebug -sv_seed 0 work.tb1\u0026quot;来加载仿真。这里我们多传递了两个必须的仿真参数， -solvefaildebug是为了调试随机变量的，而-sv_seed NUM则是为了传递随机的种子。那么使用这个命令再看， 是否与之前没有使用-sv_seed 0的命令产生了相同的数据呢？最后，\u0026ldquo;vsim -novopt -solvefaildebug -sv_seed random work.tb1\u0026quot;命令再来加载仿真，比较前后两次的数据是否相同？那么，对-sv_seed random的仿真选项的认识是什么? 在仿真的最后，可以发现最后打印出来的chnl_obj对象的obj_id值是1200，那么这代表什么含义？为什么会有1200个chanl_obj对象产生呢？整个仿真过程中，在同一时刻，最多的时候一同有几个chnl_trans对象在仿真器内存中存在呢？这么做对内存的利用是否合理？是否还有更好的办法使得在同一时间chnl_trans对象的数量比代码中用到的更少呢?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface module tb1; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end import chnl_pkg1::*; chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_basic_test basic_test; chnl_burst_test burst_test; chnl_fifo_full_test fifo_full_test; initial begin basic_test = new(); basic_test.set_interface(chnl0_if, chnl1_if, chnl2_if); basic_test.run(); end endmodule   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228  package chnl_pkg1; class chnl_trans; rand bit[31:0] data[]; rand int ch_id; rand int pkt_id; rand int data_nidles; rand int pkt_nidles; bit rsp; local static int obj_id = 0; // USER TODO 1.1.  // Specify constraint to match the chnl_basic_test request  constraint cstr{ data.size inside {[4:8]}; foreach(data[i]) data[i] == \u0026#39;hC000_0000 + (this.ch_id\u0026lt;\u0026lt;24) + (this.pkt_id\u0026lt;\u0026lt;8) + i; soft ch_id == 0; soft pkt_id == 0; data_nidles inside {[0:2]}; pkt_nidles inside {[1:10]}; }; function new(); this.obj_id++; endfunction function chnl_trans clone(); chnl_trans c = new(); c.data = this.data; c.ch_id = this.ch_id; c.pkt_id = this.pkt_id; c.data_nidles = this.data_nidles; c.pkt_nidles = this.pkt_nidles; c.rsp = this.rsp; // USER TODO 1.2  // Could we put c.obj_id = this.obj_id here? and why?  return c; endfunction function string sprint(); string s; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;chnl_trans object content is as below: \\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;obj_id = %0d: \\n\u0026#34;, this.obj_id)}; foreach(data[i]) s = {s, $sformatf(\u0026#34;data[%0d] = %8x \\n\u0026#34;, i, this.data[i])}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;rsp = %0d: \\n\u0026#34;, this.rsp)}; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; return s; endfunction endclass: chnl_trans class chnl_initiator; local string name; local virtual chnl_intf intf; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; function new(string name = \u0026#34;chnl_initiator\u0026#34;); this.name = name; endfunction function void set_name(string s); this.name = s; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task run(); this.drive(); endtask task drive(); chnl_trans req, rsp; @(posedge intf.rstn); forever begin this.req_mb.get(req); this.chnl_write(req); rsp = req.clone(); rsp.rsp = 1; this.rsp_mb.put(rsp); end endtask task chnl_write(input chnl_trans t); foreach(t.data[i]) begin @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= t.data[i]; wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%0t channel initiator [%s] sent data %x\u0026#34;, $time, name, t.data[i]); repeat(t.data_nidles) chnl_idle(); end repeat(t.pkt_nidles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endclass: chnl_initiator class chnl_generator; int pkt_id; int ch_id; int ntrans; int data_nidles; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; function new(int ch_id, int ntrans); this.ch_id = ch_id; this.pkt_id = 0; this.ntrans = ntrans; this.req_mb = new(); this.rsp_mb = new(); endfunction task run(); repeat(ntrans) send_trans(); endtask // generate transaction and put into local mailbox  task send_trans(); chnl_trans req, rsp; req = new(); assert(req.randomize with {ch_id == local::ch_id; pkt_id == local::pkt_id;}) else $fatal(\u0026#34;[RNDFAIL] channel packet randomization failure!\u0026#34;); this.pkt_id++; $display(req.sprint()); this.req_mb.put(req); this.rsp_mb.get(rsp); $display(rsp.sprint()); assert(rsp.rsp) else $error(\u0026#34;[RSPERR] %0t error response received!\u0026#34;, $time); endtask endclass: chnl_generator class chnl_agent; chnl_generator gen; chnl_initiator init; local virtual chnl_intf vif; function new(string name = \u0026#34;chnl_agent\u0026#34;, int id = 0, int ntrans = 1); this.gen = new(id, ntrans); this.init = new(name); endfunction function void set_interface(virtual chnl_intf vif); this.vif = vif; init.set_interface(vif); endfunction task run(); this.init.req_mb = this.gen.req_mb; this.init.rsp_mb = this.gen.rsp_mb; fork gen.run(); init.run(); join_any endtask endclass: chnl_agent class chnl_root_test; chnl_agent agent[3]; protected string name; function new(int ntrans = 100, string name = \u0026#34;chnl_root_test\u0026#34;); foreach(agent[i]) begin this.agent[i] = new($sformatf(\u0026#34;chnl_agent%0d\u0026#34;,i), i, ntrans); end this.name = name; $display(\u0026#34;%s instantiate objects\u0026#34;, this.name); endfunction task run(); $display($sformatf(\u0026#34;*****************%s started********************\u0026#34;, this.name)); fork agent[0].run(); agent[1].run(); agent[2].run(); join $display($sformatf(\u0026#34;*****************%s finished********************\u0026#34;, this.name)); // USER TODO 1.3  // Please move the $finish statement from the test run task to generator  // You woudl put it anywhere you like inside generator to stop test when  // all transactions have been transfered  $finish(); // USER TODO 1.4  // Apply \u0026#39;vsim -novopt -solvefaildebug -sv_seed 0 work.tb1\u0026#39; to run the  // simulation, and check if the generated data is the same as previously  // Then use \u0026#39;vsim -novopt -solvefaildebug -sv_seed random work.tb1\u0026#39; to  // run the test 2 times, and check if the data generated of 2 times are  // is the same or not?  // USER TODO 1.5  // In the last chnl_trans object content display, why the object_id is  // 1200? How is it counted and finally as the value 1200?  endtask function void set_interface(virtual chnl_intf ch0_vif, virtual chnl_intf ch1_vif, virtual chnl_intf ch2_vif); agent[0].set_interface(ch0_vif); agent[1].set_interface(ch1_vif); agent[2].set_interface(ch2_vif); endfunction endclass // USER TODO 1.1  // each channel send data with idle_cycles inside [0:2]  // and idle peroids between sequential packets should be inside [3:5]  // each channel send out 200 data then to finish the test  // The idle_cycle constraint should be specified inside chnl_trans  class chnl_basic_test extends chnl_root_test; function new(int ntrans = 200, string name = \u0026#34;chnl_basic_test\u0026#34;); super.new(ntrans, name); endfunction endclass: chnl_basic_test class chnl_burst_test extends chnl_root_test; //USER TODO  endclass: chnl_burst_test class chnl_fifo_full_test extends chnl_root_test; // USER TODO  endclass: chnl_fifo_full_test endpackage    更加灵活的测试控制 ：  如果要实现不同的test类，例如chnl_basic_test、chnl burst_test和chnl_fifo_full_test，那么对于不同的test需要对chnl_generator的随机变量做出不同的控制，继而进一步控制其内部随机的chnl_tans对象。也就是说，随机化也是可以分层次的，例如在test层可以随机化generator层，而依靠generator被随机化的成员变量，再来利用它们进一步随机化generator中的chnl_tans对象，由此来达到顶层到底层的随机化灵活控制。那么从这个角度出发，就需要将generator从agent单元中搬迁出来，并且搁置在test层中来方便test层的随机控制，因此在chnl_pkg2.sv和tb2.sv中主要去认识如何更好的组织验证结构，从而实现更加方便的测试控制。\n 由于将generator搬迁到test层次中，所以需要将gen和agent中组件的mailbox连接起来，方便gen与agent中init的数据通信。 在领略了如何在test中的do_config对gen[0]进行随机化控制后，需要对gen[1]也按照代码中的具体要求进行随机控制。 请按照代码中的具体要求对gen[2]进行随机控制。 按照代码中的具体要求，在chnl_burst_test::do_config()任务中对三个generator进行随机控制。 按照代码中的具体要求，在chnl_fifo_full_test::do_config()任务中对三个generator进行随机控制。 在tb2.sv中，对于测试的选择将由仿真时的参数传递来完成。这意味着，以后的递归测试，即创建脚本命令，由仿真器读入，分别传递不同的随机种子和测试名称即可完成对应的随机测试，而这种方式即是回归测试的雏形。所以请按照之前的仿真命令，在命令窗口中添加额外的命令\u0026quot;+TESTNAME=testname\u0026rdquo;，这里的+TESTNAME=表示的仿真命令项，在由内部解析之后，testname会被捕捉并且识别，例如可以传递命令\u0026quot;+TESTNAME=chnl_burst_test\u0026quot;来在仿真时运行测试chnl_burst_test。请充分理解此要求，懂得如何捕捉命令，如何解析命令，最后如何选择正确的测试来运行。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking endinterface module tb2; logic clk; logic rstn; logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_data ) ,.mcdt_val_o (mcdt_val ) ,.mcdt_id_o (mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end import chnl_pkg2::*; chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); chnl_basic_test basic_test; chnl_burst_test burst_test; chnl_fifo_full_test fifo_full_test; chnl_root_test tests[string]; string name; // USER TODO 2.6  // User runtime option \u0026#39;+TESTNAME=[testname]\u0026#39; to specify which test to run  // It also implies each time should only run only one test  initial begin basic_test = new(); burst_test = new(); fifo_full_test = new(); tests[\u0026#34;chnl_basic_test\u0026#34;] = basic_test; tests[\u0026#34;chnl_burst_test\u0026#34;] = burst_test; tests[\u0026#34;chnl_fifo_full_test\u0026#34;] = fifo_full_test; if($value$plusargs(\u0026#34;TESTNAME=%s\u0026#34;, name)) begin if(tests.exists(name)) begin tests[name].set_interface(chnl0_if, chnl1_if, chnl2_if); tests[name].run(); end else begin $fatal($sformatf(\u0026#34;[ERRTEST], test name %s is invalid, please specify a valid name!\u0026#34;, name)); end end else begin $display(\u0026#34;NO runtime optiont TEST=[testname] is configured, and run default test chnl_basic_test\u0026#34;); tests[\u0026#34;chnl_basic_test\u0026#34;].set_interface(chnl0_if, chnl1_if, chnl2_if); tests[\u0026#34;chnl_basic_test\u0026#34;].run(); end end endmodule   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279  package chnl_pkg2; class chnl_trans; rand bit[31:0] data[]; rand int ch_id; rand int pkt_id; rand int data_nidles; rand int pkt_nidles; bit rsp; local static int obj_id = 0; constraint cstr{ data.size inside {[4:8]}; foreach(data[i]) data[i] == \u0026#39;hC000_0000 + (this.ch_id\u0026lt;\u0026lt;24) + (this.pkt_id\u0026lt;\u0026lt;8) + i; soft ch_id == 0; soft pkt_id == 0; data_nidles inside {[0:2]}; pkt_nidles inside {[1:10]}; }; function new(); this.obj_id++; endfunction function chnl_trans clone(); chnl_trans c = new(); c.data = this.data; c.ch_id = this.ch_id; c.pkt_id = this.pkt_id; c.data_nidles = this.data_nidles; c.pkt_nidles = this.pkt_nidles; c.rsp = this.rsp; return c; endfunction function string sprint(); string s; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;chnl_trans object content is as below: \\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;obj_id = %0d: \\n\u0026#34;, this.obj_id)}; foreach(data[i]) s = {s, $sformatf(\u0026#34;data[%0d] = %8x \\n\u0026#34;, i, this.data[i])}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;rsp = %0d: \\n\u0026#34;, this.rsp)}; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; return s; endfunction endclass: chnl_trans class chnl_initiator; local string name; local virtual chnl_intf intf; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; function new(string name = \u0026#34;chnl_initiator\u0026#34;); this.name = name; endfunction function void set_name(string s); this.name = s; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task run(); this.drive(); endtask task drive(); chnl_trans req, rsp; @(posedge intf.rstn); forever begin this.req_mb.get(req); this.chnl_write(req); rsp = req.clone(); rsp.rsp = 1; this.rsp_mb.put(rsp); end endtask task chnl_write(input chnl_trans t); foreach(t.data[i]) begin @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= t.data[i]; wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%0t channel initiator [%s] sent data %x\u0026#34;, $time, name, t.data[i]); repeat(t.data_nidles) chnl_idle(); end repeat(t.pkt_nidles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endclass: chnl_initiator class chnl_generator; rand int pkt_id = -1; rand int ch_id = -1; rand int data_nidles = -1; rand int pkt_nidles = -1; rand int data_size = -1; rand int ntrans = 10; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; constraint cstr{ soft ch_id == -1; soft pkt_id == -1; soft data_size == -1; soft data_nidles == -1; soft pkt_nidles == -1; soft ntrans == 10; } function new(); this.req_mb = new(); this.rsp_mb = new(); endfunction task run(); repeat(ntrans) send_trans(); endtask // generate transaction and put into local mailbox  task send_trans(); chnl_trans req, rsp; req = new(); assert(req.randomize with {local::ch_id \u0026gt;= 0 -\u0026gt; ch_id == local::ch_id; local::pkt_id \u0026gt;= 0 -\u0026gt; pkt_id == local::pkt_id; local::data_nidles \u0026gt;= 0 -\u0026gt; data_nidles == local::data_nidles; local::pkt_nidles \u0026gt;= 0 -\u0026gt; pkt_nidles == local::pkt_nidles; local::data_size \u0026gt;0 -\u0026gt; data.size() == local::data_size; }) else $fatal(\u0026#34;[RNDFAIL] channel packet randomization failure!\u0026#34;); this.pkt_id++; $display(req.sprint()); this.req_mb.put(req); this.rsp_mb.get(rsp); $display(rsp.sprint()); assert(rsp.rsp) else $error(\u0026#34;[RSPERR] %0t error response received!\u0026#34;, $time); endtask function string sprint(); string s; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;chnl_generator object content is as below: \\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;ntrans = %0d: \\n\u0026#34;, this.ntrans)}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;data_size = %0d: \\n\u0026#34;, this.data_size)}; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; return s; endfunction function void post_randomize(); string s; s = {\u0026#34;AFTER RANDOMIZATION \\n\u0026#34;, this.sprint()}; $display(s); endfunction endclass: chnl_generator class chnl_agent; chnl_initiator init; local virtual chnl_intf vif; function new(string name = \u0026#34;chnl_agent\u0026#34;); this.init = new(name); endfunction function void set_interface(virtual chnl_intf vif); this.vif = vif; init.set_interface(vif); endfunction task run(); fork init.run(); join endtask endclass: chnl_agent class chnl_root_test; chnl_generator gen[3]; chnl_agent agent[3]; protected string name; function new(string name = \u0026#34;chnl_root_test\u0026#34;); foreach(agent[i]) begin this.agent[i] = new($sformatf(\u0026#34;chnl_agent%0d\u0026#34;,i)); this.gen[i] = new(); // USER TODO 2.1  // Connect the mailboxes handles of gen[i] and agent[i].init  end this.name = name; $display(\u0026#34;%s instantiate objects\u0026#34;, this.name); endfunction virtual task run(); $display($sformatf(\u0026#34;*****************%s started********************\u0026#34;, this.name)); this.do_config(); fork agent[0].run(); agent[1].run(); agent[2].run(); join_none fork gen[0].run(); gen[1].run(); gen[2].run(); join $display($sformatf(\u0026#34;*****************%s finished********************\u0026#34;, this.name)); // USER TODO 1.3  // Please move the $finish statement from the test run task to generator  // You woudl put it anywhere you like inside generator to stop test when  // all transactions have been transfered  $finish(); endtask virtual function void set_interface(virtual chnl_intf ch0_vif, virtual chnl_intf ch1_vif, virtual chnl_intf ch2_vif); agent[0].set_interface(ch0_vif); agent[1].set_interface(ch1_vif); agent[2].set_interface(ch2_vif); endfunction virtual function void do_config(); assert(gen[0].randomize() with {ntrans==100; data_nidles==0; pkt_nidles==1; data_size==8;}) else $fatal(\u0026#34;[RNDFAIL] gen[0] randomization failure!\u0026#34;); // USER TODO 2.2  // To randomize gen[1] with  // ntrans==50, data_nidles inside [1:2], pkt_nidles inside [3:5],  // data_size == 6  // USER TODO 2.3  // ntrans==80, data_nidles inside [0:1], pkt_nidles inside [1:2],  // data_size == 32  endfunction endclass class chnl_basic_test extends chnl_root_test; function new(string name = \u0026#34;chnl_basic_test\u0026#34;); super.new(name); endfunction endclass: chnl_basic_test // USER TODO 2.4  // each channel send data packet number inside [80:100]  // data_nidles == 0, pkt_nidles == 1, data_size inside {8, 16, 32}  class chnl_burst_test extends chnl_root_test; function new(string name = \u0026#34;chnl_burst_test\u0026#34;); super.new(name); endfunction //USER TODO  endclass: chnl_burst_test // USER TODO 2.5  // keep channel sending out data packet with number, and please  // let all of slave channels raising fifo_full (ready=0) at the same time  // and then to stop the test  class chnl_fifo_full_test extends chnl_root_test; function new(string name = \u0026#34;chnl_fifo_full_test\u0026#34;); super.new(name); endfunction // USER TODO  endclass: chnl_fifo_full_test endpackage    测试平台的结构 ：  最后一个实验部分即指导认识验证环境的其它组件，monitor和checker。并且通过合理的方式来构成最终用来测试MCDT的验证环境，在这个环境中需要再回顾generator、intitator、monitor和checker各自的作用。在顶层环境中，将checker置于test层中，而不是agent中，需要思考这么做的好处在什么地方。同时需要在认识generator和initiator有数据通信的同时，可以掌握monitor与checker之间的数据通信，还有checker如何针对MCDT利用内部的数据缓存进行数据比较。\n 在chnl_monitor类和mcdt_monitor类各自的mon_trans()方法中需要采集正确的数据，将它们写入mailbox缓存，同时将捕捉的数据也打印出来，便于我们的调试。 在chnl_agent中，参考如何例化的initiator对象，也对chnl_monitor对象开始例化、传递虚接口和使其运行。 在chnl_checker的任务do_compare()中，需要从checker自己的数据缓存mailbox中分别取得一个输出端的采集数据和一个输入端的采集数据，继而将它们的内容进行比较，需要注重的是，输出端的缓存只有一个，而输入端的缓存有三个，需要考虑好从哪个输入端获取数据与输出端缓存的数据进行比对。 在顶层环境chnl_root_test类中，需要对mcdt_monitor和chnl_checker进行例化、传递虚接口，并且将chnl_monitor、mcdt_monitor的邮箱句柄分别指向chnl_checker中的邮箱实例。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  `timescale 1ns/1ps interface chnl_intf(input clk, input rstn); logic [31:0] ch_data; logic ch_valid; logic ch_ready; logic [ 5:0] ch_margin; clocking drv_ck @(posedge clk); default input #1ns output #1ns; output ch_data, ch_valid; input ch_ready, ch_margin; endclocking clocking mon_ck @(posedge clk); default input #1ns output #1ns; input ch_data, ch_valid, ch_ready, ch_margin; endclocking endinterface interface mcdt_intf(input clk, input rstn); logic [31:0] mcdt_data; logic mcdt_val; logic [ 1:0] mcdt_id; clocking mon_ck @(posedge clk); default input #1ns output #1ns; input mcdt_data, mcdt_val, mcdt_id; endclocking endinterface module tb3_ref; logic clk; logic rstn; mcdt dut( .clk_i (clk ) ,.rstn_i (rstn ) ,.ch0_data_i (chnl0_if.ch_data ) ,.ch0_valid_i (chnl0_if.ch_valid ) ,.ch0_ready_o (chnl0_if.ch_ready ) ,.ch0_margin_o(chnl0_if.ch_margin ) ,.ch1_data_i (chnl1_if.ch_data ) ,.ch1_valid_i (chnl1_if.ch_valid ) ,.ch1_ready_o (chnl1_if.ch_ready ) ,.ch1_margin_o(chnl1_if.ch_margin ) ,.ch2_data_i (chnl2_if.ch_data ) ,.ch2_valid_i (chnl2_if.ch_valid ) ,.ch2_ready_o (chnl2_if.ch_ready ) ,.ch2_margin_o(chnl2_if.ch_margin ) ,.mcdt_data_o (mcdt_if.mcdt_data ) ,.mcdt_val_o (mcdt_if.mcdt_val ) ,.mcdt_id_o (mcdt_if.mcdt_id ) ); // clock generation  initial begin clk \u0026lt;= 0; forever begin #5 clk \u0026lt;= !clk; end end // reset trigger  initial begin #10 rstn \u0026lt;= 0; repeat(10) @(posedge clk); rstn \u0026lt;= 1; end import chnl_pkg3::*; chnl_intf chnl0_if(.*); chnl_intf chnl1_if(.*); chnl_intf chnl2_if(.*); mcdt_intf mcdt_if(.*); chnl_basic_test basic_test; chnl_burst_test burst_test; chnl_fifo_full_test fifo_full_test; chnl_root_test tests[string]; string name; initial begin basic_test = new(); burst_test = new(); fifo_full_test = new(); tests[\u0026#34;chnl_basic_test\u0026#34;] = basic_test; tests[\u0026#34;chnl_burst_test\u0026#34;] = burst_test; tests[\u0026#34;chnl_fifo_full_test\u0026#34;] = fifo_full_test; if($value$plusargs(\u0026#34;TESTNAME=%s\u0026#34;, name)) begin if(tests.exists(name)) begin tests[name].set_interface(chnl0_if, chnl1_if, chnl2_if, mcdt_if); tests[name].run(); end else begin $fatal($sformatf(\u0026#34;[ERRTEST], test name %s is invalid, please specify a valid name!\u0026#34;, name)); end end else begin $display(\u0026#34;NO runtime optiont +TESTNAME=xxx is configured, and run default test chnl_basic_test\u0026#34;); tests[\u0026#34;chnl_basic_test\u0026#34;].set_interface(chnl0_if, chnl1_if, chnl2_if, mcdt_if); tests[\u0026#34;chnl_basic_test\u0026#34;].run(); end end endmodule   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510  package chnl_pkg3; // static variables shared by resources  semaphore run_stop_flags = new(); class chnl_trans; rand bit[31:0] data[]; rand int ch_id; rand int pkt_id; rand int data_nidles; rand int pkt_nidles; bit rsp; local static int obj_id = 0; constraint cstr{ soft data.size inside {[4:8]}; foreach(data[i]) data[i] == \u0026#39;hC000_0000 + (this.ch_id\u0026lt;\u0026lt;24) + (this.pkt_id\u0026lt;\u0026lt;8) + i; soft ch_id == 0; soft pkt_id == 0; data_nidles inside {[0:2]}; pkt_nidles inside {[1:10]}; }; function new(); this.obj_id++; endfunction function chnl_trans clone(); chnl_trans c = new(); c.data = this.data; c.ch_id = this.ch_id; c.pkt_id = this.pkt_id; c.data_nidles = this.data_nidles; c.pkt_nidles = this.pkt_nidles; c.rsp = this.rsp; return c; endfunction function string sprint(); string s; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;chnl_trans object content is as below: \\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;obj_id = %0d: \\n\u0026#34;, this.obj_id)}; foreach(data[i]) s = {s, $sformatf(\u0026#34;data[%0d] = %8x \\n\u0026#34;, i, this.data[i])}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;rsp = %0d: \\n\u0026#34;, this.rsp)}; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; return s; endfunction endclass: chnl_trans class chnl_initiator; local string name; local virtual chnl_intf intf; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; function new(string name = \u0026#34;chnl_initiator\u0026#34;); this.name = name; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task run(); this.drive(); endtask task drive(); chnl_trans req, rsp; @(posedge intf.rstn); forever begin this.req_mb.get(req); this.chnl_write(req); rsp = req.clone(); rsp.rsp = 1; this.rsp_mb.put(rsp); end endtask task chnl_write(input chnl_trans t); foreach(t.data[i]) begin @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 1; intf.drv_ck.ch_data \u0026lt;= t.data[i]; @(negedge intf.clk); wait(intf.ch_ready === \u0026#39;b1); $display(\u0026#34;%0t channel initiator [%s] sent data %x\u0026#34;, $time, name, t.data[i]); repeat(t.data_nidles) chnl_idle(); end repeat(t.pkt_nidles) chnl_idle(); endtask task chnl_idle(); @(posedge intf.clk); intf.drv_ck.ch_valid \u0026lt;= 0; intf.drv_ck.ch_data \u0026lt;= 0; endtask endclass: chnl_initiator class chnl_generator; rand int pkt_id = -1; rand int ch_id = -1; rand int data_nidles = -1; rand int pkt_nidles = -1; rand int data_size = -1; rand int ntrans = 10; mailbox #(chnl_trans) req_mb; mailbox #(chnl_trans) rsp_mb; constraint cstr{ soft ch_id == -1; soft pkt_id == -1; soft data_size == -1; soft data_nidles == -1; soft pkt_nidles == -1; soft ntrans == 10; } function new(); this.req_mb = new(); this.rsp_mb = new(); endfunction task run(); repeat(ntrans) send_trans(); run_stop_flags.put(); endtask // generate transaction and put into local mailbox  task send_trans(); chnl_trans req, rsp; req = new(); assert(req.randomize with {local::ch_id \u0026gt;= 0 -\u0026gt; ch_id == local::ch_id; local::pkt_id \u0026gt;= 0 -\u0026gt; pkt_id == local::pkt_id; local::data_nidles \u0026gt;= 0 -\u0026gt; data_nidles == local::data_nidles; local::pkt_nidles \u0026gt;= 0 -\u0026gt; pkt_nidles == local::pkt_nidles; local::data_size \u0026gt;0 -\u0026gt; data.size() == local::data_size; }) else $fatal(\u0026#34;[RNDFAIL] channel packet randomization failure!\u0026#34;); this.pkt_id++; $display(req.sprint()); this.req_mb.put(req); this.rsp_mb.get(rsp); $display(rsp.sprint()); assert(rsp.rsp) else $error(\u0026#34;[RSPERR] %0t error response received!\u0026#34;, $time); endtask function string sprint(); string s; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;chnl_generator object content is as below: \\n\u0026#34;)}; s = {s, $sformatf(\u0026#34;ntrans = %0d: \\n\u0026#34;, this.ntrans)}; s = {s, $sformatf(\u0026#34;ch_id = %0d: \\n\u0026#34;, this.ch_id)}; s = {s, $sformatf(\u0026#34;pkt_id = %0d: \\n\u0026#34;, this.pkt_id)}; s = {s, $sformatf(\u0026#34;data_nidles = %0d: \\n\u0026#34;, this.data_nidles)}; s = {s, $sformatf(\u0026#34;pkt_nidles = %0d: \\n\u0026#34;, this.pkt_nidles)}; s = {s, $sformatf(\u0026#34;data_size = %0d: \\n\u0026#34;, this.data_size)}; s = {s, $sformatf(\u0026#34;=======================================\\n\u0026#34;)}; return s; endfunction function void post_randomize(); string s; s = {\u0026#34;AFTER RANDOMIZATION \\n\u0026#34;, this.sprint()}; $display(s); endfunction endclass: chnl_generator typedef struct packed { bit[31:0] data; bit[1:0] id; } mon_data_t; class chnl_monitor; local string name; local virtual chnl_intf intf; mailbox #(mon_data_t) mon_mb; function new(string name=\u0026#34;chnl_monitor\u0026#34;); this.name = name; endfunction function void set_interface(virtual chnl_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task run(); this.mon_trans(); endtask task mon_trans(); mon_data_t m; forever begin @(posedge intf.clk iff (intf.mon_ck.ch_valid===\u0026#39;b1 \u0026amp;\u0026amp; intf.mon_ck.ch_ready===\u0026#39;b1)); // USER TODO 3.1  // Put the data into the mon_mb and use $display() to print the stored  // data value with monitor name  m.data = intf.mon_ck.ch_data; mon_mb.put(m); $display(\u0026#34;%0t %s monitored channle data %8x\u0026#34;, $time, this.name, m.data); end endtask endclass class mcdt_monitor; local string name; local virtual mcdt_intf intf; mailbox #(mon_data_t) mon_mb; function new(string name=\u0026#34;mcdt_monitor\u0026#34;); this.name = name; endfunction task run(); this.mon_trans(); endtask function void set_interface(virtual mcdt_intf intf); if(intf == null) $error(\u0026#34;interface handle is NULL, please check if target interface has been intantiated\u0026#34;); else this.intf = intf; endfunction task mon_trans(); mon_data_t m; forever begin @(posedge intf.clk iff intf.mon_ck.mcdt_val===\u0026#39;b1); // USER TODO 3.1  // Put the data into the mon_mb and use $display() to print the stored  // data value with monitor name  m.data = intf.mon_ck.mcdt_data; m.id = intf.mon_ck.mcdt_id; mon_mb.put(m); $display(\u0026#34;%0t %s monitored mcdt data %8x and id %0d\u0026#34;, $time, this.name, m.data, m.id); end endtask endclass class chnl_agent; local string name; chnl_initiator init; chnl_monitor mon; // USER TODO 3.2  // Refer to how we create, set virtual interface and run the initiator  // object, use do the similar action to the monitor object  virtual chnl_intf vif; function new(string name = \u0026#34;chnl_agent\u0026#34;); this.name = name; this.init = new({name, \u0026#34;.init\u0026#34;}); this.mon = new({name, \u0026#34;.mon\u0026#34;}); endfunction function void set_interface(virtual chnl_intf vif); this.vif = vif; init.set_interface(vif); mon.set_interface(vif); endfunction task run(); fork init.run(); mon.run(); join endtask endclass: chnl_agent class chnl_checker; local string name; local int error_count; local int cmp_count; mailbox #(mon_data_t) in_mbs[3]; mailbox #(mon_data_t) out_mb; function new(string name=\u0026#34;chnl_checker\u0026#34;); this.name = name; foreach(this.in_mbs[i]) this.in_mbs[i] = new(); this.out_mb = new(); this.error_count = 0; this.cmp_count = 0; endfunction task run(); this.do_compare(); endtask task do_compare(); mon_data_t im, om; forever begin // USER TODO 3.3  // compare data once there is data in in_mb0/in_mb1/in_mb2 and out_mb  // first, get om from out_mb, and im from one of in_mbs  out_mb.get(om); case(om.id) 0: in_mbs[0].get(im); 1: in_mbs[1].get(im); 2: in_mbs[2].get(im); default: $fatal(\u0026#34;id %0d is not available\u0026#34;, om.id); endcase if(om.data != im.data) begin this.error_count++; $error(\u0026#34;[CMPFAIL] Compared failed! mcdt out data %8x ch_id %0d is not equal with channel in data %8x\u0026#34;, om.data, om.id, im.data); end else begin $display(\u0026#34;[CMPSUCD] Compared succeeded! mcdt out data %8x ch_id %0d is equal with channel in data %8x\u0026#34;, om.data, om.id, im.data); end this.cmp_count++; end endtask endclass // USER TODO 3.4  // Create, set interface and run the object mcdt_mon and checker  class chnl_root_test; chnl_generator gen[3]; chnl_agent agents[3]; mcdt_monitor mcdt_mon; chnl_checker chker; protected string name; event gen_stop_e; function new(string name = \u0026#34;chnl_root_test\u0026#34;); this.name = name; this.chker = new(); foreach(agents[i]) begin this.agents[i] = new($sformatf(\u0026#34;chnl_agent%0d\u0026#34;,i)); this.gen[i] = new(); // USER TODO 2.1  // Connect the mailboxes handles of gen[i] and agents[i].init  this.agents[i].init.req_mb = this.gen[i].req_mb; this.agents[i].init.rsp_mb = this.gen[i].rsp_mb; this.agents[i].mon.mon_mb = this.chker.in_mbs[i]; end this.mcdt_mon = new(); this.mcdt_mon.mon_mb = this.chker.out_mb; $display(\u0026#34;%s instantiated and connected objects\u0026#34;, this.name); endfunction virtual task gen_stop_callback(); // empty  endtask virtual task run_stop_callback(); $display(\u0026#34;run_stop_callback enterred\u0026#34;); // by default, run would be finished once generators raised \u0026#39;finish\u0026#39;  // flags  $display(\u0026#34;%s: wait for all generators have generated and tranferred transcations\u0026#34;, this.name); run_stop_flags.get(3); $display($sformatf(\u0026#34;*****************%s finished********************\u0026#34;, this.name)); $finish(); endtask virtual task run(); $display($sformatf(\u0026#34;*****************%s started********************\u0026#34;, this.name)); this.do_config(); fork agents[0].run(); agents[1].run(); agents[2].run(); mcdt_mon.run(); chker.run(); join_none // run first the callback thread to conditionally disable gen_threads  fork this.gen_stop_callback(); @(this.gen_stop_e) disable gen_threads; join_none fork : gen_threads gen[0].run(); gen[1].run(); gen[2].run(); join run_stop_callback(); // wait until run stop control task finished  // USER TODO 1.3  // Please move the $finish statement from the test run task to generator  // You would put it anywhere you like inside generator to stop test when  // all transactions have been transfered  endtask virtual function void set_interface(virtual chnl_intf ch0_vif ,virtual chnl_intf ch1_vif ,virtual chnl_intf ch2_vif ,virtual mcdt_intf mcdt_vif ); agents[0].set_interface(ch0_vif); agents[1].set_interface(ch1_vif); agents[2].set_interface(ch2_vif); mcdt_mon.set_interface(mcdt_vif); endfunction virtual function void do_config(); endfunction endclass class chnl_basic_test extends chnl_root_test; function new(string name = \u0026#34;chnl_basic_test\u0026#34;); super.new(name); endfunction virtual function void do_config(); super.do_config(); assert(gen[0].randomize() with {ntrans==100; data_nidles==0; pkt_nidles==1; data_size==8;}) else $fatal(\u0026#34;[RNDFAIL] gen[0] randomization failure!\u0026#34;); // USER TODO 2.2  // To randomize gen[1] with  // ntrans==50, data_nidles inside [1:2], pkt_nidles inside [3:5],  // data_size == 6  assert(gen[1].randomize() with {ntrans==50; data_nidles inside {[1:2]}; pkt_nidles inside {[3:5]}; data_size==6;}) else $fatal(\u0026#34;[RNDFAIL] gen[1] randomization failure!\u0026#34;); // USER TODO 2.3  // ntrans==80, data_nidles inside [0:1], pkt_nidles inside [1:2],  // data_size == 32  assert(gen[2].randomize() with {ntrans==80; data_nidles inside {[0:1]}; pkt_nidles inside {[1:2]}; data_size==32;}) else $fatal(\u0026#34;[RNDFAIL] gen[2] randomization failure!\u0026#34;); endfunction endclass: chnl_basic_test // USER TODO 2.4  // each channel send data packet number inside [80:100]  // data_nidles == 0, pkt_nidles == 1, data_size inside {8, 16, 32}  class chnl_burst_test extends chnl_root_test; function new(string name = \u0026#34;chnl_burst_test\u0026#34;); super.new(name); endfunction virtual function void do_config(); super.do_config(); assert(gen[0].randomize() with {ntrans inside {[80:100]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[0] randomization failure!\u0026#34;); assert(gen[1].randomize() with {ntrans inside {[80:100]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[1] randomization failure!\u0026#34;); assert(gen[2].randomize() with {ntrans inside {[80:100]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[2] randomization failure!\u0026#34;); endfunction endclass: chnl_burst_test // USER TODO 2.5  // keep channel sending out data packet with number, and please  // let at least two slave channels raising fifo_full (ready=0) at the same time  // and then to stop the test  class chnl_fifo_full_test extends chnl_root_test; function new(string name = \u0026#34;chnl_fifo_full_test\u0026#34;); super.new(name); endfunction virtual function void do_config(); super.do_config(); assert(gen[0].randomize() with {ntrans inside {[1000:2000]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[0] randomization failure!\u0026#34;); assert(gen[1].randomize() with {ntrans inside {[1000:2000]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[1] randomization failure!\u0026#34;); assert(gen[2].randomize() with {ntrans inside {[1000:2000]}; data_nidles==0; pkt_nidles==1; data_size inside {8, 16, 32};}) else $fatal(\u0026#34;[RNDFAIL] gen[2] randomization failure!\u0026#34;); endfunction // get all of 3 channles slave ready signals as a 3-bits vector  local function bit[3] get_chnl_ready_flags(); return {agents[2].vif.mon_ck.ch_ready ,agents[1].vif.mon_ck.ch_ready ,agents[0].vif.mon_ck.ch_ready }; endfunction virtual task gen_stop_callback(); bit[3] chnl_ready_flags; $display(\u0026#34;gen_stop_callback enterred\u0026#34;); @(posedge agents[0].vif.rstn); forever begin @(posedge agents[0].vif.clk); chnl_ready_flags = this.get_chnl_ready_flags(); if($countones(chnl_ready_flags) \u0026lt;= 1) break; end $display(\u0026#34;%s: stop 3 generators running\u0026#34;, this.name); -\u0026gt; this.gen_stop_e; endtask virtual task run_stop_callback(); $display(\u0026#34;run_stop_callback enterred\u0026#34;); // since generators have been forced to stop, and run_stop_flag would  // not be raised by each generator, so no need to wait for the  // run_stop_flags any more  $display(\u0026#34;%s: waiting DUT transfering all of data\u0026#34;, this.name); fork wait(agents[0].vif.ch_margin == \u0026#39;h20); wait(agents[1].vif.ch_margin == \u0026#39;h20); wait(agents[2].vif.ch_margin == \u0026#39;h20); join $display(\u0026#34;%s: 3 channel fifos have transferred all data\u0026#34;, this.name); $display($sformatf(\u0026#34;*****************%s finished********************\u0026#34;, this.name)); $finish(); endtask endclass: chnl_fifo_full_test endpackage   lab4 在接下来进入lab4之前，你头脑中需要再复习这些概念： 第一，验证环境按照隔离的观念，应该分为硬件DUT，软件验证环境，和处于信号媒介的接口interface；第二，对于软件验证环境，它需要经历立阶段(build)、连接阶段(connect)、产生激励阶段(generate)和发送激励阶段(transfer)，只有当所有的激励发送完毕并且比较完全之后，才可以结束该测试 。\n与lab3相比，lab4的环境是完善的，这其中的原因主要有两方面，一方面是因为从lab4开始在验证更大的子系统，即MCDF。与MCDT相比，MCDF主要添加了寄存器控制和状态显示功能，同时也添加了一个重要的数据整形功能，因此，你会发现lab4的验证文件多了。另外一方面，代码之所以增多是为了让整个验证环境的各个组件之间相互独立，功能清晰，可以发现不同的package之间的功能是独立的，同一个package中的各个验证组件的功能也是独立的。那么不同组件之间的同步和通信依靠什么呢？没错，那就是已经学习到的event和mailbox。\n如何开始lab4呢？大胆地编译所有的文件，然后给出仿真命令就可以了：\nvsim -novopt -classdebug -solvefaildebug -sv_seed 0 +TESTNAME=mcdf_data_consistence_basic_test -I mcdf_data_consistence_basic_test.log work.tb 来看看上面主要的仿真命令项：\n -classdebug，这是为了提供更多的SV类调试功能 -solvefaildebug，这是为了在SV随机化失败之后有更多的信息提示出来， -sv_seed 0，暂时给固定的随机种子值0 +TESTNAME=mcdf_data_consistence_basic_test，这是指定仿真选择的测试 -I mcdf_data_consistence_basic_test.log，这是让仿真的记录保存在特定的测试文件名称中  那么在开始测试并且最终结束之后，在你的项目目录下会有两个文件产生：mcdf_data_consistence_basic_test_sim.log会保存所有的仿真信息，，而mcdf_data_consistence_basic_test_checker.log则只会保存做数据比较和最终比较报告信息。需要注意的是，在测试的过程中，如果测试发生错误会立即停止下来，可以根据当前时刻的错误报告定位出数据比较错误的时间点，再去核对波形，分析是硬件问题还是环境问题。\n那么验证环境这么完善，是不是不需要做lab4了呢？NONONO\u0026hellip;，lab4的重点是要在本次练习中领会，怎么样才是一个完整的验证计划和实施。什么是验证计划的核心要素点？那就是围绕着设计的功能点罗列出需要展开测试的功能点，以及如何展开测试，并且指明测试的验收标准是什么。我们lab4中主要以测试是否通过为原则，而在lab5中，将进一步掌握代码覆盖率和功能覆盖率的验收标准。\n 从验证框图可以更好地理解验证环境的组件和组件之间的通信连接情况。无论对于接下来着手构建环境，还是将它作为验证代码的一个形象说明，它都比代码更直接地形容整个验证环境。那么接下来，请画出验证结构吧。    验证结构      checker     接下来，会指定你需要在mcdf_pkg.sv中参考以后测试类mcdf_data_consistence_basic_test而去创建其它的测试类名，它们对应的测试功能点，以及测试标准是什么，在你按照要求，实现了所有的测试之后，记得将每个测试都至少跑一遍，如果你跑的过程中发现mcdf_checker报错，分析是不是设计问题，确定是设计bug可以提交bug，待设计修复后继续测试。理论上，如果对同一个测试，每次使用不同的随机种子即\u0026rdquo;-sv_seed RANDNUM\u0026rdquo;，那么你得次数越多，就越有机会发现新的bug，而至于需要跑多少遍，或者每个测试中需要发送多少次数据包(发送得越多越好，那么究竟要发送多少次才可以停下来呢？标准是什么？) 这个问题在lab5会解答。     测试功能点 测试内容 测试通过标准 测试类名     寄存器读写测试 所有控制寄存器的读写测试 所有状态寄存器的读写测试 读写值是否正确 mcdf_reg_write_read_test   寄存器稳定性测试 非法地址读写，对控制寄存器的保留域进行读写，对状态寄存器进行写操作 通过写入和读出，确定寄存器的值是预期值，而不是紊乱值，同时非法寄存器操作也不能影响MCDF的整体功能 mcdf_reg_illegal_access_test   数据通道开关测试 对每一个数据通道对应的控制寄存器域en配置为0，在关闭状态下测试数据写入是否通过 在数据通道关闭情况下，数据无法写入，同时ready信号应该保持为低，表示不接收数据，但又能使得数据不被丢失，因此数据只会停留在数据通道端口 mcdf_channel_disable_test   优先级测试 将不同数据通道配置为相同或者不同的优先级，在数据通道使能的情况下进行测试 如果优先级相同，那么arbiter应该采取轮询机制从各个通道接收数据，如果优先级不同，那么arbiter应该先接收高优先级通道的数据，同时，最终所有的数据都应该从MCDF发送出来 mcdf_arbiter_priority_test   发包长度测试 将不同数据通道随机配置为各自的长度，在数据通道使能的情况下进行测试 从formatter发送出来的数据包长度应该同对应通道寄存器的配置值保持一—对应，同时数据也应该保持完整 mcdf_formatter_length test   下行从端低带宽测试 将MCDF下行数据接收端设置为小存储量，低带宽的类型，由此使得在由formatter发送出数据之后，下行从端有更多的机会延迟grant信号的置位，用来模拟真实场景 在req拉高之后，grant应该在至少两个时钟周期以后拉高，以此来模拟下行从端数据余量不足的情况。当这种激励时序发生10次之后，可以停止测试。 mcdf formatter_grant_test    测试代码根据后文链接，自行下载。\nlab5 本次练习将认识如何定义覆盖率，如何从验证计划到测试用例的实现，最后再到覆盖率的量化。从本次练习，可以掌握验证量化的两种基本数据，即代码覆盖率和功能覆盖率。从这两种覆盖率，就可以掌握何时结束验证，确认验证的完备性。\nlab5的代码是基于lab4的代码，主要修改的文件即mcdf_pkg.sv。在mcdf_pkg.sv中，已经为添加了一个关于MCDF的覆盖率模型mcdf_coverage，并且将它例化在顶层环境中。你可以阅读代码，了解mcdf_coverage的例化、虚接口的传递、覆盖率的定义和采样。同时，提供了一个新的test，即mcdf_full_random_test。这个test尽可能的将一些测试相关参数在仿真时进行了随机化。在接下来的仿真中，依然可以复用你之前lab4按照要求创建的几个test，将它们搬迁到lab5中。不过，lab5的要求是，需要最终达到“尽可能高的代码覆盖率和功能覆盖率”。所以结合本次练习最终的验收目标，可以复用你之前的测试用例。当然，在学习了覆盖率相关的课程之后，就懂得了，当最终覆盖率无法提升时，需要修改的约束，或者创建新的test。\n 通过等级：代码覆盖率大于90%，功能覆盖率大于90%。 优秀等级：代码覆盖率大于95%，功能覆盖率等于100%。  测试代码根据后文链接，自行下载。\n文章原创,可能存在部分错误,欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":46,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（八）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-eight/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第七篇，主要介绍类型转换、虚方法、对象拷贝、回调函数和参数化类。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明           类型转换 写在前面  类型转换可以分为 静态转换和动态转换 。 静态转换即需要在转换的表达式前 加上单引号 即可，该方式并不会对转换值做检查。如果发生转换失败，我们也无从得知。 动态转换即需要使用 系统函数$cast(tgt， src) 做转换。 静态转换和动态转换均需要操作符号或者系统函数介入，统称为 显式转换 。 不需要显式操作的转换，我们称之为 隐式转换 。例如赋值语句右侧是4位的矢量，而左侧是5位的矢量，隐式转换会先做位宽扩展(隐式)，然后再做赋值。  动态转换  当我们使用类的时候， 类句柄的向下转换 ，即从父类句柄转换为子类句柄时， 需要 使用$cast() 函数 进行转换， 否则会出现编译错误，这一步也是编译器的保护措施，防止用户出现错误的赋值。 如果将子类句柄赋值给父类句柄时，编译器则认为赋值是合法的，但分别 利用子类句柄和父类句柄调用相同对象的成员时，将可能有不同的表现 。  子类句柄赋值于父类句柄 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Transaction; rand bit[31:0] src; function void display(input string prefix=\u0026#34;\u0026#34;); $display(\u0026#34;%s Transaction: src=%0d\u0026#34;, prefix, src); endfunction endclass class BadTr extends Transaction; bit bad_crc; function void display(input string prefix=\u0026#34;\u0026#34;); $display(\u0026#34;%s BadTr: bad_crc=%b\u0026#34;, prefix, bad_crc); super.display(prefix); endfunction endclass Transaction tr; BadTr bad, bad2;        1 2 3 4 5 6  Transaction tr; BadTr bad; bad=new() ; //构建BadTr扩展对象 tr=bad; //基类句柄指向扩展对象 $display(tr.src) ; //显示基类对象的变量成员 tr.display() ; //??    tr.display() ; 调用的是父类的display。  父类句柄转换为子类句柄 1 2 3  tr=new() ; //创建一个父类对象 bad=tr; //ERROR：编译错误，即便使用cast进行转换，虽然解决编译错误，但是返回值为0，bad仍为空句柄。 $display(bad.bad_crc) ; //bad_crc成员不在父类对象中    将一个父类句柄赋值给一个子类句柄并不总是非法的。 但是SV编译器对这种直接赋值的做法是禁止的，也就是说无论父类句柄是否真正指向了一个子类对象，赋值给子类句柄时，编译(静态)都将出现错误。 因此需要$cast(tgt， src) 来实现句柄类型的动态转换。 $cast(tgt， src) 会检查句柄所指向的对象类型， 而不仅仅检查句柄本身。 一旦源对象跟目的句柄是同一类型，或者是目的句柄的扩展类，$cast() 函数执行即会成功， 返回1， 否贝返回0。       1 2 3 4 5 6 7 8 9  bad=new(); //创建Bad Tr子对象 tr=bad; //父类句柄指向子类对象 //动态类型转换， 检查tr的源对象是否是bad 2类型或者其子类 //如果转换失败，将报告错误信息 if(!$cast(bad2, tr)) $display(\u0026#34;cannot assign tr to bad2\u0026#34;); $display(bad2.bad_crc); //bad 2指向的对象包含band_src成员 bad2.display() ; //??    bad2.display() ; 调用子类的方法。  虚方法 写在前面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class basic_test; int fin; int def = 100; function new() ; $display(\u0026#34;basic_test::new\u0026#34;) ; endfunction task test() ; $display(\u0026#34;basic_test::test\u0026#34;) ; endtask endclass class test_wr extends basic_test; int def = 200; function new() ; super.new() ; $display(\u0026#34;test_wr::new\u0026#34;) ; endfunction task test() ; super.test() ; $display(\u0026#34;test_wr::test\u0026#34;) ; endtask endclass    类的继承是从 继承成员变量和成员方法 两个方面。 从例码中可以看到test_wr类和test_rd类分别继承了basic_test类的成员变量以及成员方法。 除了介绍的类的封装和继承，关于类的 多态性(polymorphism) 也是必须关注的。 正是由于类的多态性，使得用户在设计和实现类时， 不需要担心句柄指向的对象类型是父类还是子类，只要通过虚方法，就可以实现动态绑定(dynamic binding) ， 或者在SV中称之为动态方法查找(dynamic method lookup) 。  非虚函数的调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  basic_test t; test_wr wr; initial begin wr=new() ; t=wr; $display(\u0026#34;wr test starts\u0026#34;) ; wr.test() ; $display(\u0026#34;wr test ends\u0026#34;) ; $display(\u0026#34;t test starts\u0026#34;) ; t.test() ; $display(\u0026#34;t test ends\u0026#34;) ; end //输出结果： // wr test starts // basic_test::test // test_wr::test // wr test ends // t test starts // basic_test::test // t test ends    首先， 在执行wr.test() 时， 由于wr类型为test_wr， 则索引到的test() 应该为test_wr类的方法test。 同时， 由于在test_wr::test中显式调用了super.test() ， 则会先执行basic_test::test， 然后再执行test_wr::test中其余的代码。 这里值得注意的是， 默认情况下， 子类覆盖(override) 的方法并不会继承父类同名的方法， 而只有通过super.method()的方式显式执行，才会达到继承父类方法的效果，初学SV的用户容易在这里混淆方法覆盖和类继承的概念。 当wr对象的句柄传递给t后， 由于t本身是basic_test类， 所以，在执行t.test时， t只会搜寻basic_test::test方法。 （多态的问题是什么？在句柄传递中，子类句柄赋值给父类句柄，调用同名函数时，子类句柄调用的是子类函数，父类句柄调用的是父类函数，即便把子类句柄赋值给了父类句柄，也无法通过父类句柄调用子类函数）       虚函数的调用  我们将已经在编译阶段就可以确定下来调用方法所处作用域的方式称之为静态绑定(static binding) ， 而与之相对的是动态绑定。 动态绑定指的是，在调用方法时，会 在运行时来确定句柄指向对象的类型，再动态指向应该调用的方法 。 为了实现动态绑定， 我们将basic_test::test定义为虚方法。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class basic_test; ... virtual task test(stm_ini ini) ; $display(\u0026#34;basic_test::test\u0026#34;) ; endtask ... endclass //wr test starts只做了这么一个改动以后，我们重复运行之前的测试代码，可以看到运行结果变为： // wr test starts // basic_test::test // test_wr::test // wr test ends // t test start.s // basic_test::test // test_wr::test // t test ends    由于声明了basic_test::test为虚方法， 系统在执行t.test时，会检查t所指向对象的类型为test_wr类， 进而调用test_wr::test。 于是， 输出结果与调用wr.test一致。 我们就可以通过虚方法的使用来实现类成员方法调用时的动态查找，用户无需担心使用的是父类句柄还是子类句柄，因为最终都会实现动态方法查找，执行正确的方法。       虚方法的建议  在为父类定义方法时，如果该方法 日后可能会被覆盖或者继承 ，那么应该声明为虚方法。 虚方法如果要定义，应该 尽量定义在底层父类中 。这是因为如果virtual是声明在类继承关系的中间层类中， 那么只有从该中间类到其子类的调用链中会遵循动态查找，而最底层类到该中间类的方法调用仍然会遵循静态查找。 虚方法 通过virtual声明， 只需要声明一次即可 。例如上面代码中，只需要将basic_test::test声明为virtual， 而 其子类则无需再次声明 ，当然再次声明来表明该方法的特性也是可以的。 虚方法的继承也需要 遵循相同的参数和返回类型 ，否则，子类定义的方法须归为同名不同参的其它方法。  为什么使用虚方法  首先：当 父类指针指向子类对象 ，如果不将test函数声明为虚函数，最终调用的是父类test函数；如果将test函数声明为虚函数，那么调用的是子类test函数。 为什么要用父类指针指向子类对象呢？用子类指针指向子类对象不好吗？虽然这样说，但是实际开发过程中不是这样的，当我们使用一些类库、框架的时候，这些类库、框架是事先就写好的。我们在使用的时候不能直接修改类库的源码，我们只能派生类库中的类来覆盖一些成员函数以实现我们的功能，但这些成员函数有的是由框架调用的。这种情况下，用虚函数是很好的办法。  对象拷贝 写在前面  对于拷贝(copy) ， 对象的拷贝要比其它SV的变量类型都让人“当心”。 因为就SV普通的变量拷贝而言，只需要通过赋值操作符“=”就足够了。 而对象的拷贝则无法通过“=”来实现，因为这一操作是句柄的赋值，而不是对象的拷贝。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  test_wr h; initial begin wr = new(); h = wr; $display(\u0026#34;wr.def=%Od\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); h.def = 300; $display(\u0026#34;wr.def=%Od\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); end //输出结果： // wr.def = 200 // h.def = 200 // wr.def = 300 // h.def = 300         在h=wr之后，由于是句柄的赋值，所以h.def=300的操作， 实际上是对这两个句柄指向的共同对象做的成员变量赋值。所以，从最终打印的结果可以看出，wr.def与h.def的值相同。 那么如果要拷贝对象，指的是首先创建一个新的对象(开辟新的空间)，再将目标对象的成员变量值拷贝给新对象的成员，这就使得新对象与目标对象的成员变量数值保持一致，即完成了对象的拷贝(成员变量的拷贝)。 初学者需要区别句柄拷贝与对象拷贝的区别。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class basic_test; //父类  ... virtual function void copy_data(basic_test t) ; t.def=def; t.fin=fin; endfunction virtual function basic_test copy() ; basic_test t=new(0) ; //创建父类对象  copy_data(t) ; return t; endfunction endclass class test_wr extends basic_test; //子类  ... function void copy_data(basic_test t) ; test_wr h; super.copy_data(t) ; $cast(h, t); //关键代码，句柄转化  h.def=def; endfunction function basic_test copy() ; test_wr t=new() ; //创建子类对象  copy_data(t) ; return t; endfunction endclass   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  module tb; .... test_wr wr; //子类  test_wr h; //子类  initial begin wr=new() ; $cast(h, wr.copy()); //copy会返回父类句柄，所以这里将父类句柄转化为子类句柄  $display(\u0026#34;wr.def=%0d\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); h.def=300; $display(\u0026#34;wr.def=%0d\u0026#34;, wr.def); $display(\u0026#34;h.def=%0d\u0026#34;, h.def); end ... endmodule //输出结果： // wr.def=200 // h.def=200 // wr.def=200 // h.def=300   赋值和拷贝  声明变量和创建对象是两个过程，也可以一步完成。  Packet pl; p1=new;   如果将p1赋值给另外一个变量p2，那么依然只有一个对象，只是指向这个对象的句柄有p1和p2. 以下这种方式表示p1和p2代表两个不同的对象。在创建p2对象时， 将从p 1拷贝其成员变量例如integer、string和句柄等， 该种拷贝方式称为浅拷贝(shallowcopy) 。   1 2 3 4  Packet pl; Packet p2; p1=new; p2=new p1;   总结  将成员拷贝函数copy_data() 和新对象生成函数copy() 分为两个方法，这样使得子类继承和方法复用较为容易。 为了保证父类和子类的成员均可以完成拷贝，将拷贝方法声明为虚方法，且遵循只拷贝该类的域成员的原则，父类的成员拷贝应由父类的拷贝方法完成。 在实现copy_data() 过程中应该注意句柄的类型转换， 保证转换后的句柄可以访问类成员变量。  回调函数 写在前面  理想的验证环境是在被移植做水平复用或者垂直复用时，应当尽可能少地修改模块验证环境本身，只在外部做少量的配置，或者定制化修改就可以嵌入到新的环境中。 要做到这一点，一方面我们可以通过顶层环境的配置对象自顶向下进行配置参数传递，另外一方面我们可以在测试程序不修改原始类的情况下注入新的代码。 例如， 当我们需要修改stimulator的行为时， 有两种选择， 一个是修改父类，但针对父类的会传播到其它子类；另外一个选择是，在父类定义方法时，预留回调函数入口，使得在继承的子类中填充回调函数，就可以完成对父类方法的修改。       实例  示意：   1 2 3 4 5 6 7 8  virtual class Driver_cbs; //Driver回调虚类  virtual task pre_tx(ref Transaction tr, ref bit drop) ; //默认不做操作  endtask virtual task post_tx(ref Transaction tr) ; //默认不做操作  endtask endclass    实例：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  class Driver; Driver_ebs cbs[$]; task run() ; bit drop; Transaction tr; forever begin drop=0; agt2drv.get(tr) ; foreach(ebs[il) cbs[il.pre_tx(tr, drop) ; if(drop) continue; transmit(tr) ; foreach(cbs[il) cbs[i] .post_tx(tr) ; end endtask endclass class Driver_cbs_drop extends Driver_abs; virtual task pre_tx(ref Transaction tr, ref bit drop) ; //1/100的传输事务丢弃概率  drop=($urandom range(0, 99) ==0) ; endtask endclass program automatic test; Environment env; initial begin env=new() ; env.gen_cfg() ; env.build() ; begin//创建回调对象井且植入driver  Driver_abs_drop dcd=new() ; env.drv.cbs.push_back(dcd) ; end env.run() ; env.wrap_up(); end endprogram   完成回调函数功能需要三步：  预留回调函数入口 定义回调的类和回调函数 例化和添加回调的类  参数化类 写在前面  参数化的使用是为了提高代码的复用率。 无论是设计还是验证，如果代码会被更多的人使用或者被更多的项目所采用，那么就需要考虑使用参数来提高复用率。 参数的使用越合理，后期维护的成本就会相应降低。 在硬件设计中，参数往往是整型，例如端口数目或者位宽。在验证环境中，参数的使用更加灵活，可以使用各种类型来做类定义时的参数。 在SV中，可以为类增加若干个数据类型参数，并在声明类句柄的时候指定类型。 SV的类参数化近似于C++中的模板。  实现一个简化的mailbox 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class mailbox; local int queue[$] ; task put(input int i) ; queue.push_back(i) ; endtask task get(ref int o) ; wait(queue.size() \u0026gt;0) ; o=queue·pop_front() ; endtask task peek(ref int o) ; wait(queue.size() \u0026gt;0) ; o=queue[0] ; endtask endclass    这个简化的mailbox的问题在于它只能用于操作整数类型。 如果要存储real类型， 或者某一个类的句柄，那么就得复制该类，然后将数据类型由int类型转换为real类型或者某一个类的类型。 这样将导致类的快速增长，而且是重复代码的大规模增长，代码维护将变得冗长乏味而且还容易出错。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class mailbox #(type T=int) ; local T queue[$] ; task put(input T i) ; queue.push_back(i) ; endtask task get(ref T o) ; wait(queue.size() \u0026gt;0) ; o=queue.pop_front() ; endtask task peek(ref T o) ; wait(queue.size() \u0026gt;0) ; o=queue[Ol; endtask endclass initial begin real o; mailbox #(real) mb; //创建一个存储real类型的mailbox  mb=new() ; for(inti=0; i\u0026lt;5; i++) mb.put(i*2.0) ; //将real值存储入mb  for(inti=0; i\u0026lt;5; i++) mb.get(o) ; //从mb取出real值 end    在类定义时添加参数#(typeT=int) ， 这表示后期类在声明变量时如果不指定参数类型， 则默认采用int类型。 将原代码int用参数T来代替。 参数化的类将可以在后期例化时使用不同的参数，以此来存储不同的数据类型。  文章原创,可能存在部分错误,欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":47,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（七）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-seven/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第六篇，主要介绍覆盖率类型、功能覆盖策略、覆盖组、数据采样、覆盖选项和数据分析。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明           覆盖率类型 写在前面  覆盖率是 衡量设计验证完备性 的一个通用词。 随着测试逐步覆盖各种合理的场景，仿真过程会慢慢勾画出你的设计情况。 覆盖率工具会 在仿真过程中收集信息 ，然后进行后续处理并且得到覆盖率报告。 通过这个报告找出覆盖之外的盲区，然后修改现有的测试或者创建新的测试来填补这些盲区。 这个过程可以一直迭代进行，直到你对覆盖率满意为止。  可以使用一个反馈回路来分析覆盖率的结果，并决定采取哪种行动来达到100%的覆盖率。 首要的选择是使用更多的种子来运行现有的测试程序。 当大量种子依然对于覆盖率增长没有帮助时，需要建立新的约束。 只有在确实需要的时候才会求助于创建定向测试。         代码覆盖率   不添加任何额外的HDL代码，工具会通过分析源代码和增加隐藏代码来自动完成代码覆盖率的统计。\n  当运行完所有测试，代码覆盖率工具便会创建相应的数据库。\n  仿真器都带有代码覆盖率的工具，覆盖率数据也可被转换为可读格式。\n  行覆盖率：多少行代码已经被执行过。\n  路径覆盖率：在穿过代码和表达式的路径中有哪些已经被执行过。\n  翻转覆盖率：哪些单位比特变量的值为0或1。\n  状态机覆盖率：状态机哪些状态和状态转换已经被访问过。\n  代码覆盖率最终的结果用于衡量你执行了设计中的多少代码。\n  关注点应该放在设计代码的分析上，而不是测试平台。\n  未经测试的设计代码里可能隐藏硬件漏洞，也可能仅仅就是冗余的代码。\n  代码覆盖率衡量的是测试对于硬件设计描述的”实现”究竟测试得有多彻底，而非针对验证计划。\n  代码覆盖率达到了100%，并不意味着验证的工作已经完成，但代码覆盖率100%是验证工作完备性的必要条件。\n  断言覆盖率  断言是用于一次性地或在一段时间对一个或者多个设计信号在逻辑或者时序上的声明性代码。 断言可以跟随设计和测试平台一起仿真，也可以被形式验证工具所证实。 你可以使用SV的程序性代码编写等效性检查， 但使用SVA(SV断言)来表达会更容易。 断言最常用于查找错误，例如两个信号是否应该互斥，或者请求与许可信号之间的时序等。 一旦检测到问题，仿真就可以立即停止。 有些断言可以用于查找感兴趣的信号值或者设计状态。 可以使用cover property来测量这些关心的信号值或者状态是否发生。 在仿真结束时，仿真工具可以自动生成断言覆盖率数据。 断言覆盖率数据以及其它覆盖率数据都会被集成在同一个覆盖率数据库中，verifier可以对其展开分析。  功能覆盖率  验证的目的就是确保设计在实际环境中的行为正确。 功能描述文档详细说明了设计应该如何运行，而验证计划则列出了相应的功能应该如何激励、验证和测量。 当你收集测量数据希望找出那些功能已经被覆盖时，你其实就是在计算”设计”的覆盖率。 功能覆盖率是和功能设计意图紧密相连的，有时也被称为”描述覆盖率”，而代码覆盖率则是衡量设计的实现情况。 某个功能在设计中可以被遗漏，代码覆盖率不能发现这个错误，但是功能覆盖率可以。        每一次仿真都会产生一个带有覆盖率信息的数据库，记录随机游走的轨迹。 把这些信息全部合并在一起就可以得到功能覆盖率，从而衡量整体的进展程度。 通过分析覆盖率数据可以决定如何修改回归测试集。 如果覆盖率在稳步增长，那么添加新种子或者加长测试实际即可。 如果覆盖率增速放缓，那么需要添加额外的约束来产生更多”有意思”的激励。 如果覆盖率停止增长，然而设计某些测试点没有被覆盖到，那么就需要创建新的测试了。 如果覆盖率为100%但依然有新的设计漏洞，那么覆盖率可能没有覆盖到设计中的某些设计功能区域。  漏洞率曲线  在一个项目实施期间，你应该保持追踪每周有多少个漏洞被发现。 一开始，当你创建测试程序时，通过观察可能就会发现很多漏洞。 当设计逐渐稳定时，你需要利用自动化的检查方式来协助发现可能的漏洞。 在设计临近流片时，漏洞率会下降，甚至有望为零。即便如此，验证工作仍然不能结束。 每次漏洞率下降时，就应该寻找各种不同的办法去测试可能的边界情况(corner case)。 漏洞率可能每周都有变化，这跟很多因素都有关。不过漏洞率如果出现意外的变化，可能预示着潜在的问题。  功能覆盖策略 收集信息而非数据  比如MCDF， 你需要关心的是合法的寄存器地址和非法的寄存器地址，可写的寄存器域和非法的寄存器域，而不是具体的寄存器地址数值。 一旦关注的地方着眼于感兴趣的状态，而不是具体数值，那么这对于你如何定义功能覆盖率，以及如何收集信息会减轻很大的负担。 设计信号如果数量范围太大，应该拆分为多个小范围再加上边界情况。  只测量需要的内容  Verifier需要懂得， 在使能覆盖率收集时， 这一特性会降低很大的仿真性能。 由于收集功能覆盖率数据的开销很大，所以应该只测量你会用来分析并且改进测试的那部分数据。 同时也需要设定合理的覆盖率采样的事件，一方面提升采样效率，一方面也可以降低收集覆盖率的开销。  验证的完备性  完备的覆盖率测量结果和漏洞增长曲线，可以帮助确认设计是否被完整地验证过。 如果代码覆盖率低但功能覆盖率高，这说明验证计划不完整，测试没有执行设计的所有代码。 如果代码覆盖率高但功能覆盖率低，这说明即使测试平台很好地执行了设计所有代码，但是测试还是没有把设计定位到所有感兴趣的状态上。 你的目标是同时驱动高的代码覆盖率和功能覆盖率。       覆盖组 写在前面  覆盖组(covergroup) 与类相似， 一次定义后便可以多次实例化。 covergroup可以包含一个或者多个coverpoint， 且全都在同一时间采集。 covergroup可以定义在类中，也可以定义在interface或者module中。 covergroup可以采样任何可见的变量，例如程序变量、接口信号或者设计端口。 一个类里可以包含多个covergroup。 当你拥有多个独立的covergroup时， 每个covergroup可以根据需要自行使能或者禁止。 每个covergroup可以定义单独的触发采样事件，允许从多个源头收集数据。 covergroup必须被例化才可以用来收集数据。  在类里定义covergroup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Transactor; Transaction tr; mailbox mbx_in; covergroup CovPort; coverpoint tr.port; endgroup function new(mailbox mbx_in) ; //CovPort = new() ;  CovPort cg1 = new() ; //使用这种例化方式可以给对象设定名字  this.mbx_in=mbx_in; endfunction task main; forever begin tr=mbx_in.get; ifc.cb.port \u0026lt;= tr.port; ifc.cb.data \u0026lt;= tr.data; CovPort.sample() ; end endtask endclass    covergroup由采样的数据和数据被采样的事件构成。 当这两个条件都准备好以后，测试平台便会触发covergroup。 这个过程可以通过直接使用sample() 函数完成， 也可以在covergroup中采样阻塞表达式或者使用wait或@实现在信号或事件上的阻塞。 如果你希望在代码中显式地触发covergroup采样， 或者不存在采样时刻的信号或事件， 又或者一个covergroup被例化为多个实例需要单独触发， 那么可以使用sample()方法。 如果你想借助已有的事件或者信号触发covergroup， 可以在covergroup声明中使用阻塞语句。   1 2 3 4  event trans_ready; covergroup CovPort @(trans_ready); coverpoint ifc.cb.port; endgroup    与直接调用sample() 相比， 使用事件触发的好处在于你能够借助已有的事件。  数据采样 写在前面  当你在coverpoint指定采样一个变量或表达式时， SV会创建很多的”仓(bin) ”来记录每个数值被捕捉到的次数。 这些bin是衡量功能覆盖率的基本单位。 covergroup中可以定义多个coverpoint， coverpoint中可以自定义多个cover bin或者SV帮助自动定义多个cover bin（建议自己定义，原因有两点：一是工具可能会多定义其他的bin，二是工具定义的bin不能很好的命名，基于这两点，自己定义bin在覆盖率分析时更容易）。 每次covergroup采样， SV都会在一个或者多个cover bin中留下标记， 用来记录采样时变量的数值和匹配的cover bin。 在仿真之后，可以使用分析工具读取这些数据库来生成覆盖率报告，包含了各部分和总体的覆盖率。  coverpoint和bin  为了计算一个coverpoint上的覆盖率， 首先需要确定可能数值的个数，这也被称为域。 覆盖率就是采样值的数目除以bin的数目。例如一个3比特变量的域是0：7， 正常情况下会自动分配8个bin。如果仿真过程中有7个值被采样到， 那么最终该coverpoint的覆盖率是7/8。 所有的coverpoint的覆盖率最终构成一个covergroup的覆盖率。 所有的covergroup的覆盖率构成了整体的功能覆盖率。  bin的创建和应用  SV会默认为某个cover point创建bin， 用户也可以自己定义bin的采样域。 如果采样变量的域范围过大而又没有指定bin， 那么系统会默认分配64个bin， 将值域范围平均分配给这64个bin。 用户可以通过covergroup的选项auto_bin_max来指定自动创建bin的最大数目（默认64）。 实际操作中， 自动创建bin的方法不实用， 建议用户自行定义bin，或者减小auto_bin_max的数值。   1 2 3 4 5  covergroup CovPort; options.auto_bin_max=8; //所有cover point auto_bin数量=8  coverpoint tr.port {options.auto_bin_maxm 2; } //特定cover point auto_bin数量=2 endgroup   命名coverpoint和bin 1 2 3 4 5 6 7 8  covergroup CovKind; coverpoint tr.kind{ bins zero=(0) ; //1个仓代表kind==0  bins lo=([1：3] ， 5) ; //1个仓代表1:3和5  bins hi[] =([8：S] 1; //8个独立的仓代表8:15  bins misc=default; //1个仓代表剩余的所有值  }//没有分号 endgroup    注意coverpoint定义使用{} 而不是begin\u0026hellip;end。大括号的结尾没有带分号， 这和end一样。  条件覆盖率  可以使用关键词iff给coverpoint添加条件。 这种做法常用于在复位期间关闭覆盖以忽略不合理的条件触发。 也可以使用start和stop函数来控制covergroup各个独立实例。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  covergroup CoverPort; coverpoint port iff (!bus_if.reset); endgroup //===========================================  initial begin CovPort ck = new(); #1ns; ck.stop(); bus_if.reset=1; #100ns bus_if.reset=0; ck.start(); ck.sample(); end   翻转覆盖率  coverpoint也可以用来记录变量从A值到B值的跳转情况。 还可以确定任何长度的翻转次数。   1 2 3 4 5  covergroup CoverPort; coverpoint port { bins t1 = (0=\u0026gt;1), (0=\u0026gt;2), (0=\u0026gt;3); } endgroup   wildcard覆盖率  可以使用关键字wildcard来创建多个状态或者翻转。 在表达式中，任何x，z或者?都会被当成0或1的通配符。   1 2 3 4 5 6 7  bit [2:0] port; covergroup CoverPort; coverpoint port{ wildcard bins even={3\u0026#39;b??0}; wildcard bins odd={3\u0026#39;b??1} } endgroup   忽略bin  在某些coverpoint可能始终无法得到全部的域值。 对于那些不计算功能的域值可以使用ignore_bins来排除， 最终它们并不会计入coverpoint的覆盖率。   1 2 3 4 5  bit[2:0] low_ports_0_5; //只使用数值0-5 covergroup CoverPort; coverpoint low_ports_0_5 { ignore_bins hi={[6, 7]}; //忽略数值6-7 endgroup   非法的bin  有些采样值不仅应该被忽略，而且如果出现还应该报错。 这种情况可以在测试平台中监测， 也可以使用illegal_bins对特定的bin进行标示。   1 2 3 4 5 6  bit[2:0] low_ports_0_5; //只是用数值0-5 covergroup CoverPort; coverpoint low_ports_0_5{ illegal_bins hi={[6, 7]}; //如果出现6-7便报错  } endgroup   交叉覆盖率  coverpoint是记录单个变量或者表达式的观测值。 如果想记录在某一时刻，多个变量之间值的组合情况，需要使用交叉(cross) 覆盖率。 cross语句只允许带coverpoint或者简单的变量名。   1 2 3 4 5 6 7 8 9 10 11  class Transaction; rand bit[3：0] kind; rand bit[2：0] port; endclass Transaction tr; covergroup CovPort; kind: coverpoint tr.kind; //kind是coverpoint名称  port: coverpoint tr.port; //port是coverpoint名称  cross kind, port; endgroup   排除部分cross bin  通过使用ignore bins、binsof和intersect分别指定coverpoint和值域， 这样可以清除很多不关心的cross bin。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  covergroup Covport; port: coverpoint tr.port { bins port[] = {[O:$]}; } kind: coverpoint tr.kind { bins zero = {0}; bins lo = {[1:3]}; bins hi[] = {[8:$]}; bins misc = default; } cross kind, port { ignore_bins hi = binsof(port) intersect {7}; ignore_bins md = binsof(port) intersect {0} \u0026amp;\u0026amp; binsof(kind) intersect {[9:11]}; ignore_bins lo = binsof(kind.lo); } endgroup    原来port有8个bin，kind有11个bin，正常cross会产生88个bin，通过ignore_bins，hi排除了11个，md排除了3个，lo排除了24个。具体自行分析。  指定精细的交叉覆盖率  随着cross覆盖率越来越精细， 可能需要花费不少的时间来指定哪些bin应该被使用或者被忽略。 更适合的方式是不使用自动分配的cross bin， 而自己声明感兴趣的cross bin。 假如有两个随机变量a和b，它们带着三种感兴趣的状态，(a==0，b==0)、(a==1、b==0)和(b==1)。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Transaction; rand bit a, b; endclass covergroup CrossBinNames; a: coverpoint tr.a { bins a0 = {0}; bins a1 = {1}; option.weight=0; } //不计算覆盖率  b: coverpoint tr.b { bins b0 = {0}; bins b1 = {1}; option.weight=0; } //不计算覆盖率  ab: cross a, b { bins aOb0 = binsof(a.a0) \u0026amp;\u0026amp; binsof(b.b0); bins a1b0 = binsof(a.a1) \u0026amp;\u0026amp; binsof(b.b0); bins b1 = binsof(b.bl);} endgroup   1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Transaction; rand bit a, b; endclass covergroup CrossBinsofIntersect; a: coverpoint tr.a { option.weight=0; } //Do nOt count this cover point  b: coverpoint tr.b { option.weight=0; } //Do nOt count this cover point  ab: cross a, b { bins aOb0 = binsof(a) intersect{O} \u0026amp;\u0026amp; binsof(b) intersect{O}; bins alb0 = binsof(a) intersect{1} \u0026amp;\u0026amp; binsof(b) intersect{O}; bins b1 = binsof(b) intersect{1}; } endgroup   覆盖选项 单个实例的覆盖率  如果对一个covergroup例化多次， 那么默认情况下SV会将所有实例的覆盖率合并到一起。如果需要单独列出每个covergroup实例的覆盖率，需要设置覆盖选项。   1 2 3 4  covergroup CoverLength; coverpoint tr.length; option.per_instance=l; //每个实例单独收集 endgroup   注释  如果有多个covergroup实例， 可以通过参数来对每一个实例传入单独的注释。这些注释最终会显示在覆盖率数据的总结报告中。   1 2 3 4 5 6 7 8 9 10 11 12  covergroup CoverPort(int lo, hi, string comment); option.comment = comment; option.per_instance = 1; coverpoint port { bins range= {[lo:hi]}; } endgroup ... CoverPort cp_lo = new(0, 3, \u0026#34;Low port numbers\u0026#34;); CoverPort cp_hi = new(4, 7, \u0026#34;High port numbers\u0026#34; ;   覆盖次数限定  默认情况下， 数值采样了1次就可以计入有效的bin。可以通过修改atleast来修改每个bin的数值最少的采样次数， 如果低于at_least数值， 则不会被计入bin中。 option.at_least可以在covergroup中声明来影响所有的coverpoint，也可以在coverpoint中声明来只影响该coverpoint下所有的bin。 一般会使用默认的1，除非有特殊要求。  覆盖率目标  一个covergroup或者一个coverpoint的目标是100%覆盖率。 不过你也可以将其设置为低于100%的目标。这个选项只会影响覆盖率报告。 一般会使用默认的100，除非有特殊要求。   1 2 3 4  covergroup CoverPort; coverpoint port; option.goal=90; endgroup   covergroup方法  sample() ： 采样。 get_coverage() /get_inst_coverage() ： 获取覆盖率，返回0-100的real数值。 set_inst_name(string) ： 设置cover group的名称。 start() /stop() ： 使能或者关闭覆盖率的收集。  数据分析  使用$get_coverage() 可以得到总体的覆盖率。 也可以使用covergroup_inst.get_inst_coverage() 来获取单个covergroup实例的覆盖率。 这些函数最实际的用处是在一个测试当中监测覆盖率的变化。 如果覆盖率水平在一段时间之后没有提高，那么这个测试就应该停止。 重启新的随机种子或者测试可能有望提高覆盖率。 如果测试可以基于功能覆盖率采取一些深入的行动，例如重新限定随机的约束，那将是一件非常好的事情，但是这种测试很难编写。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":48,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（六）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-six/"},{"content":"本文 主要介绍emacs org-model 的使用方法。\n   版本 说明     0.1 初版发布   0.2 添加Org-Mode导出如何禁用下划线转下标   0.3 添加代码块的介绍    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  博客园：Org-mode 简明手册 神器中的神器org-mode之入门篇  什么是org-mode？ org-mode 是文本编辑器Emacs中一种支持内容分级显示的编辑模式。这种模式支持写 To-Do 列表，日志管理，做笔记，做工程计划或者写网页。\n安装 emacs 23以后默认自动安装 org-mode ，如果想安装最新版，可以手动下载安装包或通过emacs包管理器进行安装。手动下载和安装请参考org-mode下载页面。\n大纲 org-mode强大的操作能力源于它对大纲的支持。\n标题 文章中的标题可以通过 #+TITTLE: 来设置标题； 正文中的标题可以通过*，一个*表示一级，两个*表示二级标题。如：\n1 2 3 4  #+TITLE: emacs org-mode 的使用 *这是一个一级标题 ** 这是一个二级标题 *** 以此类推（最多10个*）   注意： ‘*’要位于行首；‘*’后面要有一个空格。\n大纲相关的快捷键 折叠    快捷键 说明     S-TAB 循环切换 整个文档 的大纲状态（三种状态：折叠，打开下一级，打开全部）   TAB 循环切换光标 所在大纲 的状态 （三种状态：折叠，打开下一级，打开全部）    大纲间移动    快捷键 说明     C-c C-n/p 下/上一标题   C-c C-f/b 下/上一标题（仅限同级标题）   C-c C-u 跳到上一级标题   C-c C-j 切换到大纲浏览状态    基于大纲的编辑    快捷键 说明     M-RET 插入一个同级标题   M-S-RET 插入一个同级TODO标题   M-LEFT/RIGHT 将当前标题升/降级   M-S-LEFT/RIGHT 将子树升/降级   M-S-UP/DOWN 将子树上/下移   C-c * 将本行设为标题/正文   C-c C-w 将子树或区域移动到另一标题处（跨缓冲区）   C-x n s/w 只显示当前子树/返回   C-c C-x b 在新缓冲区显示当前分支（类似C-x n s)   C-c / 只列出包含搜索结果的大纲，并高亮，支持多种搜索方式   C-c C-c 取消高亮    关于大纲显示 org的大纲显示模式会对不同级标题采用不同颜色显示，但是默认的大纲显示没有缩进，如果想添加缩进显示，可以用M-x，输入org-indent-mode。如果想让某个文件默认用这种方式打开，可以在文件头部增加：\n1  #+STARTUP: indent   如果希望打开所有org文件都默认用这种方式，可以在.emacs或.emacs.d/init.el中添加如下配置：\n1  (setq org-startup-indented t)   轻量级标记语言 Org现在已经成为一种专门的轻量级标记语言，与Markdown、reStructedText、Textile、RDoc、MediaWiki等并列。\n段落 可能我们习惯了回车下一行开启新的段落，而在org-mode中，需要回车两次，也就是段落间需要用空行隔开。\n字体 *粗体* /斜体/ +删除线+ _下划线_ 下标： H_2 O 上标： E=mc^2 等宽字： =git= 或者 ～git～ （ox-hugo并未将org中上下标的语法转为markdown，暂时没有解决方案）\n列表 列表语法  无序列表以\u0026rsquo;-'、\u0026lsquo;+'或者\u0026rsquo;*\u0026lsquo;开头 有序列表以\u0026rsquo;1.\u0026lsquo;或者\u0026rsquo;1)\u0026lsquo;开头 描述列表用\u0026rsquo;::\u0026rsquo; 列表层级用缩进体现  注意事项： 列表符号后面都要有空格；同级别的列表缩进要相同；空两行之后列表结束；\n举例如下：\n1 2 3 4 5 6  + treeroot + branch1 + branch2 + treeroot 1) branch1 2) branch2   列表快捷键    快捷键 说明     TAB 折叠列表项   M-RET 插入项   M-S-RET 插入带复选框的项   M-S-UP/DOWN 移动列表项   M-LEFT/RIGHT 升/降级列表项，不包括子项   M-S-LEFT/RIGTH 升/降级列表项，包括子项   C-c C-c 改变复选框状态   C-c - 更换列表标记（循环切换）    表格 表格语法 任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。一个表格是下面的样子：\n1 2 3  | Name | Height | Weight | Age | |----------+--------+--------+-----| | Abcdefgh | 178 | 123 | 18 |   创建表格时，首先输入表头（如下），然后在第二行按Tab键，会自动补全表格框架。表格的标题声明可有可无，看个人需求。\n1 2 3  #+CAPTION: 表格的标题 | Name | Height | Weight | Age| |-   有时候，表格的某一项特别的长，你可以在任意一个表格的空白项内输入数字来限制其所在列的长度，可以可以通过l、c、r来设置左中右对齐（默认左对齐）。比如(=\u0026gt;代表内容隐藏内容，实际为Abcedfgh)：\n1 2 3 4  | \u0026lt;5\u0026gt; | \u0026lt;l5\u0026gt; | \u0026lt;r5\u0026gt; | \u0026lt;c5\u0026gt; | | Name | Hei=\u0026gt; | Wei=\u0026gt; | Age | |-------+-------+-------+-------| | Ab=\u0026gt; | | | |   列表快捷键    快捷键 说明     C-c 竖线 创建或转换成表格   快捷键 说明   C-c C-c 调整表格，不移动光标   TAB 移动到下一区域，必要时新建一行   S-TAB 移动到上一区域   RET 移动到下一行，必要时新建一行   M-LEFT/RIGHT 移动列   M-UP/DOWN 移动行   M-S-LEFT/RIGHT 删除/插入列   M-S-UP/DOWN 删除/插入行   C-c - 添加水平分割线   C-c RET 添加水平分割线并跳到下一行   C-c ^ 根据当前列排序，可以选择排序方式    缺陷 目前表格不支持拆分和合并，只能使用如下格式替代。\n| 一级部门 | 二级部门 | 人数 | |----------+----------+------| | A | A.1 | 5 | | | A.2 | 6 | |----------+----------+------| | B | B.1 | 7 | | | B.2 | 3 | 分隔线 三条短线或以上显示为分隔线。‘\u0026mdash;’\n链接（图片与网址） 链接语法 链接用于链接一些资源地址，如图片、文件、URL等。如下（可省略链接描述）：\n1 2 3  [[http://orgmode.org/orgguide.pdf][grgguid.pdf]]] [[file:/home/maple/图片/test.jpg][a picture]] [[file:/home/maple/图片/test.jpg]]   直接显示的图片在Emacs里默认不显示，需按C-c C-x C-v才能显示，在输出成其他格式（html、pdf……）后也能看到。\n设置图片大小和标题 1 2 3  #+ATTR_HTML: width 100% #+CAPTION: Black Boy [[https://raw.githubusercontent.com/cao-arvin/image/master/01-Software-Install/BlackBoy-01.jpg]]   链接快捷键    快捷键 说明     C-c C-l 插入链接和说明   C-c C-x C-v 显示链接图片    标签 Tag的作用 对于信息的管理，有分类(category)和标签(tag)两种方式。这两种方式各有特点：通常分类是固定的，很少变化，而tag随时可以增加。分类通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。所以，这两种方式通常结合起来使用。\n标记Tag 在Org-mode中，可以对标题增加tag标记。标记的格式如下：\n1  标题 :标记1标记2:标记3:   而且Org-mode的标签自动按照大纲树的结构继承。即子标题自动继承父标题的标签。比如：\n1 2 3  *Meeting with the French group :work: ** Summary by Frank :boss:notes: ***TODO Prepare slides for him :action:   则最后一行标题具有 work, boss, notes, action 四个标签。如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：\n1  #+FILETAGS: :Peter:Boss:Secret:   如果手工输入标签，在标题后设置标签，键入\u0026rsquo;:\u0026lsquo;后，M-Tab自动提供标签的补齐。更方便的做法是在正文部分用C-c C-q 或直接在标题上用C-c C-c创建标签，这种方式可以列出所有预定义的标签以便选取。\n预定义Tag 预定义的方式有两种：\n 在当前文件头部定义，这种方式预定义的标签只能在当前文件中使用，每项之间必须用空格分隔，可以在括号中定义一个快捷键；花括号里的为标签组，只能选择一个，对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效：   1  #+TAGS: { 桌面(d) 服务器(s) } 编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)    在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：   1 2 3 4 5 6 7 8 9  (setq org-tag-alist \u0026#39;( (:startgroup . nil) (\u0026#34;桌面\u0026#34; . ?d) (\u0026#34;服务器\u0026#34; . ?s) (:endgroup . nil) (\u0026#34;编辑器\u0026#34; . ?e) (\u0026#34;浏览器\u0026#34; . ?f) (\u0026#34;多媒体\u0026#34; . ?m) ))   Tag搜索 Tag搜索快捷键    快捷键 说明     C-c \\ 按tag搜索标题   C-c / m 搜索并按树状结构显示   C-c a m 按标签搜索多个文件（需要将文件加入全局agenda)    逻辑表达式限制条件 + 和 a+b 同时有这两个标签 - 排除 a-b 有 a 但没有 b | 或 a|b 有 a 或者有 b \u0026amp; 和 a\u0026amp;b 同时有 a 和 b，可以用“+”替代 在查询视图中 C-c C-c 退出。\nGTD（时间任务管理） 请参考org-mode，最强的任务管理利器，没有之一。我暂时并未使用org-mode进行时间任务管理，待使用后将总结进行补充。其实时间任务管理工具有很多，包括手机移动端，不一定非要使用emacs，不过emacs精神就是用emacs做一切。我用org-mode主要是做笔记和写博客，通过ox-hugo转为hugo识别的markdown文档，再通过hugo生成站点文件。\nOrg-Mode导出如何禁用下划线转下标 更多时候我们需要将org文件导出为pdf或html文件，这就会遇到一个问题，emacs org mode会将下划线转为下标格式，对导出的文件浏览很有影响。解决这个问题可参考如下两个方法：\n 在org文件添加OPTIONS：   1  #+OPTIONS: ^:nil    在配置文件（.emacs/init.el）添加如下设置：   1  (setq org-export-with-sub-superscripts nil)   代码块 对于程序员来讲，写文章时免不了需要展示代码，org-mode的代码块的关键字是“#+BEGIN_SRC \u0026hellip; #+END_SRC” ，在SRC后指明语言，可以支持缩进和语法高亮显示。示例如下（为了展示完整代码，对代码块关键字使用//进行了注释）：\n1 2 3 4 5 6 7 8 9  //#+BEGIN_SRC verilog  module tb; reg clk; initial begin clk = 1\u0026#39;b0; end always #5 clk = ~clk; endmodule //#+END_SRC    高亮显示：如果在org-mode编辑时代码不支持高亮显示，首先查看语言名称是否拼写错误（支持的常用语言类型罗列在了下面），如果确认无误，代码仍未高亮显示，请将代码“(setq org-src-fontify-natively t)”添加到.emacs或.init.el文件。     语言 标识符     C C   C++ C++   CSS css   Emacs Lisp emacs-lisp   Java java   Javascript js   LaTeX latex   Lisp lisp   MATLAB matlab   Org mode org   Perl perl   Python python   shell sh   SQL sql     缩进：在SRC代码块中，使用TAB键会按照语言格式自动缩进，如果未实现缩进，在非语言类型拼写错误下，请将代码“(setq org-src-tab-acts-natively t)”添加到.emacs或.init.el文件。（选中代码区域然后组合键C-M-\\可以实现选择区域的自动缩进） 快速输入代码块：代码块的标签当然可以手动编辑，不过emacs提供了快捷键：先输入“\u0026lt;s”，然后按下TAB键，可自动创建代码块。其次还有以下快捷键，本人使用不多，读者可自行了解：  \u0026lt;s + TAB 可以直接生成 #+BEGIN_SRC \u0026lt;e + TAB 可以直接生成 #+BEGIN_EXAMPLE \u0026lt;l + TAB 可以直接生成 #+BEGIN_EXPORT latex 如果是单行代码，可以直接使用\u0026rdquo;: xxxx\u0026quot;来表示，不过格式为text，这对展现一个命令示例非常有用。   另外光标在 SRC 区域的时候，C-c ' （单引号）可以弹出一个代码编辑区域。这里可以方便的编辑代码，编辑结束后kill此buffer即可。  脚注 在 org mode 中，你可以为你的文章添加注脚（footnote）。注脚的格式有两种，一是方括号+数字，二是方括号+fn+名字。\n光标移动到插入脚注的位置，快捷键 C-c C-x f，接下来会自动跳转到文章末尾，填写脚注内容（注意：必须要顶格写）：\n1 2  [1] The link is: http://orgmode.org [fn:orghome] The link is: http://orgmode.org   输入法切换 emacs自带输入法，快捷键是Ctrl-\\，这里倒不是要使用emacs的输入法，而是为了在不知道啥原因敲错，导致emacs为拼音输入时，可以自己切换回来。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":49,"section":"docs","tags":["emacs"],"title":"emacs org-mode 的使用","uri":"https://www.wenhui.space/docs/02-emacs/emacs_org_mode/"},{"content":"本文 主要介绍有关python的一些基础知识。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 python： Python 2.7.13  参考  菜鸟教程：Python基础教程  写在前头 什么是Python？ Python语言是少有的一种可以称得上即简单又功能强大的编程语言。它具有以下特点：\n 简单易学： 读Python程序就像是读英语，语法极其简单。 免费开源： Python是FLOSS（自由/开放源码软件）之一。 可移植： 多平台支持Python环境，方便程序移植。 面向过程和面向对象： Python既支持面向过程，也支持面向对象。面向过程，由过程或仅仅是可重用代码的函数构建起来；面向对象，由数据和功能组合而成的对象构建起来。（个人理解，在当做脚本语言时，主要是面向过程编程） 可扩展和可嵌入： Python程序可以使用其他语言，也可以被其他语言使用。 丰富的函数库： Python标准库很大，功能很强。  安装Python  如果你是Linux用户，系统应该已经自带Python，可以使用 python \u0026ndash;version 查看版本号。如果没有安装（可能性很小），可以使用系统的包管理器安装 sudo apt install python ，或者去Python官网下载页面下载最新Linux版本，也可以从别人那里copy可执行二进制文件。 如果你是windows用户，去Python官网下载页面下载最新Windows版本，手动安装，安装过程与其他软件类似，具体请自行百度。  运行方法  可以在python解释器直接运行python命令，打开终端，在命令行键入python，启动解释器，现在输入print \u0026lsquo;Hello World\u0026rsquo;，然后按回车，会看到屏幕输出Hello World。 使用源文件形式运行python程序： source HelloWorld.py 可执行的Python程序： 将程序源文件更改为可执行属性 chmod 755 HelloWorld.py ，在终端命令行直接运行 ./HelloWorld.py 。  获取帮助 help() 函数用于查看函数或模块用途的详细说明，按q退出。(注意：查看模块前，需要先import模块)\n\u0026gt;\u0026gt;\u0026gt;help('sys') # 查看 sys 模块的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help('str') # 查看 str 数据类型的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;a = [1,2,3] \u0026gt;\u0026gt;\u0026gt;help(a) # 查看列表 list 帮助信息 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help(re.findall) # 显示re模块的findall方法的帮助 ……显示帮助信息…… 基本概念 数  整数： 1、 2、 3、 -1、 -2、 -3（默认十进制，也可以采用其他进制表示： 0b 二进制，0o 八进制，0x 十六进制） 浮点数： 3.14、 3.14E-4（也就是0.000314） 复数： (-1+2j)、 (1-2j)， 也可以complex(a,b)表示， 复数的实部 a 和虚部 b 都是浮点型  字符串  单引号： ‘Hello \\\u0026lsquo;World！\\'’，输出 Hello \u0026lsquo;World！\u0026rsquo; （也就是单引号中使用单引号，需要转义，使用其他符号无需转义） 双引号： \u0026ldquo;Hello \\\u0026ldquo;World！\\\u0026quot;\u0026quot;，输出 Hello \u0026ldquo;World！\u0026rdquo; （也就是双引号中使用双引号，需要转义，使用其他符号无需转义） 三引号（三个连续单引号）： \u0026lsquo;\u0026lsquo;\u0026lsquo;\u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026quot;'''，输出 \u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026rdquo; （三引号中使用双引号和单引号，无需转义） 转义符： 转义符是反斜杠 \u0026ldquo;\\\u0026rdquo; ，如\\\\代表\\符号，如‘Hello \\\u0026lsquo;World！\\'’，\\\u0026lsquo;代表\u0026rsquo;（注意：行末的\\，代表下一行继续，也就是不换行，而非转义符） 自然字符串： 引号表示的一般字符串时是支持转义的，如果不需要转义，可以使用自然字符串（字符串前加r或R）。举例：一般字符串\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \u0026lsquo;world\u0026rsquo;；自然字符串r\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \\\u0026lsquo;world\\\u0026rsquo; 。 自动拼接： print \u0026lsquo;Hello\u0026rsquo; \u0026lsquo;World\u0026rsquo; ，会输出 HelloWorld 。  变量 用标识符命名的存储单元的地址称为变量，变量是用来存储数据的，通过标识符可以获取变量的值，也可以对变量进行赋值。对变量赋值的意思是将值赋给变量，赋值完成后，变量所指向的存储单元存储了被赋的值，在Pyhton语言中赋值操作符为“=、+=、-=、*=、/=、%=、**=、//=”。声明变量的语法如： name=”Peter”\n标识符 标识符用于Python语言的变量、关键字、函数、对象等数据的命名。标识符的命名需要遵循下面的规则。\n 可以由字母（大写A—Z或小写a—z）、数字（0—9）和_（下划线）组合而成，但不能由数字开头； 不能包含除_以外的任何特殊字符，如：%、#、\u0026amp;、逗号、空格等； 不能包含空白字符（换行符、空格和制表符称为空白字符）； 标识符不能是Python语言的关键字和保留字； 标识符区分大小写，num1和Num2是两个不同的标识符。 标识符的命名要有意义，做到见名知意。  数据类型 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。由于Python变量无需声明，所以它没有类型，我们所说的\u0026quot;类型\u0026quot;是变量所指的内存中对象的类型。标准的数据类型由如下几个：\n Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典）  对象 python中一切皆为对象，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method） Python中的对象包含三要素：id、type、value 其中id用来唯一标识一个对象， type标识对象的类型， value是对象的值 is判断的是a对象是否就是b对象，是通过id来判断的 ==判断的是a对象的值是否和b对象的值相等，是通过value来判断的。\n物理行和逻辑行 物理行是你在编写程序时所看见的。逻辑行是Python看见的单个语句。\n 如果你想要在一个物理行中描述多个逻辑行，那么你需要在逻辑语句末尾添加\u0026rdquo;;\u0026quot;，表示一个逻辑语句的结束（物理行末尾分号可写可不写）。 如果你想要在多个物理行中描述一个逻辑行，那么你需要在物理行末添加\u0026rdquo;/\u0026quot;，表示一个逻辑语句未结束，接下一行。  缩进 空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。也就是说，同一层次的语句必须有相同的缩进。\n运算符 运算符 特别说明：运算符左右可以存在空格，也可以不存在空格，不同于shell中赋值符'=\u0026rsquo;，左右是不能有空格的。\n 算数运算符：     运算符 名称 说明 例子     \u0026lsquo;+\u0026rsquo; 加 相加 3+5输出8; \u0026lsquo;a'+'b'输出\u0026rsquo;ab\u0026rsquo;   \u0026lsquo;-\u0026rsquo; 减 负数或相减 -5.2输出一个负数; 50-24输出26   \u0026lsquo;*\u0026rsquo; 乘 相乘或字符串重复 2*3输出6; \u0026lsquo;la\u0026rsquo;*3输出\u0026rsquo;lalala\u0026rsquo;   \u0026lsquo;**\u0026rsquo; 幂 x的y次幂 3**4输出81（即3 * 3 * 3 * 3）   \u0026lsquo;/\u0026rsquo; 除 x除以y 4/3输出1; 4.0/3或4/3.0输出1.3333333333333333;   ’%‘ 取模 返回除法的余数 8%3输出2; -25.5%2.25输出1.5   \u0026lsquo;//\u0026rsquo; 取整 返回商的整数部分（向下取整） 5.9//2输出2.0     比较运算符：     运算符 名称 说明 例子     \u0026lsquo;\u0026lt;\u0026rsquo; 小于 x是否小于y 是返回True，否返回False（首字母大写），5\u0026lt;3返回False； 3\u0026lt;5\u0026lt;7返回True   \u0026lsquo;\u0026gt;\u0026rsquo; 大于 x是否大于y 是返回True，否返回False（首字母大写），3\u0026gt;5返回False； 7\u0026gt;5\u0026gt;3返回True   \u0026lsquo;\u0026lt;=\u0026rsquo; 小于等于 x是否小于等于y x=3; y=6; x\u0026lt;=y返回True   \u0026lsquo;\u0026gt;=\u0026rsquo; 大于等于 x是否大于等于y x=4; y=3; x\u0026gt;=y返回True   \u0026lsquo;==\u0026rsquo; 等于 比较对象是否相等 x=2; y=2; x==y返回True; x='str\u0026rsquo;; y='stR\u0026rsquo;; x==y返回False   \u0026lsquo;!='或'\u0026lt;\u0026gt;\u0026rsquo; 不等于 比较两个对象是否不相等 x=2; y=3; x!=y返回True     赋值运算符：     运算符 名称 说明     \u0026lsquo;=\u0026rsquo; 简单的赋值运算符 a=2+3, a结果为5   \u0026lsquo;+=\u0026rsquo; 加法赋值运算符 a=7, a+=2, a结果为9   \u0026lsquo;-=\u0026rsquo; 减法赋值运算符 a=7, a-=2, a结果为5   \u0026lsquo;*=\u0026rsquo; 乘法赋值运算符 a=7, a*=2, a结果为14   \u0026lsquo;/=\u0026rsquo; 除法赋值运算符 a=7, a/=2.0, a结果为3.5   \u0026lsquo;%=\u0026rsquo; 取模赋值运算符 a=7, a%=2, a结果为1   \u0026lsquo;**=\u0026rsquo; 幂赋值运算符 a=7, a**=2, a结果为49   \u0026lsquo;//=\u0026rsquo; 取整除赋值运算符 a=7, a//=2, a结果为3     位运算符（避免表格中 或符号'|\u0026rsquo; 被转义，这里使用 \u0026lsquo;竖线\u0026rsquo; 代替）：     运算符 名称 说明 例子     ’\u0026laquo;’ 左移 一个数的比特形式进行左移 2\u0026laquo;2输出8，也就是0b10 \u0026laquo;2 结果为0b1000   ’\u0026raquo;‘ 右移 一个数的比特形式进行右移 11\u0026raquo;1输出5，也就是0b1011 \u0026raquo;1 结果为ob101   ’\u0026amp;’ 按位与 数的按位与 5\u0026amp;3输出1，也就是0b101 \u0026amp; 0b001 结果为0b001   ‘竖线’ 按位或 数的按位或 5'竖线\u0026rsquo;3输出7，也就是0b101 \u0026lsquo;竖线\u0026rsquo; 0b001 结果为0b111   \u0026lsquo;^\u0026rsquo; 按位异或 数的按位异或 5^1输出4，也就是0b101 ^ 0b001 结果为0b100   \u0026lsquo;~\u0026rsquo; 按位取反 x的按位取反，其值为-(x+1) ~5输出-6，也就是~0b0101 结果为0b1010(待补充)     逻辑运算（符布尔与和或，建议表达式为判断表达式，而非计算表达式，除非你明确知道返回结果的形式是什么）：     运算符 名称 说明 例子     \u0026lsquo;not\u0026rsquo; 布尔“非” not True 返回False x=2; y=3; not x!=y返回False   \u0026lsquo;and\u0026rsquo; 布尔“与” True and True 返回True 1\u0026lt;2 and 2\u0026lt;3 返回True； 1\u0026lt;2 and 2+3 返回2+3结果5   \u0026lsquo;or\u0026rsquo; 布尔“或” True or False 返回True 1\u0026lt;2 or 2\u0026gt;3 返回True； 1\u0026gt;2 or 2+3 返回2+3结果5     成员运算符     运算符 说明     \u0026lsquo;in\u0026rsquo; 如果在指定的序列中找到值返回 True，否则返回 False。   \u0026lsquo;not in\u0026rsquo; 如果在指定的序列中没有找到值返回 True，否则返回 False。     身份运算符     运算符 说明     \u0026lsquo;is\u0026rsquo; is 是判断两个标识符是不是引用自一个对象   \u0026lsquo;is not\u0026rsquo; is not 是判断两个标识符是不是引用自不同对象    是不是觉得is和==功能相同呢？那就理解错了，下面对is和==进一步说明。==是比较判断两个对象的value(值)是否相等；is比较判断两个对象id是否相同。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026gt;\u0026gt;\u0026gt; a = 1 #a和b为数值类型 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 14318944 \u0026gt;\u0026gt;\u0026gt; id(b) 14318944 \u0026gt;\u0026gt;\u0026gt; a = \u0026#39;cheesezh\u0026#39; #a和b为字符串类型 \u0026gt;\u0026gt;\u0026gt; b = \u0026#39;cheesezh\u0026#39; \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 42111872 \u0026gt;\u0026gt;\u0026gt; id(b) 42111872 \u0026gt;\u0026gt;\u0026gt; a = (1,2,3) #a和b为元组类型 \u0026gt;\u0026gt;\u0026gt; b = (1,2,3) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 15001280 \u0026gt;\u0026gt;\u0026gt; id(b) 14790408 \u0026gt;\u0026gt;\u0026gt; a = [1,2,3] #a和b为list类型 \u0026gt;\u0026gt;\u0026gt; b = [1,2,3] \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42091624 \u0026gt;\u0026gt;\u0026gt; id(b) 42082016 \u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} #a和b为dict类型 \u0026gt;\u0026gt;\u0026gt; b = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42101616 \u0026gt;\u0026gt;\u0026gt; id(b) 42098736 \u0026gt;\u0026gt;\u0026gt; a = set([1,2,3])#a和b为set类型 \u0026gt;\u0026gt;\u0026gt; b = set([1,2,3]) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 14819976 \u0026gt;\u0026gt;\u0026gt; id(b) 14822256   总结：只有数值型和字符串型的情况下，a is b才为True，当a和b是tuple，list，dict或set型时，a is b为False。\n运算符优先级 优先级从高到低。\n   运算符 说明     ** 指数 (最高优先级)   ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)   * / % // 乘，除，求余数和取整除   + - 加法减法   \u0026raquo; \u0026laquo; 右移，左移运算符   \u0026amp; 位 \u0026lsquo;AND\u0026rsquo;   ^ \u0026lsquo;竖线\u0026rsquo; 位运算符   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   == 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not and or 逻辑运算符        虽然python解释器对运算符号优先级指明了顺序，但还是建议使用圆括号来更明确地指出运算的先后顺序，使程序尽可能地易读。例如，2+(3*4)显然比2+3*4清晰。\n控制流 if判断 Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。条件判断语句中，\u0026ldquo;判断条件\u0026quot;成立时（非零），则执行后面的语句，执行内容可以多行，以缩进来区分表示同一范围。其中else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  num = 5 if num == 3: # 判断num的值 print \u0026#39;boss1\u0026#39; print \u0026#39;boss2\u0026#39; print \u0026#39;boss3\u0026#39; elif num \u0026lt; 0: # 值小于零时输出 print \u0026#39;worker1\u0026#39; print \u0026#39;worker2\u0026#39; print \u0026#39;worker3\u0026#39; else: # 条件均不成立时输出 print \u0026#39;roadman1\u0026#39; print \u0026#39;roadman2\u0026#39; print \u0026#39;roadman3\u0026#39;   输出结果为：\nroadman1 roadman2 roadman3 while循环 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。while语句有一个可选的else从句，在不满足while条件时执行。举例如下：\n1 2 3 4 5 6 7 8  count = 0 while (count \u0026lt; 3): print \u0026#39;The count is:\u0026#39;, count count = count + 1 else: print \u0026#34;end while at count:\u0026#34;, count print \u0026#34;Good bye!\u0026#34;   结果如下：\nThe count is: 0 The count is: 1 The count is: 2 end while at count: 3 Good bye! for循环 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。for语句有一个可选的else从句，在执行完for内容时执行一次（除非遇到break）。举例如下：\n1 2 3 4 5 6 7 8  for i in [1,2,3]: print i else: print \u0026#39;end for i=\u0026#39;, i #------------------------ for letter in \u0026#39;ABC\u0026#39;: print \u0026#39;letter:\u0026#39;, letter   结果如下：\n1 2 3 end for i= 3 letter: A letter: B letter: C break语句 break语句可以强制终止循环语句，即使while循环条件仍为True或for循环序列还没有被完全递归。注意：break终止for或while循环 ，对应的循环else块将不执行。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: break print \u0026#39;there is break\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除break语句，将结果进行比较）：\n1 2 3 continue语句 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: continue print \u0026#39;there is continue\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除continue语句，将结果进行比较）：\n1 2 3 4 end while, i= 5 函数 函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。\n函数形参 函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为实参。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  def printMax(a, b): if a \u0026gt; b: print a, \u0026#39;is maximum\u0026#39; else: print b, \u0026#39;is maximum\u0026#39; #---------------------------------------------- printMax(3, 4) # directly give literal values x = 5 y = 7 printMax(x, y) # give variables as arguments   结果如下：\n4 is maximum 7 is maximum 局部变量 在函数内声明的变量，与函数外具有相同名称的其他变量没有任何关系，也就是变量的作用域仅限于函数内容，是局部的，这样的变量被称作局部变量。举例如下（注意，函数要先定义，才可以使用）：\n1 2 3 4 5 6 7  def local_test(num): num += num print \u0026#39;local_test\\\u0026#39;s num is\u0026#39;, num num = 10 local_test(num) print \u0026#39;main_program\\\u0026#39;s num is\u0026#39;, num   结果如下：\nlocal_test's num is 20 main_program's num is 10 默认参数 对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。注意：不能先声明有默认值的形参而后声明没有默认值的形参。如 def func(a, b=5, c=3) 是有效的， def func(a=5, b) 是无效的。举例如下：\n1 2 3 4 5  def say(message, times = 1): print message * times say(\u0026#39;Hello\u0026#39;) say(\u0026#39;World\u0026#39;, 3)   结果如下：\nHello WorldWorldWorld 关键字参数 如果某个函数有许多参数，只想指定其中某些参数的值，可以通过命名来为这些参数赋值，这种方法就是关键字参数。换句话说，关键字参数就是调用参数时使用名字（关键字）而不是位置来给函数指定实参。举例如下：\n1 2 3 4 5 6  def func(a, b=5, c=10): print \u0026#39;a =\u0026#39;, a print \u0026#39;b =\u0026#39;, b print \u0026#39;c =\u0026#39;, c func(c=1, b=2, a=3)   结果如下：\na = 3 b = 2 c = 1 return语句 return 语句就是讲结果返回到调用的地方，并把程序的控制权一起返回程序运行到所遇到的第一个return即返回（退出def块），不会再运行第二个return。举例如下：\n1 2 3 4 5 6 7 8 9 10 11  def add_sub (a, b): c = a + b d = a - b return c, d x = 3 y = 2 m, n = add_sub(x,y) print x, \u0026#39;+\u0026#39;, y, \u0026#39;=\u0026#39;, m print x, \u0026#39;-\u0026#39;, y, \u0026#39;=\u0026#39;, n   结果如下：\n3 + 2 = 5 3 - 2 = 1 文档字符串 DocStrings 文档字符串是一个重要工具，用于解释文档程序，帮助你的程序文档更加简单易懂。我们可以在函数体的第一行使用一对三个单引号 '\u0026rsquo;\u0026rsquo; 或者一对三个双引号 \u0026quot;\u0026rdquo;\u0026rdquo; 来定义文档字符串。你可以使用 __doc__（注意双下划线）调用函数中的文档字符串属性。举例如下：\n1 2 3 4 5 6  def function(): \u0026#39;\u0026#39;\u0026#39; The introduction to function. \u0026#39;\u0026#39;\u0026#39; pass print (function.__doc__)   输出结果如下：\nThe introduction to function. 特别说明：在函数的第一个逻辑行的字符串是这个函数的文档字符串（也适用于模块和类）。文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾，一般概括介绍函数的功能。第二行是空行，从第三行开始是详细介绍函数功能和使用方法。强烈建议，函数中使用文档字符串时遵循这个惯例。\n模块 什么是模块？ 在python中，一个文件（以“.py”为后缀名的文件）就叫做一个模块，每一个模块在python里都被看做是一个独立的文件。模块可以被其他程序引用，从而使用该模块里的函数等功能，使用Python中的标准库也是采用这种方法。\nPython中模块分为以下三类：\n 系统内置模块：如：sys、time、json模块等等； 自定义模块：自定义模块是自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用； 第三方的开源模块：这部分模块可以通过pip install进行安装，有开源的代码；  import模块 首先模块要先使用import语句导入到程序，如“import sys”导入sys模块，import的使用遵循以下规则：\n 使用关键词“import”，后面跟具体的模块名称，则可以导入某一个模块； 同一个模块不管你执行了多少次“import”，只会被导入一次，以防止模块一遍又一遍的被执行； “import”应该被放在代码的顶端；  再来你说一说import的搜索路径和顺序，如下：\n 当前目录 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。  如果我们自定义一个模块（不能与系统模块重名），如何让python成功import呢？第一，我们可以将模块文件与引用模块的程序放在同一目录，可自动搜索到；第二，修改系统环境变量PYTHONPATH，比如自定义模板文件放在~/my_lib，可以将以下内容添加到~/.bashrc，并重启终端。\n1  export PYTHONPATH=~/my_lib/:$PYTHONPATH   from\u0026hellip;import 语句 Python 的 from 语句可以从模块中导入一个指定的部分到当前命名空间中。举例如下：\n1  from fib import fibonacci   也可以使用import modname from *语句，将模块中所有函数导入到当前命名空间中，但不建议这样做。举例如下：\n1  from fib import *   import和import\u0026hellip;from的区别 import和import\u0026hellip;from的区别，从函数引用来看就理解了，如下(support是自定义的模块，只为解释模块使用)：\n import   1 2  import support support.print_func(\u0026#34;Runoob\u0026#34;)    import\u0026hellip;from   1 2  from support import * print_func(\u0026#34;Runoob\u0026#34;)   从以上内容也看出，import和import\u0026hellip;from的区别，也知道为什么不建议使用import\u0026hellip;from * ，因为这样有可能带来函数命名上的冲突。总之，建议还是直接使用import。\npython中的包 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在__init__.py 文件, 该文件的内容可以为空。__init__.py 用于标识当前文件夹是一个包。\n如定义一个包，文件目录如下：\npackage_runoob |-- __init__.py |-- runoob1.py |-- runoob2.py 使用程序：\n1 2  from package_runoob.runoob1 import runoob1 from package_runoob.runoob2 import runoob2   python的标准库 python的标准库内容很多，这也是Python强大之处，在这里不进行描述，后续会根据自己使用情况，对某些內建函数进行介绍。分享一个Python标准库介绍文档，可供查阅，百度网盘分享资源： 链接：https://pan.baidu.com/s/1o7G32%5FilSHhflfYTHuJq3g 密码：h2vv 。\n数据结构 在Python中有三种内建的数据结构——列表、元组和字典。我们将会学习如何使用它们，以及它们如何使编程变得简单。\n列表 列表中的元素应该包括在方括号中，并用逗号隔开。列表中，可以添加、删除或是搜索列表中的元素。由于可以增加或删除元素，所以列表是可变的数据类型。列表中的每个元素都分配一个数字（用来索引它的位置），第一个索引是0，第二个索引是1，依此类推。创建列表的方法如下：\n1 2 3  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5 ] list3 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]   访问列表中的值（列表索引时，默认从左到右，负号‘-’可代表从右到左，冒号‘:’可定义区间，省略则代表起始或末尾）：\n1 2 3 4 5 6 7  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5, 6, 7 ] print \u0026#34;list1[0]: \u0026#34;, list1[0] print \u0026#34;list1[-2]: \u0026#34;, list1[-2] print \u0026#34;list2[1:5]: \u0026#34;, list2[1:5] print \u0026#34;list2[1:]: \u0026#34;, list2[1:]   添加、修改和删除列表中的元素：\n1 2 3 4  list = [] ## 创建空列表 list.append(\u0026#39;Google\u0026#39;) ## 在列表末尾添加元素 list[0] = \u0026#39;Baidu\u0026#39; ## 修改列表第一个元素 del list[0] ## 删除列表中第一个元素   列表的操作符：\n   表达式 结果 说明     len([1, 2, 3]) 3 长度   [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合   [\u0026lsquo;Hi!'] * 4 [\u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!'] 重复   3 in [1, 2, 3] True 元素是否存在于列表中   for x in [1, 2, 3]: print x 1 2 3 迭代    Python列表函数：\n   函数 说明     len(list) 列表元素个数   max(list) 返回列表元素最大值   min(list) 返回列表元素最小值   list(seq) 将元组转换为列表    Python列表方法：\n   方法 说明     list.append(obj) 在列表末尾添加新的对象   list.count(obj) 统计某个元素在列表中出现的次数   list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）   list.index(obj) 从列表中找出某个值第一个匹配项的索引位置   list.insert(index, obj) 将对象插入列表   list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值   list.remove(obj) 移除列表中某个值的第一个匹配项   list.reverse() 反向列表中元素   list.sort([func]) 对原列表进行排序    元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可(元组中只包含一个元素时，需要在元素后面添加逗号)。如下：\n1 2 3 4 5  tup1 = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34; tup4 = () tup5 = (33,)   元组的运算和索引与列表相同，可参考列表。唯一不同的是元组不可修改，不可删除，不可添加。\n元组的函数：\n   方法 说明     cmp(tuple1, tuple2) 比较两个元组元素   len(tuple) 计算元组元素个数   max(tuple) 返回元组中元素最大值   min(tuple) 返回元组中元素最小值   tuple(seq) 将列表转换为元组    字典 字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中，举例如下：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; }   多级字典嵌套：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} }   访问字典数据（如果key不存在，则会报告异常）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; } print \u0026#34;dict[\u0026#39;Alice\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;] #------------------------------------------ dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} } print \u0026#34;dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]   修改、删除和添加字典元素：\n1 2 3 4 5 6 7 8 9 10 11  dict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} dict[\u0026#39;Age\u0026#39;] = 8 # update dict[\u0026#39;School\u0026#39;] = \u0026#34;RUNOOB\u0026#34; #add print \u0026#34;dict[\u0026#39;Age\u0026#39;]: \u0026#34;, dict[\u0026#39;Age\u0026#39;] print \u0026#34;dict[\u0026#39;School\u0026#39;]: \u0026#34;, dict[\u0026#39;School\u0026#39;] del dict[\u0026#39;Name\u0026#39;] # delete Name dict.clear() # clear dict del dict # delete dict   字典的特性：\n 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个会覆盖前一个。 key必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。  字典内置函数：\n   序号 说明     cmp(dict1, dict2) 比较两个字典元素   len(dict) 计算字典元素个数，即key的总数   str(dict) 输出字典可打印的字符串表示   type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型    字典内置方法：\n   序号 说明     dict.clear() 删除字典内所有元   dict.copy() 返回一个字典的浅复   dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始   dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default   dict.has_key(key) 如果键在字典dict里返回true，否则返回fals   dict.items() 以列表返回可遍历的(键, 值) 元组数   dict.keys() 以列表返回一个字典所有的   dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaul   dict.update(dict2) 把字典dict2的键/值对更新到dict   dict.values() 以列表返回字典中的所有   pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值   popitem() 返回并删除字典中的最后一对键和值    序列 列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。索引和切片的使用方法在列表和元组中已经有介绍，这里不再赘述。\n引用 创建一个对象并给它赋一个变量的时候，这个变量仅仅 引用 那个对象，而不是表示这个对象本身！j简单来说，创建的对象指向的是计算机中存储赋值对象的内存，而并非重新开辟一块内存对应被赋值对象。一般说来，使用者不需要关心，但是如果你想要复制一个列表或者类似的序列，必须使用切片操作符来取得拷贝，如果只是想要使用另一个变量名，可以直接赋值，不过两个名称都引用同一个对象，一不小心就可能会引来各种麻烦。特别给Perl程序员提示：python中序列的赋值语句不创建拷贝，需要使用切片操作符来建立序列的拷贝。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  print \u0026#39;Simple Assignment\u0026#39; shoplist = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;carrot\u0026#39;, \u0026#39;banana\u0026#39;] mylist = shoplist # mylist is just another name pointing to the same object! del shoplist[0] print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that both shoplist and mylist both print the same list without # the \u0026#39;apple\u0026#39; confirming that they point to the same object #--------------------------------------------------------------------- print \u0026#39;Copy by making a full slice\u0026#39; mylist = shoplist[:] # make a copy by doing a full slice del mylist[0] # remove first item print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that now the two lists are different   中文 Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入 # -- coding: UTF-8 -- 或者 # coding=utf-8 就行了。注意： # coding=utf-8 的 = 号两边不要空格。如果以上教程中出现中文注释或其他中文内容，运行时报错，请添加中文支持。\n输入输出 打印的屏幕 最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式（显示时，Python会在逗号分隔处自动插入一个空格）。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：\n1  print \u0026#34;Python\u0026#34;,\u0026#34;是一个非常棒的语言，不是吗？\u0026#34;   读取键盘输入 raw_input函数，raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：\n1 2  str = raw_input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   input函数，input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。\n1 2  str = input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   举例如下（input）：\n请输入：[x*5 for x in range(2,10,2)] 你输入的内容是: [10, 20, 30, 40] 文件操作 打开文件 语法规则如下：\n1  file object = open(file_name [, access_mode][, buffering])   参数说明：\n file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。  模式说明：\n   模式 说明     t 文本模式 (默认)   b 二进制模式   x 写模式，新建一个文件，如果该文件已存在则会报错   + 打开一个文件进行更新可读可写   r 以只读方式打开文件（默认模式）   r+ 打开一个文件用于读写   w 打开一个文件只用于写入（文件存在则覆盖，不存在则新建）   w+ 打开一个文件只用于读写（文件存在则覆盖，不存在则新建）   a 打开一个文件用于追加（文件存在则末尾添加内容，不存在则新建））   a+ 打开一个文件用于读写（文件存在则末尾添加内容，不存在则新建））    对r+、w+、a+进一步说明：\n   描述 r+ w+ a+     当前文件不存在时文件 抛出异常 创建文件 创建文件   打开后原文件内容 保留 清空 保留   初始位置 0 0 文件尾   写入位置 标记位置 标记位置 写入时默认跳至文件尾    文件对象属性    属性 描述     file.closed 返回true如果文件已被关闭，否则返回false   file.mode 返回被打开文件的访问模式   file.name 返回文件的名称   file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true    关闭文件 File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：\n1  fileObject.close()   write和read write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符('\\n\u0026rsquo;)，举例如下，创建foo.txt文件，并将内容写入该文件，并最终关闭文件：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;w\u0026#34;) fo.write( \u0026#34;www.runoob.com!\\nVery good site!\\n\u0026#34;) # 关闭打开的文件 fo.close()   read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 read需要传入一个参数，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。举例如下（读取上面创建的文件前10个字符）：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 关闭打开的文件 fo.close()   文件定位 tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 查找当前位置 position = fo.tell() print \u0026#34;当前文件位置 : \u0026#34;, position # 把指针再次重新定位到文件开头 position = fo.seek(0, 0) str = fo.read(10) print \u0026#34;重新读取字符串 : \u0026#34;, str # 关闭打开的文件 fo.close()   os模块 Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能，通过import导入模块可参考上文模块章节。\n rename：   1 2  # 重命名文件test1.txt到test2.txt。 os.rename( \u0026#34;test1.txt\u0026#34;, \u0026#34;test2.txt\u0026#34; )    remove：   1 2  # 删除一个已经存在的文件test2.txt os.remove(\u0026#34;test2.txt\u0026#34;)    mkdir：   1 2  # 创建目录test os.mkdir(\u0026#34;test\u0026#34;)    chdir：   1 2  # 将当前目录改为\u0026#34;/home/newdir\u0026#34; os.chdir(\u0026#34;/home/newdir\u0026#34;)    getcwd：   1 2  # 给出当前的目录 print os.getcwd()    其他，可参考os模块提供的内建函数手册。  异常处理 什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在python无法正常处理程序时就会发生一个异常（异常是python对象，表示一个错误）。错误分两种：\n 语法错误： 这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正。 逻辑错误： 程序执行时遇到的错误，比如0做除数。  异常种类有哪些？ 常见的异常种类：\n   异常类型 说明     AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x   IOError 输入/输出异常；基本上是无法打开文件   ImportError 无法引入模块或包；基本上是路径问题或名称错误   IndentationError 语法错误（的子类） ；代码没有正确对齐   IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]   KeyError 试图访问字典里不存在的键   KeyboardInterrupt Ctrl+C被按下   NameError 使用一个还未被赋予对象的变量   SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）   TypeError 传入对象类型与要求的不符合   UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它   ValueError 传入一个调用者不期望的值，即使值的类型是正确的    所有标准异常    异常类型 说明     BaseException 所有异常的基类   SystemExit 解释器请求退出   KeyboardInterrupt 用户中断执行(通常是输入^C)   Exception 常规错误的基类   StopIteration 迭代器没有更多的值   GeneratorExit 生成器(generator)发生异常来通知退出   SystemExit Python 解释器请求退出   StandardError 所有的内建标准异常的基类   ArithmeticError 所有数值计算错误的基类   FloatingPointError 浮点计算错误   OverflowError 数值运算超出最大限制   ZeroDivisionError 除(或取模)零 (所有数据类型)   AssertionError 断言语句失败   AttributeError 对象没有这个属性   EOFError 没有内建输入,到达EOF 标记   EnvironmentError 操作系统错误的基类   IOError 输入/输出操作失败   OSError 操作系统错误   WindowsError 系统调用失败   ImportError 导入模块/对象失败   KeyboardInterrupt 用户中断执行(通常是输入^C)   LookupError 无效数据查询的基类   IndexError 序列中没有没有此索引(index)   KeyError 映射中没有这个键   MemoryError 内存溢出错误(对于Python 解释器不是致命的)   NameError 未声明/初始化对象 (没有属性)   UnboundLocalError 访问未初始化的本地变量   ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象   RuntimeError 一般的运行时错误   NotImplementedError 尚未实现的方法   SyntaxError Python 语法错误   IndentationError 缩进错误   TabError Tab 和空格混用   SystemError 一般的解释器系统错误   TypeError 对类型无效的操作   ValueError 传入无效的参数   UnicodeError Unicode 相关的错误   UnicodeDecodeError Unicode 解码时的错误   UnicodeEncodeError Unicode 编码时错误   UnicodeTranslateError Unicode 转换时错误   Warning 警告的基类   DeprecationWarning 关于被弃用的特征的警告   FutureWarning 关于构造将来语义会有改变的警告   OverflowWarning 旧的关于自动提升为长整型(long)的警告   PendingDeprecationWarning 关于特性将会被废弃的警告   RuntimeWarning 可疑的运行时行为(runtime behavior)的警告   SyntaxWarning 可疑的语法的警告   UserWarning 用户代码生成的警告    异常处理的方法  如果错误发生的条件是可预知的，我们需要用if进行处理，在错误发生之前进行预防。   1 2 3 4 5 6 7 8  AGE=10 while True: age=input(\u0026#39;\u0026gt;\u0026gt;: \u0026#39;).strip() if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age=int(age) if age == AGE: print(\u0026#39;you got it\u0026#39;) break    如果错误发生的条件是不可预知的，则需要用到try..except：在错误发生之后进行处理。   1 2 3 4 5 6 7 8 9 10  try: f=open(\u0026#39;a.txt\u0026#39;) g=(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g)) except StopIteration: f.close()   try\u0026hellip;except\u0026hellip;的详细用法 我们把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，也可以处理一组圆括号中的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except。\n 异常类只能来处理指定的异常情况，如果非指定异常则无法处理：   1 2 3 4 5  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: # 未捕获到异常，程序直接报错 print e    多分支：   1 2 3 4 5 6 7 8 9  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e)    多分支＋Exception：   1 2 3 4 5 6 7 8 9 10 11  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) except Exception as e: print(e)    异常的其他机构（try\u0026hellip;finally语法）：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) #except Exception as e: # print(e) else: print(\u0026#39;try内代码块没有异常则执行我\u0026#39;) finally: print(\u0026#39;无论异常与否,都会执行该模块,通常是进行清理工作\u0026#39;)    主动触发异常（raise语句）：   1 2 3 4  def functionName( level ): if level \u0026lt; 1: raise Exception(\u0026#34;Invalid level!\u0026#34;, level) # 触发异常后，后面的代码就不会再执行    自定义异常：   1 2 3 4 5 6 7 8 9 10  class Networkerror(BaseException): def __init__(self,msg): self.msg=msg def __str__(self): return self.msg try: raise Networkerror(\u0026#39;类型错误\u0026#39;) except Networkerror as e: print(e)    断言：assert条件：   1 2  assert 1 == 1 assert 1 == 2   总结： 使用异常处理方法，可以时代码程序拥有以下几个优点， 1）把错误处理和真正的工作分开来； 2）代码更易组织，更清晰，复杂的工作任务更容易实现； 3）代码更成熟，不至于由于一些小的疏忽而使程序意外崩溃了。 既然异常处理有这么多好处，是不是要为每一段程序都加上try\u0026hellip;except呢？首先try\u0026hellip;except是附加的一种异常处理逻辑，与主要的工作是没有关系的，这种东西加的多了，会导致代码可读性变差，其次只有在错误发生的条件无法预知的情况下，才应该做异常处理，而不是为自己不成熟的代码擦屁股。\n","description":"","id":50,"section":"docs","tags":["Python"],"title":"Python简明教程","uri":"https://www.wenhui.space/docs/06-linux-skills/language-skills/python_tutorial/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第五篇，主要介绍线程的使用、线程的控制和线程的通信。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明           线程的使用 程序和模块  module（模块）作为SV从verilog继承过来的概念，自然地保持了它的特点，除了作为RTL模型的外壳包装和实现硬件行为，在更高层的集成层面，模块之间也需要通信和同步。 对于硬件的过程块，他们之间的通信可理解为不同逻辑/时序块之间的通信或同步，是通过信号的变化来完成的。 从硬件实现角度来看，Verilog通过Always、initial过程语句块和信号数据连接实现进程间通信。 我们可以将不同的module作为独立的程序块，他们之间的同步通过信号的变化（event触发）、等待特定事件（时钟周期）或时间（固定延时）来完成。 如果按照软件的思维理解硬件仿真，仿真中各个模块首先是独立运行的线程（thread）。 模块（线程）在仿真一开始便并行执行，除了每个线程会依照自身内部产生的事件来触发过程语句块之外，也同时依靠相邻模块间信号变化来完成模块之间的线程同步。       什么是线程  线程即独立运行的程序。 线程需要被触发，可以结束或者不结束。 在module中的initial和always，都可以看做独立的线程，它们会在仿真0时刻开始，而选择结束或者不结束（对initial而言）。 硬件模型中由于都是always语句块，所以可以看成是多个独立运行的线程，而这些线程会一直占用仿真资源，因为它们不会结束。 软件测试平台中的验证环境都需要initial语句块去创建，而在仿真过程中，验证环境中的对象可以创建和销毁，因此软件测试端的资源占用是动态的。 软件环境中的initial块对语句有两种分组方式，使用 begin\u0026hellip;end 或 fork\u0026hellip;join 。 begin\u0026hellip;end 中的语句是 顺序执行 的，而 fork\u0026hellip;join 中的语句是 并发执行 的。 与 fork\u0026hellip;join 类似的并发执行语句还有 fork\u0026hellip;join_any 和 fork\u0026hellip;join_none。  线程的概念澄清  线程的执行轨迹是 呈树状结构的，即任何线程都应该有父线程 。 父线程可以开辟若干子线程，父线程可以暂停或终止子线程 。 当子线程终止时，父线程可以继续执行。 当父线程终止时，其开辟的所有子线程都应当会终止。  线程的控制 fork并行线程语句块      fork\u0026hellip;join  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join $display(\u0026#34;@%0t: after join\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join example @10: sequential after #10 @10: parallel start @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @60: after join @140: finish after 80       总结：可见fork\u0026hellip;join内是并行执行的，initial块内程序作为父线程，并创建了四个子线程。  $display\u0026hellip; #50 $display\u0026hellip; #10 $display\u0026hellip; begin #30 $display\u0026hellip; #10 $display\u0026hellip; end    fork\u0026hellip;join_any  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join_any example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join_any $display(\u0026#34;@%0t: after join_any\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join_any example @10: sequential after #10 @10: parallel start @10: after join_any @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @90: finish after 80  总结：子线程的创建与fork\u0026hellip;join是一致的，不同的是，fork\u0026hellip;join要等所有子线程执行完毕才会继续执行父线程的程序，而fork\u0026hellip;join_any中只要有一个子线程（最短的）执行完毕，父线程的程序就会被执行的。  fork..,join_none  测试代码   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin $display(\u0026#34;@%0t: start fork...join_none example\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); fork $display(\u0026#34;@%0t: parallel start\u0026#34;, $time); #50 $display(\u0026#34;@%0t: parallel after #50\u0026#34;, $time); #10 $display(\u0026#34;@%0t: parallel after #10\u0026#34;, $time); begin #30 $display(\u0026#34;@%0t: sequential after #30\u0026#34;, $time); #10 $display(\u0026#34;@%0t: sequential after #10\u0026#34;, $time); end join_none $display(\u0026#34;@%0t: after join_none\u0026#34;, $time); #80 $display(\u0026#34;@%0t: finish after 80\u0026#34;, $time); end    测试结果   @0: start fork...join_none example @10: sequential after #10 @10: after join_none @10: parallel start @20: parallel after #10 @40: sequential after #30 @50: sequential after #10 @60: parallel after #50 @90: finish after 80  总结：子线程的创建与fork\u0026hellip;join是一致的，不同的是，fork\u0026hellip;join要等所有子线程执行完毕才会继续执行父线程的程序，而fork\u0026hellip;join_none中父线程与子线程是并行执行的。  等待所有衍生线程  在SV中，当程序中的initial块全部执行完毕，仿真器就退出了，也就是如果以上测试代码中没有最后的\u0026hellip;finish after\u0026hellip;语句，对于join_any和join_none其子线程没有全部执行完毕仿真就结束了。 如果需要等待所有fork块中的子线程全部执行完毕在退出结束initial块，可以使用wait fork语句来等待所有子线程结束。   1 2 3 4 5 6 7 8 9 10 11 12  task run_thread; ... fork check_trans(tr1); //thread1  check_trans(tr2); //thread2  check_trans(tr3); //thread3  join_none ... // 等待所有fork中的线程结束  wait fork; endtask   停止单个线程  在使用了fork\u0026hellip;join_any和fork\u0026hellip;join_none以后，我们可以使用disable来指定需要停止的线程。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  parameter TIME_OUT = 1000; task check_trans(transaction tr); fork begin // 等待回应或达到某个最大延时  fork : timeout_block begin wait (bus.cb.addr == tr.addr); $display(\u0026#34;@%0t: Addr match %d\u0026#34;, $time, tr.addr); end #TIME_OUT $display(\u0026#34;@%0t: Error: timeout\u0026#34;, $time); join_any disable timeout_block; end join_none endtask   停止多个线程  disable fork可以停止从当前线程中衍生出来的所有子线程。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  initial begin check_trans(tr0); //线程0  //创建一个线程来控制disable fork的作用范围  fork //线程1  begin check_trans(tr1); //线程2  fork //线程3  check_trans(tr2); //线程4  join // 停止线程1-4， 单独保留线程0  #(TIME_OUT/2) disable fork; end join end    其实最准确的关闭线程的方法是，给定线程的标号，关闭指定的线程。  停止被多次调用的任务  如果给线程指明标号，那么当这个任务或线程被多次调用后，使用disable去终止这个线程时，会将所有的同名线程全部终止。 在创建task时，如果使用disable进程标号，一定要确认该task是否会被多处调用，如果多处调用要避免使用disable进程标号。  线程的通信 写在前面  测试平台中的所有线程都需要同步并交换数据。 一个线程可能需要等待另一个线程。 多个线程可能同时访问同一个资源。 线程之间可能需要交换数据。 所有这些数据交换和同步称之为线程间的通信（IPC，Interprocess Communication）。  event事件  verilog中，一个线程总是要等待一个带@操作符的事件。这个操作符是边沿敏感的，所以它总是阻塞着、等待着事件的变化。 其他线程可以通过-\u0026gt;操作符来触发事件，结束对一个线程的阻塞。 这就像在打电话时，一个人等待另一个人的呼叫。 测试代码（注意，event需声明而不需要new）：   1 2 3 4 5 6 7 8 9 10 11 12 13 14  event el,\te2; initial begin $display(\u0026#34;@t0t: 1: before trigger\u0026#34;, $time); -\u0026gt; el; @e2; $display(\u0026#34;@%0t: 1: after trigger\u0026#34;, $time); end initial begin $display(\u0026#34;@t0t: 2: before trigger\u0026#34;, $time); -\u0026gt; e2; @e1; $display(\u0026#34;@t0t: 2: after trigger\u0026#34;, $time); end    测试结果：   @0: 1: before trigger @0: 2: before trigger @0: 1: after trigger  总结：  第一个initial启动，触发e1事件，然后阻塞在e2上。 第二个initial启动，触发e2事件，然后阻塞在e1上。 e1和e2同一时刻被触发，但由于delta cycle的时间差使得两个initial块可能无法等到e1或e2。（根据上面的执行结果，可以分析得出，虽然是同一时刻，initial 1 还是被先执行了，先打印了before，然后拨打了电话（e1），然后等待接电话（e2），此时initial 2被执行，打印了before，拨打电话（e2），此时initial已经等待接听电话，所以initial 1打印了after，也就是接通了电话，而initial 2是接不到电话的，因为在接听之前tinitial 1已经拨出去了，所以没有打印出after） 也就是，等待事件触发要在事件发生之前，否则将错过事件，所以，更安全的方式可以使用event的方法triggered()，相当于为拨打电话提供了留言功能。   测试代码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14  event el,\te2; initial begin $display(\u0026#34;@t0t: 1: before trigger\u0026#34;, $time); -\u0026gt; el; wait (e2.triggered()); $display(\u0026#34;@%0t: 1: after trigger\u0026#34;, $time); end initial begin $display(\u0026#34;@t0t: 2: before trigger\u0026#34;, $time); -\u0026gt; e2; wait (e1.triggered()); $display(\u0026#34;@t0t: 2: after trigger\u0026#34;, $time); end    测试结果：   @0: 1: before trigger @0: 2: before trigger @0: 1: after trigger @0: 2: after trigger  总结：  对于triggered()而言，如果事件在当前时刻已经被触发，则不会引起阻塞，否则会一直等到事件被触发为止。 这个方法相对@而言，更与能力保证，只要event被触发过，就可以防止引起阻塞。    通知的需求  不同的线程之间，有时会有互相告知的需求。比如，我们要开一辆车，在踩油门要行驶之前，首先得看一下汽车有没有发动，那么这辆车可能是这样设计的：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module road; initial begin automatic car byd = new(); byd.drive(); end endmodule class car; bit start=0; task launch(); start=1; $display(”car is launched”); endtask task move(); wait(start==1); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; join endtask endclass //输出结果： // car is launched // car is moving    以上的例子可以看出，两个线程launch和move是通过线程间共享变量car::start和wait语句来实现了线程launch通知线程move的功能。 我们也可以将线程间共享变量car::start改为事件来触发。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class car; event e_start; task launch(); -\u0026gt; e_start; $display(”car is launched”); endtask task move(); wait(e_start.triggered()); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; join endtask endclass    当汽车要加速的时候，添加速度显示功能：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  module road; initial begin automatic car byd = new(); byd.drive(); byd.speedup(); byd.speedup(); byd.speedup(); end endmodule class car; event e_start; event e_speedup; int speed = 0; ...... task speedup(); #10ns; -\u0026gt; e_speedup; endtask task display(); forever begin @e_speedup; speed++; $display(\u0026#34;speed is %0d\u0026#34;, speed); end endtask task launch(); start=1; $display(”car is launched”); endtask task move(); wait(start==1); $display(”car is moving”); endtask task drive(); fork this.launch(); this.move() ; this.display() ; join_none endtask endclass //输出结果： // car is launched // car is moving // speed is 1 // speed is 2 // speed is 3     这里有两点值得分析：\n 为什么使用@e_speedup？因为使用 triggered的话，再第一次触发以后，下次会认为已经触发过而不再继续等待触发，这和设计功能是违背的，这里需要对@和triggerd按功能区分使用（UVM中提供一种event使用方式，当第一次事件触发以后，会清除此次触发，这样就不存在triggerd的问题了）。 为什么改为join_none？ 因为父线程中的speedup需要和三个子线程并行执行。    总结：\n 从这个汽车加速的例子来看，如果你需要一直踩着油门不放的话，这个加速的event必定会被不断触发，而当线程A要给线程B传递超过一次事件时，使用公共变量就不再是一个好的选择了。 通过event的触发，可以多次通知另一个线程，注意此时应该使用@。    semaphore旗语  semaphore可以实现对同一资源的访问控制。 对于初学者而言，无论线程之间在共享什么资源，都应该使用semaphore等资源访问控制的手段， 以此避免可能出现的问题。 semaphore有三种基本操作。new() 方法可以创建一个带单个或者多个钥匙的semaphore，使用get() 可以获取一个或者多个钥匙，而put()可以返回一个或者多个钥匙。 如果你试图获取一个semaphore而希望不被阻塞， 可以使用try_get() 函数。它返回1表示有足够多的钥匙， 而返回0则表示钥匙不够。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  program automatic test(bus_ifc.TB bus); semaphore sem; //创建一个semaphore  initial begin sem=new(1) ; //分配一个钥匙  fork sequencer() ; //产生两个总线事务线程  sequencer() ; join end task sequencer; repeat($urandom%10) //随机等待0-9个周期  @bus.cb; send Trans() ; //执行总线事务  endtask task sendTrans; sem.get(1) ; //获取总线钥匙  @bus.cb; //把信号驱动到总线上  bus.cb.addr\u0026lt;=t.addr; ...... sem.put(1) ; //处理完成时把钥匙返回  endtask endprogram     线程之间除了”发球”和接球”这样的打乒乓以外，还有更深入的友谊，比如共用一些资源。\n  对于线程间共享资源的使用方式， 应该遵循互斥访问(mutex access) 原则。\n  控制共享资源的原因在于，如果不对其访问做控制，可能会出现多个线程对同一资源的访问，进而导致不可预期的数据损坏和线程的异常，这种现象称之为\u0026quot;线程不安全\u0026rdquo;。\n  以这里比亚迪为例：\n   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  class car; semaphore key; function new(); key=new(1) ; endfunction task get_on(string p); $display(\u0026#34;%s is waiting for the key\u0026#34;, p); key.get(); #1ns; $display(\u0026#34;%s got on the car\u0026#34;, p); endtask task get_off(string p); $display(\u0026#34;%s got off the car\u0026#34;, p); key.put(); #1ns; $display(\u0026#34;%s returned the key\u0026#34;, p); endtask endclass module family; car byd=new(); string p1=\u0026#34;husband\u0026#34;; string p2=\u0026#34;wife\u0026#34;; initial begin fork begin//丈夫开车  byd.get_on(p1); byd.get_off(p1); end begin//妻子开车  byd.get_on(p2); byd.get_off(p2); end join end endmodule //打印结果 // husband is waiting for the key // wife is waiting for the key // husband got on the car // husband got off\tthe car // husband returned the key // wife got on the car // wife got off the car // wife returned the key    一开始在拿到这辆车的时候，只有一把钥匙，而丈夫和妻子如果都想开车的话，也得遵循先到先得的原则。所以，当丈夫和妻子同时都想用车的时候， 一把钥匙(semaphore key) 只可以交给他们中的一位， 另外一位则需要等待，直到那把钥匙归还之后才可以使用。 从上面的输出结果来看，也是能够看出来，虽然丈夫和妻子在同一时间想开这辆车，然而也只能允许一位家庭成员来驾驶。直到丈夫从车上下来，归还了钥匙以后，妻子才可以上车。 我们用这个生动的例子来解释semaphore对于控制访问共享资源的帮助， 从上面对于semaphore key的使用来看， key在使用前必须要做初始化，即要告诉用户它原生自带几把钥匙。 从例子来看，它只有1把钥匙，而丈夫和妻子在等待和归还钥匙时，没有在semaphore::get() /put() 函数中传递参数， 即默认他们等待和归还的钥匙数量是1。semaphore可以被初始化为多个钥匙， 也可以支持每次支取和归还多把钥匙用来控制资源访问。 semaphore存在一些问题，这些问题就需要在coding时格外注意。  即使semaphore中没有钥匙，仍然可以执行还钥匙。 即使A拿到了钥匙，B没拿到钥匙，B仍然可以还钥匙。    mailbox信箱  线程之间如果传递信息，可以使用mailbox，mailbox和队列queue有相近之处。 mailbox是一种对象，因此也需要使用new()来例化。例化时有一个可选的参数size来限定其存储的最大数量。如果size是0或者没有指定，则信箱是无限大的，可以容纳任意多的条目。 使用put()可以把数据放入mailbox，使用get()可从信箱移除数据。 如果信箱为满，则put()会阻塞；如果信箱为空，则get()会阻塞。 peek()可以获取对信箱里数据的拷贝而不移除它。 线程之间的同步方法需要注意，哪些是阻塞方法，哪些是非阻塞方法，即哪些是立即返回的，而哪些可能需要等待时间的。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  program automatic bounded; mailbox mbx; initial begin mbx=new(1); //容量为1  fork //Producer线程  for(inti=1; i\u0026lt;4; i++) begin $display(\u0026#34;Producer: before put(%0d)\u0026#34;, i); mbx.put(i); $display(\u0026#34;Producer: after put(%0d)\u0026#34;, i); end //consumer线程  repeat(3) begin int j; #1ns mbx.get(j); $display(\u0026#34;Consumer: after get(%0d)\u0026#34;, j); end join end endprogram //测试结果 // Producer: before put(1) // Producer: after put(1) // Producer: before put(2) // Consumer: after get(1) // Producer: after put(2) // Producer: before put(3) // Consumer: after get(2) // Producer: after put(3) // Consumer: after get(3)    mailbox和queue的区别：  maibox必须通过new() 例化， 而队列只需要声明。 mailbox可以将不同的数据类型同时存储，不过这么做是不建议的；对于队列来讲，它内部存储的元素类型必须一致。 maibox的存取方法put() 和get() 是阻塞方法，即使用时方法不一定立即返回；而队列所对应的存取方式，push_back()和pop_front()方法是非阻塞的，会立即返回。注意在用队列时要先判断空满，根据功能需求可以用wait等待，也可以使用if判断；此外调用阻塞方法时，要在task中调用，因为阻塞方法是耗时的，调用非阻塞可以在task也可以在function。 mailbox只能够用作FIFO，而queue除了按照FIFO使用，还有其它应用的方式例如LIFO(Last In First Out) 。 对于mailbox变量的操作， 在传递形式参数时，实际传递并拷贝的是mailbox的指针；等同于队列参数声明为ref，也就是指针，区别就是对参数是引用而不是拷贝。   关于mailbox的其它特性：  mailbox在例化时， 通过new(N) 的方式可以使其变为定长(fixed length)容器。这样在负载到长度N以后， 无法再对其写入。如果用new() 的方式， 则表示信箱容量不限大小。 除了put() /get() /peek() 这样的阻塞方法， 用户也可以考虑使用try_put() /try_get() /try_peek() 等非阻塞方法。 如果要显式地限定mailbox中元素的类型， 可以通过mailbox #(type=T)的方式来声明。例如上面的三个mailbox存储的是int， 则可以在声明时进一步限定其类型为mailbox #(int) 。    三种通信的比较和应用  event： 最小信息量的触发，即单一的通知功能。可以用来做事件的触发， 也可以多个event组合起来用来做线程之间的同步。 semaphore： 共享资源的安全卫士。如果多线程间要对某一公共资源做访问，即可以使用此方式。 mailbox： 精小的SV原生FIFO。在线程之间做数据通信或者内部数据缓存时可以考虑使用此方式。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":51,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（五）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-five/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第四篇，主要介绍类随机约束和分布、约束块控制、随机函数、数组约束、随机控制。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明     OCP Open Closed Principle 开闭原则    随机约束和分布 为什么需要随机？  芯片复杂度越来越高，在20年前 定向测试 已经无法满足验证的需求，而 随机测试 的比例逐渐提高。 定向测试能找到你认为可能存在的缺陷，而 随机测试可以找到连你都没有想到的缺陷 。 随机测试的环境要求比定向测试复杂，它需要激励、参考模型和在线比较。上百次的仿真不再需要人为参与，以此来提高验证效率。 随机测试相对于定向测试可以减少相当多的代码量，而产生的激励较定向测试也更多样。  为什么需要约束？  如果随机没有约束，产生有效激励的同时，还 会产生大量的无效激励 。 通过为随机添加约束，这种 随机自由是一种合法的随机 ，产生有效的测试激励。 约束不是一成不变的，为了获取期望的测试范围或期待的数值范围，约束需要“变形”。 随机的对象不只是一个数据，而是 有联系的变量集合 。通常这些变量集合会被封装在一个数据类里，同时需要类中声明数据之间的约束关系。因此，约束之后要产生一个随机数据的“求解器”，即在满足数据本身和数据之间约束关系的随机数值解。 约束不但 可以指定数据的取值范围 ，还 可以指定各个数值的随机权重分布 。  我们需要随机什么？  器件配置： 通过寄存器和系统信号。 环境配置： 随机化环境，例如合理的时钟和外部反馈信号。 原始输入数据： 例如MCDF数据包的长度、带宽，数据间的顺序。 延时： 握手信号之间的时序关系，例如valid和ready，req和ack之间的时序关系。 协议异常： 如果反馈信号给出异常，那么设计是否可以保持后续数据处理的稳定性。  声明随机变量的类  随机化是为了产生更多可能的驱动，我们倾向于将相关数据有机整理在一个类的同时，也用“rand”关键词来表明它的随机属性。 “randc”关键词表示周期性随机，即所有可能的值都赋过值后随机才可能重复，也就好比54张扑克牌抽牌游戏，rand代表每抽完一张放回去才可以下次抽牌，randc代表没抽完一张不需要放回就抽取下一张，如果抽完了，那就全部放回再次同样规则抽取。 rand和randc，只能声明类的变量，硬件域以及软件域的局部变量都不可以。 随机属性需要配合SV预定义的随机函数std::randomize()使用。即通过声明rand变量，并且在后期调用randomize()函数才可以随机化变量。 约束constraint也同随机变量一起在class中声明。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class packet; rand bit [31:0] src, dst, data[8]; randc bit [7:0] kind; constraint c { src \u0026gt;10; src \u0026lt;15; } endclass //----------------------------------  Packet p; initial begin p = new(); //assert语句保证randomize成功，否则会报fatal（如果约束冲突，如src\u0026gt;15 and src\u0026lt;10则会随机失败）  assert (p.randomize()) else $fatal(0, \u0026#34;Packet::randomize failed\u0026#34;); transmit(p); end   什么是约束  约束表达式的求解是有SV的约束求解器自动完成的。 求解器能够选择满足约束的值，这个值是由SV的PRNG（伪随机数发生器）从一个初始值（seed）产生。只要改变种子的值，就可以改变CRT的行为。 SV标准定义了表达式的含义以及产生的合法值，但没有规定求解器计算约束的准确顺序。也就是，不同仿真器对于同一个约束类和种子求解出的数值可能不同。 什么可以被约束？SV只能随机化二值数据类型，但数据位可以是二值或四值的，所以无法随机出x值和z值，也无法随机出字符串。   1 2 3 4 5 6 7 8 9 10 11  class date; rand bit [2:0] month; //note:  rand bit [4:0] day; rand int year; constraint c_data { month inside {[1:12]}; day inside {[1:31]}; year inside {[2010:2030]};} } endclass   请问：month=10，day=31，year=2020此组随机值可以产生吗？ 答案：不能，因为month的声明是3位，所以不可能出现数值10，这也是经常会犯的错误，当你约束数据时，一定要与声明数据的位数相匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class stim; const bit [31:0] CONGEST_ADDR = 42; //声明常数  typedef enum {READ, WRITE, CONTROL} stim_e; randc stime_e kind; rand bit [31:0] len, src, dst; bit congestion_test; constraint c_stim { len \u0026lt; 1000; len \u0026gt; 0; if(congestion_test) ( dst inside {[CONGEST_ADDR-100:CONGEST_ADDR+100]}; src == CONGEST_ADDR; ) else ( src inside {0, [10:20], [100:200]}; ) } endclass   权重分布  关键词dist可以在约束中用来产生随机数值的权重分布，这样某些值的选取机会要大于其他值。 dist操作符带有一个值的列表以及相应的权重，中间用 := 或 :/ 分开。值和权重可以是常数，也可以是变量。 权重不要百分比表示，权重的和也不必是100。 := 操作符表示值的范围内的每一个值的权重是相同的， :/ 操作符表示权重要平均分到范围内的每一个值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  rand int src, dst; constraint c_dist { src dist {0:=40, [1:3]:=60;} // src=1, weight=40/220  // src=2, weight=60/220  // src=3, weight=60/220  // src=4, weight=60/220  dst dist {0:/40, [1:3]:/60;} // dst=1, weight=40/100  // dst=2, weight=20/100  // dst=3, weight=20/100  // dst=4, weight=20/100 }   集合成员和inside  inside是常见的约束运算符，表示变量属于某个值的集合，除非还存在其他约束 ，否则随机变量在集合里取值的概率是相等的（集合里也可以是变量）。 可以使用 $ 符指定最大或最小值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  rand int c; int lo, hi; constraint c_range{ c inside {[lo:hi]}; } //-------------------------------  rand bit [6:0] b; rand bit [5:0] e; constraint c_range { b inside {[$:4], [20:$]}; e inside {[$:4], [20:$]}; }   条件约束  可以通过 -\u0026gt; 或者 if-else来让一个约束表达式在特定条件有效。   1 2 3 4 5 6 7 8 9 10 11  constraint c_io { (i_space_mode) -\u0026gt; addr[31] == 1\u0026#39;b1; //i_space_mode!=0 } //--------------------------------------  constraint c_io { if(i_space_mode) //i_space_mode!=0  addr[31] == 1\u0026#39;b1; else; }   双向约束  约束块不是自上而下的程序代码，它们是声明性代码，是并行的，所有的约束同时有效。 约束是双向的，这表示它会同时计算所有的随机变量的约束，增加或删除任何一个变量的约束都会直接或间接的影响所有相关的值的选取。 约束块可以声明多个，但是它们仍旧是并行的，如果对同一变量进行约束，取两者约束的交集，也就是两个约束都会生效，与写在一个约束块效果相同。 子类会继承父类的约束。  约束块控制 打开或关闭约束  一个类可以包含多个约束块，可以把不同约束块用于不同测试。 一般情况下，各个约束块之间的约束内容是相互协调不违背的，因此通过随机函数产生的随机数可以找到合适的解。 对于其他情况，例如跟胡不同需求，来选择使能哪些约束块，禁止哪些约束块，可以使用内建函数constraint_mode()打开或者关闭约束。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class packet; rand int length; constraint c_short {length inside {[1:32];}} constraint c_long {length inside {[1000:1032];}} endclass //------------------------  packet p; initial begin p =new (); //create a long packet by disabling c_short  p.c_short.constraint_mode(0); assert(p.randomize()); transmit(p); //create a short packet by disabling all constraint and then enable only c_short  p.constraint_mode(0); p.c_short.constraint_mode(1); assert(p.randomize()); transmit(p); end   内嵌约束  伴随着复杂的约束，它们之间会相互作用，最终产生难以预测的结果。用来使能和禁止这些约束的代码也会增加测试的复杂性。 经常增加或修改类的约束也可能会影响整个团队的工作，这需要考虑类的OCP原则（开放封闭原则，也就是哪些对外部开放，哪些不对外开放）。 SV允许使用 randomize() with来增加额外的约束，这和在类里增加约束是等效的，但同时要注意类内部约束和外部约束之间应该是协调的，如果出现违背，随机数会求解失败（求解失败，不同的工具报告形式不同，有的是error，有的是warning）。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class packet; rand int length; constraint c_short {soft length inside {[1:32];}} endclass //------------------------  packet p; initial begin p =new (); assert(p.randomize() with { length inside {[36:46];}; length != 40; } ); transmit(p); end   上述例子中randomize() with{}约束与c_short产生可冲突，那会不会报错呢？答案是不会，因为c_short约束前加了soft（软约束）关键字，意义就在于当外部或子类的约束发生冲突时，其优先级降低，不会影响外部或子类的约束。\n随机函数 pre_randomize 和 post_randomize  有时需要在调用randomize()之前或之后立即执行一些操作，例如在随机前设置一些非随机变量（上下限、条件值、权重）,或者在随机化后需要计算数据的误差、分析和记录随机数据等。 SV提供两个预定义的void类型函数pre_randomize和post_randomize，用户可以类中定义这两个函数，分别在其中定义随机化前的行为和随机化后的行为。 如果某个类中定义了pre_randomize或post_randomize，那么对象在执行randomize()之前或之后会分别执行这两个函数，所以pre_randomize和post_randomize可以看做是randomize函数的回调函数（callback function）。  系统随机数函数 SV提供了一些常用的系统随机函数，这些系统随机函数可以直接调用来返回随机数值：\n $random()平均分布，返回32位有符号随机数。 $urandom()平均分布，返回32位无符号随机数。 $urandom_range()在指定范围内的平均分布。  随机化个别变量  在调用randomize()时可以传递变量的一个子集，这样只会随机化类里的几个变量。 只有参数列表里的变量才会被随机化，其他变量会被当做状态量而不会被随机化。 所有的约束仍然保持有效。 注意：类里所有没有被指定rand的变量也可以作为randomize()的参数而被随机化。 注意：未进行随机化的变量默认初始值为0。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class rising; byte low; rand byte med, hi; constraint up { low\u0026lt;med; med\u0026lt;hi; } endclass //----------------------------------  initial begin rising r; r =new(); r.randomize(); //随机化hi和med，不改变low  r.randomize(med); //只随机化med  r.randomize(low); //只随机化low end   数组约束 约束数组的大小  在约束随机标量的同时，我们也可以对随机化数组进行约束。 多数情况下，数组的大小应该给定范围，防止生成过大体积的数组或空数组。 此外，还可以在约束中结合数组的其他方法sum(), product(), and(), or(), 和xor()。   1 2 3 4 5 6  class dyn_size; rand logic [31:0] d[]; constraint d_size { d,size() inside {[1:10];}; } endclass   约束数组的元素  SV可以利用foreach对数组每一个元素进行约束，和直接写出对固定大小数组的每一个元素相比，foreach更简洁。 针对动态数组，foreach更适合于对非固定大小数组中每个元素的约束。   1 2 3 4 5 6 7 8  class good_sum5; rand uint len[]; constraint c_len{ foreach (len[i]) len[i] inside {[1:255]}; len.sum() \u0026lt; 1024; len.size() inside {[1:8]}; } endclass   产生唯一元素值的数组  如果想要产生一个随机数组，它的每一个元素值都是唯一的，如果使用randc数组，嘛呢数组中的每一个元素只会独立的随机化，并不会按照我们期望的使得数组中的元素值是唯一的。 解决方案1：   1 2 3 4 5 6  rand bit [7:0] data; constraint c_data{ foreach(data[i]) foreach(data[j]) if(i != j) data[i] != data[j]; }    解决方案2：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class randc_data; randc bit [7:0] data[64]; endclass class data_array; bit [7:0] data_array [64]; function void pre_randomize(); randc_data rcd; rcd = new(); foreach (data_array[i]) begin assert(rcd.randomize()); data_array[i] = rcd.val; end endfunction endclass    特别示例如下，首先“\u0026lt;=”代表小于等于，其次限定da.size为（3/4/5），实际不可能取到5，原因是da.size的约束体现在“da[i] \u0026lt;= da[i+1]”时，约束的是i和i+1为为（3/4/5）。   1 2 3 4 5  rand bit [7:0] da[]; constraint c_da { da.size() inside {[3:5]}; foreach(da[i]) da[i] \u0026lt;= da[i+1]; }   随机化句柄数组  随机句柄数组的功能是在调用其所在类的随机函数时，随机函数会随机化数组中的每一个句柄所指向的对象。因此随机句柄数组的声明一定要添加rand来表示其随机化的属性，同时在调用随机函数前要保证句柄数组中的每一个句柄元素都是非悬空的，这需要早随机化之前为每一个元素句柄构建对象。 如果要产生多个随机对象，那么你可能需要建立随机句柄数组。和整数数组不同，你需要在随机化前分配所有的元素，因为在随机求解器不会创建对象。使用动态数组可以按照需要分配最大数量的元素，然后再使用约束减小数组的大小。在随机化时，动态句柄数组的大小可以保持不变或减小，但不能增加。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  parameter MAX_SIZE = 10; class RandStuff; bit[1:0] value = 1; endclass class RandArray; rand RandStuff array[]; constraint c_array { array.size() inside {[1:MAX_SIZE]}; } function new(); //分配最大容量  array = new[MAX_SIZE]; foreach (array[i]) array[i] = new(); endfunction endclass //---------------------------  RandArray ra; initial begin // 构造数组和所有对象  ra = new(); // 随机化数组，但可能会减小数组  assert(ra.randomize()); foreach(ra.array[i]) $display(ra.array[i].value); end    问题1：执行ra.randomize() with {array.size=2}时，array[0].value 和 array[0].value分别是多少？ 答案都是1，首先value没有加rand，所以randomize不会随机value，仍然保持为1。 问题2：为什么要分配最大容量？ 答案是只有创建对象，并且分配最大容量，才能保证随机化时可能会碰到句柄数组悬空，无指向对象，随机会报错。 总结：句柄数组的随机，首先查看句柄指向的对象内有没有rand变量，其次对句柄数组按最大容量进行例化。  随机控制  产生事务序列的另一个方法是使用SV的randsequence结构。这对于随机安排组织原子（atomic）测试序列很有帮助。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin for (int i=0; i\u0026lt;15; i++) begin randsequence (stream) stream: cfg_read := 1 | //权重不一样  io_read := 2 | //权重不一样  mem_read := 5; //权重不一样  cfg_read: (cfg_read_task;) | (cfg_read_task;) cfg_read; mem_read: (mem_read_task;) | (mem_read_task;) mem_read; io_read: (io_read_task;) | (io_read_task;) io_read; endsequence end end    我们也可以使用randcase来建立随机决策树，但它带来的问题是没有变量可供追踪调试。   1 2 3 4 5 6 7 8 9  initial begin int len; randcase: 1: len = $urandom_range(0,2); //10%  8: len = $urandom_range(3,5); //80%  1: len = $urandom_range(6,7); //10%  endcase $display(\u0026#34;len=%0d\u0026#34;, len); end    总结：  randsequence和randcase是针对轻量级的随机控制的应用。而我们可以通过定义随机类取代上述随机控制的功能，并且由于类的继承性使得后期维护代码时更加方便。 randsequence的相关功能我们在协调激励组件和测试用例时，可能会用到。 randcase则对应着随机约束中的dist权重约束 + if-else条件约束的组合。    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":52,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（四）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-four/"},{"content":"本文 主要介绍一种verilog语言中获取随机数的方法。\n   版本 说明     0.1 初版发布    代码展示  逻辑实现   1 2 3 4 5  function [31:0] get_random; input signed [31:0] min_num; input signed [31:0] max_num; get_random = min_num + {$random}%(max_num-min_num+1); endfunction // get_random    逻辑测试（如果范围包括负数，请将random_num声明为有符号类型）   1 2 3 4 5 6 7 8 9 10 11 12  reg signed random_num initial begin #0 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #10 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #20 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end end   应用场景 实际设计中并不会使用随机数的生成逻辑，因为本身逻辑也是非可综合的。使用随机数生成逻辑往往用于测试逻辑。典型的应用如，为时钟添加时钟偏移（多用于跨时钟域设计的验证，如异步fifo验证）。\n1 2 3 4 5 6 7 8 9 10  parameter CLK_PERIOD = 50; reg clk; reg signed [31:0] random_num; reg [31:0] clk_shift_period; initial clk = 0; always begin random_num = get_random(-CLK_PERIOD/5,+CLK_PERIOD/5);//skewing 20%  clk_shift_period = CLK_PERIOD + random_num; #clk_shift_period/2 clk = ~clk; end   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":53,"section":"docs","tags":["Verilog"],"title":"Verilog中获取随机数","uri":"https://www.wenhui.space/docs/07-ic-verify/tips/random-in-verilog/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第三篇，主要介绍类和对象的概述、类的成员、类的继承、句柄的使用、包的使用。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明     OOP Object Oriented Programming 面向对象编程    类和对象概述 类和对象  面向对象的编程语言更符号人对自然语言的理解（属性property和功能function）。 这个世界由无数的类（class）和对象（object）构成的。 类是将相同的个体抽象出来的描述方式， 对象是实体，其具备有独立行为能力 。 具有相同属性和功能的对象属于同一类，而不同的类之间可能有关系（继承关系）或没有关系。 在C语言中，编程基于过程方法（function）；在verilog中，提供了笨拙的“类对象编程”可能性，也就是在module中定义方法（function/task/always/initial），而后调用module实例中的方法。 verilog中module+method的方式与sv中class定义有本质的区别，即面向对象的三要素： 封装（encapsulation）、继承（inheritance）、多态（polymorphism） 。本节只阐述类的封装和继承，多态在后续高级章节介绍。 类的定义 核心是属性声明和方法定义 ，所以类 既可以保存数据，也可以处理数据 。这与struct结构体的重要区别就是，结构体只是数据的集合，而类不仅保存数据，还可以进行数据处理。  为了直观说明类的属性和方法，举例如下：\n 类名： 鸟 属性： 翅膀：有，羽毛：有 方法： 飞  例化一个类的过程，就是创建类的一个实例，类的实例就是对象 。比如家里养了一只喜鹊（两只的话就是两个对象），这就是对象，它属于鸟类，满足鸟类的属性，具有鸟类的方法，同时也可以拥有自己的属性，如下：\n 实例名： 喜鹊1 属性： 翅膀：有，羽毛：有，颜色：黑白，体重：700g \u0026hellip;\u0026hellip; 方法： 飞  验证为什么需要OOP 验证环境的各个组件具有以下特点：\n 验证环境中不同组件其功能和所需处理的数据内容是不同的 。 验证环境中同一类组件其所具备的功能和数据内容相似 。  所以，基于以上两点，验证环境中 各个组件角色明确、功能独立 ，使用面向对象编程与验证环境的构建原则十分吻合。\n第一个transaction事务类：\n1 2 3 4 5 6 7  class transaction; bit [31:0] addr, crc, data[8]; function void display; $display(\u0026#34;transaction: %h\u0026#34;, addr); endfunction endclass   可见class的定义和module的定义类似，不过module和class完全不同：\n module属于硬件域，class属于软件域 。 module内的变量是静态的，代表硬件电路，class内的变量是动态的，代表软件行为 。 class内可以并且建议定义软件变量（bit等），而module只能定义硬件变量（reg、wire等）。 class例化后称为 对象 ，module例化后称为 实例 。 class内不能出现initial和always。  OOP的重要概念  class类： 基本模块包含成员变量（属性）和方法。module也可以存在变量和方法，不过属于硬件域。 object对象： 类的实例。module也可以例化，属于硬件域。 Handle句柄（指针）： 用来指向对象的指针。module通过层级索引找到设计的实例。 property属性（变量）： 在类中声明的存储数据的变量。在module中就是reg和wire。 method方法： 在类中可以使用function/task来定义方法，在module中定义function/task，也可以定义always/initial。  创建对象  再次强调v module和sv class的区别 ：  两者共同点在于均使用“模板”来创建内存实例。 不同点在于v module例化是 静态 的，编译时完成，而sv class例化是 动态 的，可以任意时间点发生，这也使得类的例化方式更加灵活和节省空间。 v module中没有句柄概念，而是通过 层级索引 方式找到实例（A.B.C.sig1），而sv class通过 句柄 使操作更加灵活。   创建对象时，需要清楚什么是声明，什么是创建（例化） ：  声明： transaction trans; 创建： trans = new();   创建对象时创建了什么？ 开辟了新的内存空间，用来存放对象的成员变量和方法。 创建对象时可以通过自定义构建函数来完成变量的初识化和其他操作。   1 2 3 4 5 6 7 8  class transaction; bit [31:0] addr, crc, data[8]; function new(); addr = 3; foreach(data[i]) data[i] = 5; endfunction endclass    构建函数new() 系统预定义的函数，不需要指定返回值， 函数会隐式的返回例化后的对象指针 ，所以并不是没有返回值， 不能加void 。 new函数也可以 定义多个参数 作为初始化时外部传入数值的手段。   1 2 3 4 5 6 7 8 9 10 11 12 13  class transaction; bit [31:0] addr, crc, data[8]; function new(bit[31:0] a=3, d=5); addr = a; foreach(data[i]) data[i] = d; endfunction endclass initial begin transaction trans; //声明  trans = new(10, 20); //带初始化数据的创建 end   句柄的传递 区分了 类（抽象）和对象（具体） 之后，还需要区分 对象（存储空间）和句柄（对象指针） 。也就是说，在创建了对象之后，该对象的存储空间位置不会变，而指向该空间的句柄可以有多个。\n1 2 3 4  transaction t1, t2; //声明句柄 t1和t2（此时句柄悬空，无指向对象） t1 = new(); //例化对象，将其句柄赋予t1 t2 = trans1; //将t1的值赋予t2，也就是句柄t1和t2指向同一对象 t1 =new(); //例化第二个对象，并将其句柄赋予t1   首先两个new就代表创建了两个对象，最终t1指向第二个对象，t2指向了第一个对象。\n     对象的销毁  软件编程的灵活在于 动态的分配内存空间 ，在资源闲置时可以回收空间。 C++语言中的类除了有构建函数，还有析构函数， 析构函数的作用就是手动释放空间 ，这对编程人员的细心和经验提出了要求；而Java和Python等后续的OOP语言不再需要手动定义析构函数，而是自动回收释放空间。 sv也采用自动回收空间的处理方式。回收原则： 当一个对象在整个程序中没有任何地方再需要它时，便会被销毁，也即是回收空间。不需要的意思就是没有句柄指向该对象 。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class word; byte nb[]; //声明动态数组  function new(int n); nb = new[n]; //创建动态数组（创建类的对象是使用\u0026#34;new()\u0026#34;）  endfunction endclass initial begin : initial_1 word wd; for(int i=1; i\u0026lt;=4; i++) wd = new(i); end initial begin : initial_2 #1p3 $display(\u0026#34;How many Bytes are allocated for word instances??\u0026#34;); end   根据以上代码，假设wd=new(1)需要分配1Byte空间，那么在initial_2中当打印语句时，需要为例化开辟多少空间呢？答案是4Byte，原因是wd是静态的；如果将wd声明改为“automatic word wd;”，答案就是0Byte，原因是wd是动态的，且#0ps时刻被创建，而#1ps打印时，wd变量已经消失，空间被回收了。\n句柄的使用  句柄可以用来创建多个对象，也可以前后指向不同对象。 可以使用句柄来调用对象中的成员变量或者成员方法，如下：   1 2 3 4  transaction trans; //声明句柄 trans = new(); //例化对象 trans.addr = 32\u0026#39;d10; // 为对象的成员变量赋值 trans.display(); //调用对象的成员方法   静态变量  与硬件域不同的是，class中声明的变量默认是动态的，其生命周期在仿真中的某一时间点，也就是对象的创建到对象的销毁。 如果使用 关键字static 来声明class内的变量，则其为静态变量。静态变量的生命周期 贯穿整个仿真阶段 。 如果类中声明了静态变量，那么可以 直接引用该变量class::var ，或者通过例化对象引用object.var。类中静态变量声明后，无论例化多少个对象，只可以共享一个同名的静态变量，因此 类的静态变量的使用可以打通各个对象，但是要注意共享资源的保护，换句话说，任何地方修改静态变量，大家都会看到它的修改 。  静态方法  类似与静态变量，在class中定义的方法默认为动态的，我们可以通过 static关键字将其声明为静态方法 。 静态方法内可以声明并使用动态变量，但是 不能使用类的动态变量 。原因是在调用静态方法时，可能还没有创建具体的对象，对应的动态变量也就没有被创建，这时候是无法使用类的动态变量，编译时就会报错；静态方法中可以使用类的静态变量，因为静态变量和静态方法一样，编译时就创建了。  类的成员 写在前面  类是成员变量和成员方法的载体，这些成员可以完成 保存数据和处理数据的功能 ，并且类的变量和方法应该遵循“聚拢”原则，也就是一个类的功能要尽可能单一，做好专职工作。 类作为载体，天生具备了闭合属性，也就是将其属性（变量）和方法封装在类的内部，不会直接暴露给外部，并且 可以通过protected和local的关键词，设置变量和方法的外部访问权限 。 如果没有指明访问类型，成员 默认为public （public并不是关键字），意味着子类和外部都可以访问。 如果指明访问类型为 protecd ，那么 只有该类及其子类可以访问，外部无法访问 。 如果指明访问类型为 local ，那么 只有该类可以访问，子类和外部无法访问 。 访问类型的设定是为了更好的封装类，尤其是发布供他人使用的软件包，如果验证环境应用范围较窄，可以使用默认的public访问类型，方便类的外部更好的使用变量和方法。  定义和调用成员方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class transaction1; bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction1\u0026#34;); endfunction endclass class transaction2; bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction2\u0026#34;); endfunction endclass   1 2 3 4 5 6 7 8 9  transaction1 t1; //声明句柄t1 transaction2 t2; //声明句柄t2 initial begin t1 = new(); //创建对象  t1.display(); //调用transaction1::display()  t2 = new(); //创建对象  t2.display(); //调用transaction2::display() end   类的封装   类和结构体的异同 ：\n 二者本身都可以定义数据成员。 类变量在声明后，需要构造才会创建对象实体，而struct在变量声明时已经开辟内存。（有时候类没有new函数，也并不会出错，并不是不需要new，而是系统自动调用了new函数） 类除了可以声明数据变量，还可以声明方法，而struct不能。换句话说，struct就是个数据结构，而class包含了数据成员以及对数据成员处理的方法。    类与module的异同 ：\n 从数据和方法来看，两者都可以作为封闭容器来定义和存储。 从例化来看，module必须在仿真开始时就确定是否要例化，而类可以在仿真的任意时刻被例化。换句话说，module是硬件域，静态的，class是软件域，动态的。 从封装性来看，module内的变量和方法是对外部公共开发的，而类可以定义为公共的、受保护的和私有的。 从继承性来看，module没有继承性可言，也就是无法在原有的module的基础上进行module的功能扩展，而继承性是类的一大特点。    思考  可以在哪里定义类？ 答案：module、interface、program和package，也就是所有“盒子”。 可以在类中再声明类成员吗？ 答案：可以，类也是一种数据载体。 What is this ？ 答案：如果在类中使用 this ，即表明this.X所调用的成员是当前类的成员，而非同名的局部变量或者形式参数等。   1 2 3  function new(string name); this.name = name; //将参数传递的name赋值给当前类的name变量 endfunction    类有编译顺序吗？ 答案：有，建议的编译顺序是先编译基类，再编译高级类，或者说先编译将被引用的类，再编译引用 之前已经编译过的类 的类，其实就是个依赖关系。  类的继承 写在前面  继承也符合我们的认识世界的观点，我们对世界的认识无外乎归纳法和演绎法。 归纳法就是从个别特别到一般属性的方法，从具体对象中抽象出类的属性和方法，这就是定义类的思维方式。 “白猫黑猫都是猫，抓住老鼠就是好猫”，这里白猫黑猫都继承于猫类，他们有一个属性是颜色，另一个属性是好坏。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class cat; protected color_t color; local bit is_good; function set_good(bit s); this.is_good = s; endfunction endclass class black_cat extends cat; function new(); this.color = \u0026#34;BLACK\u0026#34;; endfunction endclass class white_cat extends cat; function new(); this.color = \u0026#34;WHITE\u0026#34;; endfunction endclass black_cat bk; white_cat wt; initial begin bk = new(); wt = new(); bk.set_good(1); wt.set_good(0); end   由上面代码得出结论：\n 不可以通过外部修改黑/白猫的颜色，因为声明的是受保护的变量。 黑/白猫不可以自己初始化时设置is_good夸自己是好猫，因为cat类定义的is_good是local类型。 外部不可以通过访问黑/白猫的is_good属性来得知是不是好猫，因为cat类定义的is_good是local类型，无法访问。 黑/白猫是不是大脸猫，无从得知，因为没有这个属性。  案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class basic_test; int def = 100; //成员变量赋予默认值  int fin; task test(sim_ini ini); $display(\u0026#34;basic_test::test\u0026#34;); endtask function new(int var); //......  endfunction endclass class test_wr extends basic_test; function new(); super.new(def); $display(\u0026#34;test_wr::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_wr::test\u0026#34;); //......  endtask endclass class test_rd extends basic_test; function new(); super.new(def); $display(\u0026#34;test_rd::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_rd::test\u0026#34;); //......  endtask endclass    类test_wr和test_rd是子类，其父类为basic_test，也叫基类。 子类在定义new函数时，应该首先调用父类的new函数，即super.new()。 要想继承父类的属性和方法，必须调用（显式或隐式）super.new()。 从创建对象的初始化来看，用户应该注意如下的规则：  子类的实例对象在初始化时首先会调用父类的构造函数。 当父类构造函数完成时，会将子类实例对象中各个成员变量按照他们定义时的默认值初始化，如果没有默认值则不初始化。 在成员的变量默认值赋予后（声明的同时即赋值），才会最后进入用户定义的new函数中执行剩余的初始化代码。    成员的覆盖 在父类和子类里，可以定义相同名称的成员变量和方法（形式参数和返回值也应该相同），而在引用时，也将按照句柄类型来确定作用域。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class basic_test; int def = 100; //成员变量赋予默认值  function new(int var); //......  endfunction endclass class test_wr extends basic_test; int def = 200; //成员变量赋予默认值  function new(); super.new(def); $dispaly(\u0026#34;test_wr::super.def =%0d\u0026#34;, super.def); //super.def为100  $dispaly(\u0026#34;test_wr::this.def =%0d\u0026#34;, this.def); //this.def为200  endfunction //...... endclass module tb; //...... basic_test t; test_wr wr; initial begin wr = new(); t = wr; //将子类对象句柄赋值给父类句柄（实际上父类句柄t仍旧只能访问父类变量，而并没有扩大作用域至子类，如果想扩大作用域，只能使用$cast，而不是等号）  $display(\u0026#34;wr.def = %0d\u0026#34;, wr.def ); $display(\u0026#34;t.def = %0d\u0026#34;, t.def ); end endmodule   最后打印的wr.def和t.def的值分别为多少？答案是200和100。首先声明了父类的句柄t和子类句柄wr，创建了子类的实例wr，又将子类的句柄wr赋给了父类句柄t。此时 句柄t和wr都指向了这个对象 ，这里就有区分了，虽然都指向同一对象，但是 子类句柄wr可以访问这个对象中的全部变量 ，也就是def默认值为200，而 父类句柄t只能访问子类继承自父类的变量 ，也就是def默认值为100。这里有两个关键点， 一是父类和子类都声明了相同名字的变量，二是子类句柄赋值给了父类句柄 ，在此场景下需要特别注意。\n总结：\n test_wr类新定义的变量test_wr::def和basic_test::有冲突（同名），但是在类的定义里， 父类和子类拥有同名的变量和方法也是允许的 。当子类作用域中出现父类同名的变量和方法，则 以子类作用域为准 。同时也可以使用this/super来指明使用子类/父类的变量/方法。 父类和子类拥有同名或非同名的变量或方法时，子类使用变量和方法，如果不指明super/this，则依照由近及远的原则来引用变量。  首先看变量是否是在函数内部定义的局部变量。 其次看变量是否是当前类定义的成员变量。 最好再看变量是否是父类或更底层类的变量。    句柄的使用 句柄的传递  句柄可以作为形式参数通过方法来完成对象指针的传递，从外部传入方法内部（注意：传递的参数是句柄，而不是对象，并且对象是创建在一块内存里的，永远不可能作为参数传递）。   1 2 3 4 5 6 7 8 9  task generator; tranctions t; t = new(); transmit(t); endtask task transmit(transaction t); //...... endtask    句柄也可以在在方法内部首先完成修改，而后再由外部完成使用。   1 2 3 4 5 6 7 8 9 10 11 12 13  function void create(tranction tr); //Bug, miss ref  tr =new(); tr.addr = 100; //initialize other fields  //...... endfunction transaction t; initial begin create(t); t.addr = 10; $display(t.addr); end   问题：最后显示的t.addr的数值是多少？ 答案：报错。分析：create函数的参数默认为input，没有返回值，也就是create函数内所做的操作都是局部的，而在外部看来，句柄t还是个null，没有实例，所以在引用t.addr时会报错。改进方法是：参数声明为inout 或 添加ref关键字。\n句柄的动态修改 程序执行时，可以在任何时候为句柄创建新的对象，并将新的指针赋值给句柄。\n1 2 3 4 5 6 7 8 9 10 11 12  task generate trans(); transaction t; //声明句柄  tranction fifo[$]; //声明存放句柄的队列  t =new(); //创建对象  for(int=0; i\u0026lt;3; i++) begin t.addr = i\u0026lt;\u0026lt;2; fifo.push_back(t); end t = fifo.pop_front(); endtask   问题：最后t.addr数值多少？ 答案：8。分析：首先循环对t.addr的赋值依次为0 4 8，队列依次存入三个t，最后弹出第一个赋给t，仿佛最后t.addr的值应该是第一个数字0，为什么会是8，原因就一个，队列里存放的是句柄，不是对象，三次存入的句柄t的内容不变，都指向对象t，而对象t的addr变量是8。所以牢记： *传递的是句柄，而不是对象*。\n包的使用 包的意义  sv语言提供了一种在多个module、interface和program中共享parameter、data、type、task、function、class等的方法，即利用package（包）的方式来实现。如果装修一个大房子（完整的验证环境）来看的话，我们喜欢将不同的模块的类定义归整到不同的package中。 这么做的好处在于将一簇相关的类组织在单一的命名空间下，使得分属于不同模块验证环境的类来自于不同package，这样便于通过package来解决类的归属问题。  包的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package regs_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage package arb_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage //导入包 module tb; import regs_pkg::*; import arb_pkg::*; regs_mon mon1 = new(); arb_mon mon2 = new(); endmodule    两个package regs_pkg和arb_pkg中都定义了4个与模块验证相关的类，即stimulator、monitor、checker、env。两个不同的package内存在同名的类，但是它们的内容是不同的。 如果我们将这些重名的类归属到不同的package中去编译，不需要担心命名冲突的问题，因为package会将命名空间分隔开率，在使用同名类时，注明要使用哪个package的即可。   1 2  regs_pkg::monitor mon1 = new(); arb_pkg::monitor mon2 = new();   包与库的区分  package可以对类名做一个隔离的作用，使用不同的package管理同名的类，可以解决命名冲突问题。（使用域名索引符“::”） package更多的意义是将软件封装在不同的命名空间中，以此来与全局的命名空间进行隔离。 library是编译的产物，硬件都会被编译到库中，如果不指明编译库，会被编译到默认的库中（worklibrary），同样可以解决命名冲突的问题（不过设计中我认为都会依靠一套完整的命名规则来命名，这样不仅解决同名冲突问题，还可以从名字上了解到模块的更多信息）。 库既可以容纳硬件、也可以容纳软件，包括package。  包的命名规则  在创建package的时候，已经在指定包名称的时候隐含地指定了包的默认路径，即包文件所在的路径，如果在package中要include该路径之外的文件，需要额外指定搜索路径“+incdir+PATH”。 如果遵循package的命名习惯，不但要求定义的package名称独一无二，其内部定义的类也应该尽可能独一无二。 如果不同package中定义的类名也不相同，在顶层的引用可以通过“import pkg_name::*”的形式，来表示在tb中引用的类如果在当前域中没有定义，会搜寻regs_pkg和arb_pkg中定义的类（前提是所有类不同名）。 类的命名上，建议加上指明特定身份的前缀，比如package名。  包的使用建议  在包中可以定义类、静态方法和静态变量。 如果将类封装在某一个包中，那么它就不应该在其他地方编译，这样可以方便后面对类的引用。 类和包是好朋友，包是类的归宿，类是包的子民。 一个完整模块的验证环境组件类，应该由一个对应的模块包来封装。 使用`include关键词完成类在包中的封装，要注意编译的前后顺序。 编译一个包的背后实际是将各类文件平铺在包中，按照顺序完成包和包内各类的有序编译。 使用类的可以通过`import完成包中所有类或者某个类的导入，使得新环境可以识别出来，否则类会躺在包外不被外部识别。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":54,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（三）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-three/"},{"content":"本文 主要介绍辅助verilog编码的三款工具，简化编码工作。\n   版本 说明     0.1 初版发布    三大利器 请查看往期博客：\n Emacs verilog-mode 的使用 代码预处理工具ep3的使用 verilog中reg和wire的自动声明  verilog编码我们需要写什么？ 如下代码，我们实际要写的，也就是真正的逻辑部分，而其他部分基本全部由以上三大利器完成。注意，正常使用顺序为：先ep3进行代码预处理，再verilog-mode进行AUTO处理，最后自动声明reg和wire。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  module demo(/*AUTOARG*/); input clk; input din1; input [3:0] din2; @for i=0 to 5 output dout@i; @endfor /*AUTOWIRE*/ /*AUTOREG*/ /*AUTO DECLARE*/ assign sig1 = \u0026amp;din_b[3:0]; //.........other logic  sub_mod i_sub_mod(/*AUTOINST*/); endmodule   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":55,"section":"docs","tags":["Verilog"],"title":"简化verilog编码的全套解决方案","uri":"https://www.wenhui.space/docs/08-ic-design/rtl-coding/verilog-coding-three-tools/"},{"content":"本文 主要介绍一款代码预处理工具：ep3（基于Perl语言开发）。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Perl： v5.24.1  参考  https://metacpan.org/search?q=ep3 http://www.lujun.org.cn/?p=2099  什么是ep3？ ep3是一款基于Perl语言开发的脚本工具，主要对代码中一些重复代码，通过脚本处理自动生成，以节省编码工作。\n下载与安装 下载  github（安装包）：https://github.com/weiqi7777/ep3 百度网盘分享资源（安装包）： 链接：https://pan.baidu.com/s/1VU3%5FbI0HXdhopquccYHo2Q 密码：co5s 百度网盘分享资源（可执行程序）： 链接：https://pan.baidu.com/s/1GKROlch5GDqglpbbUs09mw 密码：andt  安装  下载可执行程序的话，将其放到/usr/local/bin/目录（也可以是其他PATH变量下目录）下即可使用，无需安装。 下载安装包的话（详情可见readme），安装到/usr/local/bin/（需要root权限）：   1 2 3 4 5  su perl Makefile.PL make make test make install    下载安装包的话（详情可见readme），安装到~/tool/bin/：   1 2 3 4  perl Makefile.PL PREFIX=~/tools/usr make make test make install   使用命令 1  ep3 [option] source_file \u0026gt;result_file   option选项：\n1 2 3 4 5 6 7 8 9  Usage:\t/usr/local/bin/ep3 [-include dir] [-define key [value]] [-delimeter string] [-module modulename] [-[no]comments] [-[no]protect] [-[no]depend] file1 [file2 .. filen]    -include： 指明include路径 -define： 定义参数， 如 -define TYPE=1（参数赋值等号左右无空格） -nocomments: 去除文件中的注释 -noprotect: 注释保护，默认是不对注释内容进行处理的，如果设为-noprotect，会处理注释内容 -delimeter string: 默认是@，可以指定其他字符 其他参数：待学习，暂不清楚  使用场景 删除注释 使用命令 ep3 -nocomments filename.v \u0026gt;filename.v ，即可删除代码中所有注释内容。\n循环  原代码   1 2 3  @for i =2 to 5 reg mem@i; @endfor    ep3 filename.v \u0026gt;filename.v 处理后   1 2 3 4  reg mem2; reg mem3; reg mem4; reg mem5;   传递参数和条件判断 注意：ep3传递参数和带参数值的条件判断（@if和@elif和 @else 和@endif关键字），只能使用命令行传参使用。\n 原代码   1 2 3 4 5 6 7 8 9  @if TYPE == 0 reg TYPE_0; @elif TYPE == 1 reg TYPE_1; @elif TYPE == 2 reg TYPE_2; @else reg TYPE_3; @endif    ep3 -define TYPE=2 filename.v \u0026gt;filename.v 处理后（注意，TYPE=2，等号左右无空格；如果多个参数，每一个参数前都要有-define）：   1  reg TYPE_2;   定义宏  原代码（也可以将宏定义内容放到某文件，在使用宏前进行include，效果相同，关于include的使用请参考下文)：   1 2 3  @macro `A_WIDTH 8 reg [`A_WIDTH-1:0] sig1;    处理后：   1  reg [8-1:0] sig1;   def判断 关键字：@ifdef和@ifndef和@else和@endif。\n 原代码（也可以将define定义内容放到某文件，在def判断前进行include，效果相同，关于include的使用请参考下文）：   1 2 3 4 5 6 7  @define TYPE0_ON @ifdef TYPE0_ON reg TYPE_0; @else reg TYPE_1; @endif    处理后：   1  reg TYPE_0;    还可以使用@enum定义宏，一行定义多个，与@define效果相同   1  @enum a,b,c,d   include  原代码：   1 2  //include @include \u0026#34;inc1.v\u0026#34;    创建inc1.v文件，其内容如下（如果是@define或@macro，换成对应内容即可）：   1 2  reg mem1; reg mem2;    ep3关于include的查找默认是当前目录，使用 ep3 filename.v \u0026gt;filename.v 命令即可 ，如果非同一目录，可以在命令行指定目录 ep3 -include ./include/ filename.v \u0026gt;filename.v ，也可以在@include语句中指明文件目录，处理后如下：   1 2 3  //include reg mem1; reg mem2;   replace  原代码  replace以空格为分隔符，第一个参数作为被替换对象，其余作为替换内容。\n1 2 3  @replace AA BB MM CC This is AA;    处理后   1  This is BB MM CC;   perl_begin和perl_end ep3支持在代码中使用perl语言生成代码，关键字是@perl_begin和@perl_end。\n 原代码：   1 2 3 4 5  @perl_begin for($i=0;$i\u0026lt;3;$i++) { print \u0026#34;reg mem${i};\\n\u0026#34;; } @perl_end    处理后：   1 2 3  reg mem0; reg mem1; reg mem2;   也可以使用perl语言定义子函数，辅助生成代码：\n 原代码（定义了@hello函数）：   1 2 3 4 5 6 7 8 9 10  1 Text to be printed ... @perl_begin sub hello { my $self = shift; print \u0026#34;Hello there\\n\u0026#34;; } @perl_end 2 Text to be printed ... @hello 3 Text to be printed ...    处理后（在“2 Text”后引入@hello）：   1 2 3 4  1 Text to be printed ... 2 Text to be printed ... Hello there 3 Text to be printed ...   更多无耻要求 以上是常用场景，基本满足日常需求了，如有更多无耻要求，请查看相关资料，并且有解决方案的话，欢迎分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":56,"section":"docs","tags":["Verilog"],"title":"代码预处理工具ep3的使用","uri":"https://www.wenhui.space/docs/06-linux-skills/tools-skills/ep3_tool/"},{"content":"本文 主要介绍一款自己开发的Python脚本： verilog中reg和wire的自动声明 。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Python： Python 2.7.13  功能  该脚本会统计always块和assign语句中的赋值对象，并且自动识别wire类型和reg类型，以及信号位宽，完成自动声明。 会滤除已声明的wire和reg信号，以及output信号，不会对已声明的信号重复声明。 支持位宽使用宏定义，建议使用 [`XXX_WIDTH-1 : 0] 方式定义（对于使用宏定义的信号，需要对自动生成的声明结果再次确认，如有修改，可将修改后的信号声明置于/*AUTO DECLARE*/之前，脚本不会对已声明的信号重复声明）。 自动滤出注释内容。 其他功能，待添加（如begin end匹配检查）  脚本源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304  #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import operator import re import os import os.path #Ignore comments Begin #-------------------------------------------------------- def ignore_comments(line_val, nextline_is_comment): line_nocomment=re.sub(\u0026#39;//[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_val) #Ignore comments(//) line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments(/* */) line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) #Ignore comments(/* */ Cross-line_nocomment) currentline_is_comment=nextline_is_comment if \u0026#34;/*\u0026#34; in line_nocomment: nextline_is_comment=True line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if \u0026#34;*/\u0026#34; in line_nocomment: nextline_is_comment=False currentline_is_comment=False line_nocomment=re.sub(\u0026#39;[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if currentline_is_comment: line_nocomment=re.sub(\u0026#39;[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) if line_nocomment == \u0026#39;\u0026#39;: line_nocomment=\u0026#34;/*LINE_IS_COMMENT*/\u0026#34; return line_nocomment, nextline_is_comment #-------------------------------------------------------- #Ignore comments End #Fetch Keywords Add To Dict Begin #-------------------------------------------------------- def fetch_keywords(line_val): line_val=re.sub(\u0026#39;input \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;output \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;wire \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;reg \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;assign \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;[\u0026lt;]?=[\\S\\s]*\u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=line_val.strip() signal_width=re.findall(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, line_val) if len(signal_width) != 0 : signal_name=re.sub(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, \u0026#39;\u0026#39;, line_val) signal_name=signal_name.strip() signal_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;\\[[\\s]*([`a-zA-Z0-9_\\-]+)\u0026#39;, line_val)) signal_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;([`a-zA-Z0-9_\\-]+)[\\s]*\\]\u0026#39;, line_val)) else: signal_name=line_val.strip() signal_width_max=\u0026#39;0\u0026#39; signal_width_min=\u0026#39;0\u0026#39; return signal_name, signal_width_max, signal_width_min #-------------------------------------------------------- #Fetch Keywords Add To Dict End #Add Keys To Dict Begin #-------------------------------------------------------- def add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, key_val, key_width_max, key_width_min): if type_val == \u0026#39;output_type\u0026#39;: output_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;input_type\u0026#39;: input_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;wire_type\u0026#39;: wire_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;reg_type\u0026#39;: reg_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return input_check=input_dict.has_key(key_val) output_check=output_dict.has_key(key_val) reg_check=reg_dict.has_key(key_val) wire_check=wire_dict.has_key(key_val) addwire0_check=addwire_dict0.has_key(key_val) addreg0_check=addreg_dict0.has_key(key_val) addwire1_check=addwire_dict1.has_key(key_val) addreg1_check=addreg_dict1.has_key(key_val) if key_width_max.isdigit() and key_width_min.isdigit(): if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: signal_width_max=addwire_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addwire_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addwire_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addwire_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif output_check or addwire1_check or wire_check: pass else: addwire_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: signal_width_max=addreg_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addreg_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addreg_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addreg_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif addreg1_check or reg_check: pass else: addreg_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) else: update_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;`[a-zA-Z0-9]+[\\s]*\\-[\\s]*1\u0026#39;, key_width_max)) update_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;0\u0026#39;, key_width_min)) if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: addwire_dict0.pop(\u0026#39;key_val\u0026#39;) if addwire1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif output_check or wire_check: pass else: addwire_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: addreg_dict0.pop(\u0026#39;key_val\u0026#39;) if addreg1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif reg_check: pass else: addreg_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return #-------------------------------------------------------- #Add Keys To Dict End #Print Declare Begin #-------------------------------------------------------- def print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1): addwire_dict0_keys=addwire_dict0.keys() addwire_dict1_keys=addwire_dict1.keys() addreg_dict0_keys=addreg_dict0.keys() addreg_dict1_keys=addreg_dict1.keys() print \u0026#34; // Begin auto declaration\u0026#34; print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict1_keys: if addwire_dict1[key][\u0026#39;width_max\u0026#39;] == addwire_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addwire_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict1_keys: if addreg_dict1[key][\u0026#39;width_max\u0026#39;] == addreg_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addreg_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict0_keys: if addwire_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; wire \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addwire_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict0_keys: if addreg_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; reg \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addreg_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // End auto declaration\u0026#34; #-------------------------------------------------------- #Print Declare End #Main Program Begin #-------------------------------------------------------- #open verilog file #================= try: vfile=open(sys.argv[1], \u0026#39;r\u0026#39;) alllines=vfile.readlines() except (IOError,OSError) as reason: print(\u0026#39;文件出错了！错误原因是：\\n\u0026#39; + str(reason)) finally: vfile.close() #================= #line process #================= input_dict={} output_dict={} wire_dict={} reg_dict={} addwire_dict0={} addreg_dict0={} addwire_dict1={} addreg_dict1={} nextline_is_comment=False currentline_is_comment=False line_num=0 for line in alllines: line_num+=1 line_nocomment, nextline_is_comment=ignore_comments(line, nextline_is_comment) if line_nocomment == \u0026#34;/*LINE_IS_COMMENT*/\u0026#34;: continue #print \u0026#34;Line Nocomment:\u0026#34;, line_nocomment output_regex=re.compile(\u0026#39;(output[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) input_regex=re.compile(\u0026#39;(input[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) wire_regex=re.compile(\u0026#39;(wire[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) reg_regex=re.compile(\u0026#39;(reg[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) addwire_regex=re.compile(\u0026#39;(assign[\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) addreg_regex=re.compile(\u0026#39;([\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) output_line=output_regex.findall(line_nocomment) input_line=input_regex.findall(line_nocomment) wire_line=wire_regex.findall(line_nocomment) reg_line=reg_regex.findall(line_nocomment) addreg_line=addreg_regex.findall(line_nocomment) addwire_line=addwire_regex.findall(line_nocomment) if len(output_line) != 0: type_val=\u0026#34;output_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(output_line)) elif len(input_line) != 0: type_val=\u0026#34;input_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(input_line)) elif len(wire_line) != 0: type_val=\u0026#34;wire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(wire_line)) elif len(reg_line) != 0: type_val=\u0026#34;reg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(reg_line)) elif len(addwire_line) != 0: #Note: wire should be judged before reg type_val=\u0026#34;addwire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addwire_line)) elif len(addreg_line) != 0: type_val=\u0026#34;addreg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addreg_line)) else: continue # print \u0026#34;##Type Vale :\u0026#34;, type_val # print \u0026#34;##Signal_Name :\u0026#34;, signal_name # print \u0026#34;##Signal_Width_Max:\u0026#34;, signal_width_max # print \u0026#34;##Signal_Width_Min:\u0026#34;, signal_width_min # print \u0026#34;\\n\u0026#34; add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, signal_name, signal_width_max, signal_width_min) #================= #print declare #================= #print addwire_dict0 #print \u0026#34;\u0026#34; #print addwire_dict1 #print \u0026#34;\u0026#34; #print addreg_dict0 #print \u0026#34;\u0026#34; #print addreg_dict1 print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1) #================= #-------------------------------------------------------- #Main Program End   使用方法 写在前头  此脚本要求所有自声明的wire和reg要在/*AUTO DECLARE*/之前 要添加自动声明的位置，严格使用/*AUTO DECLARE*/关键字。 本脚本不支持以下赋值语句，请不要使用同时给多个信号赋值的语句：   1  assign {sig_a, sig_b} = 2\u0026#39;b11;    此脚本只自动声明被赋值信号，如有例化模块的输出信号，请使用emacs verilog-model 的AUTOWIRE。  手动添加 可以使用脚本将自动声明结果打印的屏幕或重定向到文件，手动赋值粘贴，使用命令如下(脚本文件名为verilog_auto_declare.py)：\n1 2  python verilog_auto_declare.py verilog_filename.v python verilog_auto_declare.py verilog_filename.v \u0026gt;autodeclare.log   shell封装 如果想将声明结果自动添加到文件，需要用shell将脚本进行封装。\n print_declare.sh（请更改为自己的verilog_auto_declare.py路径）   1 2 3 4 5 6  #!/bin/bash  python ~/Treasury/tools_and_drives/verilog_auto_declare/verilog_auto_declare.py $1 \u0026gt;autodeclare.log sed \u0026#39;/\\/*AUTO DECLARE/r autodeclare.log\u0026#39; $1 \u0026gt; print_declare.v mv print_declare.v $1 rm -rf autodeclare.log    delete_declare.sh   1 2 3 4  #!/bin/bash  sed \u0026#39;/\\/\\/ Begin auto declaration/,/End auto declaration/c \\\u0026#39; $1 \u0026gt;delete_declare.v mv delete_declare.v $1   使用时 source print_declare.sh verilog_filename.v 和 source delete_declare.sh verilog_filename.v 即可。也可以将shell脚本文件属性改为可执行，通过设置alias或将其放到linux的PATH变量路径，可以在终端直接使用。如下：\n 更改文件属性   1 2  chmod 755 print_declare.sh chmod 755 print_declare.sh    设置alias（将下面内容添加到~/.bashrc文件）   1 2 3  #verilog_auto_declare alias print_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/print_declare.sh\u0026#39; alias delete_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/delete_declare.sh\u0026#39;   效果 verilog源码 以下代码无实际意义，仅作为测试使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   print_declare后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ // Begin auto declaration  // Please double check the declaration with macro  wire [`YYYYWIDTH] marco_yyyy; wire [`XXXXWIDTH-1:0] marco_xxxx; reg [`AAAAWIDTH-1:0] marco_aaaa; reg [`BBBBWIDTH-1:0] marco_bbbb; // Please double check the declaration with macro  wire w_yyyy; wire w_xxxx; wire [ 1: 1] wccy; wire [ 2: 2] wccx; reg r_yyyy; reg r_zzzz; reg r_xxxx; // End auto declaration  //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   下载  百度网盘分享资源 链接：https://pan.baidu.com/s/1WEzfSkeZsgYp8gITMsWtqQ 密码：7ui9  其他说明 此版本为初步完成，可能存在部分bug，如有发现bug或有新的需求，欢迎交流。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":57,"section":"docs","tags":["Python","Verilog"],"title":"verilog中reg和wire的自动声明","uri":"https://www.wenhui.space/docs/06-linux-skills/script-skills/verilog_auto_declare/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第二篇，主要介绍接口、采样和数据驱动、测试的开始和结束、调试方法。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明           接口 什么是接口？  接口 主要用作验证 ，国外有些团队会使用sv进行设计，那么接口就会用作设计。 验证环境中，接口可以 使连接变得简洁而不易出错 。 interface和module的使用性质很像， 可以定义端口，也可以定义双向信号，可以使用initial和always，也可以定义function和task 。 interface可以 在硬件域和软件域间传递信息 ，也就是可以作为module的端口列表，也可以作为软件方法的形式参数。 对于interface的初步认识，可以看作“插排”，DUT与TB之间的数据驱动就是靠这个“插排”来完成的。  接口的定义与使用  interface的定义结构与module类似。 interface的 端口列表只需定义时钟、复位等公共信号 ，或者不定义任何端口信号，而在变量列表中定义DUT与TB连接的各个变量， 建议用logic来定义 。 interface也可以依靠参数化方式提高复用性。 interface在例化时， 与module例化方式相同 。 对于有对应interface的DUT和TB组件，在例化时，传递匹配的interface变量名也就完成了interface内变量的传递，换句话说就是两者打通，对应interface的不同组件之间变量信号实时传递。       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  interface arb_interface(input bit clk); logic [1:0] grant, request; logic reset_n; endinterface module arb(arb_interface arb_if); //......  always@(posedge arb_if.clk or negedge arb_if.reset_n)begin if(!arb_if.reset_n) arb_if.grant \u0026lt;= 2\u0026#39;b00; else arb_if.grant \u0026lt;= next_grant; end //...... endmodule module testbench(arb_interface arb_if); //......  initial begin @(posedge arb_if.clk) arb_if.request \u0026lt;= 2\u0026#39;b01; $display(\u0026#34;@%0t: Drove req=01\u0026#34;, $time); repeat(2) @(posedge arb_if.clk); if(arb_if.grant != 2\u0026#39;b01) $display(\u0026#34;@%0t: a1: grant != 2\u0026#39;b01\u0026#34;, $time); $finish; end endmodule module tb_top; bit clk; initial clk = 1\u0026#39;b0; always #5 clk = ~clk; arb_interface arb_if(clk); arb a1(arb_if); test t1(arb_if); endmodule   接口的优势  将有关信号封装在接口，对于设计和验证环境都便于维护，如需修改、添加、删除信号，只需修改interface文件即可。 接口在硬件域（module）和软件域（class）都可以使用，是 硬件域和软件域交互的唯一媒介 。 接口可例化，对于多组相同总线，通过例化可灵活使用，简化代码且便于维护。 每一个agent使用对应的interface，简化验证平台结构，便于维护。 tb顶层例化时，无需定义信号连线，只需例化interface。  采样和数据驱动 竞争问题  为了避免RTL仿真行为中发生信号竞争问题， 建议使用非阻塞赋值(\u0026lt;=) （简单来说阻塞赋值是顺序执行，非阻塞赋值是并发执行，硬件电路行为是并发执行）。 在仿真行为中，为了避免时序电路中时钟和驱动信号的时序竞争，我们需要 尽量明确驱动时序和采样时序 。 默认情况下，时钟对于组合电路的驱动会添加一个 无线最小时间（delta-cycle）的延迟 ，而该延迟无法用绝对时间单位衡量，它要比最小时间单位精度还要小。这是 仿真工具为了符合硬件电路真实行为（建立时间保持时间以及线延迟）而做出的处理 。（注意： #0并不代表0延迟，而是指延迟delta-cycle）  为了说明delta-cycle的概念，举例如下：\n 源代码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  `timescale 1ns/1ps module top_module (); bit clk1,clk2; bit rstn; logic [7:0] d1; initial begin clk1 = 0; forever #5 clk1 \u0026lt;= ~clk1; end always@(clk1) clk2\u0026lt;=clk1; initial begin #0 rstn \u0026lt;= 0; #10 rstn \u0026lt;= 1; #20 $finish; end always@(posedge clk1 or negedge rstn) if(!rstn) d1 \u0026lt;= 0; else d1 \u0026lt;= d1+1; always@(posedge clk1) $display(\u0026#34;clk1: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); always@(posedge clk2) $display(\u0026#34;clk2: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); endmodule    仿真结果：   Running Icarus Verilog simulator... VCD info: dumping is suppressed. clk1: 5000 ps d1 value is 0xxx clk2: 5000 ps d1 value is 0x0 clk1: 15000 ps d1 value is 0x0 clk2: 15000 ps d1 value is 0x1 clk1: 25000 ps d1 value is 0x1 clk2: 25000 ps d1 value is 0x2 Hint: Total mismatched samples is 0 out of 0 samples Simulation finished at 30000 ps Mismatches: 0 in 0 samples 为什么同样在25000ps时刻，d1在clk1和clk2下的采样值不同？首先clk2是在clk1下驱动的，也就是clk2比clk1延迟一个delta-cycle时间，clk1驱动了d1，d1也比clk1延迟一个delta-cycle时间。25000ps，当在clk1下采样时，d1的值还未更新，所以采到的是0x1；而在clk2下采样时，d1已由clk1驱动更新，所以采到的是0x2。如果还未完全理解，可以打开波形窗口，不过要打开delta-cycle的开关，可以看到delta-cycle的存在，对电路的数据驱动和采样时序会有更直观的理解。\n  总结：\n 如果处于各种原因，clk与被采样数据之间存在若干个delta-cycle的延迟，那么对数据的采样会存在问题。 采样数据的竞争问题会成为潜在困扰仿真采样准确性的问题。 避免采样的竞争问题： 1）在驱动时，添加相应的人为延迟，使clk与驱动变量之间的延迟加大，提高DUT使用驱动信号时的准确度；2）在采样时，依靠采样前某段时刻进行采样，来模拟建立时间的采样要求，确保采样的可靠性。    图示：\n    未显示 delta-cycle     显示 delta-cycle    clocking  在接口中声明clocking（时序块）和采样的时钟信号，可以用来 实现信号的同步和采样 。 clocking块基于时钟周期对信号进行驱动或采样的方式，使testbench不再苦恼于如何准确及时地对信号驱动或采样,消除了信号竞争的问题。   1 2 3 4 5 6  clocking bus @(posedge clk1); default input #10ns output #2ns; input data, ready, enable; output negedge ack; input #1step addr; endclocking          对上述clocking描述代码进行说明 ：\n 第一行定义clocking块bus，使用上升沿来驱动和采样。 第二行指出输入信号在clk1上升沿之前5ns采样，输出信号在clk1上升沿之后2ns驱动（输入为采样，输出为驱动）。 第三行声明输入信号，采用默认的输入事件（clk1上升沿5ns前采样）。 第四行声明输出信号，并且指明为clk1下降沿驱动，覆盖了原有的clk1上升沿后2ns驱动。 第五行定义了输入信号addr，采用了自定义的采样事件，clk1上升沿后的1 step，覆盖了原有的clk1上升沿前5ns采样，这里1 step使得采样发生在clk1上升沿的上一个时钟片采样区域，即可以保证采样到的数据是上一个时钟周期数据。    clocking块的总结 ：\n clocking块不仅可以定义在interface中，也可以定义在module和program中。 clocking中列举的信号不是自己定义的，而是interface或其他声明clocking的模块定义的。 clocking在声明完后，应该伴随着定义默认的采样事件，也就是“default input/output event”，如果没有定义，会默认使用时钟上升/下降沿前1step进行采样，时钟上升/下降沿后#0进行驱动。 除了定义默认的采样和驱动事件，定义信号方向时同样可以用新的采样/驱动事件对默认事件进行覆盖。    modport modport本身目的就是将信号分组和指明输入输出方向，在连接时工具会进行端口方向检查，防止连接出错，不过掌握clocking之后，可以忽略modport，clocking已经对信号输入输出方向进行了声明。\n结论  为了避免采样竞争问题，验证工程师应该在验证环境的驱动环节添加固定延迟，使得在仿真波形中更容易体现出时钟与被驱动信号之间的时序前后关系，同时这样也便于对DUT的准确处理和TB的准确采样。 如果TB在采样从DUT送出的数据，在时钟与被驱动信号之间存在delta-cycle时，应该考虑在时钟采样沿的更早时间端段去模拟建立时间要求，这种方法也可以避免由于delta-cycle问题带来的采样竞争问题。 当我们把clocking运用到interface中，用来声明各个接口与时钟的采样和驱动关系后，可以大大提高数据驱动和采样的准确性，从根本上消除采样竞争的可能性。  测试的开始和结束 写在前头  各个设计自身可以认为是一个大的线程，内部有包含多个并行的线程，而模块之间连接即线程的通信，主要依靠信号的变化。 可以想象，对于一个设计，如果在仿真开始没有任何激励，那么仿真不具备执行条件，也可以认为已经结束，因为在设计内部没有产生任何新的事件，也不会触发组合逻辑和时序逻辑。 如果仿真开始后仅提供时钟和复位信号，验证会持续下去，而对设计不会产生实质的功能影响。从设计角度来看，复位信号是为了让设计进入一个确定的初始状态，而时钟就是脉搏跳动。 verilog测试中，可以通过系统函数 “$finish()” 来结束仿真，也可以通过 “$stop()” 来暂停仿真。  program  program是作为验证而提出的，可以有效控制仿真的进程，但是目前验证平台更多基于UVM，UVM有独特的控制机制，所以program在实际项目中使用并不多。 program的提出， 将验证部分和设计部分进行有效隔离 ，每一个program作为一个独立测试， 当testbench中所有program中最后一个initial块完成后，结束仿真 。这是program的隐式结束。 有些program内的initial块无法正常结束，这时候需要使用 显示结束，使用“$exit()” 来结束program。 program被看做软件域，所以不可以出现always、module、interface等硬件相关语句，并且不可以例化其他program。 program被看做软件域，可以在program内部定义变量和发起多个initial块，并且建议使用阻塞赋值（软件方式的顺序执行）。 program对于数据采样也可以消除delta-cycle竞争问题，详细内容可见红宝书“SV环境构建篇之程序和模块”。（待了解）  总结  硬件域（module）、软件域（program）、中间域（interface） 。 不仅可以使用interface clocking来消除采样竞争问题，可以使用program（建议使用clocking）。 program可以控制仿真的结束。 使用“$stop()”和“$finish()”可以结束仿真。  调试方法 调试工具 大多工程师选择使用verdi作为调试工具，主要有三个窗口：层级列表窗口、源代码窗口、波形窗口。verdi的具体使用方法，请参考我的另一篇帖子 Verdi使用总结 。\n打印消息 打印消息是调试循环语句、顺序执行语句等查看路径和当前变量值的简便方式，除此之外，由于验证平台更多变量是动态的，无法在调试工具查看动态变量值，所以对与验证环境的调试，更多使用打印消息。\n打印消息命令“$display()”：\n $time代表仿真时间变量。 显示格式： %x（十六进制）、%d（十进制）、%b（二进制）、%s（字符串）、%t（时间）。 $display（消息级别）、$warning（警告级别）、$error（错误级别）、$fatal（严重错误级别） 字符串变量格式化：string s = $sformatf(\u0026ldquo;Hello, %s!\u0026quot;, name_s);  设置断点  可以通过调试工具为程序设置断点。 通过设置断点（breakpoint）可以查看程序执行到断点处（程序暂停）的变量数值，而设置断点要求验证工程师对程序执行顺序足够了解。 设置断点可以便于查看软件程序（function、task、object）中局部变量的数值。注意：动态变量是无法添加到波形查看的。 设置断点还可以方便调试程序执行的顺序，例如在顺序执行语句执行的多个位置设置断点，通过仿真执行，查看程序是否在断点处暂停，如果没有，那么程序的挂起（hang-on）原因就在上一个断点和此断点之间。通过此方法可定位可疑程序的范围。 如果查看局部变量，需要使用局部变量窗口（Local Windows），继而通过断点查看变量（暂时不知verdi是否支持，待学习）。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":58,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（二）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-two/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 SV学习笔记 部分第一篇，主要介绍数据类型、过程块、方法（函数与任务）、设计例化和连接。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《SystemVerilog验证》 克里斯.斯皮尔 书籍    专业术语与缩略语    缩写 全称 说明     SV SystemVerilog 基于Verilog扩展而来的，为验证而生的语言    数据类型 內建数据类型   四状态与双状态 ：\n 四状态指0、1、X、Z，包括logic、integer、 reg、 wire。 双状态指0、1，包括bit、byte、 shortint、int、longint。    有符号与无符号 ：\n 有符号：byte、shortint、int、longint、integer。 无符号：bit、logic、reg、wire。    关于数据类型使用的几个注意点 ：\n SV中虽然支持reg和wire，但对于 验证平台要尽量使用logic ，并且建议采样RTL信号时变量要使用logic类型。 实际工作中 使用最多的是logic和bit ，一般 需要计数和比较大小时会使用byte或int 。 尽量 避免两种不同数据类型变量进行操作 ，包括 有无符号、四状态双状态、不同位宽 ，如必须进行操作，请先转换为同一类型。    关于数据类型转换的几个注意点 ：\n 四状态转换为双状态时， x和z转换为0 。 多位数据赋值给少位数据，则 高位被截取忽略 ；少位数据赋值给多位数据，双状态类型的 高位赋值为0 ，四状态类型的 高位赋值为x 。（以上指的是无符号类型） 有符号变量转无符号变量，直接赋值的话会将 原始比特数据 赋给无符号变量，但其原符号位失去含义；使用转换语句转换的话，会将有符号变量 取模 赋值给无符号变量。 总之，还是尽量避免数据类型间的转换，数据类型间的转换是容易出错的地方，需要格外注意。    数据类型转换操作 ：\n   1 2 3 4 5 6 7 8 9 10 11 12 13  //静态转换（不对转换值进行检查）： unsigned_data = unsigned\u0026#39;(signed_data); int_data = int\u0026#39;(real_data); real_data = real\u0026#39;(int_data); //动态转换（仿真时对转换值进行检查，转换失败会报告）： //$cast(tgt, src); $cast(unsigned_data, signed_data); //静态和动态转换都属于显示转换，不借助操作符的转换称为隐式转换 logic data0; bit data1; data1 = data0;   定宽数组  数组声明 :   1 2 3 4 5 6 7 8 9 10  //变量左侧为矢量宽度，右侧为维度，且从左至右代表维度从高到低  //二维数组（习惯上左右顺序是从低到高，这对初始化很重要） int data_a[0:15]; // 16个整数[0]...[15] int data_a[16]; // 紧凑型声明  //多维数组（左边为高维度） int data_a[0:7] [0:3]; int data_a[8] [4]; // 紧凑的多维数组声明 int data_a[7][3] = 1; // 为最后一个元素赋值    数组的初始化和赋值 ：   1 2 3 4  int data_a[4] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[0:3] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[4] = \u0026#39;{4{1}}; //全赋值为1 int data_a[4] = \u0026#39;{5,default:-1}; //data_a[0]为5，其他为-1    存储空间 ：   1 2 3 4 5 6 7 8 9  bit [3][7:0] b_pack; bit [7:0] b_unpack [3]; logic [3][7:0] b_pack; logic [7:0] b_unpack [3]; //变量左侧代表矢量宽度，右侧代表数组维度，也可以称为数组的合并与非合并，以上都可以代表24bit数据容量。 //二值逻辑bit声明，每bit位占用1bit空间，第一种声明占用1WORD空间，3x8bit，第二种声明占用3个WORD空间，3WORD x 1x8bit； //四值逻辑logic声明，每bit位占用2bit空间，第一种声明占用2WORD空间，3x16bit，第二种声明占用3WORD空间，3WORD x 1x16bit。 //所以，在合适的时候选用合并数组，能够节省存储空间。（软件仿真时计算机空间占用都是以word为单位的）         数组操作之for和foreach循环 ：   1 2 3 4 5 6 7 8 9 10  bit [31:0] src[5]; bit [31:0] dst[5]; for(int i=0; i\u0026lt;$size(src); i++) src[i] = i; foreach (dst[j]) dst[j] = src[j] * 2; //$size(src)是获取最高维度变量个数，也可以指定维度$size(src，1)，其中1代表最高，2次之... //foreach语句会遍历数组变量，这也是最推荐的使用方法，多维度遍历可以使用foreach(dst[i,j])。    数组操作之复制和比较 ：   1 2 3 4 5 6 7 8 9 10 11  bit [31:0] src[5] = \u0026#39;{0,1,2,3,4}; bit [31:0] dst[5] = \u0026#39;{4,3,2,1,0}; if(src == dst) $display(\u0026#34;src == dst\u0026#34;); //比较数组  dst = src; //数组复制  src[0] = 5; //修改数组中某元素  //赋值可以直接使用赋值符号“=”； //直接进行数组的复制； //比较，也可以使用“==”或“!=”来比较，不过结果仅限于内容相同或不相同。   动态数组  定宽数组类型宽度编译时已经确定，若在程序运行时确定数组宽度就要使用 动态数组 。 动态数组特点就是仿真运行时灵活调节数组的大小，也就是存储量。 动态数组开始时使用“[]”来声明，此时数组为空，其后使用“new[]”来分配空间，方括号中传递数组宽度。 调用“new[]”时也可以将数组名一并传递，将已有数组的值复制到新的数组中。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int dyn[]; int d2[]; //声明动态数组  initial begin dyn = new[5]; //分配5个元素  foreach(dyn[j]) dyn[j] = j; //对元素初始化  d2 = dyn; //复制动态数组，d2初始元素个数为零，复制后元素个数为5，且dyn和d2各自独立  d2[0] = 5; //修改元素值，此时dyn[0]仍为0，d2[0]为5  dyn = new[20](dyn); //分配20个数值并进行复制，也就是dyn初始值5个元素复制给了新的dyn低5个元素，高15个元素为0.  dyn = new[100]; //重新分配100个数值，而旧值不复存在  dyn.delete(); //删除所有元素 end   队列  队列结合了链表和数组的优点，可以在任何地方添加和删除元素，并且通过索引实现对任一元素的访问。 队列的声明是使用美元符号的下标：[$]，队列元素标号从0到$。 队列不需要new[]去创建空间，只需要使用队列的方法为其增减元素，队列初始空间为零。 队列的简单使用是通过 push_back()和pop_front() 的结合来实现FIFO的用法。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int j = 1; int q2[$] = {3,4}; int q[$] = {0,2,5}; //队列的赋值不需要单引号  initial begin q.insert(1, j); //{0,1,2,5} 在1位置插入j  q.insert(3, q2); //{0,1,2,3,4,5} 在3位置中插入队列q2  q.delete(1); //{0,2,3,4,5} 删除队列中1位置元素  //下列操作才是队列中最常用方法  q.push_front(6); //{6,0,2,3,4,5} 在队列头部插入  j = q.pop_back(); //{6,0,2,3,4} 在队列尾部弹出  q.push_back(8); //{6,0,2,3,4,8} 在队列尾部插入  j = q.pop_front(); //{0,2,3,4,8} 在队列头部弹出  foreach(q[j]) $display(q[j]); //打印整个队列  q.delete(); //删除整个队列 end   关联数组  如果需要一个超大容量存储空间，而有相当部分数据不会被存储和访问，不管使用定宽数组还是动态数组，都会造成存储的浪费，这时候需要使用关联数组。 关联数组可以保存稀疏矩阵元素，当你对一个非常大的地址空间进行寻址时，该数组 只为写入的元素分配空间 ，所以关联数组需要的空间远小于定宽或动态数组。 此外关联数组的灵活应用，在其他高级语言中都有类似的存储结构，比如Perl语言中称为哈希(Hash)，Python中称为词典(Dictionary)，可以灵活赋予key和value。       1 2 3 4 5 6 7 8 9 10 11 12 13 14  bit [63:0] assoc[int]; //声明关联数组，关联数组中[]内声明数据类型，也就是index类型 int index = 1; repeat(64) begin //对稀疏分布的元素初始化  assoc[index] = index; index = index \u0026lt;\u0026lt;1; //1 2 4 8 16 ...... end foreach(assoc[i]) //使用foreach变量关联数组，注意：并不一定按index大小顺序依次执行（可以使用sort排序）  $display(\u0026#34;assoc[%d] = %h\u0026#34;, i, assoc[i]); //找到并删除第一个元素，使用if(assoc.first(index)) 可以判断数组是否为空 assoc.first(index); //将assoc第一个索引值赋给index assoc.delete(index); //删除assoc的index索引元素   结构体  sv中可以使用struct语句创建结构，与c语言类似。 sv中struct功能较少，只可以定义一个 数据的集合 ，也就是将若干相关变量组合到一个struct结构定义中。 通过 使用typedef和struct，可以定义新的数据类型 ，可利用新的数据类型声明变量。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //非合并结构 typedef struct { bit[7:0] r; bit[7:0] g; bit[7:0] b; } pixel_str; //使用typedef和struct创建新的数据类型 pixel_str  pixel_str my_pixel; //使用新的数据类型声明变量 my_pixel = \u0026#39;{8\u0026#39;h10, 8\u0026#39;h20, 8\u0026#39;h30}; //结构体赋值，此时赋值与声明时一一对应  //合并结构 typedef struct { bit[7:0] r, bit[7:0] g, bit[7:0] b; } pixel_str; //使用typedef和struct创建新的数据类型 pixel_str  pixel_str my_pixel; //使用新的数据类型声明变量 my_pixel = {8\u0026#39;h10, 8\u0026#39;h20, 8\u0026#39;h30}; //结构体赋值，此时赋值与声明时一一对应    关于赋值时什么时候使用单引号：  合并型存储的不需要使用单引号，就好比数据的拼接，队列是合并型存储的。 非合并型存储需要使用单引号，如数组和结构体。    枚举类型  规范的操作码和指令有利于代码的编写和维护，如ADD、WRITE、IDEL等。 枚举类型enum经常 和typedef搭配使用 ，由此便于用户自定义枚举类型的共享使用。 枚举类型 保证避免一些非期望值的出现 ，增加代码可维护性和降低设计风险。   1 2 3 4 5 6 7 8 9 10  typedef enum {INIT, DECODE, IDLE} fsmstate_e; //声明枚举类型和自定义数据类型 fsmstate_e pstate, nstate; //通过自定义枚举数据类型 声明变量  case(pstate) //枚举类型主要应用于状态机  IDEL: nstate = INIT; INIT: nstate = DECODE; default: nstate = IDLE; endcase $display(\u0026#34;Next state is %s\u0026#34;, nstate.name()); //显示状态名   字符串  verilog语言中是不存在字符串的，而sv中添加了字符串string类型。 所有相关的字符串处理，都使用string来保存和处理。 字符串处理相关的格式化函数可以 使用$sformatf() ，如果只是打印输出，可以直接使用$display()。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  string s1, s2; //声明字符串，此时为空。 int i1, i2; initial begin i1 = 2005; s1.itoa(i); // integer converted to string  s2 = \u0026#34;IEEE\u0026#34;; $display(s2.tolower()); //显示 ieee (转小写)  s2 = {s2, \u0026#34;-P1800\u0026#34;}; //字符串拼接， \u0026#34;IEEE-P1800\u0026#34;  s2 = $sformatf(\u0026#34;%s%s\u0026#34;, s1, \u0026#34;-P1800\u0026#34;); //字符串拼接， \u0026#34;IEEE-P1800\u0026#34;  i2 = s2.len(); //获取字符串长度  $display(\u0026#34;@%t: %s\u0026#34;, $time, $sformatf(\u0026#34;%s %d\u0026#34;, s2, 42)); //$sformatf返回字符串 end   过程块  过程快有两种：initial和always。 initial是 不可综合的 ，为验证而生，always是 可综合的 ，代表硬件电路。 always是 硬件行为 ，可综合，使用时需要 区分时序电路描述和组合电路描述 。 initial是 软件行为 ， 块内语句 顺序执行，且只执行一次 。 initial块和always块之间，以及不同initial块，不同always块，在 仿真一开始都是同时执行 的。 在verilog时代，所有的测试都放在initial块中，并且为了便于统一管理，建议 放在同一个initial块中 。 module、interface可视为 硬件域 ，program、class可视为 软件域 ，区分硬件域和软件域对理解initial和always很有帮助。 initial块可以放在module、interface和program中；always块只能放在module、interface中。 对于过程块，使用 begin\u0026hellip;end 将其作用域包住，对于控制语句和循环语句，同样适用。  方法（函数与任务） 函数function  可以在参数列表指定输入参数(input)、输出参数(output)、输入输出参数(inout)或者引用参数(ref)，如果不指明默认为input。 可以有返回值，也可以无返回值(void)。 函数其他属性：  默认数据类型为logic。 数组可以作为形式参数传递。 function可以返回或不返回结果，返回结果需要使用关键字return，不返回需要声明为void function。 只有数据变量可以在形式参数列表被声明为ref类型，而线网类型则不能声明为ref类型。 使用ref时，有时为了保护参数对象只被读取不被修改，可以通过const的方式限定ref声明的参数。 在声明参数时，可以设置默认值（input a=10），同时如果在调用时省略参数的传递，则函数中使用默认值。     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function int double_f1(input int a); return 2*a; endfunction function void double_f2(constraint ref int a, ref int b); b = 2*a; endfunction initial begin int a; int b; double_f2(a, b); $display(\u0026#34;double of %0d is %0d\u0026#34;, 10, double_f1(10)); $display(\u0026#34;double of %0d is %0d\u0026#34;, 10, b); end   任务task 任务相比函数更加灵活，且有以下不同点：\n task无法通过return返回结果（也无需加void），只能通过input、output、inout或ref的参数来返回。 task内 可以使用耗时语句 ，而function不能。常见的耗时语句如： @event、wait event、#delay 等。   1 2 3 4 5 6 7  task double_t1(input [31:0] a, output [31:0] b); //不指明方向则默认为input  b = 2*a; endtask task double_t2(constraint ref int a, ref int b); b = 2*a; endfunction   使用建议  初学者傻瓜式用法，可以 全部采用task来定义方法 ，因为它可以内置耗时语句，也可不以内置耗时语句。 经验者要区分两种方法， 非耗时方法使用function，耗时方法使用task ，也就是function中完成纯粹的逻辑运算，而task更多完成需要耗时的信号采样或者驱动等场景。 调用function：在function和task内均可以调用其他function；用task，如果被调用task内使用了耗时语句，只能在task调用。  变量的声明周期  sv中数据的生命周期分为 动态(automatic)和静态(static) 。 局部变量 的生命周期与其所在域共存亡，也就是在function/task中的临时变量， 在其被调用结束后，临时变量的生命周期也将终结 。 全局变量 在程序执行 开始到结束一直存在 。 如果数据变量被声明为automatic，那么在进入该进程/方法后，automatic变量会被创建，离开该进程/方法后，automatic变量被销毁。而static在仿真开始时被创建，而在进程/方法执行过程中，不会被销毁，且可以 被多个进程和方法所共享 。 module内全部是静态变量，代表真实的电路结构。 对于automatic方法，其内部所有变量默认也是automatic。 对于static方法，其内部所有变量默认也是static。 对于static变量， 声明时应该对其做初始化 ，而初始化只会伴随它的生命周期执行一次，不会随着方法调用而多次初始化。 在module、program、interface声明的变量，以及其他在task/function之外声明的变量，默认是静态变量，存在于是整个仿真阶段。  设计例化和连接 模块定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  module xprop ( // Outputs out1, // Inputs clk, sel, din0 ); input clk; input sel; input [7:0] din0; output out1; //...... //......  endmodule   模块例化 1 2 3 4 5 6 7 8 9 10 11 12  module testbench; //...... //......  xprop dut( // Outputs  .out1 (out1), // Inputs  .clk (clk), .sel (sel), .din0 (din0)); endmodule   模块连接 模块连接就是将硬件电路在测试平台进行例化，传统的verilog验证方法，在initial过程块产生激励，驱动硬件电路完成仿真。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":59,"section":"docs","tags":["SystemVerilog"],"title":"SV学习笔记（一）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/sv-study-note-one/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 验证工程师与芯片验证 部分第五篇，主要介绍验证方法、UVM简介、UVM组件、UVM环境。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《全面的功能验证：完整的工业流程》 Bruce Wile , John C. Goss , Wolfgang 书籍    专业术语与缩略语    缩写 全称 说明     DUT Device/Design Under Test 待测试器件/设计   RTL Register Transfer Level 寄存器传输级   ESL electric system level 电子系统级（比RTL抽象级别更高，主要用于系统建模）   CDC Cross-clock Domain Check 跨时钟域检查   EC Equivalence Check 等价性检查（形式化验证的一种方式）   PC Property Check 属性检查（形式化验证的一种方式）   HLS High Level synthesis 高阶综合   UVM Universal Verification Methodology 通用验证方法学    验证方法 写在前面  目前验证方法和工具种类繁多，最好在系统了解验证方法和工具后，掌握 一整套工具箱 ，根据设计的特点选用合适的验证方法。 目前的芯片设计，已经无法依赖 单一的工具、语言或方法 来达到验证的完备性。 不同的语言、方法、工具以及脚本 没有绝对的优劣区分 ，比如仿真验证协同形式化验证一同完善功能覆盖率，也可能通过语言和脚本之间的整合来最终完成一项验证流程。 作为一名有经验的验证工程师，需要在掌握现有的各种方法和工具的前提下，通过合理的选择，最后 保质高效低耗 地完成验证任务。  方法分类  动态仿真（dynamic simulation） 静态/形式检查（formal check） 虚拟模型（virtual prototype） 硬件加速（hardware acceleration） 电源功耗（power consumption） 性能评估（performance evaluation）  动态仿真  该方式是通过 测试序列 和 激励生成器 驱动dut，伴随着仿真时间，进而判断 输出是否符合预期 。 我们需要 仿真器 来配合这一项工作，验证人员也需要 查看比较结果和仿真波形 ，最终判断测试用例 是否通过 。 如果按照激励生成方式和检查方式，我们可以将动态仿真进一步分为： 定向测试、随机测试、参考模型检查、断言检查 。  静态/形式检查 与动态仿真相对的是静态检查，它本身 不需要仿真激励 ，通过 工具的辅助 ，验证人员即可以发现设计中存在的问题。静态检查可以细分出更多种类，它们关注的领域也不相同，我们将这些方法概括为：\n 语法检查（syntax check） ：  与编译器自带的功能一样，验证工具一旦需要建立模型，都需要编译器对目标语言提供语法检查。 仿真编译器会帮助检查语法错误，例如 拼写、声明、引用、例化、连接、定义 等常见语法错误。 不同仿真工具对语言标准的解释也可能存在少量偏差，以及严格度略有不同。   语义检查（linting check） ：  语义检查和语法检查相比，是在 设计的可行性 上做 深度检查 。 语义检查使用专用工具来协助完成，例如spyglass，语义检查的范围包括： 常见的设计错误、影响覆盖率收敛的问题、可能会产生x值以及受其影响的设计部分 。 这些静态检查最大的便捷之处在于，可以 早期 发现一些 功能实现以外的设计问题 ，而且也有助于 完善设计代码 ，以便提高有效覆盖率以及RTL与网表的逻辑 一致性 。   跨时钟域检查（CDC Cross-clock Domain Check） :  有些 复杂的设计 都拥有 多个时钟 ，且表现为 异步关系 ，不同模块被不同的时钟驱动，就会形成 不同的时钟域 。 拥有多时钟域的硬件，它的 跨时钟域 的逻辑通讯就需要考虑同步问题了。用来验证这些设计要求的过程被称为 跨时钟域检查 。 之所以需要同步是考虑到不同时钟域的 信号采样问题 ，当时钟域A的信号进入时钟域B被采样时， 相对于时钟B存在不同的延迟 ，这种随机性可能导致 建立时间或者保持时间无法满足 ，进而导致 不可预期 的功能失败。 这种跨时钟域问题无法通过RTL动态仿真检查出来，而通过 静态的跨时钟域检查 就可以分析这一问题。 通过该方法可以在设计早期来识别出跨时钟域的问题，CDC就是为了保证所有CDC信号都能够正确的同步，目前支持CDC检查的商业工具有Spyglass等。   形式验证（formal verification） ：  等价性检查（EC， Equivalence Check）：用来保证两个电路行为是 等价 的，也可以用来检查不同抽象级的电路是否一致，例如RTL和网表。 属性检查（PC， Property Check）：又称为模型检查（MC，Model Check），电路的行为通过验证语言来描述其属性，随后通过静态方式来证明 所有状态空间 下都满足该条件，否则举出 反例 来证明设计行为 不符合属性描述 。    虚拟模型  虚拟模型即 高抽象级的硬件模型 ， 软件模型 可基于硬件虚拟模型（SystemC/ESL）完成 早期开发 ，并且将反馈交给设计。这种反馈在以往的瀑布模式开发周期中是无法实现的，因为 软件往往需要等到硬件设计制造完成后才能展开 。 通过虚拟模型，硬件可以 更早的获取软件反馈 而对设计进行修改。这种 硬件和软件更紧密的协作方式 ，可以体现更多的优势，比如利用虚拟模型获取 性能数据 可以对硬件早期结构提供参考意见，或者判断硬件和软件的协同任务是否可以满足 功耗目标 。 在目前多核的手机移动平台上，一个增长的需求就是将不同的任务合理分配到多核上面来取得更好的性能，而这种软件层面的评估就可以在虚拟建模阶段完成。 目前我们通过多项虚拟建模的技术，如 协同设计、协同仿真和验证 ，试图在 早期就发现设计缺陷 ，使得修改这些缺陷可以相对容易实施的阶段完成。 虚拟模型在用SystemC实现时，通过 高阶综合（HLS）工具 可以将SystemC转为RTL或门级网表，同时可以将 虚拟模型集成到设计 中， 先行完成某些验证任务 ，待后续将其替换为RTL。       硬件加速  动态仿真和静态检查方法具有各自的优势，然而他们的不具备一个优势就是 速度 。尤其是在SoC的设计体量越来越大的时候， 仿真速度 成为了制约验证进度的重要障碍。 由于仿真速度的限制，一些真实的用例也无法在 RTL级仿真 很快地呈现结果，这种困难在硅后测试发现问题反馈给硬件团队时更加明显，因为通常这意味着硬件团队需要 消耗很长的仿真时间 进行分析，找到可能的问题点，拆分软件场景，进而在硬件仿真上尝试重现问题。 仿真速度的限制使得无法通过仿真在早期测试软件，而这一任务一般交给 硬件加速仿真平台 。 一般需要等到 硬件设计初步稳定 ，进而将其映射到可配置的硬件加速平台上面，这种方式相比于RTL仿真速度已经有了质的提升。 目前业界主要的硬件加速方式分为两种， 即FPGA和专用的模拟器（仿真加速器） 。 FPGA主要是为软件开发提供平台，而模拟器则是为了 硬件和软件协同 验证和整个系统的测试（其本质就是FPGA硬件和仿真器软件的结合）。FPGA不可以设置断点，也无法看到大量的内部信号，而模拟器可以做到，同时速度优于RTL的动态仿真。（如Cadence的Palladium）  效能验证   在移动时代，硬件提升性能的方式主要体现在以下几种：\n 提升原有 处理器性能、存储空间、数据总线带宽或者采取多核处理 方式。 增加额外的 协处理单元 ，或者 新的功能模块 。 在后端允许的情况下提高工作 时钟频率 。    随着性能的提升， 能耗 也会逐步提高，这在过去的PC时代还不是一个显著问题，但是到了移动时代，就越发要求硬件在性能有提升的基础上，同时要考虑能耗是否也可以接受。\n  硅前设计阶段进行能效验证，涉及的流程可分为两个部分：\n 功能验证： PA（Power Aware）仿真 ，通过与仿真器结合，模拟电源域的开关进行设计检查。 功耗预测与优化：通过 第三方功耗分析工具 ，结合仿真数据，进行功耗预测，并且给出分析结果。    移动芯片节能技术是一项全方位的改进流程，从 工艺制程、电路、封装到模块设计、Soc设计、系统和应用软件开发 等等，整个环节都需要有效利用能量。下面这个表格是从芯片硬件和软件采用的节能技术（省去工艺制程）。\n     域 节能技术     硬件 多核与聚合结构、多电压域、电源门控时钟门控、保持寄存器   电源管理 稳压调节、提升屏显功耗方案、智能电源管理   软件 开发工具、动态电源时钟调节、算法程序优化    性能验证  在性能验证中离不开 大量的运算或者数据传输 。硅前RTL验证的瓶颈之一在于仿真速度，而且一旦到了芯片级仿真，这一因素就更进一步放大了。 在产品定义过程，对于系统的运算和数据传输都有要求，如果可以在 产品实现阶段尽早地得出性能有关的数据 ，这不但可以帮助提前验证硬件性能是否满足要求，在进度允许的情况下还可以 修改硬件设计完善其性能 。 这种将 性能测试提前 的方式也可以使得硅前验证与硅后测试采用一致的测试用例，从而得出 可对比的性能数据 。 性能验证是用来衡量一个系统在 特定的工作负载 下它的 响应能力和稳定性 ，同时性能报告也可以用来 分析和优化 系统的质量标准，例如可靠性和资源使用能力。 性能验证是一门实用的 计算机科学工程方法 ，在软件功能测试中分类较多： 负载测试（load test）、压力测试（stress test）、浸泡测试（soak test）、尖峰冲击测试（spike test）、配置测试（configuration test）、隔断测试（isolation test） 等。 目前硅前验证阶段， 性能验证还是一个新颖的概念 ，一方面由于业界对这一测试还 没有形成统一标准 ，另外也是由于性能验证更多的是在 衡量指标 ，而验证本身关注更多的是功能正确性。 但同时，对一些性能要求严格的硬件设计，我们确实希望能够 更早期就得出一些数据 ，而且最好能够赶上给设计 做出反馈并加以完善 ，以此来降低开发成本。  UVM简介 写在前面  SystemVerilog 从2002年的3.0标准逐步发展到IEEE-1800 SystemVerilog 2012标准，是目前 IC验证的霸主 。 高级的验证方法学在2011年后逐步融合，也就是VMM、OVM等逐步统一为 UVM（Universal Verification Methodology） 。 SV的核心特性是 面向对象、随机约束、线程通信 等，这些特性使建立验证环境十分便利。 所谓验证方法学，并不是必须与某种语言绑定，而体现在验证的方法上，其目的是 提供一些可以复用的类 ，通过复用来 减轻项目中工作量 ，同时为验证新人 提供一套可靠地框架 ，这就是 验证方法学 。 UVM中的Universal（通用），也就是适用大多数验证项目，包括模块级到系统级，ASIC到FPGA，以及控制逻辑、数据通路到处理器验证的全部场景。 UVM的 框架构建类和测试类 能够帮助验证工程师减轻环境构建的负担，从而将更多精力集中在 如何指定验证计划和创建测试场景 。 认识UVM应由浅入深：  认识UVM的类库和核心机制。 学习核心的UVM组件和层次结构。 了解常见的UVM组件间的通信方式。 深入UVM测试场景。 UVM的寄存器模型应用。    SV与UVM的关系   SV是SystemVerilog，一门面向对象编程的语言，在Verilog基础上发展而来，兼容verilog的所有特性。\n  UVM不是一门语言，而是基于SytsmVerilog开发的类库，以及一套验证平台开发框架，称为验证方法学，被大部分EDA工具所支持。\n  举例：SystemVerilog好比汉字，UVM好比基于汉字的诗词、成语、典故，当天空下雪时：\n SV+UVM：忽如一夜春风来，千树万树梨花开。 Only SV：风景美如画，吟诗赠天下。奈何没文化，卧草雪好大。    UVM类库      UVM的类库大致分为以下几类：\n 核心基类 工厂类（factory） 事务类（transaction）和序列类（sequence） 结构创建类（structure creation） 环境组件类（environment component） 通信管道类（channel） 信息报告类（message report） 寄存器模型类（register model） 线程同步类（thread synchronization） 事务接口类（transaction interface）  UVM组件       验证组件按照功能划分，可以分为 激励器（stimulator/driver）、监测器（monitor）和检查器（checker） 。 这三个核心组件与验证环境的三个关键特性相对应，也就是 激励、监测和检查 。 从UVM基类继承的一个核心分支，即 uvm_component类 ，它们是UVM类库中的重要成员，是 构成整个验证环境框架的基础 ，uvm_component类依据不同功能，又分为以下几个子类：  uvm_driver uvm_monitor uvm_sequencer uvm_agent uvm_scoreboard uvm_env uvm_test    UVM环境 uvm环境中很重要的一点是 phase机制 。\n 传统的硬件设计模型在仿真开始前，已经完成例化和连接了。 而SV的 软件部分 对象例化是在 仿真开始后执行 的。虽然对象例化时只是通过 调用构建函数new() ，但是单单通过new()函数无法 实现验证环境的层次化 ，也就是保证例化的先后关系和各个 组件之间的连接 。 如果需要实现高级功能，比如在 顶层到底层的配置 时，SV也无法在底层组件例化之前完成对底层的 配置逻辑 。 因此，UVM验证环境构建时，引入 phase机制 ，通过该机制可以很清晰的 将UVM仿真阶段层次化 。这里层次化，不仅仅是 各个phase的执行顺序 ，还有 同一phase中的层次化组件之间phase也有先后关系 。     phase 函数/任务 执行顺序 功能 典型应用     build 函数 自顶向下 创建和配置测试平台的结构 创建组件和寄存器模型，设置或者获取设置   connect 函数 自底向上 建立组件之间的连接 连接TLM的接口，连接寄存器模型和adapter   end_of_elaboration 函数 自底向上 测试环境的微调 显示环境结构、打开文件，为组件添加额外配置   start_of_simulation 函数 自底向上 准备测试环境的仿真 显示环境结构、设置断点，设置初始运行时的配置值   run 任务 自底向上 激励设计 提供激励、采集数据、数据比较   extract 函数 自底向上 从测试环境中收集数据 从测试平台提取剩余数据，从设计观察最终状态   check 函数 自底向上 检查任何不期望的行为 检查不期望的数据   report 函数 自底向上 报告测试数据 报告测试结果，并将其写入文件中   final 函数 自顶向下 完成测试活动、结束仿真 关闭文件，结束联合仿真引擎      创建测试平台      phase机制    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":60,"section":"docs","tags":null,"title":"验证工程师与芯片验证（五）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/verifier-and-verify-five/"},{"content":"本文 主要对linux系统中对系统的一些设置操作进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  VNC使用笔记  开启VNC：第一步在终端通过ssh登录用户，win系统也可以使用putty；第二步开启VNC服务，会显示开通的端口号，根据此端口可以使用ip加端口号进行VNC登录；第三步设置VNC登录密码。（每个用户可以开启多个端口，另外，VNCSERVER的大部分配置文件及日志文件都在用户home目录下.vnc目录下）   1 2 3  ssh username@ip_addr vncserver vncpasswd    开启指定端口的vnc（注意冒号前有空格，若该端口已占用，VNC会自动创建新的端口）   1  vncserver :2    开启指定分辨率的vnc   1  vncserver -geometry 1920x1080    查看自己已开启的VNC端口   1  vncserver -list    杀死已开启的VNC端口（冒号前有空格）   1  vncserver -kill :2   修改分辨率 选择系统提供的分辨率选项： 菜单栏系统 -\u0026gt; 首选项 -\u0026gt; 硬件 -\u0026gt; 显示器 -\u0026gt; 选择分辨率\n选择自定义分辨率：  生成自定义的分辨率modeline   1 2 3 4  cvt 1600 850 60 #宽 高 刷新频率 #显示如下 # 1600x850 59.92 Hz (CVT) hsync: 52.91 kHz; pclk: 111.75 MHz Modeline \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    xrandr创建新的mode   1  xrandr --newmode \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    查看xrandr输出设备（也包含可使用的分辨率）   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  xrandr #显示如下，×代表当前使用的分辨率 Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192 eDP-1 connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 277mm x 156mm 1366x768 60.00*+ 48.00 1360x768 59.80 59.96 1024x768 60.04 60.00 960x720 60.00 928x696 60.05 896x672 60.01 960x600 60.00 960x540 59.99 800x600 60.00 60.32 56.25 840x525 60.01 59.88 800x512 60.17 700x525 59.98 640x512 60.02 720x450 59.89 640x480 60.00 59.94 680x384 59.80 59.96 576x432 60.06 512x384 60.00 400x300 60.32 56.34 320x240 60.05 DP-1 disconnected (normal left inverted right x axis y axis) HDMI-1 disconnected (normal left inverted right x axis y axis) DP-2 disconnected (normal left inverted right x axis y axis) HDMI-2 disconnected (normal left inverted right x axis y axis)    选择输出设备添加自定义分辨率mode   1  xrandr --addmode DP-1 1600x850_60.00    自定义的分辨率已经添加到系统可选项，可以回到上文的选择系统提供的分辨率选项进行设置 其他说明：首先系统提供的分辨率可选项已经很多，并且多数设备系统可以自适应，以上的添加自定义分辨率的操作不常用到  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":61,"section":"docs","tags":["Linux"],"title":"Linux系统设置记录","uri":"https://www.wenhui.space/docs/06-linux-skills/usual-skills/linux_syscfg_notes/"},{"content":"本文 主要介绍emacs folding-mode的使用。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  什么是folding-mode? emacs 的folding-mode是一种emacs的副模式，提供代码折叠功能，方便代码阅读和编辑。emacs用户肯定知道org-mode的大纲模式，但是只能在阅读或编辑org文档时才可以使用，而folding-mode可以对任何模式实现类似于org-mode大纲模式的功能。\n安装folding-mode 最简捷的安装方式，是通过emacs的包管理器安装，安装方法请参考我的另一篇帖子 emacs如何安装插件 。\nfolding-mode的使用 修改emacs配置文件 安装folding-mode后，需要修改emacs配置文件，.emacs或.emacs.d/init.el，开启folding-mode功能，请将下面代码添加到emacs配置文件。注意：如需为新的格式添加folding-mode功能，请参照folding-add-to-marks-list完成添加。\n1 2 3 4 5 6 7 8  (if (load \u0026#34;folding\u0026#34; \u0026#39;nomessage \u0026#39;noerror) (folding-mode-add-find-file-hook)) (folding-add-to-marks-list \u0026#39;verilog-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;c-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;latex-mode \u0026#34;%%{{{\u0026#34; \u0026#34;%%}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;lisp-mode \u0026#34;;;{{{\u0026#34; \u0026#34;;;}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;shell-script-mode \u0026#34;##{{{\u0026#34; \u0026#34;##}}}\u0026#34;)   个人配置 为了使用方便，我对folding-mode的常用命令设置了别名，如下：\n1 2 3 4 5 6 7 8  (defalias \u0026#39;me-folding-mode \u0026#39;folding-mode) (defalias \u0026#39;me-folding-reg \u0026#39;folding-fold-region) (defalias \u0026#39;me-folding-in \u0026#39;folding-shift-in) (defalias \u0026#39;me-folding-out \u0026#39;folding-shift-out) (defalias \u0026#39;me-folding-hide-all \u0026#39;folding-whole-buffer) (defalias \u0026#39;me-folding-show-all \u0026#39;folding-open-buffer) (defalias \u0026#39;me-folding-hide \u0026#39;folding-hide-current-entry) (defalias \u0026#39;me-folding-show \u0026#39;folding-show-current-entry)   使用 folding-mode，我主要是以命令的形式使用，其实也支持快捷键，快捷键比较复杂且难以记住，如folding-shift-in，快捷键是 C-c @ \u0026gt;，所以我还是以快捷键使用为主，其他快捷键可以查看folding-mode文档或使用emacs help。\n 打开文件（支持folding-mode的类型）， M-x folding-mode ，打开folding-mode。 选中一块区域，输入 M-x me-folding-reg，此时会在buffer中仅显示选中的内容，且上下插入了folding的注释符，输入标题（也就是第一行注释符后的内容），添加标题后 M-x me-folding-out 可以显示所有内容；或者可以手动添加folding的注释符，通过 M-x me-folding-hide/show 打开或关闭折叠区。 其他命令可自行尝试，不再说明。  效果  hide：   1  # {{{ Title1...    show:   1 2 3 4 5 6 7  # {{{ Title1 aaabbbccc=123456 aaabbbccc=123456 aaabbbccc=123456 # }}}   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":62,"section":"docs","tags":["emacs"],"title":"emacs使用folding-mode","uri":"https://www.wenhui.space/docs/02-emacs/emacs_folding_mode/"},{"content":"本文 主要介绍芯片相关公司的组织架构，和职级与职位及对应的英文缩写。\n   版本 说明     0.1 初版发布   0.2 增加常见职级职位英文缩写    写在前头 本文主要属于科普，目的是避免像我一样，在与别人聊天中对关于职级职位的英文，自己一脸懵逼。\n一般芯片公司的组织架构      公司一级部门由董事长/总经理和副董事长/副总经理负责（也可以称为总裁、副总裁）：\n 董事长/总经理： 向董事会负责。 董事长/总经理助理： 负责协助完成董事长的行程安排、计划实施和会议总结等其他事项。 副董事长/副总经理助理： 负责分管的具体事项，如财政、人力、市场、研发。  公司二级部门由各部门总监负责（芯片公司研发是重中之重，往往研发属于一级部门，研发下设二级部门）：\n 人事部： 负责薪酬、考核、招聘、培训等。 财务部： 负责报销、发票、进帐、出账、税务等。 行政部： 负责会议记录、办公室、后勤、车辆的调度使用等。 市场部： 负责市场、销售、客服等。 运营部： 负责生产管理和运营管理等。 品控部： 负责供应商品质、设计品质、流程体系、可靠性品质等。 研发部： 下设项目部 、验证部、IP部、SOC部、软件测试部、固件开发部、后端设计部等。  项目部： 负责项目立项调研，牵头项目规划和执行。 验证部： 负责项目中验证任务（此验证部与IP部和SOC部的验证团队功能有交叉，不同公司分设不同）。 IP部： 负责IP的开发，其中下设验证团队和设计团队，以及可能还有算法模型设计团队。 SOC部： 负责芯片的集成，包括存储、互连、总线等。 软件测试部： 完成芯片的软件测试。 固件开发部： 完成芯片的固件驱动开发。 后端设计部： 完成芯片的后端版图设计，包括行布局布线和物理验证。    公司三级部门由各部门经理或项目经理负责：\n 设计团队： 负责芯片的前端RTL设计。 验证团队： 负责芯片的验证。  公司职位与职级，以及对应的英文 公司规模和企业性质不同，都会有不同的组织架构，以下只是列举出常见的职位名称，以及其职能，仅供参考：\n GM： 是英文 General Manager 的缩写，指总经理，总经理（General manager）传统意义上是一个公司的最高领导人或该公司的创始人。但实际上，总经理所在的层级，还是会因公司的规模而有所不同。 CEO： 是英文 Chief Executive Officer 的缩写，指首席执行官，是在一个企业中负责日常事务的最高行政官员，又称作行政总裁、总经理或最高执行长 COO： 是英文 Chief Operating Officer 的缩写，指首席运营官，主要是负责公司的日常营运，辅助CEO的工作。对CEO负责，负责企业的运营管理。COO在某些公司中同时任职 总裁 ，但他们通常是常务或资深的副总裁。 CFO： 是英文 Chief Finance Officer 的缩写，指首席财务官，CFO是绝对的二号人物，对公司上市全权负责，对公司长远发展的了解，和对公司整体战略的把握，都要远超其他C级人物。再者，很多时候CFO是董事会直接委派的，有间接地监督CEO和管理团队的职责，所以CFO地位绝对超然。 VP： 是英文 Vice President 的缩写，指副总裁，副总裁是总裁的助手，受总裁委托分管公司日常经营管理工作，对总裁负责，并在副总裁职责范围内签发有关业务文件，总裁因故不能履行职务时，副总裁受总裁委托代行总裁的职权。 HRD： 是英文 Human Resource Director 的缩写，指人力资源总监，人力资源总监要从战略高度努力构建高效实用的人力资源管理系统，成功进行人才选拔，建立科学的考核与激励机制，最大限度地激发人才潜能，创建优秀团队，塑造卓越的企业文化，推动组织变革与创新，最终实现组织的持续发展。 HRM： 是英文 Human Resource Manager 的缩写，指人力资源经理，分管组织管理、人事信息管理、招聘管理、培训管理、绩效管理、福利管理、工资管理等全部或部分职责。 HRBP：是英文 Human Resource BUSINESS PARTNER 的缩写，指人力资源业务合作伙伴，实际上就是企业派驻到各个业务部门或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。 MD： 是英文 Marketing Director 的缩写，指市场总监，企业中负责市场运营工作的高级管理人员，主要负责在企业中对营销思想进行定位；把握市场机会，制定市场营销战略和实施计划，完成企业的营销目标；协调企业内外部关系，对企业市场营销战略计划的执行进行监督和控制；负责企业营销组织建设与激励工作。  以上列出的是公司各大部门的管理层职位（可能不全），下面我们来看一下职级：\n   职级名称 英文 职级名称 英文       总裁 CEO/GM   首席科学家 Chief Scientific Officer 副总裁 VP   研究员 Researcher Engineer 总监 Director   专家 Proficient Engineer 经理 Manager   高级工程师 Senior Engineer 主管 Header/Leader   中级工程师 Middle Engineer     初级工程师 Junior Engineer      以上信息仅是自己简单的个人理解，实际公司中职级分的可能更细，并且会设有类似于Senior Management Engineer这样的研发管理职位，总之，本篇文章仅为科普，如有幸更专业的人士看到此帖子，欢迎指正。\n常见职级职位英文缩写    缩写 英文 中文     PL Project Leader 项目负责人   FAE Field Application Engineer 现场技术支持工程师/售前售后服务工程师    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":63,"section":"docs","tags":null,"title":"你应该知道的职级与英文缩写","uri":"https://www.wenhui.space/docs/10-polular-science/rank-of-organization/"},{"content":"本文 主要介绍本人使用形式化验证的一些经验总结。\n   版本 说明     0.1 初版发布    背景  验证工具： Cadence 公司的 JasperGold  写在前头 形式化验证是一种验证方法，而实际应用方向主要有两方面，一是综合前后的等价性检查，二是RTL设计的功能验证。本文所讲的是形式化验证方法在RTL设计功能验证方向的应用。\n模拟仿真验证和形式化验证 芯片验证的两个方法，一个是模拟仿真验证，另一个是形式化验证。\n模拟仿真验证是目前最主流的验证方法，主要是以 UVM 为代表的验证方法学，特点就是搭建模拟仿真环境，通过随机化激励进行模拟仿真，reference module作为验证标准进行结果数据的check，以收集覆盖率的方式作为验证进度的参考，当代码覆盖率和功能点覆盖率达到100%时，做到sign off。由此看来，模拟仿真的优点就是基本不受设计复杂度的影响，而缺点就是验证环境搭建较复杂，测试激励手动添加，收集覆盖率周期较长，尤其是Corner场景的覆盖很让人头疼。\n形式化验证从某层面看似乎让人省心。形式化方法简单的说就是用数学工具进行定义、开发和验证，它会对设计电路进行数学建模，然后穷举系统运行过程中电路所能达到的所有状态，以断言的形式完成设计电路的功能验证和规则检查（也可以通过reference model的形式，做结果数据的check）。听起来似乎完美，但是这要依赖强大的运算系统和EDA工具，否则会发生状态爆炸问题，长时间无法得出证明结果。以目前的形式化验证工具来看，还不足以吃进一个超复杂的设计电路，来完全替代模拟仿真的验证方法。\n所以，在芯片的验证中，随机仿真验证和形式化验证往往是相辅相成，一个更适合系统级功能验证，一个更适合模块级的功能验证。除此之外，还有FPGA的硬件加速测试，这三种验证手段可谓是三位一体，相辅相成。\n什么是形式化验证 个人认为，形式化验证是基于严格的数学算法和模型，根据设计功能提取电路规则的属性描述，并穷举系统运行过程中电路所能达到的所有状态，自动进行数学分析和证明。验证过程如下：\n  形式化验证示例    以上的形式化验证过程就像做一道数学证明题，用数学方法证明该命题是否成立，而这个证明过程是验证工具完成的，工程师不需要关心。目前，业界主流的形式化验证工具主要有Cadence的 JasperGold 和 Synposys 的 VC-Formal。\nSVA语法 形式化验证使用的是 SVA (SystemVerilog Assertion) 语言，属于SV的一部分，下面对SVA基本的使用语法进行说明。\nSVA的语法主要分为三种使用类型：assume、assert、cover。使用的基本规则为，先描述一个property，然后为property设置为assume或assert或cover，命名时习惯性将property名字添加“P_”前缀，将assume名字添加“ASM_”前缀，将assert名字添加“AST_”前缀，将cover名字添加“COV_”前缀。注：建议所有属性带时钟沿触发条件。\nAssume Assum即假定之意，也就是假定某些信号符合某规则特性，最常见的就是给输入信号添加约束，下面对assume语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1); endproperty ASM_property_name: assume property (P_property_name);    精简写法   1  ASM_property_name: assume property (@(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1));   Assert Assert即断言之意，也就是认为某些信号符合某规则特性，出现反例则报错，最常见的就是给关键信号依据特定属性设置断言，来进行特性检查，下面对assert语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1); endproperty AST_property_name: assert property (P_property_name);    精简写法   1  AST_property_name: assert property (@(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1));   Cover cover即覆盖之意，也就是对某些信号的某规则特性进行采样，反馈是否覆盖该特性，下面对cover语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1); endproperty COV_property_name: cover property (P_property_name);    精简写法   1  COV_property_name: cov property (@(posedge clk) (condition==1\u0026#39;b1) -\u0026gt; (result==1\u0026#39;b1));   JasperGold的使用 本文使用的形式化验证工具是JasperGold，其常用的使用方法有两种类型，一个是SEC，对模块功能做对等性检查，另一个是FPV，基于规则特性的功能验证。这里只对FPV进行介绍，也就是 Formal Property Verifycation。\n验证环境       FPV_project_name：整个FPV的验证环境。 Report：用来存放验证报告。 Source：整个FPV环境的文件源。 FPV_project_name.tcl：FPV验证环境的启动脚本。 Design：文件源中的设计文件，也可以不存放设计文件，而由design.flist指定设计文件。 Property：文件源中的验证文件（SVA），提取设计文件的属性。 Refer_model：此文件为参考模型文件，根据需求创建，非必须。  启动脚本  设置环境变量   1 2 3  set FPV_ROOT /FPV_project_path set DES_PATH $FPV_ROOT/source/design set PRO_PATH $FPV_ROOT/source/property    设置功能点收集选项   1 2  set_capture_elaborated_design on check_cov –init –exclude_bind_hierarchies –enable_prove_based_proff_core    编译设计文件 (注：v2k指IEEE 2001 标准)   1  analyze -v2k –f $DES_PATH/design.flist    编译验证文件   1  analyze –sva –f $PRO_PATH/property.flist    设置顶层   1  elaborate –top top_module_name    设置时钟和复位 (注：如果复位是低位有效，则为 ~reset_signal_name)   1 2  clock clock_signal_name reset reset_signal_name    设置最长验证时间   1  set_prove_time_limit 24h    启动验证   1  prove -all    生成报告   1  report –summary –force –result –file “report/FPV_project_name.rpt”    其他  以上只说明了基本设置，其他详细设置可参考手册或JasperGold的Tcl Command Help。\n启动命令 启动验证环境很简单，验证流程主要依靠启动脚本的设置，而验证环境的启动只需在终端敲下启动命令即可，如下：\n1  jg FPV_project_name.tcl   关于形式化验证的个人总结 什么样的设计适合用形式化验证  规模较小：设计模块太大对应验证复杂度较高，导致验证时间过长。 功能独立：功能独立的设计更容易提取规则属性。 时序较短：时序较长会导致验证复杂度增大，验证时间指数增长。 接口清晰：接口清晰便于对输入添加约束，避免非法输入影响验证结果。  形式化验证中影响验证时间的因素  设计复杂度：设计复杂度高，肯定验证时间长，这也是为什么形式化验证不适合大的设计模块。 时序较长：形式化验证是所有状态的全遍历，时序每增加一个cycle，所增加的遍历空间并非只是此cycle，还包括此cycle与前几个cycle的状态组合，换句话说，时序增加，遍历空间指数增长。 设计中存在时序控制：比如advance_pipeline对pipeline进行使能控制的此类信号，以及所有影响流水线不能依次脉动流出的控制信号。 设置的特性检查：设置的特性检查越多越复杂，对应的验证时间越长，如果以reference model形式进行数据结果check，所需验证时间最长，但是若只提取设计特性又很难做到signoff标准。  形式化验证不能验证完全是不是就无任何作用 当然不是！\n 形式化验证工具进行了语法检查，可确定设计逻辑语法无误。 形式化验证工具进行了部分特性检查，可确定已验证的特性符合设计规则。  换句话说，形式化验证不能验证完全，虽然不能做到sign off，但是可以将前期暴露的语法bug和设计bug进行修复，最终验证不完全，无非表明我不一定是对的，但也没找到我的错误，说明设计代码已经达到一定成熟度。\n形式化验证工具的其他用途  完成设计不加任何特性检查，直接启动形式化验证工具，可将暴露的语法错误和警告修复，提高设计代码质量。当然反过来，验证人员可先启动形式化验证工具，将暴露的语法错误和警告提单给设计人员。 设计时对于显而易见的规则特性边设计边记录，待设计交付验证人员时，可先启动形式化验证，修复前期bug，提高设计代码质量。 模拟仿真中收集覆盖率，对于较难收到的功能点可利用形式化验证工具去设置cover，辅助模拟仿真创建定向用例。这里提两点，一是需要确定输入的场景作为输入约束，二是无需保证形式化验证的正确性，因为只是提取测试激励，正确性由模拟仿真保证。  复杂设计如何完成验证 复杂的设计验证时间通常较长，不容易完成验证，但是，依据设计的特性，也是可以通过一些手段完成验证，下面以典型设计举例。\n设计结构      此设计有以下几个特点：\n 设计中stage1输入，stage5输出，中间需寄存四拍。 设计中分为流水线控制信号、数据信号和控制信号、组合逻辑三个部分，流水线控制信号带复位。 设计中为单向流动，无bypass，也就是流水线前后独立，无反馈。 设计中带advance_pipeline，流水线的使能控制，也就是流水线可能锁定n拍后重新启动。 设计中模块支持多功能类型，也就是op_type。  复杂设计的形式化验证方案  依据功能类型，分类验证，各个功能依次验证。 约束输入，单功能验证仅提交一次，运算数据由工具遍历，验证功能正确性。 除流水线控制寄存器之外，其他寄存器不加复位，工具会将其初始值进行遍历，可等效为激励输入前模块的任何状态。 凡是影响流水线行进的输入，全部添加约束，可以约束停顿周期为1~2，或直接约束为无停顿，暂不验证流水线控制功能。 数据check语法采用单比特，如“data_a[3:0]==data_b[3:0]”改为“data_a[3]==data_b[3], data_a[2]==data_b[2] ……”，前者遍历空间是2^4，后者遍历空间2*4。 对流水线控制功能的验证，在其算法功能验证的正确基础上，将数据进行适当约束，减少遍历空间，主要验证流水线控制功能。 其他手段有待后续补充。  其他减少状态空间的方法  抽象模型：如fifo或其他存储类模块，设计本身主要验证的是控制逻辑，从而可以减少存储单元来针对设计完成抽象模型，可以有效的减少状态空间。 黑盒化：将不关心的设计设置黑盒，可以有效的减少状态空间 断点：待了解  以上方法还未在实际工程中使用过，待后续总结\n推荐书籍  《SystemVerilog Assertion应用指南》 《Formal Verification: An ESSential Toolkit For Modern VLSI Design》 以及其他EDA厂商提供的使用手册和培训资料（如哪位读者有此类资料，感谢分享）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":64,"section":"docs","tags":["Formal"],"title":"Formal验证技术总结","uri":"https://www.wenhui.space/docs/07-ic-verify/formal/formal/"},{"content":"本文 主要对日常linux系统中一些工具的安装过程进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  安装tree命令 tree命令在deepin系统中没有自带，需要手动安装，此命令可以通过代码显示方式列出文件结构，在有些编写文档需对文件结构进行描述时很有用（如何使用可以通过man tree查看），安装命令如下：\n1  sudo apt install tree   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":65,"section":"docs","tags":["Linux"],"title":"Linux安装工具记录","uri":"https://www.wenhui.space/docs/06-linux-skills/usual-skills/linux_tools_notes/"},{"content":"本文 主要介绍一个破解版的谷歌访问助手工具。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 google版本： 78.0.3904.97（正式版本） （64 位）  谷歌访问助手能做什么  解决chrome扩展程序无法自动更新的问题 可以访问google搜索、gmail邮箱和google+  下载  进入github网址进行下载 我的百度网盘分享资源 链接：https://pan.baidu.com/s/1nVTXRinSBhOz17C23ytM7w 密码：j0lt  使用  打开google浏览器（Windows和Linux均支持） 点击功能栏右侧三个点，选择设置，打开设置页面 选择扩展程序，进入扩展程序页面 打开 开发者模式 ，选择 加载已解压的扩展程序包 ，选择刚刚下载的压缩包解压后的文件夹 可以开始访问了（该插件通过代理服务器访问Google，代理服务器的地址和密码以及PAC脚本均由插件动态获取。研究发现，即使将PAC脚本替换掉，依然只能访问Google和GMail，其余网站无法打开，表明服务器端已进行了限制。）    谷歌访问助手页面    注意 该插件是在使用网络代理访问外网，建议仅在安装扩展程序以及google查资料时使用，尽量不要长时间访问外网。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":66,"section":"docs","tags":["google"],"title":"最简单易用的谷歌访问助手","uri":"https://www.wenhui.space/docs/01-software-install/google_assistant/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 验证工程师与芯片验证 部分第四篇，主要介绍验证周期、验证管理三要素、验证的收敛、问题的追踪、团队的建设、验证的专业化。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《全面的功能验证：完整的工业流程》 Bruce Wile , John C. Goss , Wolfgang 书籍    专业术语与缩略语    缩写 全称 说明     GLS Gate level simulation 门级仿真   TO Tape-out 流片   CDC Cross clock domain chec 跨时钟域检查   PA Power-Aware-Testing 能效测试   SDF Standrad Dealy Format 标准延时格式文件（常说的反标文件）   ECO Engineering Change Order Flow ECO是指在流程中某个阶段发现错误，在不需要重复全流程的情况下，通过对当前流程阶段的设计直接进行变更，以减小全流程重复带来的项目时间的延长。由于门级网表到最后的版图期间仍可能发现设计错误，因此通常需要通过对门级网表直接进行设计变更。    验证的周期 验证菜鸟的成长  确定验证的模块，与设计人员交流，熟悉模块，进行模块验证，所有的精力专注在这个模块。 考虑验证时间，尽可能又快又多的发现bug，在项目节点前完成验证。 在模块验证完后不知做什么，被动安排工作。 不清楚每个节点应该做什么、上一个节点和下一个节点的联系、不同节点对整个项目周期的意义，这些需要有一个宏观的认识。 随着经验增长，被赋予更多的责任，从模块到子系统，再到系统。 接到富有挑战性的任务会感受到压力，但是学到的东西也更多。 每一个验证人员能够充分了解各个验证环节，那么就可以更好的贯彻验证任务，保持信息通畅，整体的风险就会降低。  验证与设计的节点       RTL0： 芯片框架 和 模块功能 定义完成，进行任务分配和制定验证策略。 RTL1： 模块和子系统 的功能信号定义完成，开始搭建验证环境。 RTL2： 完成所有模块的设计，模块功能全部完成验证，完成部分系统验证。 RTL3： 完成芯片 系统 的连线集成和验证，完成系统验证，覆盖所有的功能点。 GLS： 完成 门级网表 的验证。 TO： 回顾验证的各项检查清单，最终 *流片*。  RTL0    任务 内容     团队验证环境准备 项目的工作目录、采取的验证进度跟踪方法   验证人力和进度安排 模块、子系统、系统需要的人力和进度安排   验证工具和方法选择 仿真工具和形式化验证工具的版本、验证方法学   验证文档 记录验证策略、验证平台环境、方法学    RTL1    任务 内容     搭建模块验证环境 按照设计接口搭建验证环境   生成寄存器模型 由设计XML文件生成UVM寄存器模型   验证文档 模块验证环境、寄存器模型 、环境编译   验证计划回顾 模块级验证计划的回顾    RTL2    任务 内容     语义检查（linting） 检查常见的设计规范问题   跨时钟域检查（CDC） 模块、子系统级的CDC检查   创建测试用例 将测试用例同功能验证点完成匹配   仿真验证、形式化验证 选择合适的方法学完成模块全部和子系统80%以上的验证   回归测试 创建和更新模块级/子系统级的回归测试表   bug修复和跟踪 记录发现的bug，完成修复后的回归测试    RTL3    任务 内容     跨时钟域检查（CDC） 完成系统级的CDC检查   能效仿真（PA） 完成系统级的PA仿真   仿真验证和形式化验证 完成系统级的验证   创建测试用例 创建系统级测试用例   回顾测试用例 系统级测试用例和功能点回顾   bug修复和跟踪 修复系统级测试的bug，并跟踪和回归测试   回归测试 集中提交所有模块的测试用例，评估整体进度   代码/功能覆盖率收集 合并模块/芯片覆盖率，创建新的用例完备覆盖率    GLS    任务 内容     门级验证环境准备 需要从RTL芯片验证环境做更新，使用门级仿真   网表仿真验证 从RTL级选择测试用例，在网表环境测试逻辑一致性   网表+SDF仿真验证 伴随门级延迟仿真，完成时序验证   bug修复和验证 伴随设计ECO流程，完成RTL和门级验证    TO    任务 内容     验证功能点回顾 确保所有待验的功能点全部被测试用例覆盖   测试用例回顾 检查最终回归测试表结果，检查用例是否全部通过   覆盖率回顾 检查最终合并的覆盖率，功能覆盖率100%，代码覆盖率在90%以上   门级仿真用例回顾 所有的时序违例均被修正和过滤，功能全部通过    验证管理三要素 时间管理  早行动 ：  各个模块和系统验证人员早参与到项目的前期定义环节，可以尽早知道设计的改动，从而考虑如何对原有的环境做出更新。同时，在选用IP和定义新模块的过程中，验证人员也可以更早的考虑选用什么验证IP、验证方法以及相应的工具。 有经验的验证团队，在项目开始之前就考虑更新的验证环境、流程、工具选择、方法学、技能训练、自主工具脚本开发等。 将验证环境搭建工作和测试用例创建工作分开，也就是少数人搭建维护验证环境，剩下的绝大部分人专心创建测试用例，通过这种让验证人员更专注的进行功能验证的模式来提高产出率。   少依赖 ：  一旦有了充分的意识，懂得验证过程并非是在设计完备后开始，那么验证人员就应该想出各种办法来减轻或者消除对于设计进度的依赖性。 尤其对于验证经理而言，让团队因为依赖一些未完成的事情而白白浪费时间，这对于项目进行来讲是大忌。 同时，验证团队往往需要在多个项目中一边开展新项目一边维护老项目，这更需要做好人力协调安排，避免出现项目之间人力冲突的情况。   大局观 ：  验证人员不但要专注于自己的“一亩三分地”，还要清楚共同的关键节点，以及各个模块之间的依赖性， 面临选择验证方法和工具时，需要考虑的不单单是该方法或该工具可以提高多少仿真速度或覆盖率，同时也要考虑人员的技能培训投入、学习曲线、新工具整合、新环境维护等与项目进度密切相关的因素。    人力安排  团队建设 ：  由于验证技术的趋势变化加快，新的方法、工具层出不穷，验证团队成员组成往往需要不同的技术背景。 招聘或培养人员时，要考虑所要具备的基本技能，和在某些技术领域拥有着丰富经验。比如软件编程、验证环境建设、形式化验证、硬件加速等。 一个经验丰富的验证团队，成员之间的技能一般会有重叠和差异部分。这种方式可以保证在人员任务分派时会有多种选择，同时团队共同工作时可以实现技能互补。 不同经验层次的梯队可以保持技术的传承，梯队培养，同时在任务分派的时候，也可以考虑将新的任务交给老员工，将老的任务交给新员工，满足老员工新技能培养、接受新的挑战，也使得新员工快速使用项目环境。   技术和管理 ：  技术功底深厚的人少有管理同样出色的，而善于在不同部门、技术组之间沟通的人善于协调、计划和监督却又无法很好的兼顾技术层面。 往往技术优秀的人才会被委以团队和项目管理的职责，但是这种选择不一定是最合适的。 伴随着验证项目的要求越来越复杂，芯片公司也越来越需要有经验的项目管理者，因为这样一位管理者会对整个项目起到组织和推动的作用。 好的验证组织既需要有技术良好的梯队，也应该具备贯彻执行验证计划的执行力，一个验证团队需要不同技术专长的验证人员，也需要可以统管全局的验证经理。    任务拆分和重组 项目启动初期，由于系统结构和设计功能描述尚未确定，相邻模块间的接口上不稳定，这时候在这些不确定中找到确定因素，来安排验证进度、估算所需的验证资源，对于验证经理的经验有很高的要求。\n 任务拆分指的是可以将一件用时较长或较复杂的任务拆分为相对独立的小任务。拆分任务的好处：  更容易清楚要做的任务和技术难易度、时间长短。 帮助分辨不同小的任务间的依赖性。 发现哪些部分是核心，哪些部分存在风险。 在有多人参与情况下，可以合理的分配任务，并发执行。 细化的任务有助于进度的跟踪和工作的量化。   任务重组指的是验证经理在统筹各个模块、不同验证节点之间的任务时，可以合理的对不同任务进行合并、转接、排序等，它的目的是更有效利用整体的验证资源。常见的任务重组场景包括：  发现各个验证模块中共同的可利用资源，指派专人维护（验证IP、回归工具、环境、脚本、仿真工具）。 模块A和模块B都需要创建一个类似的环境或组件时，考虑两个组件间共同规划同一个环境或参数化组件，以便减少整体工作量，提高模块复用性。 在发现不同模块之间有依赖性的时候，就需要安排优先级，消除依赖路径，尽可能使全员都行动起来。    验证的收敛 写在前面 随机验证的方式使得回归测试更加有意义。一般来讲，我们基于两种目的来提交回归测试表：\n 由于随机环境每次产生激励序列不同，这样每次回归测试均会对覆盖率收集做出贡献。 当设计bug修复后，回归测试保证bug的修复且不会引入新的bug。  回归测试具体指的是每次直接将所有测试用例提交到服务器运行，并且检查测试结果，对于模块级的回归测试，这种方法在时间和计算资源上也许是可行的，但对于系统级回归测试，这种方式每次要消耗的时间和资源需要重新考虑，一般考虑的因素是： 回归流程 、 回归质量 、 *回归效率*。\n回归流程        流程阶段：\n RTL1：模块级基本功能验证、模块级高级功能验证。 RTL2：模块级回归测试和收集覆盖率、系统级基本连接验证、系统级模块交互功能验证。 RTL3：系统级回归测试和收集覆盖率、模块级和系统级副覆盖率合并。    流程细节：\n 模块设计阶段，除了准备验证环境，在验证的基本功能完成之时就应该创建一些 基本的测试用例 ，并逐渐形成回归列表，在RTL2时要全部测试通过。 保证基本功能回归列表时，一些 高级功能或附加功能 ，以及 corner场景 尽可能的在RTL2前完成验证。但是这些功能可能有部分需要在RTL2和RTL3之间完成验证，所以按照优先级划分功能回归列表也需要作为模块验证完成的检查项。 由于RTL2节点可以保证基本功能的正常工作，这份回归测试表单也使得RTL3开始时进行的 系统集成 工作得到保障。 RTL2和RTL3之间，需要完成模块级的高级功能验证，之后 反复 进行回归测试，通过大规模的随机测试来验证设计的 稳定性 ，并且完成覆盖率的收集。 模块级验证必须在RTL3之前完成，而 系统级验证 必须在门级仿真之前完成，并且尽可能减小落后于节点的差距。    备注： 这里提到的 基本功能回归表 ，能够初步保证设计代码的正确性，在代码提交前设计师先通过代码编译检查和基本功能回归测试，通过后再提交到 git库 ，交验证人员进行更多的高级功能回归测试，可以减少因提交代码质量导致时间的浪费，也可以将其集成到git提交管理。\n  回归质量  芯片设计在每次完成后，我们可以通过回归测试工具将设计、验证环境的编译、仿真、结果检查集成为一体，也可以通过一些简单的命令由设计者先查看 基本功能 是否正常工作。 只有保证基本功能回归列表测试通过，代码 版本管理 工具才可以允许提交，同时通知验证人员更新设计代码，随后展开高级功能的回归测试。 如果验证人员发现了bug，设计人员在bug修复后，先通过 基本功能测试 ，再递交给验证人员检查之前的bug场景，确定修复后再进行高级功能或更高层次的验证工作。        总结：  前期设计不稳定时，主要定期提交基本功能测试来快速检查功能是否通过。 设计比较稳定后，规划用时较短、测试场景简单的用例，检查核心功能是否正确。 设计后期，应该一方面实现复杂场景测试，一方面大量提交回归测试表类完善功能覆盖率。    回归效率   影响回归效率的几个方面：\n 模块级验证阶段 ，随机测试方式倾向于反复提交测试表来产生各种可能场景，而到了后期覆盖率难以得到更多提升，那么如何 精细控制随机约束 使得每次回归测试总有新增覆盖率的收获就显得额外关键。 在设计bug修复后，如何 快速检查设计基本功能 ，保证设计版本提交的质量，这对提高回归测试效率也很关键，一个低质量的设计代码会降低回归测试的收益。 系统级验证阶段 ，由于测试用例时间明显加长，每次回归整个测试表需要消耗很长时间，越到后期反复回归的 收益就越低 ，但同时验证管理又需要这样的数据，这种矛盾也需要化解。    提升回归效率：\n 切分测试场景 ，将较长的测试用例切分为多个序列，这样做的好处是避免过于冗长复杂的测试用例，划分多个用例可以方便并行提交，用计算资源来节省时间。 对于较难切分场景的测试用例，比如系统级仿真时需要先完成上电、复位、时钟使能等一系列初始化操作之后才能进行有效测试场景，可以考虑 快速跳转到特定状态 来实现缩短测试时间。 针对第二条所描述的特定状态，也就是需要长时间的运行来到达某一测试状态，建议分为两个阶段，第一阶段来检查跳转该状态的条件以及跳转功能是否正常，第二阶段在第一阶段测试通过的前提下，可以 直接初始化到测试状态 ，例如强行置位寄存器、状态信号等方式，使得设计快速到达测试状态，缩短测试时间。 尽可能给予充分的计算资源，目前用于仿真的普遍方式是，中心化 服务器集群 来提供计算和数据存储资源，通过资源分配管理办法来实现充足的 并行运算 资源，缩短回归测试的运行时间。 后期回归测试，使用定向用例或精确控制随机约束，提高覆盖率收集的效率。    问题的追踪 问题类型  系统功能定义问题。 硬件设计问题。 芯片验证环境问题。 综合时序问题。 硅前工具问题。 引用库和IP问题。  追踪工具  关于bug追踪需要的功能： 分类、派发、查找、追溯、报告 等。 标准化的问题追踪工具可以加速芯片开发的进度：  商业工具：Team Foundation Server(Microsoft), JIRA, Rational cLEARqUEST(IBM) 开源工具：Bugzilla(Mozilla), Redmine, Trace    工具功能  记录 ：记录问题标题、内容、出错场景、背景描述、发布版本、测试用例、复现命令以及其他相关文件。 分类 ：归属哪个项目、哪一层次、哪个模块、哪一类型以及问题的严重性。 派发 ：问题提交即代表追踪的开始，管理者或提交人员可以指定谁来修复。 查找 ：查找功能可以方便bug追踪的查看，也可以在新bug发生时查找是否之前出现过此bug或有其他同事已经提交相同bug。 追溯 ：追溯是跟踪bug的状态迁移，从提交、派发、解决、完成等一系列状态的迁移。 报告 ：将整个数据库中的bug统计，从不同的维度形成报告，方便管理者查看。  追踪流程       步骤1：发现一个新的问题，填写相应内容并在追踪工具中提交。 步骤2：提交者将问题派发给所有者，如果所有者发现该问题不属于自己负责，派发给真正的所有者。 步骤3：如果问题所有者分析后确定问题属于自己，则进入开始状态，修复问题。 步骤4：如果问题所有者分析后发现并非属于自己，则将状态重新修改为新的问题。 步骤5：如果该问题之前已经被提交，则将状态修改为重复状态，同时需要备注已经提交相同问题的ID号，用来追溯。 步骤6：如果该问题不严重影响项目进度且不是致命问题时，可能选择延后， 步骤7：如果该问题在新的版本中已修复，可以将该问题改为解决状态。 步骤8：如果问题所有者将问题进行了修复，则将问题修改为解决状态。 步骤9：问题所有者修复问题过程，发现该问题之前已经被提交，仍可以改为重复状态。 步骤10：问题所有者修复问题过程，仍可以改为延后状态。 步骤11：问题修复后，问题所有者可以将该问题派发给验证人员。 步骤12：问题得到修复和验证后，问题再次派发给当初的提交者或管理员，由他们将状态修改为关闭状态。 步骤13：问题可能会被重启，由问题所有者分析是否需要再次修复。 步骤14：问题重启后，若确定需要再次修复，则进入开始状态。 步骤15：问题重启后，若确定已经修复，则可转入解决状态。 步骤16：之前延迟的问题此时具备解决条件时，可选择重启。  团队的建设 7个好习惯之从全局入手  同一个问题，专家的考虑角度总会比新手 更高、更广、更丰富 ，解决问题的方案也会有高低的区别，所以无论处于哪个专业水平，总会有 更高更全面的视角 等待挖掘。 对于一个团队而言，在项目启动的时候，如果团队负责人能够对项目的 周期、难点、人力估计、环境建设 做出响应，与团队 分享 他的视野，保证团队 清楚 接下来大家如何作战、 清楚 每个阶段的作战目标，对于整个项目的推进很有意义。 团队中每一个成员在思考问题时都保持一种 全局观 ，往往对于项目的中长期运行，可以 更少资源、更高效率 的去实现目标，另外对 个人成长 也很有意义。  7个好习惯之追求百分百  如果一个问题从硅前 隐藏 到门级仿真，那么 代价 是数倍的，如果 隐藏 到硅后测试， 代价 是数十倍的，这就需要每个人的 严谨工作态度，百分百的工作努力 。 如果遇见了问题就要及时解决它，以往的经验来看，凡是没有验证过的场景就一定存在bug，在发现问题或预测到问题的存在时，就 尽早的去解决 它，否则隐藏的风险会在后期不对放大， 如果你认为没问题，那么问题很快就会来找你 。 如果发现一个会影响大家的问题， 主动去修复 它，避免问题的延续导致影响更多的人，以及更长的影响时间。 维护好自己的 TODO list ，确保有序高效的完成它们，切记不能遗忘否则可能会带来灾难，并且当自己不确定时及时请高层次的人员或负责人来帮助自己确认。  7个好习惯之保持面向对象的开发习惯  对于设计人员， 面向对象 的开发方式不一定要熟悉，但对于验证人员，它的重要性尤为显著。 无论使用SV、SC、C++还是Python，如果需要开发一个 长期维护 的环境或工具，请先考虑 面向对象 的方式。  7个好习惯之合理复用  复用 是高效验证的核心理念，无论是方法学的推陈出新还是验证环境的搭建维护，都需要考虑复用。 复用 所涉及的范围很广，除了设计模块复用、验证环境复用、测试用例复用之外，也包括项目环境复用、 脚本 复用等。 验证目前占到整个芯片开发60%以上的工作量， 提高复用性 可以 加快验证速度和减少维护成本 。 为了提高复用性，在构建验证环境时，尽可能考虑 验证环境参数化、脚本自动化、提交文档 等方式，使得验证环境的维护和使用。  7个好习惯之保持创新  从新手逐渐变为“老司机”之后，往往会有一段 倦怠期或自满期 ，因为验证人员觉得：他对所属的模块已经足够掌握，验证环境也熟悉，似乎没有那么多再需要深挖的地方了。 这个时候，可以 争取新的模块和任务 ，往往“老司机”和新任务的搭配，能够 发现更多的问题和改善措施 。 我们相信验证总会有需要不断完善的地方，在新的空余你的思想还会保持一段活跃的时间，从而提出一些新的改善方法。 如何让大脑 保持不断创新 ？除了不断学习。不断交流外，那就是永远 追求验证效率 的提高。实际工作中的创新，一旦被证明它对整个团队的价值，那么不单单是它的作用会逐渐放大，而且你也可以感染和吸引更多的人，一同加入到你们的创新队伍中去。  7个好习惯之高效的沟通  首先，多人团队可以进一步 拆分 为5人以内的小组， 平行 执行任务，保持各组之间的 独立 。 其次，在可行的情况下优先考虑 面对面谈话 ，次者打电话，再次者写邮件，我们相信口头表达是最高效的方式。 再者，尽量 少开会、开短会 ，只邀请必要的人参加，节省他人时间，也节省自己的时间（最害怕白天开会，晚上加班coding）。 最后，如果有条件，可以将团队在一些 关键项目节点 前，聚集在一起办公进行 团队作战 ，减少沟通成本。  7个好习惯之突破责任边界  在设计的 边界划分 上，我们可以通过定义模块层次和结构来实现，而在验证工作中，我们无法很 清晰的划分出边界 ，因为模块间有互动功能。 一般情况下，我们会遵循 主从端、上下行数据传输和功能实现工作量大小 的方式来确定， 互动功能 由哪一方来验证。 尽管我们希望以一种合理的方式来划分验证边界，但仍然难免有一些边界不清晰的功能交互部分。 如果有关联的模块A、B双方可以 突破责任边界 ， 积极承担 各自的部分，或者从项目整体出发，去定义验证的完整方案，在考虑工作的承担问题，毫无疑问这对于整体验证质量是有益的。 主动突破责任边界 ，会对自己的成长很有帮助，学到更多东西。  验证的专业化 对于验证的偏见   A公司目前的 设计复杂度低 ，而且有面向市场的进度压力，所以他们更愿意将设计做完后经过 简单的测试 直接将 原型验证通过FPGA来实现和测试 ，至于 RTL验证 的投入则少的可怜。\n  B公司的 验证平台 已经很多年 没有更新 ，尽管 设计越来越复杂 ，但是因为一直缺少经验丰富的验证师来更换升级公司的验证平台，所以在项目开始，尽管能听到越来越多对于验证平台老旧不方便的抱怨，项目管理者还是以 缺少合适的人力 为理由，让大家 通过加班来弥补验证平台的效率缺失 。\n  C公司 没有专门的验证团队 ，而验证的工作几乎是公司内部的 设计人员之间相互合作验收 的，在 缺少验证标准、计划、环境和文档 的情况下， 设计师同时也兼任了验证师的角色 。如果询问设计师，实施验证是否困难？他们会回答，这不就是添加激励，看看行为是否异常吗？在他们眼里， 设计工作才是应该受到公司最多关注的 。\n  D公司验证团队整体实力与设计团队有不小差距，通过分析我们可以发现，该公司的 验证团队 是由公司 不合格或暂时没经验的设计师和新进公司的新手 拼凑组成的。公司的管理层认为，验证的好处不单单是可以发现一些漏洞，还可以让那些 不合格或暂时没经验的设计师先到验证环境去熟悉 ，至少不会因为一些简单的错误给设计种下一些严重的漏洞。看起来D公司的验证团队接收到的，是一种 隐形的“二等公民” 。不过通过验证工作，debug过程可以熟悉设计，进而在对设计有一定理解之后，逐渐承担设计任务，也是很多公司目前采用的培养方式。\n  E公司的设计团队和验证团队比较健全，然而他们之间的 沟通经常不顺 。当验证人员在项目前期发现bug时，还可以和设计人员探讨修复bug的问题，而到了 项目的后期 ，如果再发现什么严重的漏洞，设计人员就显得不那么愉快了。因为 漏洞越到了后期才被发现，修复漏洞的难度和代价越大 ，同时由于项目进度的压力，有时候设计人员不得不 加班加点 去完成，这就是为什么不愉快的原因。\n  验证的专业化认识   A公司虽然看起来在用FPGA可以快速得到测试结果，但是更多地是将设计作为 黑盒验证 ，缺少内部信号的检查调试，同时 缺少随机激励的场景 来达到 验证的完备性 ，缺少 边缘场景错误场景 保证设计的稳定性。\n  B公司为什么缺少合适的人？深层次的原因恐怕与公司 对验证不重视 有很大关系。如果一开始从验证人员招聘和对验证贡献的充分肯定上入手，那么 验证人员的培养不会滞后于设计人员太多 。\n  C公司除了对与设计师的验证能力充分“信任”之外，也没有觉得验证是一项 单独需要培养的技能 ，或者说 缺乏对一个专业验证团队的认识 。事实上，验证确实不是一项技能，而是需要很多知识综合起来的技能。\n  D公司看起来倒是通过这种小聪明，使得烫手的员工没有做出什么可能让公司无法挽回的损失。但除了 让员工被感到不信任 之外，公司又如何能够保证他们的验证工作做的足够好？要知道验证和设计一样重要， 设计种下了漏洞，验证没有发现，同样是致命的 。\n  E公司的设计人员越到后期越不情愿听到自己的设计被发现漏洞，而且和验证人员沟通起来也颇为困难。除了对于设计和验证的关系需要理清之外，该公司还需要 多鼓励验证团队 ，让他们在 关键时刻顶住压力 ，该报告的设计漏洞需要义无反顾的提交，并且到 后期每报出一个漏洞都应该值得庆幸，因为幸好它没在流片后回来才被发现 。\n  验证面临的现状  芯片业对验证的偏见不单单来源于公司和业界的成见，就连 教育行业 也是如此。高校的教育与芯片行业的脱节十分严重，基本很少看到有高校 开设关于芯片验证的课程 ，哪怕是导论。 国内芯片验证领域 可参考的书目 也不多，而国外优秀的图书又没有得到及时的翻译和引进。 对于从事验证的工程师，业界优秀的图书本身也与实际工作联系不够紧密，而大多数人 缺少时间和资源 来查阅每年最新的验证领域的相关论文。 国内缺少验证行业广泛交流大会，使得验证工程师在经验积累和技术交流上，缺少途径。 就公司而言，对于验证工程师的培养以及职业发展路径上，应该给出明确的信息，从公司层面给出对验证工程师的认可，让验证工程师对于自己的职业发展感受到动力。  验证的标准化  如果想让验证技术呈现出更清晰的理念，首先要将 验证的流程标准化和量化 ，就像软件测试的环节一样。无论对于团队还是个人，只有趋于标准化、量化的验证才能更稳固地推进项目，从而做到心里清楚，手中不慌。 验证团队除了需要优秀的验证工程师，也需要经验丰富的验证经理，这一要求的着眼点不只在于日常管理，也包括针对 芯片整体验证去规划验证框架、环境、流程、制定验证计划、评估人力、时间节点 等。 验证经理会对所在的项目、之前的项目和未来的项目之间验证环境的复用和优化两方面考虑，要求模块、子系统和系统级验证环境可以保持 垂直复用 和 水平迁移 的要求。同时验证经理也需要考虑采样哪一种验证方法、选派合适的人进行验证等。  验证经验的积累和突破  经验分享 是需要长期贯彻的事情，包括公司的内部分享和公司的外部分享两方面。验证的事务做久了容易让人产生倦怠，原因主要在于验证工程师对于验证环境逐渐掌握，趋向于按照现有的环境框架去思考问题，也容易对现有环境的效率感到满足，很难做到主动突破现有框架、做出改善甚至验证环境换代的举措。 公司内部的交流值得推荐，除了 沟通成本小 ，不同验证团队、不同事业部或者分公司之间都可以就验证技术展开交流。 请 EDA技术支持工程师 ，为大家培训，或咨询。 通过总结自己的验证经验，完成体系的验证思想，发表到行业技术大会以及其他技术交流会议，同其他公司分享，也查看和听取其他公司的技术分享和探讨。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":67,"section":"docs","tags":null,"title":"验证工程师与芯片验证（四）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/verifier-and-verify-four/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 验证工程师与芯片验证 部分第三篇，主要介绍计划的概述、计划的内容、计划的实现、计划的进程评估。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《全面的功能验证：完整的工业流程》 Bruce Wile , John C. Goss , Wolfgang 书籍    专业术语与缩略语    缩写 全称 说明     FSM Finite state machine 有限状态机    计划的概述 验证计划是什么  选择验证方法和构建验证环境前，首先需要知道验证计划是什么。 展开设计之前，设计人员和验证人员都会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现和验证它。 实际项目执行中，功能描述文档和设计会不断更新，验证工程师要做好相应验证计划的更新。 验证计划在设计启动之前就已经诞生，且伴随着整个设计周期。  计划的步骤  创建验证计划 选择验证方法 人力资源调配 构建验证平台和环境组件 开发测试用例  收集的材料  结构功能描述 设计的各种操作使用模式 正常输入和错误输入场景下设计的行为 设计的接口 边界场景下设计的行为 设计在实际使用中的场景描述  计划的好处  使得设计和验证人员对于功能描述文档的理解保持一致。 将自然语言描述的功能通过可测试性语言来描述。 可以更合理的评估出工作量、人力安排和进度节点。 为验证人员提供明确的验证目标、任务和进度安排。 为功能文档提供反馈，修改文档中不明确、有歧义的描述。  影响计划的因素  验证计划是团队协作的产物，需要系统、设计、验证共同参与制定。 需要更新成百上千的测试用例，并且与计划中待测试功能一一对应。 考虑选择不同的验证方法，针对不同的设计，需要考虑使用模拟仿真、形式化验证或硬件加速验证，如需使用多平台验证，还要考虑如何实现技术平台上的兼容和跨越式复用。 添加新的设计需求，需要更新验证计划。新添加功能，要考虑额外的人力和进度影响。 多组参与验证，需要团队合作协调，以及测试用例的复用。  计划的内容 写在前面  技术角度考虑，需要有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求。 项目角度考虑，需要有使用工具、人力安排、进度安排和风险评估。  验证的功能  基本功能： 时钟、电源、复位、寄存器访问和基本功能特性，这些可以在模块级完成验证。 交互功能： 与其他模块交互的特性，需要在更高层次的子系统级或系统级完成验证。 次要功能： 这些会在项目后期完成验证，比如性能验证，即便没有达到要求但是不会存在致命影响，所以风险较低，放在最好验证。  验证的层次  结合验证功能点，需要清楚该功能点在何层次验证。 从验证效率和激励自由度来看，应该尽量在较低层次验证更多功能点。 在较高层次，应该侧重于系统集成测试。  验证的方法  方法： 模拟仿真 or 形式化验证 or 硬件加速验证。 透明度： 黑盒 or 白盒 or 灰盒（建议尽可能使用黑盒）。 激励： 定向激励 or 随机约束激励。  验证的用例 选择：\n 更随机的测试方法，尽可能遍历可能的状态空间。 适中的随机约束，倾向于更贴近实际场景的随机激励。 采用定向测试，针对一些边界情况可以更有效的收集覆盖率。  建议：\n 验证初期，应该只发送一些基本的测试数据，约束范围尽可能窄。 验证中期，由于设计基本稳定，可扩大约束范围，以此更有效地完成验证。 验证后期，有一些边界场景通过随机约束激励无法有效收集覆盖率，需要采用定向用例。       覆盖率的要求  覆盖率是衡量激励生成质量和功能点验证的量化指标。 无论何种验证，都需要采用覆盖率来确保给出了足够的激励，遍历设计可能的状态。 覆盖率可以分为代码覆盖率、功能覆盖率和断言覆盖率。 除了给出合法的激励之外，也要考虑给出错误的激励，来测试设计的稳定性和纠错能力。  工具的选择  模拟仿真工具 形式化验证工具 验证IP（如商用接口协议的验证IP） 断言IP 调试工具 硬件加速器 高层次验证语言  人力安排  不同验证方法对人力安排存在明显差别，除了考虑个人的实际经验外，也需要考虑他们是否熟悉该模块，也就是验证人员的知识和技术背景越贴合，越倾向于选择这样的验证人员，这对于人力成本和验证风险都可以降低。 推荐一个完整的项目周期内，固定人员跟踪同一个设计模块，从搭建环境、用例编写、覆盖率收集，以及模块级、子系统级、系统级整个验证过程，这样安排项目风险较低，人员成长较快。  进度安排  首先进度往往是从上向下传达的，项目有时间进度，验证师会有一个大概的进度要求。 工作量 = 人力 X 时间。 验证经常会处于人力不够充分或时间不够宽松的境地。时间往往是固定的，做好任务的安排和动态的人力分配，实现高效的资源配置是关键。 时间进度可修改吗？ 这无法回答，如果能更细致的量化和评估时间和人力安排，delay的风险会较低。  风险评估  芯片结构不稳定： 添加或修改新的功能，会增加新的工作量。 工具的不稳定： 新的版本工具会增加新的特性，有可能提高工作效率，但是也会存在适应期。同时新的工具会面临环境流程更新、技术培训等问题。 人力不稳定： 处于各种原因导致验证人员被临时替换，会加大验证风险。 设计交付时间的不稳定： 设计的delay会直接影响到验证。  计划的实现 写在前面  一份细致的验证计划也包括项目动向、更新内容和工程进度，清晰的计划更能保证时间和人力的平衡。 验证计划需要时常保持更新，给出合理的安排，从计划到实践的反馈，再到计划修改。       如何制定验证计划  邀请相关人员参加会议（设计、验证、系统等）。 开会讨论验证方案。 确定测试场景。 创建验证环境。  邀请人员    项目角色 关注角度 期望验证点     设计人员 设计实践 设计内部时序、状态机、内部逻辑   硅后测试人员 硅后模块功能测试 硅前测试用例移植到硅后测试   软件人员 模块在系统中的应用 软件正确的配置序列被测试   系统人员 结构和性能要求 设计框架符合要求，性能和效能可以早期测试   验证经理 进度、人力和优先级 给出合理安排，定期更新计划   验证人员 验证方法和环境 综合衡量其他角色意见，给出统一的解决方案    开会讨论 作为会议组织者，首先明确开会的目的和议题：\n 报告验证计划的内容。 确定验证功能点。 确定验证方案和时间节点。  一份验证计划的模板应该包含以下内容：\n 设计功能简要概述。 硬件实现结构框图。 待验证的功能点。 验证环境结构。 测试用例构成。 编译脚本和回归测试。 覆盖率分析。 风险评估。  确定测试场景  电源开关。 复位测试。 常规场景。 边缘场景。 错误场景。 性能压力测试。 选择验证层次和验证方法。  创建验证环境  搭建环境时，依据设计结构创建不同的接口信号和激励组件来构建场景。 是否可复用验证资源，以及可用的vip。 监测组件收集数据，确定采样时序和事件，捕捉有效信号。 构建参考模型，模拟DUT行为。 检查组件比对结果，输出报告信息。  计划的进程评估 写在前面 在验证过程中，需要不断更新验证进度，从 各项参数综合评估验证的完备性 ：\n 回归测试通过率（regressioin pass rate） 代码覆盖率（code coverage） 断言覆盖率（assertion coverage） 功能覆盖率（function coverage） bug曲线（bug curve）  回归测试通过率  一份 回归测试表 是将测试设计所有功能点的用例合并为一个测试集。 回归测试表的主要功能是用来在设计bug修复后或性能优化后，验证原有的功能是否正常。 回归测试不仅确保设计修改不影响原功能，且不影响其他模块功能。 回归测试表中的测试用例，需要确保可以复现激励场景。这对于定向测试是容易实现的，而对于随机约束测试，需要保存随机种子，方便复现激励场景。 如果某层次回归测试通过，可向上迁移到新的验证层次，展开新的回归测试流程。 不同层次、不同设计规模、不同测试场景的复杂度，都会影响测试用例的仿真时间。 回归测试中，对验证平台的优化（运算资源和运算效率）的要求更高。 如果系统级回归测试发现bug，修复后需要从模块级回归测试开始运行。       代码覆盖率  代码覆盖率是用来衡量 RTL代码是否被充分运行 的指标。 通过工具开关可自动收集代码覆盖率，且可以将不同批次回归测试覆盖率数据进行合并。  常见的代码覆盖率：\n 语句 覆盖率（statement coverage）： 程序每一行代码是否执行过。 条件 覆盖率（condition coverage）： 每个判断条件中的操作数被覆盖情况。 分支 覆盖率（branch coverage）： if、case、while、repeat、for等语句中各个分支执行情况。 事件 覆盖率（event coverage）： 记录某个事件被触发的次数。 翻转 覆盖率（toggle coverage）： 记录信号数据位 0-\u0026gt;1 和 1-\u0026gt;0 的翻转情况。 状态机 覆盖率（FSM coverage）： 记录状态机各个状态的进入次数，以及状态间的跳转情况。  断言覆盖率  仿真过程中，会判断断言的先决条件是否被触发，以及判断语句的成功与否。 依据仿真工具不同，断言覆盖率可分为动态仿真和形式化验证两种。  功能覆盖率 功能覆盖率衡量设计的各项功能是否实现。功能覆盖率会关注设计的输入、输出和内部状态。\n 输入： 检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。 输出： 检测是否有完整的数据传输类别，以及各种场景的反馈时序。 设计内部： 检查信号与功能点相对应，通过单一覆盖、交叉覆盖或时序覆盖来检查功能场景是否被触发。  注意： 功能覆盖率的收集需要依据功能点文档编写covergroup，且fail用例的覆盖率数据不能合并到回归测试的覆盖率数据中。\nbug曲线  验证过程中要记录和统计bug，bug管理工具一般具有提交、修改、完成、挂起四个状态。 每周统计新增bug数量和修复bug数量，绘制bug曲线。 依据bug曲线，如果能尽早的收敛，意味着后期发现bug的数量和可能性就越小，是设计稳定性的有效指标。 注意： 如果验证后期发现一个基本功能的严重bug，意味着我们很可能在之前验证过程中遗漏了一些重要场景的测试。       文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":68,"section":"docs","tags":null,"title":"验证工程师与芯片验证（三）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/verifier-and-verify-three/"},{"content":"本文 主要介绍芯片验证工程师的成长之路，包括职位概述、技术入门、能力提升和角色转换。\n写在前头，本文内容是根据自己的工作经验和行业了解，以及师兄的经验传授和网络资源，集合而成。并且我还在不断继续努力中。\n   版本 说明     0.1 初版发布   0.2 添加验证流程    背景 本人工作IC设计和IC验证同时涉及，工作领域为CPU相关，经验三年。\n参考    名称 作者 来源     《路科验证》 刘斌 网络    芯片验证职位概述  以往设计地位高于验证，随着芯片复杂度越来越高，流片成本越来越大，目前芯片验证地位与设计同样重要 验证的岗位需求量大，与设计的比例接近2:1 了解验证知识对于将来从事芯片设计也有很大帮助 公司越规模化，团队越正规化，对芯片验证的规范性和重要性就越突出 芯片验证相对设计，更讲究团队协作 芯片验证软件化，工具和语言等知识迭代快（目前相对稳定，统一使用sv语言和UVM方法学），需要不断学习 芯片验证也要懂设计代码，否则无法更好的完成芯片验证 芯片验证不仅限于发现设计bug，还包括对设计的理解以及提出修改意见  芯片验证的技术入门 芯片验证相对于芯片设计，技术门槛较低，但要学习的知识宽度要大于芯片设计。所谓技术门槛低，换句话说也就是即便你对项目领域（如射频、通信、CPU等）完全不通，但并不妨碍你做基础的验证工作。以下是个人认为芯片验证工程师入门需具备的基础：\n 基本的数字电路知识 systemverilog语言和UVM验证方法学 RTL硬件描述语言，如verilog 芯片设计项目的了解（对于前期入门阶段并不是硬性要求） 基础的脚本语言，如Makefile、shell  芯片验证工程师与FPGA验证工程师、芯片设计工程师、软件测试工程师的比较 芯片验证工程师与FPGA验证工程师  FPGA验证是更高层次的黑盒验证 FPAG验证相对于模拟仿真，缺点是难以调试IC设计的内部信号，难以深入debug FPGA验证相对于模拟仿真，优点是仿真速度快，可模拟芯片真实环境，发现隐藏bug FPGA验证工程师的技能更多是工具的使用，看到的IC设计更上层（一般IC设计完整度较高时才会上FPGA平台）  芯片验证工程师与芯片设计工程师  芯片设计工程师更加硬件化，只需verilog语言，但重点在于对设计领域的深刻理解和项目经验 芯片设计工程师对芯片验证领域无需了解太多，而验证工程师也需要对设计有一定了解 芯片验证工程师往往有机会转型到设计，debug过程对设计逐步了解，并且有时候需要给出修改意见 芯片验证工程师不仅与设计工程师协作紧密，与后端和软件工程师有时也有交互 芯片设计工程师关注的是功能结构如何转换为电路实现，芯片验证工程师关注的是电路层次是否符合功能场景 芯片设计工程师学习深度更深，芯片验证工程师学习广度更广，换句话说，验证工程师相对于设计工程师更容易转行（指项目领域，如射频、通信、CPU） 芯片设计门槛高于芯片验证，需要更强的项目领域相关背景知识（一般要求重点学校硕士学历）  芯片验证工程师与软件测试工程师 芯片验证与软件测试，对于非芯片领域或刚毕业的学生，是很容易产生误会的。\n 所处芯片开发阶段不同，芯片验证在流片前，软件测试在流片后（不仅限于流片后） 软件测试纯软件化，看不到或不关心电路结构 软件测试与软件设计的薪资差异，远远大于芯片验证和芯片设计的薪资差异，普遍来讲（排除技术大牛），芯片验证薪资往往高于软件测试（这也是为什么产生误会的原因）  芯片验证工程师的能力提升  深入学习设计领域知识和IC设计架构（对于IP验证及其重要） 深刻学习理解SV语言，可以学习与SV类似的面向对象编程语言，帮助对SV语言特性的理解 深刻学习理解UVM验证方法学，可以从软件的设计模式深入理解 优化代码结构和项目层次，增强可复用性，增强集成度和自动化 多平台验证工具的使用，如formal、FPGA等，对于覆盖率收敛很重要 脚本语言，如shell、Makefile、Python、Tcl、Perl等，掌握脚本语言是使验证平台自动化的基础 虚拟建模和VIP的开发，可增加验证效率，并且可复用性强 制定和优化验证流程，验证计划的制定和实现，验证进程评估 验证管理，包括时间和人力，以及任务安排  芯片验证工程师的角色转换 一个芯片验证工程师经历五到七年的技术积累，此时工作任务得心应手（或者说固化），往往会产生工作倦怠的态度，对于新工具和新知识的学习也不再渴望，这时候需要考虑角色的转换。\n 承担全新设计模块的验证，比如对于CPU项目，可以从DPU模块验证转为LSU模块验证 转为芯片设计，从事不同的工作内容 专职做验证平台优化，学习或自研更好的验证工具和验证方法，提高验证效率（前提是公司同意） 做技术培训者 做验证技术专家或验证管理（前提是能力出众，一般工作十年经验） 离职（需慎重，芯片行业大公司不多，跳一个少一个）  芯片验证工程师的职业规划（也是写给自己）  一年时间，完成芯片验证工程师的入门 三年时间，从初级芯片验证工程师到独立承担模块验证 三年时间，从独立承担模块验证到验证leader（也有可能转向芯片设计） N年时间，从验证人员到验证主管（或技术专家）  验证流程  创建验证计划：参照设计人员提供的设计功能描述文档创建验证计划，并且与设计工程师完成多次review，确保验证计划无明显缺陷 搭建验证环境：验证工程师搭建验证环境平台，准备测试激励 模拟仿真和debug：开始跑测试激励，进行验证环境和设计电路的debug（如果是环境问题择优化环境，设计问题定位具体bug，提交给设计人员） 回归测试：当设计电路通过了一定量的测试激励，验证人员需要准备回归测试，也就是将已有的所有测试通过的用例重新测试一遍 验证代码检查：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等 收集覆盖率：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标 完备性检查：此项任务由验证项目经理完成，主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押 硅后测试：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训  除了技术，我们还需要做什么？ 虽然我们是技术从业者，但是毕竟人的社会是复杂的，那么除了技术，我们还需要做什么？\n 提高团队合作性，让更多的人乐于和自己合作，是对自己人品和性格的最好肯定 提高行业敏锐度，多关心了解行业领域的一些事情，相信我这样是有好处的 跟对一个好领导，作为领导的主要干将，相信我这样是有好处的 保持好同事和前同事的联系，相信我这样是有好处的  顺便，对于新入职的毕业生，教你如何快速与同事和领导建立起社交关系，那就从吃食堂开始。\n书单 基础  《SystemVerilog验证》 《UVM实战》 《芯片漫游指南：从系统理论到UVM的验证全视界》 《全面的功能验证：完整的工业流程》 《Verilog与SystemVerilog的编程陷阱》 《综合与时序分析的设计约束：Synopsys设计约束（SDC）实用指南》  提升  《设计模式：可复用面向对象软件的基础》 《敏捷软件开发：原则、模式与实践》 《代码大全》 《代码阅读》 《重构：改善既有代码的设计》 《改善程序与设计的55个具体做法》  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":69,"section":"docs","tags":null,"title":"芯片验证工程师","uri":"https://www.wenhui.space/docs/07-ic-verify/verify-notes/digital-verifer/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 验证工程师与芯片验证 部分第二篇，主要介绍主要介绍测试平台、激励产生器、监测器、比较器。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《全面的功能验证：完整的工业流程》 Bruce Wile , John C. Goss , Wolfgang 书籍    专业术语与缩略语    缩写 全称 说明     tb testbench 测试平台   drv driver 驱动器   mon monitor 监测器   chk checker 比较器   ref Reference Model 参考模型    测试平台 什么是测试平台？  测试平台是整个验证系统的总称，包括验证结构中的各个组件、组件之间的连接关系、测试平台的配置和控制。 广义来讲，测试平台还包括编译仿真流程、结果分析报告和覆盖率检查等。 狭义来讲，测试平台主要关注结构和组件，如何产生所需输入，以及设计的功能检查。  经典的测试平台 经典的测试平台包含Clock/Reset组件、Driver组件、Monitor组件、Checker组件，其特性如下：\n 各个组件相互独立。 验证组件与设计之间需要连接。 验证组件之间也需要相互通信。 验证环境也需要时钟和复位信号的驱动。  验证语言趋势  SystemVerilog使用比例为主导地位。 SystemC和C/C++在验证部分也有应用空间。 验证方法学UVM的统一已经形成。  Clock/Reset组件 Clock/Reset组件就是指在testbench中产生时钟和复位信号，驱动DUT和Driver。严格来讲，算不上一个独立的组件，此功能在testbench完成。\nDriver组件  Driver主要职责是模拟与DUT交互模块的接口协议，模拟真实的接口信号驱动DUT。 Driver的激励驱动要符合接口协议，但不局限于真实的硬件行为，可使用抽象的语言方法产生丰富的测试激励。 对于接口协议，如果是成熟的商业协议，建议使用第三方的商用接口ip/vip，这很大程度上节省时间和人力。 如果接口协议为非标准，应该查看功能描述文档，明确接口协议。 Driver主要是与DUT相连接，也应该有时钟和复位的输入，确保driver的驱动激励与DUT接口保持时序同步。 Driver与DUT的连接包含两部分：initiator（发起器）和responder（响应器）。发起器是指主动发起DUT接口驱动，响应器是指接收DUT接口信号，做出响应。  Monitor组件 监测DUT的信号 Monitor主要功能是监测DUT的边界或者内部信号，并且经过打包处理传送到其他组件：\n DUT边界信号：对于系统信号如时钟，可以监测频率变化；对于总线信号，可以监测传输类型和数据内容，以及总线时序是否符合协议。 DUT内部信号：从灰盒验证的手段来看，往往需要监测内部关键信号，来反馈给Driver控制激励产生，或者完成覆盖率收集，以及其他内部功能检查。  Monitor的结构建议  独立性 ：建议不同接口信号采用独立的Monitor。 复用性 ：尽可能将组件做成验证IP，方便复用到其他环境。 可维护性 ：保持代码和验证环境的可维护性。 封装性 ：将Monitor和Driver一一对应，封装为一个小的单元，这样的小单元可以按照统一的方法实现，但又各自独立。  监测内部信号的建议  如没有特殊需求，采取灰盒验证，而非白盒。 监测内部信号应该尽量少（收集覆盖率除外），且应当为状态信号，不建议监测中间变量信号，因为其本身因时序问题信号留存不稳定，这种不稳定有可能影响到验证环境。 可以通过接口信息计算的，尽量减少监测内部信号，这样有悖于假定设计有bug的验证思想，如需采用内部信号，也要以动态检查或断言形式确保其逻辑正确性。  Checker组件 checker主要功能 checker主要承担模拟设计和功能检查的任务，主要包含以下功能：\n 接收缓存各个monitor收集的数据。 将DUT接口数据驱动给Reference Model，参考模型扮演了模拟DUT功能的角色。 通过数据比较，检查DUT输出接口是否与Reference Model产生的期望数据一致。 检查过程中保存整理验证信息，纳入检查报告中，便于仿真后的追溯。  总结来讲，Checker主要负责数据接收缓存、参考模型和检查报告。\nchecker比较方式 对于checker的数据比较，又可以分为两类：\n 线上比较（Online Check）： 仿真时收集数据与参考模型实时比较，实时报告。 线下比较（Offline Checker）： 将仿真时的数据结果保存到文件中，仿真结束后通过脚本或其他手段，进行数据比较。  checker实现结构建议  对于复杂的系统，建议集中管理checker，将不同monitor信息汇集于此，检查各个模块的功能，统一输出报告。 monitor和driver相对独立且一一对应，建议封装在agent单元组件，而checker在验证环境中心化位置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":70,"section":"docs","tags":null,"title":"验证工程师与芯片验证（二）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/verifier-and-verify-two/"},{"content":"本文 主要介绍对word编辑文档的一些建议。\n   版本 说明     0.1 初版发布    背景 本篇文章参考自王老师。\n写在前面 出于各方面原因，我们编辑文档时，主要还是使用微软的office工具word。word不敢说是最好的文档编辑工具，但是功能最强，使用最广的文档编辑工具，而我们在使用word编辑文档时，是否有好好利用了其强大的功能呢？这是一个值得思考的问题。\n我们在编辑文档时，是在编辑什么？一篇文档包含两方面，一是内容，指文档的表述文字、图表、公式等，二是表现，指文档的表现形式，比如字体字号、页边距页面大小等。那么关于是否有好好利用word强大的功能的思考，答案就有了，如果你编辑文档时，是在编辑内容，而表现形式由word工具完成，那你就好好利用word强大的功能。而往往大多数人在使用word时，还在花费大量的时间在人工排版上。换句话说，word被当做了记事本来使用。\n建议 一定要使用样式 word除了提供已有的标题和正文等样式，还可以自定义样式，也就是说，当你发现自己当前文字使用的格式会多次被使用，那就请定义一个样式吧。建议坚持使用样式，这样不仅可以减少出错和节省时间，而且方便样式替换，以及可以自动生成目录和索引。\n一定使用交叉引用 一定使用交叉引用，不要手敲编号，否则会对你的文档修改维护带来无穷后患。使用交叉引用不仅可以自动更新编号，还可以自动生成图表目录。\n一定不要敲空格来对齐 一般只有英文单词前后才会出现空格，中文文档不会出现空格，对齐应该采用制表符、对齐方式和段落缩进等，而绝不是空格。\n绘图 建议使用visio，如果是统计图建议使用excel生成。（其他visio可替代工具亦可）\n数学公式 建议使用MathType，可集成在word使用，会在word增加一个菜单项，一定要使用MathType的自动编号和引用功能，使用方法参考 MathType在Word中的使用。\n使用节 如果你希望在一篇文档中使用不同的页眉页脚等，可以插入分节符，并设置当前节与上一节格式不相同。\n使用子文档 如果你的文档过于大（几十页），且包含大量图片、公式、表格等，所有内容保存到一个文件里，一是打开、保存文件较慢，二是有破坏和丢失内容的风险。建议对于大文件的编辑，可以将每一章定义为一个子文档，在主文档中定义格式，这样既提高了文件访问速度也降低了破坏和丢失内容的风险。建议在主文档中创建子文档。\n及时保存 编辑文档时，一定要多按Ctrl+s，及时保存。\n多做备份 对编辑的文档多做版本备份。不仅word不可靠，windows也不可靠，越是重要的、工作量大的文档，越要多做备份。\n另存图片、表格和公式 文档中一张好图胜过千言，而一张好图所需的时间也不只于千言，所以对于文档中的图片、表格和公式，最好另存到其他文件夹，防止以后因为工具、格式或其他问题，导致文档中的图片、表格和格式无法正常显示，到时候哭都来不及。\n使用大纲视图 使用大纲视图，可以方便调整章节顺序。\n使用文档导航窗口 使用文档导航窗口可以方便的对文档定位。\n使用文档保护 使用文档保护可以方便对文档审阅和修改。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":71,"section":"docs","tags":["Office"],"title":"关于word编辑文档的一些建议","uri":"https://www.wenhui.space/docs/05-windows-skills/some_advices_of_word/"},{"content":"本文 芯片验证系列文章主要分为三部分：验证工程师与芯片验证、SV学习笔记、UVM学习笔记。此为 验证工程师与芯片验证 部分第一篇，主要介绍验证的背景、验证的前景、验证的目标、验证的流程。\n   版本 说明     0.1 初版发布    参考    名称 作者 来源     《芯片验证漫游指南》 刘斌 书籍   《全面的功能验证：完整的工业流程》 Bruce Wile , John C. Goss , Wolfgang 书籍    专业术语与缩略语    缩写 全称 说明     FAB fabrication/foundry 晶圆加工厂    验证的背景 芯片开发流程       从市场调研和用户需求开始，形成产品报告。 系统设计人员按照功能划分为各个子系统。 子系统被进一步划分为功能模块，并由设计团队实现。 验证人员对设计功能展开验证，发现设计缺陷，交由设计人员修正。 验证没有出现漏洞后，交由后端人员进行综合、布局、布线。 后端人员将核心数据交由FAB进行流片。  验证和设计的关系  设计如果没有经过充分验证、量化验证，是没有足够信心去流片的。 验证要懂设计，否则无法更好的发现和定位bug。 设计要懂验证，否则无法体会验证逐渐趋向于软件化。 设计需要验证尽早尽快尽量的发现设计bug，越到后期修正设计bug的代价越大：1）后期设计的修正可能牵一发而动全身；2）修正后需要完整的回归测试；3）甚至需要后端重新综合布局布线。 设计和验证都需要围绕功能描述文档展开工作。 设计初步完成时验证就要启动，甚至更早启动。 发现验证结果与预期不符，明显bug可提交给设计工程师，若无法判定，需要与设计工程师依据功能描述文档进行沟通，统一对功能的理解。 设计从底层模块向系统集成过程中，验证与设计要各自开展工作，验证要保证每一个层次验证的充分性和完备性。  验证和设计的协作       验证和设计都需要认真阅读功能描述文档。 设计会将其实现为RTL模型。 验证会按照其功能发送激励和比较结果。  验证的三个方向  设计功能是否符合功能描述文档？ 设计工程师是否有遗漏的边界场景(Corner Case)？ 设计是否足够稳定来处理错误场景(Error Response)？  验证的挑战  如何穷尽所有场景为设计产生激励？  划分有效的测试空间。 给出随机约束激励。   如何在各种激励下发现和判断设计的bug？  根据不同类型设计提供相应的测试激励，选择相应的check方法。 根据不同类型设计选择相应的验证工具，仿真验证和形式验证。 根据复杂度不同，选择黑盒验证、白盒验证以及灰盒验证。       设计类型 激励类型 结果比对方法     处理器 预先被存入到存储单元的指令和数据 每个指令执行以后寄存器的值是否符合预期   存储控制器 数据的读写操作并且尽可能覆盖所有可访问范围 数据的存储和读取是否正确   IO模块 数据包的传输，包括定义包的头部、长度、数据和地址 数据从IO的输入到输出是否得到正确的转换打包，数据是否有丢失的情况   音频视频组件 数据流的编码解码 数据流在输出端相对输入端来讲的完整性是否符合预期音频是否失真，视频是否完好   片上网络(NoC) 通过列出主从单元的访问矩阵来穷举所有可能的访问路径 各个可能访问的路径是否都可以通过同时被禁止的路径是否按照预期无法访问   系统模块(时钟、复位、电源) 逻辑开关测试，顶层连线测试 通过寄存器的配置各个控制信号是否正确更新，同时顶层的连线是否将系统模块的输出连接到目标子系统端    验证的前景  工作中设计与验证同等重要（薪资）。 验证需求量大，与设计的比例接近2:1。 学习和掌握验证知识，对后期从事设计或验证都有帮助。 公司研发团队越正规化，对验证的规范性越重视。 验证工作越来越趋向软件化，知识迭代比设计快，更富有挑战性。  验证的目标 按时：  验证工程师需要按照项目的预期进度来考虑验证节点。 协调安排各模块验证工作进度，任何一个模块验证的延迟都会影响整体验证进度。 团队协作，所有验证工程师都要有时间节点观念。  保质：  尽可能保证验证的充分性和完备性，减少硅后bug的出现。 bug出现的阶段越到后期，代价越大。 提前做好验证计划，设计与验证定期沟通，保证验证计划的充分性和完备性。  低耗：  人力和时间成本低耗，保证工作的高效率。 资金成本低耗，尽早保证验证的充分性，防止bug出现在硅后甚至客户端，就是在保证资金成本低耗。       验证的流程 验证流程       创建验证计划 ：参照设计功能描述文档创建验证计划，并且与设计师完成多次review，确保验证计划无明显缺陷。 搭建验证环境 ：验证师搭建验证环境，准备测试用例。 模拟仿真和debug ：运行测试用例，进行验证环境和设计的debug。 回归测试 ：当设计通过了一定量的测试用例，验证师需要准备回归测试，也就是将已有的测试用例重新测试一遍。 验证代码检查 ：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等。 收集覆盖率 ：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标。 完备性检查 ：主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押。 硅后测试 ：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训。  review节点  验证计划review ：设计师与验证师依据功能描述文档沟通，检查验证计划，确保无明显遗漏和功能偏差。 验证代码review ：回归测试前，设计师与验证师对验证代码进行review，检查是否有遗漏的测试用例、不恰当的随机约束等。 覆盖率review ：回归测试后，对当前覆盖率进行review，确保验证的完备性。 验证总结review ：其一是分析bug逃逸，总结经验，吸取教训；其二是验证流程、工具使用、团队协作等经验总结。  功能描述文档  接口信息 ：描述接口信号的时序信息和数据传输信息等。 结构信息 ：描述模块的逻辑结构，包含各个功能组件，以及各个功能组件的逻辑关系。 交互信息 ：描述模块与其他模块的交互信息，包括逻辑示意图和时序信息，确保集成后模块间按照预期功能完成交互。  验证计划  验证方法 ：定向验证、随机约束验证、形式化验证等。 验证工具 ：选择需要的验证工具来支持验证方法，如VCS、XRUN、JasperGold等。 验证完备性 ：量化一些参数（功能点覆盖率、代码覆盖率、断言覆盖率）可以衡量验证任务是否完成。 验证资源和进度 ：人力、时间、硬件、软件等预算。 验证功能点 ：列出验证功能点，以及明确在什么层次去验证它，甚至选择何种激励去验证它。  开发验证环境  搭建验证环境，实现driver、reference和checker。 不同的验证方法，验证环境的结构和使用软件不同。 随着bug的发现和修正，设计趋于稳定，验证环境保持更新，补充测试用例。 添加covergroup或assert，使环境支持覆盖率收集。  debug  验证环境是否存在bug。 硬件设计是否存在bug。 测试激励是否合理。 参考模型是否遵循设计功能描述文档。  回归测试  确保改动没有引入新的bug。 随机种子不同，测试激励不同，有利于收集覆盖率，往复的回归测试和补充的定向测试，可逐步提高验证的完备性。  芯片流片  经过回归测试（RTL回归和门级网表回归），项目负责人、设计负责人、验证负责人、后端负责人一同回顾整个checklist，确保通过各项指标，交给FAB厂商进行流片。 特别提示： 即便已经交给FAB厂商进行流片，仍需要继续保持回归测试，并尽可能创造新的测试激励，覆盖更多状态空间，进一步保证验证的完备性。 如果交给FAB厂商进行流片后发现设计bug，一考虑是否有软件补救办法，二提交设计修改意见，下次流片前准备好设计和验证方案。  硅后测试  流片后系统测试工程师会将芯片植入测试系统或依靠测试开发板，进行硅后测试。 硅前工程师（设计、验证）和硅后工程师保持沟通，出现测试问题，第一时间判断是测试问题还是设计bug，以及如何修补。  逃逸分析  验证无法保证设计没有任何bug，而是尽可能发现所有bug。 硅后测试发现bug，设计和验证要与系统测试沟通，尝试在硅前的仿真环境中复现。 逃逸分析后，对下一个芯片周期，设计如何规避设计bug、完善设计经验，验证如何完善验证方案、如何产生更多有效测试激励都是很有意义的。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":72,"section":"docs","tags":null,"title":"验证工程师与芯片验证（一）","uri":"https://www.wenhui.space/docs/07-ic-verify/training/verifier-and-verify-one/"},{"content":"本文 主要介绍用emacs auto-insert命令实现用模板文件创建新文件。\n   版本 说明     0.1 初版发布   0.2 添加两个函数    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs中那些简化输入的方法\u0026ndash;Autotyping Auto Insert Mode Emacs如何使用文件模板  创建模板文件 在.emacs.d目录下新建文件夹 templates，并创建verilog模板文件 templates.v，内容如下(文件名、路径、内容均可根据个人喜好进行定义，这里只是举例说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module xx(/*AUTOARG*/); /*AUTOWIRE*/ /*AUTOREG*/ endmodule   修改配置文件 我们创建了模板文件，还需要在配置文件中进行配置，打开.emacs或.emacs.d/init.el，添加以下内容(除了verilog文件模板，我还添加了shell等其他模板，不再一一说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;;about template file ;;---------------------------------------------------- (auto-insert-mode) ;; Adds hook to find-files-hook (setq auto-insert-directory \u0026#34;~/.emacs.d/templates/\u0026#34;) (setq auto-insert-query nil) ;; If you don\u0026#39;t want to be prompted before insertion (setq auto-insert-alist (append \u0026#39;((verilog-mode . \u0026#34;template.v\u0026#34;) (python-mode . \u0026#34;template.py\u0026#34;) (c-mode . \u0026#34;template.c\u0026#34;) (shell-mode . \u0026#34;template.sh\u0026#34;) ) auto-insert-alist)) ;;----------------------------------------------------   添加两个函数 插入当前时间 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前时间时， M-x now 即可。\n1 2 3 4 5  (defvar current-date-time-format \u0026#34;%Y/%m/%d %H:%S\u0026#34;) (defun now () (interactive) (insert (format-time-string current-date-time-format (current-time))) )   插入当前文件名 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前文件名时， M-x name 即可。\n1 2 3 4  (defun name () (interactive) (insert (file-name-nondirectory buffer-file-name)) )   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":73,"section":"docs","tags":["emacs","verilog"],"title":"emacs 中使用模板文件","uri":"https://www.wenhui.space/docs/02-emacs/emacs_auto_insert/"},{"content":"本文 主要介绍如何使用 Verilog-Perl 脚本对verilog代码进行神奇操作。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3 Verilog-Perl版本：Verilog-Perl-3.468  参考  Verilog-Perl使用手册  安装verilog-perl 下载  Verilog-Perl主页 我的百度网盘分享资源(Verilog-Perl-3.468) 链接：https://pan.baidu.com/s/18cqcuv3MwtlGheuy2wWl8g 密码：73wd 也可以直接使用我安装后的可执行程序，百度网盘分享资源 链接：https://pan.baidu.com/s/1w1AykoGr0AFmfnoar87FRQ 密码：9nzf  安装 安装过程中，发现有依赖错误，先下载依赖文件(我也并不知道这些依赖有何作用，无非就是报出了依赖错误，乖乖安装罢了)：\n1 2 3 4  sudo apt install flex sudo apt install bison sudo apt install g++ sudo apt install gcc   接下来进行安装(详情可查看安装包中RENAME)：\n1 2 3 4  perl Makefile.PL make make test sudo make install   vrename的使用 使用场景 vrename的使用主要有两个场景：\n 一是同一文件，修改某信号名称，不用一一修改，通过vrename即可完成全部信号名的修改（好像查找替换也行，不过修改信号名较多时，vrename还是方便一些） 二是交互文件，子模块与顶层模块间的实例化，此时修改信号就需要在不同的文件里修改或查找替换，当需要修改的信号较多时，就会繁杂且易出错，此时vrename将信号统一到一个文件里，修改此文件后使用vrename \u0026ndash;change即可完成修改，方便快捷。  使用方法 vrename可以比较方便的从多个文件中为信号和模块重命名。操作过程分为两步：\n 读取文件，你将会得到 signals.vrename 文件，其中包含了所有信号的列表。   1  vrename --list file1.v file2.v file3.v ...    可以编辑此文件，修改信号名，然后在运行第如下命令，就可以把新的信号名应用到源文件上了。   1  vrename --change file1.v file2.v file3.v ...   展示 signals.vrename 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Generated by vrename on Fri Jan 3 16:56:31 2020 # # Files read for this analysis: vfile\t\u0026#34;testbench.v\u0026#34; vfile\t\u0026#34;dut.v\u0026#34; # #\tOriginal Signal Name\tName to change to #\t--------------------\t----------------- # sigren\t\u0026#34;clk\u0026#34;\t\u0026#34;clk\u0026#34; sigren\t\u0026#34;din0\u0026#34;\t\u0026#34;din0\u0026#34; sigren\t\u0026#34;din1\u0026#34;\t\u0026#34;din1\u0026#34; sigren\t\u0026#34;din2\u0026#34;\t\u0026#34;din2\u0026#34; sigren\t\u0026#34;dout\u0026#34;\t\u0026#34;dout\u0026#34; sigren\t\u0026#34;dout_a\u0026#34;\t\u0026#34;dout_a\u0026#34; sigren\t\u0026#34;dout_b\u0026#34;\t\u0026#34;dout_b\u0026#34; sigren\t\u0026#34;dout_c\u0026#34;\t\u0026#34;dout_c\u0026#34; sigren\t\u0026#34;dout_x\u0026#34;\t\u0026#34;dout_x\u0026#34; sigren\t\u0026#34;dout_y\u0026#34;\t\u0026#34;dout_y\u0026#34; sigren\t\u0026#34;dout_z\u0026#34;\t\u0026#34;dout_z\u0026#34; sigren\t\u0026#34;dut\u0026#34;\t\u0026#34;dut\u0026#34; sigren\t\u0026#34;i_dut\u0026#34;\t\u0026#34;i_dut\u0026#34; sigren\t\u0026#34;rst_n\u0026#34;\t\u0026#34;rst_n\u0026#34; sigren\t\u0026#34;sig1\u0026#34;\t\u0026#34;sig1\u0026#34; sigren\t\u0026#34;testbench\u0026#34;\t\u0026#34;testbench\u0026#34; # # Use M-x compile in emacs to automatically perform the changes: ## Local Variables: *** ## compile-command: \u0026#34;./vrename -change testbench.v dut.v \u0026#34; *** ## End: ***   多目录问题的解决 如果文件分布到不同目录里，可以创建新的工作目录，并将源文件复制软链接至工作目录，此时就可以操作了。不过，vrename并不建议一次打开太多文件，以免信号过多。\nvhire的使用 待补充，如有使用者，欢迎传授使用技巧。\nvpassert的使用 待补充，如有使用者，欢迎传授使用技巧。\nvsplitmodule的使用 待补充，如有使用者，欢迎传授使用技巧。\nvppreproc的使用 待补充，如有使用者，欢迎传授使用技巧。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":74,"section":"docs","tags":["emacs","verilog"],"title":"Emacs Verilog Perl 的使用","uri":"https://www.wenhui.space/docs/02-emacs/verilog_perl_useguide/"},{"content":"本文 主要介绍使用emacs verilog-mode 编辑verilog的神奇操作。\n   版本 说明     0.1 初版发布   0.2 添加快捷键插入内容    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  verilog-mode  什么是verilog mode verilog-mode是Emacs的一种编辑模式，主要面对verilog的开发环境，拥有很方便的自动缩进机制和AUTO机制。AUTO机制是Emacs verilog-mode中一些自动化实现的脚本功能，比如自动填充模块参数列表、自动完成模块例化、自动声明连线等等。\n为什么使用verilog-mode verilog语法中有很多内容是冗余的，模块中必须出现却起不到什么功能作用，列举如下：\n 模块参数列表和模块端口声明input/output reg语句和已经声明为输出的信号 子模块实例化的连线声明 子模块的实例化语句和子模块的端口声明 组合逻辑always语句的敏感信号表（不过已经可以使用*来代替了）  可见verilog语法中的垃圾信息还是不少的，不过这是语法规则导致的，是语言本身的缺陷，作为使用者只能遵守语法规则。这些冗余信息中比如参数列表和模块例化连线，不仅需要花费时间去编写，而且还特别容易出错，给RTL编写以及后续的修改维护都带来很多问题。那么如果解决这些问题，会带来什么效果呢？个人认为有以下几点：\n 代码整洁，便于阅读 提高编码效率，尤其是顶层实例化 减少拼写错误 便于维护，比如修改、增加和删除端口，无需修改参数列表，比如修改、增加和删除子模块端口，无需修改顶层实例化  AUTO机制的使用 Emacs verilog-mode的AUTO机制，就是在代码中相应的位置写一些/*AUTO*/类似的注释，verilog-mode可以自动替换为所需的内容。Emacs编辑器和verilog-mode的AUTO机制结合，可以很方便的看到AUTO的效果，而且AUTO是以注释形式添加到verilog文件，在语法上本身是合法的，不会影响EDA工具的使用。举例如下：\n 原代码  top module     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  module top_md(/*AUTOARG*/); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ /*AUTOWIRE*/ wire din_a; wire din_b; always@(/*AUTOSENSE*/) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md    sub_module   1 2 3 4 5 6 7 8 9  module sub_md(/*AUTOARG*/); input din_a; input din_b; output [1:0] dout_a; wire [1:0] dout_a; assign dout_a[1:0] = {din_b,din_a}; endmodule // sub_md    AUTO之后   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  module top_md(/*AUTOARG*/ // Outputs dout1, dout2, // Inputs din1, din2 ); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ // Beginning of automatic regs (for this module\u0026#39;s undeclared outputs) reg dout1; // End of automatics /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire [1:0] dout_a; // From i_sub_md of sub_md.v // End of automatics  wire din_a; wire din_b; always@(/*AUTOSENSE*/din1 or din2) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/ // Outputs  .dout_a (dout_a[1:0]), // Inputs  .din_a (din_a), .din_b (din_b)); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md   使用 AUTOSENSE 自动生成敏感表 在Verilog 2000中，已经对语法做出了简化，比如使用 @(×) 来代替敏感信号列表，但是需要EDA工具的支持。不过现在EDA工具都已经支持verilog 2005了，可以将敏感信号列表直接写为 @(×) 即可，所以 AUTOSENSE 功能可以不使用。\n1 2 3 4  always @ (/*AUTOSENSE*/) begin outin = ina | inb; out = outin; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4  always @ (/*AUTOSENSE*/ina or inb) begin outin = ina | inb; out = outin; end   使用AUTOARG自动生成模块参数表 1 2 3 4  module ex_arg (/*AUTOARG*/); input i; output o; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_arg (/*AUTOARG*/ // Outputs  o, // Inputs  i); input i; output o; endmodule   不支持带 `ifdefs 等条件限制的端口声明，如有此需求，可以将其写在 AUTOARG 之前， AUTOARG 不会对其进行重新声明。不过不建议这种方式，因为在 AUTOINST 中会引入更多的 `ifdefs 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  module ex_arg ( `ifdef need_x_input x, `endif /*AUTOARG*/ // Outputs  o, // Inputs  i); `ifdef need_x_input input x; // This is an optional input, if `need_x_signal is defined `endif ...   使用AUTOINST自动实例化 子模块：\n1 2 3 4 5  module fanout (o,i) input i; output [31:0] o; wire [31:0] o = {32{i}}; endmodule   顶层模块：\n1 2 3 4 5  module ex_inst (o,i) input i; output [31:0] o; fanout fanout (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_inst (o,i) output o; input i; fanout fanout (/*AUTOINST*/ // Outputs  .o (o[31:0]), // Inputs  .i (i)); endmodule   注意，子模块需要与顶层例化模块保存在同一文件目录，否则会索引不到子模块，而且实例化的端口名与子模块的端口名，默认是一致的。一般来讲，提倡实例化的端口名与子模块的端口名一致，这样对综合及维护都会带来好处，但是由于某些原因无法使其一致，那最简单的方法就是在 AUTOINST 之前指定实例化的端口名，所有在 AUTOINST 之前定义的端口不会再次生成，但是你最好加上 //Inputs //Outputs 注释，否则 AUTOWIRE 不知道信号方向。举例如下:\n1 2 3 4 5 6  fanout fanout ( // Inputs  .i (my_i_dont_mess_with_it), /*AUTOINST*/ // Outputs  .o (o[31:0]));   如果你被端口名不一致所困扰，可以参考我的另一篇帖子 Emacs Verilog Perl 的使用中vrename的使用章节。\n使用AUTO_TEMPLATE创建模板 如果一个模块被实例化多次，你可以使用verilog的 generate 语法，也可以使用Emacs verilog-mode的 AUTO_TEMPLATE 和 AUTOINST 。Verilog-mode向上索引最近的模板，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。\n1 2 3 4  /* psm_mas AUTO_TEMPLATE ( .PTL_MAPVALIDX (PTL_MAPVALID[@]), .PTL_BUS (PTL_BUSNEW[]), ); */   TEMPLATE中的模块名称必须与实例中的模块名称相同，并且只需列出每次实例化时名字不同的那些信号就好了。如上文的例子，要遵守此格式（每行只有一个端口，并且以逗号结尾，最后以分号结尾，就像AUTOINST产生的一样）。实际上，最简单的方法是完成一个AUTOINST，并将其修改后复制到AUTO_TEMPLATE。\n1  psm_mas ms2 (/*AUTOINST*/);   AUTO效果：\npsm_mas ms2 (/*AUTOINST*/ // Outputs .INSTDATAOUT (INSTDATAOUT), .PTL_MAPVALIDX (PTL_MAPVALID[2]), // Templated .PTL_BUS (PTL_BUSNEW[3:0]), // Templated .... @ 字符非常有用，他将被实例名的末尾数字代替（不限于1位数字），比如ms2，@替换为2。AUTO机制把模板中的 [] 替换为子模块中该信号真实的字段范围，比如 PTL_BUSNEW[] 替换成了 PTL_BUSNEW[3:0] ，因为子模块中PTL_BUSNEW信号声明就是 [3:0]。这样写的好处就是子模块的修改自动响应到顶层模块。（其实如果端口信号位宽一致，实例化端口也可以不指明位宽字段，不过为了便于维护和减少出错，建议指明位宽字段）\n神奇的 @ 不仅支持数字，还可以支持字母，这需要在模板做以下操作（模板支持正则表达式）：\n1 2 3 4 5 6 7  /* InstModule AUTO_TEMPLATE \u0026#34;_\\([a-z]+\\)\u0026#34; ( .ptl_mapvalidx\t(@_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_@), ); */ InstModule ms2_FOO (/*AUTOINST*/); InstModule ms2_BAR (/*AUTOINST*/);   AUTO效果如下：\n1 2 3 4 5 6 7 8  InstModule ms2_FOO (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(FOO_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_FOO)); InstModule ms2_BAR (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(BAR_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_BAR));   在模板中使用Lisp 在AUTO_TEMPLATE中指定简单的线名称并不能够解决所有需求，尤其是在多个实例化中使用同一信号不同数据位时。因此，Verilog-Mode允许你编写一个程序来进行计算并为实例化端口进行命名，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* InstModule AUTO_TEMPLATE ( .a(in[@\u0026#34;(+ (* 8 @) 7)\u0026#34;:@\u0026#34;(* 8 @)\u0026#34;]), );*/ InstModule u_a0 (/*AUTOINST*/ // Inputs  .a (in[7:0])); // Templated InstModule u_a1 (/*AUTOINST*/ // Inputs  .a (in[15:8])); // Templated InstModule u_a2 (/*AUTOINST*/ // Inputs  .a (in[23:16])); // Templated InstModule u_a3 (/*AUTOINST*/ // Inputs  .a (in[31:24])); // Templated   这里对上述Lisp代码部分解释一下， 也就是 @\u0026quot;(+ (* 8 @) 7)\u0026quot;:@\u0026quot;(* 8 @)\u0026quot; ：\n 基础结构为 @\u0026quot;\u0026quot; 代表@为输入参数，引号内为计算处理 每个括号内容为一步计算，形如 (* 8 @) ，意思是 @参数乘8 (+ (* 8 @) 7) 就是将 (* 8 @) 的结果加7  AUTOINSTPARAM的使用 如何在实例化时自动填充参数列表？AUTOINSTPARAM可以做到，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  module InstModule; parameter PARAM1 = 1; parameter PARAM2 = 2; endmodule module ModnameTest; InstModule #(/*AUTOINSTPARAM*/ // Parameters  .PARAM1 (PARAM1), .PARAM2 (PARAM2)) instName (/*AUTOINST*/ ...);   verilog-mode中如何使用正则表达式 在顶层实例化时，有大量的信号需要重新命名，使用模板的话会增加大量的注释内容，不过往往这些信号命名有特定的规律，我们可以使用正则表达式来处理，下面举几个例子：\n 提取信号中固定位置的数字   1 2 3  .pci_req\\([0-9]+\\)_j (pci_req_jtag_[\\1]), .pci_req12_j (pci_req_jtag_[12]),    删除末尾下划线内容   1 2 3  .\\(.*\\)_j (\\1_[]), .pci_req_j (pci_req[7:0]),    对信号矢量化处理(\\1内容代表提取末尾数字之前的内容，\\2内容代表提取末尾数字)（将@改为\\([0-9]+\\)也是可以的）   1 2 3 4 5 6  .\\(.*[^0-9]\\)@ (\\1[\\2]), .pci_req0 (pci_req[0]), .pci_req1 (pci_req[1]), .pci_req2 (pci_req[2]), .pci_req3 (pci_req[3]),   AUTOWIRE 的使用 顶层实例化时，需要将连线进行声明， AUTOWIRE 可以完成此项任务。 AUTOWIRE 将声明所有子模块输出的连接线。这对于在两个子模块之间互连但未在顶部模块中使用的信号特别有用。\n1 2 3 4 5 6 7 8 9  module top (o,i) output o; input i; /*AUTOWIRE*/ inst inst (/*AUTOINST*/); other other (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module ex_wire (o,i) output o; input i; /*AUTOWIRE*/ // Beginning of automatic wires  wire [31:0] ins2oth; // From inst of inst.v  wire [31:0] oth2ins; // From other of other.v  // End of automatics  inst inst (/*AUTOINST*/ // Outputs  .ins2oth (ins2oth[31:0]), .o (o), // Inputs  .oth2ins (oth2ins[31:0]), .i (i)); other other (/*AUTOINST*/ // Outputs  .oth2ins (oth2ins[31:0]), // Inputs  .ins2oth (ins2oth[31:0]), .i (i)); endmodule   AUTOREG的使用 如果模块输出来自寄存器，则需要将信号声明为寄存器和输出端口。 AUTOREG 将完成输出信号的寄存器声明，并且如果输出来自非寄存器，则不会添加reg声明。\n1 2 3 4 5 6 7 8  module ex_reg (o,i) output o; input i; /*AUTOREG*/ always o = i; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11  module ex_reg (o,i) output o; input i; /*AUTOREG*/ // Beginning of automatic regs  reg o; // End of automatics  always o = i; endmodule   AUTOINPUT、AUTOOUTPUT的使用 在top层中，一般只有子模块的例化，没有任何其他粘合逻辑，这也是最期望的。这时top层通过 AUTOWIRE 声明了子模块的输出连线， AUTOINST 实现了子模块的实例化，其余未声明的信号，就是top模块的输入输出信号，我们可以通过 AUTOINPUT AUTOOUTPUT 完成输入输出信号的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module top_md(/*AUTOARG*/); /*AUTOINPUT*/ /*AUTOOUTPUT*/ /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/); endmodule // top_md  module sub_md(/*AUTOARG*/); input din_a; input [1:0] din_b; output [2:0] dout_a; assign dout_a[2:0] = {din_b,din_a}; endmodule // sub_md   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module top_md(/*AUTOARG*/ // Outputs dout_a, // Inputs din_b, din_a ); /*AUTOINPUT*/ // Beginning of automatic inputs (from unused autoinst inputs) input din_a; // To i_sub_md112 of sub_md.v input [1:0] din_b; // To i_sub_md112 of sub_md.v // End of automatics /*AUTOOUTPUT*/ // Beginning of automatic outputs (from unused autoinst outputs) output [2:0] dout_a; // From i_sub_md112 of sub_md.v // End of automatics  /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/ // Outputs  .dout_a (dout_a[2:0]), // Inputs  .din_a (din_a), .din_b (din_b[1:0])); endmodule // top_md   AUTORESET的使用 寄存器类型的变量往往需要赋初值。描述时序逻辑的always时，最好对复位条件下进行寄存器变量的初始化；描述组合逻辑的always时，最好对寄存器变量赋缺省值，这样不会产生latch。对于多信号的always语句，手动添加不仅费时，而且容易出错，此时我们可以使用 AUTORESET 自动完成。这里默认初始化赋值为0，如需其他值，需要将其手动添加到 AUTORESET 之前，AUTO不会对其重复添加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_a = 1\u0026#39;h0; dout_b = 2\u0026#39;h0; dout_c = 3\u0026#39;h0; // End of automatics if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_x \u0026lt;= 1\u0026#39;h0; dout_y \u0026lt;= 2\u0026#39;h0; dout_z \u0026lt;= 3\u0026#39;h0; // End of automatics end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   注意，要先声明reg， AUTORESET 才会自动加上位宽，如果仍然不能自动将位宽加上，请在.emacs或.emacs.d/init.el文件添加以下设置：\n1  (setq verilog-auto-reset-widths t)   如果对时序逻辑always语句中的复位赋值需要添加延迟，请在.emacs或.emacs.d/init.el文件添加以下设置（注意：#1后必须有空格）：\n1  (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;)   AUTOREGINPUT的使用 在写测试激励时，往往将设计模块（也可以叫dut）作为一个子模块在testbench中进行实例化，这事需要定义一些reg类型的信号，作为dut的输入激励。 AUTOREGINPUT 可以帮你完成此任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  module testbench; /*AUTOREGINPUT*/ initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  module testbench; /*AUTOREGINPUT*/ // Beginning of automatic reg inputs (for undeclared instantiated-module inputs) reg din1; // To i_dut of dut.v reg din2; // To i_dut of dut.v // End of automatics  initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/ // Outputs  .dout (dout), // Inputs  .din1 (din1), .din2 (din2)); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   其他使用技巧 多目录问题（如果文件在同一目录，可忽略） 我们的项目工程会有很多代码，存放在不同的文件目录里，而Verilog-mode进行 AUTOINST 只会自动查找当前目录，这时候就会遇到问题了。那我们就来讲一讲verilog-mode是如何查找的吧。首先如果您在单文件中定义了多个模块，则会优先选择当前文件中的模块，然后在当前文件所在目录查找，如果定义了verilog-library-extensions，则继续查找附加扩展名的文件中查找模块，最后，它在verilog-library-directories中定义的每个目录中查找。 因此，如果您有一个顶层模块需要实例化其他目录的子模块，则需要告诉Verilog-Mode在哪些目录中查找，最好的方法是在每个需要它们的Verilog文件的末尾定义库变量：\n1 2 3 4 5  // Local Variables: // verilog-library-directories:(\u0026#34;.\u0026#34; \u0026#34;subdir\u0026#34; \u0026#34;subdir2\u0026#34;) // verilog-library-files:(\u0026#34;/some/path/technology.v\u0026#34; \u0026#34;/some/path/tech2.v\u0026#34;) // verilog-library-extensions:(\u0026#34;.v\u0026#34; \u0026#34;.h\u0026#34;) // End:   define问题（如果AUTO相关内容不涉及define，可忽略） 使用AUTOINST或AUTOSENSE时，有些场景中信号会带有define，这时候需要verilog-mode将define信息读进来，才可以正确完成AUTO功能。使用如下：\n1 2 3 4  // Local Variables: // eval:(verilog-read-defines) // eval:(verilog-read-defines \u0026#34;group_standard_includes.v\u0026#34;) // End:   第一行是读取当前文件中的define，第二行是读取define文件。\ninclude file问题（如果AUTO相关内容不涉及include，可忽略） 出于速度原因，Verilog-Mode不会自动读取include文件。这意味着include文件中定义的常量将不被作为AUTOSENSE的常量。解决方法如下：\n1 2 3  // Local Variables: // eval:(verilog-read-includes) // End:   verilog-mode 的AUTO使用方法 上文也看到了，可以通过打开emacs，使用快捷键来完成AUTO和取消AUTO，除此之外还可以当做脚本来处理，使用方法如下：\n1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   由此可见，我们可以通过脚本进行批量处理代码文件，完成AUTO机制，并且可以通过将不同目录文件复制其软连接到同一目录，再通过脚本实现AUTO机制，这样解决了不同目录对 AUTOINST 的影响。\nemacs的配置（关于verilog-mode） 以下是我的关于verilog-mode的emacs配置内容，“;;”代表注释符号。(所有设置参数均已添加注释，查看其他参数可以在verilog-mode模式下快捷键C-h m，查看verilog-mode.el)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  ;;my verilog mode config (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.vp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.vp file with verilog-mode (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.svp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.svp file with verilog-mode (setq verilog-date-scientific-format t) ;;dates are written in scientific format (e.g. 1997/09/17) (setq-default indent-tabs-mode nil) ;;false tab indent mode (setq verilog-indent-level 4) ;;Indentation of Verilog statements with respect to containing block (setq verilog-indent-level-module 0) ;;Indentation of Module level Verilog statements (eg always, initial) (setq verilog-indent-level-declaration 0) ;;Indentation of declarations with respect to containing block (setq verilog-case-indent 4) ;;Indentation for case statements (setq verilog-cexp-indent 4) ;;Indentation of Verilog statements split across lines (setq verilog-indent-lists t) ;;Indentation of lists, look the under content. ;; \u0026#34;How to treat indenting items in a list. ;;If t (the default), indent as: ;;\talways @( posedge a or ;; reset ) begin ;; ;;If nil, treat as: ;;\talways @( posedge a or ;;\treset ) begin\u0026#34; (setq verilog-indent-level-behavioral 4) ;;Absolute indentation of first begin in a task or function block (setq verilog-indent-level-directive 4) ;;Indentation to add to each level of \\\\=`ifdef declarations (setq verilog-auto-indent-on-newline t) ;;Non-nil means automatically indent line after newline (setq verilog-tab-always-indent t) ;;Non-nil means TAB should always re-indent the current line. ;;A nil value means TAB will only reindent when at the beginning of the line. (setq verilog-indent-begin-after-if t) ;;Non-nil means indent begin statements following if, else, while, etc. Otherwise, line them up. (setq verilog-auto-newline t) ;;Non-nil means automatically newline after semicolons and the punctuation mark after an end (setq verilog-auto-endcomments t) ;;Non-nil means a comment /* ... */ is set after the ends which ends cases, tasks, functions and modules. The type and name of the object will be set between the braces. (setq verilog-auto-reset-widths t) ;;True means AUTORESET should determine the width of signals (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;) ;;Text used for delays in delayed assignments. Add a trailing space if set (setq verilog-auto-lineup \u0026#39;all) ;; ;; \u0026#34;Type of statements to lineup across multiple lines. ;;If `all\u0026#39; is selected, then all line ups described below are done. ;; ;;If `declarations\u0026#39;, then just declarations are lined up with any ;;preceding declarations, taking into account widths and the like, ;;so or example the code: ;;\treg [31:0] a; ;;\treg b; ;;would become ;;\treg [31:0] a; ;;\treg b; ;; ;;If `assignment\u0026#39;, then assignments are lined up with any preceding ;;assignments, so for example the code ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f; ;;would become ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f;   有些参数目前我也不清楚具体用法和含义，如有其他好用的配置参数，欢迎推荐给我。\n忘了C-c C-a怎么办 有时候我们会忘记 C-c C-a ，显然这样会导致代码错误，如果是全部未实现AUTO还好，很容易及时发现，但是如果是在修改代码，并且仅仅是很小的改动，在功能仿真时不能及时发现，那就成了隐藏的bug，后果还是很严重的。比如组合逻辑always块的 AUTORESET ，功能仿真时并不容易被发现。 所以为了防止忘记 C-c C-a ，这里提供两种方案：\n 将verilog-auto与保存文件的 C-x C-s 绑定（注意，只有使用 C-x C-s 才有效，功能栏点击保存不会实现AUTO），请将以下代码添加到.emacs或.emacs.d/init.el（只在verilog-mode下有效，不会影响其他模式）   1 2 3 4 5 6 7  (add-hook \u0026#39;verilog-mode-hook \u0026#39;(lambda () (local-set-key (kbd \u0026#34;C-x C-s\u0026#34;) \u0026#39;(lambda () (interactive) (verilog-auto) (save-buffer)))))    使用脚本处理，将自己的源文件通过脚本处理后生成新的文件，比如我将原始文件命名为 *.vp 或 *.svp，最终处理后的文件为 *.v 或 *.sv，这样可以避免忘记完成verilog-auto。以脚本的形式进行处理还有一个好处，那就是对vim以及其他编辑器使用者比较友好，因为并非所有开发者都使用emacs。脚本处理命令如下：   1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   快捷键插入内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  C-c C-t a Insert an always @(AS) begin .. end block. C-c C-t b Insert a begin .. end block. C-c C-t c Insert a case block, prompting for details. C-c C-t f Insert a for (...) begin .. end block, prompting for details. C-c C-t g Insert a generate .. endgenerate block. C-c C-t h Insert a header block at the top of file. C-c C-t i Insert an initial begin .. end block. C-c C-t j Insert a fork begin .. end .. join block. C-c C-t m Insert a module .. (/*AUTOARG*/);.. endmodule block. C-c C-t o Insert an OVM Class block. C-c C-t u Insert an UVM Object block. C-c C-t U Insert an UVM Component block. C-c C-t p Insert a primitive .. (.. );.. endprimitive block. C-c C-t r Insert a repeat (..) begin .. end block. C-c C-t s Insert a specify .. endspecify block. C-c C-t t Insert a task .. begin .. end endtask block. C-c C-t w Insert a while (...) begin .. end block, prompting for details. C-c C-t x Insert a casex (...) item: begin.. end endcase block, prompting for details. C-c C-t z Insert a casez (...) item: begin.. end endcase block, prompting for details. C-c C-t ? Insert an if (..) begin .. end block. C-c C-t : Insert an else if (..) begin .. end block. C-c C-t / Insert a comment block. C-c C-t A Insert an assign .. = ..; statement. C-c C-t F Insert a function .. begin .. end endfunction block. C-c C-t I Insert an input declaration, prompting for details. C-c C-t O Insert an output declaration, prompting for details. C-c C-t S Insert a state machine definition, prompting for details. C-c C-t = Insert an inout declaration, prompting for details. C-c C-t W Insert a wire declaration, prompting for details. C-c C-t R Insert a register declaration, prompting for details. C-c C-t D Define signal under point as a register at the top of the modul   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":75,"section":"docs","tags":["emacs","verilog"],"title":"Emacs verilog-mode 的使用","uri":"https://www.wenhui.space/docs/02-emacs/verilog_mode_useguide/"},{"content":"本文 主要记录了emacs使用过程中的小技巧。\n   版本 说明     0.1 初版发布   0.2 添加参考链接    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs Wiki 子龙山人的emacs学习记录  帮助文档 关于阅读文档，有一些有用的命令，其中最有用的有以下几个命令:\n C-h C-h (用于显示帮助的帮助) C-h k（用于显示按键的说明） C-h f （用于显示函数的说明） C-h v (用于显示变量的说明) C-h r (在Emacs内阅读Emacs manual).  快捷键 快速放大字体  C-x C-=：放大 C-x C\u0026ndash;：缩小  文本编辑相关 Emacs 中的批量查找与替换 Emacs 有很强大的批量查找与替换功能。操作如下：\n 切换到源码项目目录，然后 M-x find-dired ，输入 . ，表示查找当前目录下的所有文件，回车，在输入 -name \u0026ldquo;.el\u0026rdquo;* ，表示只查找.el文件。再次回车后，Emacs 会打开一个缓冲区显示出项目中所有的.el后缀的文件 在显示所有查找文件的缓存页面，可以直接按t来标记所有文件，或者按m来一个一个的进行标记，如果标记错误了，可以按u来取消标记 标记完所有要进行查找替换的文件之后按Q快捷键，使用正则表达式来查找与替换被标记文件中的内容，第一次需要输入的是被查找项，回车之后在输入替换项，之后在回车，Emacs 会逐个打开被标记的文件，然后用高亮显示被正则搜索到的要替换的语句，逐个的问你是否要进行替换 显示的高亮替换项，你可以按y来确认替换，也可以按n取消替换，或者按!强制不提示而进行所有替换 替换完成后 C-x s 保存所有修改项，会逐个询问是否保存，yes代表保存，no代表不保存，！代表强制保存所有  Emacs 的查找与替换功能看似比其他软件繁琐与麻烦许多，实际上这是非常稳健的操作方式，查找与替换的过程非常透明化，你可以详细的看到要被替换的项，仔细谨慎的进行确认替换，之间也有非常多的机会来中断查找替换过程，来恢复文件中被错误替换的内容。\n录制键盘操作的宏 要录制macro， 先按下 F3， 然后进行你想要被录制的那些操作，再按下 F4 停止录制. 然后就可以通过不断的的按下 F4 来重复这些操作。\n使用f3调用emacs counter，同时搭配emacs counter的设置命令，可以在宏操作中插入自增数字：\n f3开启录制宏操作后，当再次按下f3键时，开启emacs counter，默认起始为0，按f4后结束宏录制，再次按f4执行宏操作，插入的数字会递增。 emacs counter的设置命令：C-x C-k C-i （kmacro-insert-counter）插入数字 emacs counter的设置命令：C-x C-k C-c’ (kmacro-set-counter） 设置起始值  Ediff 用Ediff来比较一个文件的两个版本很方便。 我经常使用的一个命令是 M-x ediff-buffers。 Emacs会高亮buffer间不同的地方并弹出一个新窗口供你输入命令。 例如，在新窗口中，按下n和p可以两buffer不同内容的region之间跳转。 对于每个region，你可以用a(或b)拷贝第一个(或第二个)buffer的内容到另一个buffer。 你甚至可以在激活Ediff的情况下编辑buffer。 然后再却换到Ediff窗口然后按下!来重新比对不同之处。在编辑文件的同时能够交互式地比对两个文件的不同之处，对于编辑文件那是相当有帮助。\nmark ring 你再也不同在buffer中到处找”刚才的那个位置”了。 每次你跳转了光标(e。g。 进行了文本搜索或者按下了 M-\u0026lt; 或 M-\u0026gt;)， Emacs使用mark标记下你的前一个位置。 这就好像你在看书时用手指插入某一页然后将书翻到另一页一样。 你按下 C-x C-x 就会跳转到那个mark处。 不仅如此，Emacs会保存多达16个mark，你使用 C-u C-SPC 跳转到更早些时候的mark处。 这就使得mark和mark ring成为一个很好用的导航工具了。 你完全可以不假思索的使用它: 当你想跳回上之前的位置时，不断按下 C-u C-SPC 直到你回到想要的位置为止。\n(你也可以显式的用 C-SPC 设置mark， 但是我几乎不需要通过这种方式来设置导航的坐标，只是在标示region时才会这样做。)\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":76,"section":"docs","tags":["emacs"],"title":"emacs的使用技巧记录","uri":"https://www.wenhui.space/docs/02-emacs/emacs_use_tips/"},{"content":"本文 主要介绍了为firefox安装插件的小技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  安装插件  打开firefox浏览器 打开菜单栏（右侧三杠图标），选择附加组件，打开附加组件管理器（也可以使用快捷键Ctrl-Shift-A） 附加组件管理器可以搜索、添加和删除插件  解决安装插件时浏览器无反应问题 有时候进入插件页面，点击 添加到Firefox 之后无反应，具体原因不知道，不过经过尝试，可以右键选择 在新建窗口打开链接 ，问题解决。\n推荐几个我使用的插件  侧边翻译：可以将选中的内容快速翻译，也可以选择有道或谷歌翻译整页（谷歌翻译好像不太行，不知道原因） 网页截图 Bitwarden（免费密码管理器，妈妈再也不用担心我忘记密码了） OneTab（以列表形式显示标签页，解决功能栏标签繁杂的问题）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":77,"section":"docs","tags":["firefox"],"title":"为firefox安装插件","uri":"https://www.wenhui.space/docs/01-software-install/install_plugins_for_firefox/"},{"content":"本文 主要介绍一款开源密码管理工具 Bitwarden 。\n   版本 说明     0.1 初版发布   0.2 更正 验证器秘钥（TOTP） 的理解    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  什么是Bitwarden？ Bitwarden是一款开源的密码管理器，所谓密码管理器，就是将所有密码交由工具管理，我们只需要记住主密码就行，生成密码、记忆密码和填写密码都由工具来自动完成。类似于此功能的还有PassWord、KeePass 、Lastpass等等，不过他们都是付费的，而Bitwarden是开源免费的。关于Bitwarden的详细信息可查看Bitwarden官网。\n这里简单列出个人认为Bitwarden的优点：\n 这是一款免费、开源的密码管理软件 支持 Windows、Mac、Linux 操作系统 通过插件可支持主流的浏览器，如google和firefox 提供苹果、安卓的原生应用 支持浏览器自动填写以及二次验证 可以使用官方的免费服务，也可以自建服务器  关于安全性 就安全性而言，这些密码管理工具采用的是高强度 AES-256 加密算法，想要破解几乎是不可能的事。也有人会担心把密码放在别人的服务器上不安全？个人认为是安全的，它们的加密方法，是把帐号和主密码通过算法得到一个值，然后用这个值去加密用户的各个密码，最后储存在服务器上。而加密解密都需要在本地进行，也就是说，黑客即使攻破了服务器，但无法破解密码数据库，除了把你的密码数据库删除外，其他什么也做不了。\n不过还有一句话，互联网没有绝对的安全，所以我一般把各个密码分级。\n 三级： 一般社交平台账户密码和其他应用账户密码 二级： 邮箱以及其他带有注册性的账户密码 一级： 带有支付性的账户密码 特级： 支付密码  三级交由密码工具管理，二级和一级由密码工具加个人前缀码组合，特级只放在脑子里。\n安装Bitwarden Bitwarden可以网页访问，可以安装浏览器插件，也可以下载应用程序。下载应用程序和网页登录可以选择进入Bitwarden官网，安装浏览器插件这里以firefox为例，参考我另一篇帖子 为firefox安装插件。\n如何使用Bitwarden?  打开firefox浏览器，点击插件Bitwarden，注册登录，注意， 一定要记住主密码，一定要记住主密码，一定要记住主密码 添加项目，项目内容有名称、用户名、密码、验证器密钥、网址、文件夹、笔记等等，其中网址会根据当前打开网页自动添加，密码可以选择工具生成也可以自动输入，验证器密钥TOTP（与二次验证相关，不开启二次验证可忽略），文件夹可以根据个人需求创建和选择，笔记以及其他根据个人需求填写，也可不写。 打开网页，Bitwarden插件会自动识别，打开Bitwarden，可以选择自动填充也可以手动复制  什么是 验证器秘钥（TOTP） 验证器秘钥与二次验证相关，二次验证就像除了密码之外还需要短信验证码一样，这里的两步验证也是相当于给帐号多加一把“锁”(多一步的验证)，在输入正确的账号密码之后，用户同样还需要额外输入一个每 30 秒自动变化一次的 6 位数字「二步验证码」才能完成登录。这里的验证器秘钥通过基于时间和加密算法生成“每 30 秒变化一次的 6 位数字验证码”，也叫做 TOTP (Time-Based One-time Password) 或 OTP 一次性密码。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":78,"section":"docs","tags":["firefox"],"title":"Bitwarden的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_bitwarden/"},{"content":"本文 主要对日常linux系统使用使用的命令进行记录，方便后续自己查找以及分享给需要的朋友。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  查看系统信息  查看系统版本： “cat /etc/issue” 查看内核版本（具体可以查看etc目录下关于系统和内核的文件内容）：  RedHat内核： “cat /etc/redhat-release” Debian内核： “cat /etc/debian_version”    查看命令是否存在  which perl alias print_declare  head和tail  读取前10行： head -n 10 file 读取后10行： tail -n 10 file 读取前200字符： head -c 200 file 读取前200x512字符： head -c 200b file（200k=200x1024） 读取动态文件末尾，适合动态输出的log文件：tail -f file.log 读取中间内容，如读取101行到150行内容： cat file | head -n 150 | tail -n 50  批量重命名rename  替换单个字符（小写变大写）： rename \u0026lsquo;y/a-z/A-Z/\u0026rsquo; * （替换表达式中y代表替换字符一一对应，即a替换为A，b替换为B\u0026hellip; 最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件） 替换特定字符串： rename \u0026lsquo;s/abc/123/\u0026rsquo; * （替换表达式中s代表特定字符串替换，即abc替换为123，最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件）  常用命令之grep grep命令功能是搜索文本中包含的字符串，常用方法如下：\n grep “字符串” * 搜索当前目录下的所有文件，也可以使用 *.v 只搜索带.v后缀的文件（不包含子目录下的文件） grep -r “字符串” * -r或-R可以递归搜索，也就是搜索包含子目录以及子子目录等中的所有文件 grep -i “字符串” * 忽略字符串中的大小写 grep -n \u0026ldquo;字符串\u0026rdquo; * 列出字符串所在文件的行号 grep实际使用中，由于某些特殊字符带有特殊含义，而在使用其本意时，需要结合转义字符\\，比如字符串“**“，就需要加转义”\\*\\*“，不然会匹配成任意。  终极使用：我会将此命令定义别名为gg（将下面代码赋值到.bashrc即可），这样终端命令行使用gg来达到“搜索当前目录以及子目录下所有文件，显示行号，搜索字符高亮显示”功能，这对熟悉他人文档环境时很有用，能够快速定位到自己想要搜索的内容，更快的熟悉文档环境。\n1  alias gg=\u0026#39;grep --color=auto -rn\u0026#39;   常用命令之find find是查找文件的命令，常用就是查找文件名为xx的文件，使用方法如下，这里就是在（.）当前目录及其子目录下查找带.c后缀的文件：\n1  find . -name \u0026#34;*.c\u0026#34;   也可以搭配管道命令（可以理解为同时执行），如下命令指在 find . 结果中使用 grep搜索特定字符串：\n1  find . | grep \u0026#34;文件名\u0026#34;   还可以使用参数-maxdepth来指定层级深度，我的终极使用，我会将此命令定义别名为ff（将下面代码赋值到.bashrc即可），这样终端命令行使用ff来达到“查找当前目录并设定搜索深度，比如1代表仅当前目录，带特定字符串的文件名”，使用方法如：ff 3 \u0026ldquo;*.c\u0026rdquo;\n1  alias ff=\u0026#39;ff() { find . -maxdepth $1 -name $2;}; ff\u0026#39;   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":79,"section":"docs","tags":["Linux"],"title":"Linux使用命令记录","uri":"https://www.wenhui.space/docs/06-linux-skills/usual-skills/linux_use_notes/"},{"content":"本文 主要介绍如何使用org-mode和ox-hugo写博客。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58 emacs版本：Linux GNU Emacs 26.3  参考  ox-hugo的使用手册 Org to Markdown for Hugo 使用emacs中的包管理器安装插件 Blogging with org-mode and ox-hugo  声明 当你看到此帖子，我必须要声明一下，如果你是非emacs用户，并不强烈推荐你使用emacs org-mode来写博客，除非你有足够的兴趣了解和学习emacs。\n什么是org-mode？什么是ox-hugo？  org-mode是文本编辑软件Emacs的一种支持内容分级显示的编辑模式，是一个基于快速高效的文本方式来实现做笔记、管理待办事项（TODO list）以及做项目计划的模式。本人使用感受最好的就是大纲显示模式。 ox-hugo是emacs的一个插件，可以将org格式文件转换为hugo识别的markdown格式文件。  安装emacs和安装ox-hugo插件 安装emacs就不介绍了，可参考我的另一篇帖子 emacs的安装。\n这里主要介绍一下如何安装ox-hugo插件。给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   emacs的基础使用 emacs的使用可以简单了解一下emacs启动页面的使用手册，简单了解就可以上手了。这里把最基础的使用粘贴出来。\nEmacs的快捷键都是绑定在ctrl和alt上的，例如C-x就是ctrl+x，M-x就是alt+x。\n 文件操作  C-x C-f 打开文件 C-x C-s 保存文件 C-x C-c 退出Emacs   编辑操作  C-f 前进一个字符（方向键也可以） C-b 后退一个字符（方向键也可以） C-a 移到行首 C-e 移到行尾 C-p 后退一行（方向键也可以） C-n 前进一行（方向键也可以） M-g M-g 跳到指定行 M-\u0026lt; 文档头部（配合Shift键） M-\u0026gt; 文档尾部（配合Shift键） C-d 删除一个字符（delete键也可以） C-k 删除一行 C-Shift-空格 标记开始区域 C-w 删除标记区域 C-y 粘贴删除的内容，注意：C-y可以粘贴连续C-k删除的内容；先按C-y，然后按M-y可以选择粘贴被删除的内容 M-w 复制标记区域 C-/ or C-x u 撤消操作   窗口操作  C-x 0 关闭本窗口 C-x 1 只留下一个窗口 C-x 2 垂直均分窗口 C-x 3 水平均分窗口 C-x o 切换到别的窗口 C-x s 保存所有窗口的缓冲 C-x b 选择当前窗口的缓冲区   缓冲区列表操作  C-x C-b 打开缓冲区列表 C-x k 关闭缓冲区   搜索模式  C-s 向前搜索 C-s 查找下一个 ENTER 停止搜索 C-r 反向搜索 C-s C-w 以光标所在位置的字为关键字搜索 M-% (配合Shift键) 替换， 输入y表示同意此处替换，否则输入n，全部替换使用！   帮助  C-h t 入门指南 C-h ? 查看帮助列表    org-mode和ox-hugo写博客 ox-hugo 支持两种方式来管理 org 格式的博客文章，一种是多个文章放在同一个 org 文件里，另一种是对不同的文章使用独立的 org 文件。本人喜欢第一种方式，我会将同一类的博客文章放在同一个org文件来管理。如下：\n  emacs org mode    文件头部说明  HUGO_BASE_DIR：这里是博客的根目录，因为我的org文件放在博客根目录下的 orgposts ，所以这里博客的根目录就是 “../” ，也就是本目录的上一层目录 HUGO_SECTION：生成的markdown文件的位置，比如 “./post/create_blog_site/” 就会将markdown文件生成在博客根目录下的 “content/post/create_blog_site/” hugo_auto_set_lastmod：最后修改的时间，也就是org转markdown时的时间，t的话会自动生成，也可以选择f，这个时间在jane主题也就是文章末的最后更新时间 hugo_custom_front_matter：这里是markdown文件头部参数的设置，比如toc，是否开启目录，不开启的话浏览时无目录显示，为了阅读方便建议开启 hugo_categories：分类名称，我是将同一类博客放在了一个org文件，这里就是分类名，然后每个subtree就是一个博客，会生成一个markdown文件 author:nil：这里是作者名称，在hugo的配置文件中已经配置了作者名称，这里将作者名称的控制关掉   1 2 3 4 5 6 7  #+HUGO_BASE_DIR: ../ #+HUGO_SECTION: ./post/create_blog_site/ #+hugo_auto_set_lastmod: t #+hugo_custom_front_matter: :toc true #+hugo_categories: 搭建博客站点 #+OPTIONS: author:nil   subtree 下面是一个subtree的内容(为了防止转义，前面都加了#号，实际中无#号)，下面一行一行介绍：\n 第一行是一级标题，这里也就是一个subtree，也是文章标题，后面冒号间的文字是标签，对应markdown文件中的tag，注意，冒号需要为英文符号，也可以使用 C-c C-c 快捷键输入tag；标题前的 DONE 表示完成状态，除此之外还有 TODO 状态，对应markdown文件中的 draft ， TODO 状态时，会认为是草稿，不会发布到站点，还要注意的是，状态不是手动敲上去的，而是光标放在标题行，通过Shift和左右键切换 第二行是文章创建的时间，对应markdown文件的date 第三四五行，EXPORT_FILE_NAME是输出markdown文件的名称，这里是subtree的属性描述，可使用参数应该还有很多，不过暂时没了解 最后就是博客内容了，二级标题和三级标题   1 2 3 4 5 6 7  #* DONE title_level1 :hugo:emacs: # CLOSED: \u0026lt;2019-09-13 五 14:22\u0026gt; # :PROPERTIES: # :EXPORT_FILE_NAME: Thinkpad_S2 # :END: #** title_level2 #*** title_level3   特殊需求  外链：可以使用 C-c C-l (这里是小写L)快捷键，输入链接和链接说明 图片：官方提供的方式如下(这里为了防止转义使用的小括号，实际为英文大括号)：   1  ((\u0026lt;figure src=\u0026#34;/image/cook/image0.jpg\u0026#34; title=\u0026#34;图片\u0026#34; \u0026gt;))   由于我还是希望对图片显示大小和位置能够控制，也许有其他方法还不知道，不过在这里写一个html格式的图片引用，能够实现我想要的效果，方式如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:black;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;    subtree中设置分类，如下，@后是分类，:后是标签（为了防止转义，添加了#号，实际中无#号）   1  # :@笔记:昨天:今天:明天:    脚注：在需要插入脚注的地方写下 “【fn:1】” ，在文章末尾添加脚注的说明 “【fn:1】 脚注说明” ，这里为了防止转义使用了中文符号，实际中记得使用英文符号  org文件转为markdown文件  将所有subtree都转为对应的Hugo markdown文件，快捷键 C-c C-e H A ，其中 C-c C-e 是导出快捷键，可选的有很多，比如h代表html，l代表laTex等，H代表Hugo，后面的A代表All（快捷键操作过程中会有提示，详细信息可以看提示信息） 将某subtree转为对应的Hugo markdown文件，首先光标移至对应的subtree，再通过快捷键 C-c C-e H H ，其中 C-c C-e 是导出快捷键，H代表Hugo，后面的H代表subtree（快捷键操作过程中会有提示，详细信息可以看提示信息） 其他说明：content不存在对应的目录也没关系，ox-hugo会自动创建  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":80,"section":"docs","tags":["hugo","emacs"],"title":"使用org-mode和ox-hugo写博客","uri":"https://www.wenhui.space/docs/04-build-blog-site/org_mode_and_ox_hugo/"},{"content":"本文 主要介绍如何为自己的博客自定义域名。\n   版本 说明     0.1 初版发布   0.2 解决push后自定义域名失效问题    背景  需要购买域名，我使用的是阿里云  参考  GitHub Pages 绑定来自阿里云的域名 个人独立博客如何与阿里云域名绑定  准备域名 购买域名 点击进入阿里云域名注册页面，选择自己喜欢的域名，点击查询，看一下是否被注册以及售价，我使用的是 wenhui.space ，售价十年179元，还可以。当然购买之前要先登录账户，这里使用支付宝登录即可，登录后需要实名认证，可以选择支付宝快速完成实名认证。选择心仪的域名，进行购买。\n完成域名持有者认证 需要上传个人身份证正面照片，提交认证，一般当天可以认证完成。\n域名解析 找到github page的IP地址 需要ping一下自己的github page网址，如下图，红色部分就是IP地址。\n  ping github IP    配置阿里云域名解析 登录你的阿里云账号,进入管理控制台,在左侧菜单找到 域名与网站(万网), 然后进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。输入如下图内容：\n  ping github IP    说明：  记录类型  A记录： 将域名指向一个IPv4地址（例如：8.8.8.8） CNAME：将域名指向另一个域名（例如www.qcloud.com）   主机记录  www： 解析后的域名为www.qcloud.com。 @： 直接解析主域名 qcloud.com。    配置github pages的custom domain 进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：\n     设置到这里,你就可以 通过你的域名访问你的博客啦!(可以适当等几分钟再使用新的网址访问自己的博客) 解决push后自定义域名失效问题 自定义域名失效是因为仓库中没有CNAME文件，该文件是指向你自定义域名的文件。\n 创建CNAME文件，打开终端，进入博客根目录，输入以下命令（替换为你自己的域名）：   1  echo www.wenhui.space \u0026gt;CNAME    修改issue.sh脚本，使其在每次上传public文件时，不会破坏CNAME，issue.sh如下：   1 2 3 4 5 6 7 8 9 10 11 12  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ cp ./CNAME ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":81,"section":"docs","tags":["hugo"],"title":"给自己的博客自定义域名","uri":"https://www.wenhui.space/docs/04-build-blog-site/modify_url_for_blog/"},{"content":"本文 主要介绍了一个hugo博客内容的使用技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  插入图片 1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:black;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   这里显示的是插入本地图片，图片位置放在博客站点根目录下的static文件内，上文所示路径对应文件存放路径为 “my_blog/static/image/me.jpg” ，这里可以对图片大小，显示位置，图片标题进行设置。也可以将相对路径改为网址全路径，也就是引用网上图片，这时候需要图床工具，PicGo是一个不错的选择，可参考我的另一篇帖子PicGo的安装。\n注意：static目录下的所有文件名不要使用下划线，否则会导致图片索引错误，可以使用 \u0026ldquo;-\u0026rdquo; 连字符。\n其他 我相信还有其他使用技巧，待后续补充，如果你有好的用法，欢迎推荐。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":82,"section":"docs","tags":["hugo"],"title":"hugo博客内容的使用技巧","uri":"https://www.wenhui.space/docs/04-build-blog-site/hugo_content_tips/"},{"content":"本文 主要介绍了如何将hugo创建的博客站点部署到github。\n   版本 说明     0.1 初版发布   0.2 修改issue.sh脚本    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  git的安装与介绍 请参考我的另一篇帖子git的安装。\n部署过程 在github创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    在这里要创建两个仓库，一个私有仓库，名字自定义，可以为“my\\_blog”，用来存放博客站点文件；另一个公共仓库，名字为 **username.github.io** ，记住，一定为 **username.github.io** (username替换为你的用户名），后面启用 **github page** 时会解释为什么如此命名。 克隆仓库 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。\n启用github page功能 GitHub Pages 是一个静态网站托管服务，简单说就是他可以实现创建个人网页。我们需要给名为 username.github.io 的仓库启用github page功能，需要以下几步：\n 首先空仓库是不能启用page功能的，你需要添加一个文件（无所谓什么文件，可以写个readme），通过以下git命令，上传到远程仓库。这里可能需要输入账户密码，可以使用 \u0026quot;git config \u0026ndash;global credential.helper store\u0026quot; ，避免重复输入账户密码。   1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push    打开github，进入名为 username.github.io 的仓库，然后点击 settings ，拉到最下面会看到 Github Pages ，此时关于github page是 None 状态，将其选择为 master branch （如果是私有仓库是无法开通的，所以创建时我们选择了公共仓库），如果有显示 “Your site is published at https://username.github.io/” ，就是启动了page功能，你可以使用此网址访问你的个人网页了，只不过目前什么内容都没有。这里对page的网址说明一下，如果仓库名为 username.github.io ，那网址就为 “https://username.github.io/” ，如果仓库名为其他，则网址中会带有仓库名，也就是 “https://username.github.io/reponame/” ，如果是这样，使用hugo时，本地相对路径索引的图片上传后通过网页是无法加载的，hugo生成的图片链接没有仓库名，这里是经过试错得到结论。  生成博客站点静态文件并上传到远程仓库  打开终端，进入博客站点根目录 my_blog ，使用 “hugo server” 命令预览博客，无问题的话输入 \u0026ldquo;hugo\u0026rdquo; 命令，生成博客站点静态文件 public ，我们将 public 内文件全部粘贴到 username.github.io 仓库，并上传到远程仓库，命令参考上文。 打开浏览器，输入开启github page时提示的网址，就看到你的个人博客网页了，到此部署成功。 我们也可以写一个脚本方便处理，我起名为 issue.sh ，如下：   1 2 3 4 5 6 7 8 9 10 11  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   维护自己的博客内容和环境 最初我们创建了两个仓库，目的就是一个开启page功能，将博客静态文件发布到网络，另一个就是维护博客内容和环境文件。\n 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。 将博客站点根目录my_blog中的所有文件复制到克隆的仓库文件（仓库名也可以为my_blog） 这里themes中的jane本身是一个git仓库，我们可以不用上传到远程仓库，生成的public是中间文件也不需要上传到远程仓库，所以添加一个 .gitignore 文件，git可以自动忽略 .gitignore 列出的文件，不上传到远程仓库。终端中进入博客站点根目录，输入如下命令即可：   1 2  echo themes \u0026gt;\u0026gt;.gitignore echo public \u0026gt;\u0026gt;.gitignore    将博客内容和环境文件上传之远程仓库，命令参考上文。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":83,"section":"docs","tags":["hugo"],"title":"将hugo博客部署到github","uri":"https://www.wenhui.space/docs/04-build-blog-site/hugo_deploy_to_github/"},{"content":"牛人博客  子龙山人：emacs大牛 骏的世界：CPU从业者 \u0026amp; IC验证 ManateeLazyCat：emacs elisp大牛 \u0026amp; Deepin and Emacs 开源贡献者 蜂窝科技-涉及Linux内核、ARMv8架构和Linux使用技巧等高质量文章  学习网站  在线EDA仿真网站 在线Verilog仿真网站 学习systemverilog和UVM的好网站 在线编程学习网站：实验楼 在线波形图绘制软件WaveDrom 全世界最大开源硬件IP核网站  其他网站  Linux内核下载 ARM编译器（linaro）下载网站 ARM文档下载网站  ","description":"","id":84,"section":"","tags":null,"title":"Links","uri":"https://www.wenhui.space/links/"},{"content":"本文 主要介绍了markdown基本语法。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  什么是markdown？ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。可能听起来有些抽象，简单来说就是纯文本编辑方式，依据特殊语法，经过工具渲染，可以达到很漂亮的显示效果，除此之外还能支持更多复杂功能，比如数学符号的显示等等。\nMarkdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此很多博客平台都支持markdown，比如简书和CSDN，对markdown都有很好的支持，有些网站的评论窗口也支持markdown。目前markdown因为简单易用的特点，已经被广泛使用。不过各平台对markdown的支持情况也不太统一，所以存在部分兼容问题，不过不用担心，常用语法还是一致的。\n语法介绍 标题 注意，中间有空格。\n1 2 3 4 5 6  # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题   字体  加粗：将要加粗的文字左右分别用**号包起来，如“**粗体**” （好像用下划线包起来也可以，如“__粗体__”） 斜体：将要倾斜的文字左右分别用*号包起来，如“*斜体*” （好像用下划线包起来也可以，如“_斜体_”） 斜体加粗：将要倾斜和加粗的文字左右分别用三个*号包起来，如“***粗斜体***” （好像用下划线包起来也可以，如“___粗斜体___”） 删除线：将要加删除线的文字左右分别用两个~~号包起来，如“删除线” 高亮：将要加高亮的文字左右分别用两个==号包起来，如“==高亮==”  分割线 三个或者三个以上的 - 或者 * 都可以。\n1  ---   图片 图片名称就是显示在图片下面的文字，相当于对图片内容的解释。图片标题就是当鼠标移到图片上时显示的内容。图片标题可加可不加。\n1  ![图片名称](图片网址 \u0026#39;\u0026#39;图片标题\u0026#39;\u0026#39;)   当然也可以使用html格式，这里添加了对图片的大小和显示位置做了控制，如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;图片地址\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:black;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   超链接 title可不加\n1 2  [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) [百度](http://baidu.com)   列表  无序列表(注意，符号与内容间有空格)   1 2  - 列表内容 + 列表内容    有序列表(注意，符号与内容间有空格)   1 2  1. 列表内容 2. 列表内容    列表嵌套   1 2 3 4  - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容   表格 第二行分割表头和内容，其中“-”有一个就行，也可以为了对齐多加几个；文字默认左对齐，“-”两边加“:”表示文字居中，\u0026quot;-\u0026ldquo;右边加“:”表示文字右对齐。注意，符号为英文符号。\n1 2 3 4  |表头|表头|表头| |---|:--:|---:| |内容|内容|内容| |内容|内容|内容|   代码  单行代码，代码之间分别用一个反引号包起来   1  `代码内容`    多行代码，代码之间分别用三个反引号包起来   1 2 3 4 5  ``` 代码... 代码... 代码... ```   段落、换行、缩进 Markdown语法中，两个段落之间是用空白行分隔的，如果作为两个段落，编辑时请在中间加空白行，不过中间加即时多个空白行却只显示一个空白行，如果想加多个空白行，就要借助html的换行命令，如下；如果想首行缩进，需要输入全角空格，不过不建议使用，markdown是用空白行来区分段落的，而不是缩进。\n1  \u0026lt;br\u0026gt;   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":85,"section":"docs","tags":["markdown"],"title":"markdown语法","uri":"https://www.wenhui.space/docs/04-build-blog-site/markdown/"},{"content":"本文 主要介绍了如何下载和使用hugo。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  hugo的介绍和安装 可查看本站另一篇帖子 hugo的安装。\n快速使用 根据自己的摸索，保存了一个基于jane主题的基本使用框架，开箱及用，只需要在content目录下写markdown文件即可。查看我的百度网盘分享资源 链接：https://pan.baidu.com/s/1l4RU%5FJx-2XKI-pflL-a7zA 密码：pf03 。基于此框架你也可以根据个人需求，简单调整。\n使用hugo生成站点 使用Hugo生成站点，比如希望生成到当前目录，文件名为my_blog。打开终端，命令如下：\n1  hugo new site ./my_blog   这样就在当前目录下生成了初始站点 my_blog ，进去目录查看，其文件结构如下：\n├─archetypes ├─content ├─data ├─layouts ├─static ├─themes └─config.toml 这里对站点的几个文件介绍一下：\n archetypes：原型文件，里面存在一个markdown文件的模板，使用 “hugo new xx.md” 命令时会依据该模板创建markdown文件，我一般不使用 “hugo new” 命令，而是直接手动创建markdown文件，所以不关心模板 content：内容文件，所有的帖子都以markdown文件形式存在这里，hugo会自动索引，一般功能栏的 “关于” “友链” 等页面，我会存在content一级目录，其他帖子内容在content内另建post目录，而且根据不同分类可以在post内新建目录存储，hugo会自动层级索引，也就是只要在content内的markdown文件，hugo都能找到 data：这个目前还真不知道做什么的，但不影响使用，可暂不关心（如果有熟悉的可以帮忙解释一下） layouts：个人理解这里存放的应该是关于网站布局以及其他关于网站页面显示的文件（html），不过我们一般都会安装主题，所以这个可以不关心 static：静态文件，一般js(javascript)和css文件会存放在这里，这些文件主要是与博客网页显示相关的，我没这个需求，主要是也不懂，在这里我主要存放的就是博客中用到的图片了 themes：主题文件，可以寻找自己喜欢的主题，存放在这里，简单配置即可使用 config.toml：全局配置文件，博客站点所有的配置，都在此文件完成，最比如设置使用的主题  安装主题 hugo生成站点后，还不能正常使用，需要安装自己喜欢的主题，也叫皮肤。到hugo主题列表选择一款自己喜欢的主题，下载到themes目录下，每个主题都会有一个readme文件，介绍主题的特性和指导你如何使用主题。这里以我使用的主题为例，hugo-theme-jane，此主题是由贤民大哥开发的，可以先浏览一下他的主页 贤民的比特记忆，看一下效果。\n下载jane主题  进入jane主题github网址，点击 [Clone or download] ，选择 [Download Zip] ，通过网页下载压缩包，解压后放到themes目录下 通过git下载，打开终端，进入themes目录，输入以下命令(这个网址就是github中 [Clone or download] 栏显示的网址)：   1  git clone https://github.com/xianmin/hugo-theme-jane.git    通过我的百度网盘分享资源下载， 链接：https://pan.baidu.com/s/1xQJXLyNcI0Jbymrr9uZRGQ 密码：rhaw  测试体验  存放主题文件和更名：将下载的jane主题文件放到站点的themes目录下，并将文件名hugo-theme-jane改为jane（因为exampleSite中config.toml文件对主题的选择是jane，当然你也可以修改config.toml） 复制一些示例文本：打开终端，进入站点根目录 my_blog ，输入以下命令(如果content有自己的文件，请先备份，此命令会覆盖content)   1  cp -rf themes/jane/exampleSite/content ./    复制默认的站点设置：打开终端，进入站点根目录 my_blog ，输入以下命令(如果config.toml有自己的内容，请先备份，此命令会覆盖config.toml)   1  cp -rf themes/jane/exampleSite/config.toml ./    启动 hugo server：打开终端，进入站点根目录 my_blog ，输入以下命令   1  hugo server    查看博客效果：打开 http://localhost:1313/ ，你将会看到一个示例网站，效果如下    jane主题效果    配置主题 根据自己的需求，我做了如下改动：\n 修改菜单栏为中文显示，配置文件的修改详见下文 我的配置 将外链菜单，改为页面显示，需在content目录创建 links.md 文件，文件内容就是外链页面显示内容，配置文件的修改详见下文 我的配置 （添加新菜单页面都可以使用此方式） 将about菜单页面添加到配置文件，统一管理，目的是将“about”改为中文“关于”，需要将原about.md文件的 \u0026ldquo;menu: \u0026ldquo;main\u0026rdquo; 删除（其实将title改为中文“关于”也可以实现），配置文件的修改详见下文 我的配置 调整了菜单的顺序，更改weight值即可，配置文件的修改详见下文 我的配置 删除doc菜单，个人觉得不需要此功能，删除方法是将doc菜单下的几个帖子对应的markdown文件打开，删除下面所示的代码设置（这也是一种加功能菜单的方法，需要时可以用起来）   1 2 3 4  menu: main: parent: \u0026#34;docs\u0026#34; weight: 3    删除社交链接，本人觉得不需要，所以将所有社交链接注释掉了，但还有一个RSS订阅图标，有点强迫症，还是想把它删掉，于是进入主题jane，找到 \u0026quot;./layouts/partials/social_links.html\u0026rdquo; ，将RSS图标显示相关代码注释掉了，如下   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!-- {{/* RSS icon */}} {{ with .Site.GetPage \u0026#34;home\u0026#34; -}} {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; rel=\u0026#34;noopener {{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; class=\u0026#34;iconfont\u0026#34; title=\u0026#34;rss\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; {{ partial \u0026#34;svg/rss.svg\u0026#34; }} \u0026lt;/a\u0026gt; {{ end -}} {{- end -}} --\u0026gt;    下面展示一下 我的配置 ，基本每一处都做了注释，并标注了需要改的地方：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177  # 基础设置 #------------------------------------------------------------------- baseURL = \u0026#34;https://wenhui.space\u0026#34; # 博客部署网址 ：部署到github时需要改 title = \u0026#34;Wenhui\u0026#39;s Rotten Pen\u0026#34; # 网址名称 ：改 enableRobotsTXT = true # 是否支持Robots协议，也就是机器人协议/爬虫协议，简单说可以通过搜索引擎搜索到你的主页（不确定） enableEmoji = true # 是否支持Emoji表情符号 theme = \u0026#34;jane\u0026#34; # 选用jane主题 hasCJKLanguage = true # 自动检测是否包含 中文\\日文\\韩文 paginate = 10 # 首页每页显示的文章数目 rssLimit = 20 # 限制 Rss 文章输出数量 disqusShortname = \u0026#34;\u0026#34; # disqus_shortname googleAnalytics = \u0026#34;\u0026#34; # 配置google统计，这里设置一个 google 的统计配置id,格式为UA-XXXXXXXX-X copyright = \u0026#34;\u0026#34; # 默认为下面配置的author.name， # 关于语言 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 默认博客语言环境，可选：en, zh-cn (选项由theme中i18n文件支持所决定) [languages.zh-cn] # 语言支持 en/zh-cn/other... 可查看theme中i18n文件 languageCode = \u0026#34;zh-cn\u0026#34; # 关于语法高亮，具体使用可查看https://gohugo.io/content-management/syntax-highlighting/ PygmentsCodeFences = true # Enable syntax highlighting with GitHub flavoured code fences PygmentsUseClasses = true # Use CSS classes to format highlighted code PygmentsCodefencesGuessSyntax = true # PygmentsOptions = \u0026#34;linenos=table\u0026#34; # 开启显示行号 [author] # 作者名称 ：改 name = \u0026#34;文辉\u0026#34; [sitemap] # 暂不清楚 changefreq = \u0026#34;weekly\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; #------------------------------------------------------------------- #菜单设置 #------------------------------------------------------------------- [[menu.main]] name = \u0026#34;主页\u0026#34; weight = 10 identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; [[menu.main]] name = \u0026#34;归档\u0026#34; weight = 20 identifier = \u0026#34;archives\u0026#34; url = \u0026#34;/post/\u0026#34; [[menu.main]] name = \u0026#34;分类\u0026#34; weight = 30 identifier = \u0026#34;categories\u0026#34; url = \u0026#34;/categories/\u0026#34; [[menu.main]] name = \u0026#34;标签\u0026#34; weight = 40 identifier = \u0026#34;tags\u0026#34; url = \u0026#34;/tags/\u0026#34; [[menu.main]] name = \u0026#34;关于\u0026#34; weight = 50 identifier = \u0026#34;about\u0026#34; url = \u0026#34;/about/\u0026#34; [[menu.main]] name = \u0026#34;友链\u0026#34; weight = 60 identifier = \u0026#34;links\u0026#34; url = \u0026#34;/links/\u0026#34; [[menu.main]] name = \u0026#34;订阅\u0026#34; weight = 70 identifier = \u0026#34;feed\u0026#34; url = \u0026#34;/index.xml\u0026#34; #------------------------------------------------------------------- #其他参数设置 #------------------------------------------------------------------- [params] since = \u0026#34;2019\u0026#34; # 站点建立时间 homeFullContent = false # 主页是否显示全部文章内容，否的话仅显示摘要，建议设为否 rssFullContent = true # if false, Rss feed instead of the summary logoTitle = \u0026#34;文辉的烂笔头\u0026#34; # 博客标题，默认值是上面设置的title，也就是网址名称 keywords = [\u0026#34;Hugo\u0026#34;, \u0026#34;linux\u0026#34;, \u0026#34;emacs\u0026#34;, \u0026#34;CPU\u0026#34;] # 关键字，应该是与搜索引擎搜索有关，博客内无展示 description = \u0026#34;\u0026#34; # 网页描述，应该是与搜索引擎搜索有关，博客内无展示 archive-paginate = 30 # 归档、标签、分类每页显示的文章数目，建议修改为一个较大的值 dateFormatToUse = \u0026#34;2006-01-02\u0026#34; # 日期显示格式，查看可支持的格式见https://gohugo.io/functions/format/ moreMeta = true # 是否显示字数统计与阅读时间 showMenuLanguageChooser = true # 显示语言选择开关 showAuthorInfo = true # 文章末尾显示作者信息 # 一些全局开关，这些是默认值，也可以在每一篇内容的 front matter 中对单篇内容关闭或开启某些功能，在 archetypes/default.md 查看更多信息。 toc = true # 是否开启目录 photoswipe = true # 是否启用PhotoSwipe（图片可点击） bootcdn = true # 是否使用bootcdn(@Deprecated: 请使用[params.publicCDN])（好像可以加快网页访问速度） mathjax = false # 是否使用mathjax（数学公式） contentCopyright = \u0026#39;文辉原创文章，如需转载请注明出处，谢谢！！！\u0026#39; # 改 customCSS = [] # if [\u0026#39;custom.css\u0026#39;], load \u0026#39;/static/css/custom.css\u0026#39; file customJS = [] # if [\u0026#39;custom.js\u0026#39;], load \u0026#39;/static/js/custom.js\u0026#39; file #------------------------------------------------------------------- # CDN设置，据说是提高访问速度的，具体也没感受到 #------------------------------------------------------------------- [params.publicCDN] # load these files from public cdn，若启用公共CDN，需自行定义 enable = true jquery = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js\u0026#34; integrity=\u0026#34;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; slideout = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js\u0026#34; integrity=\u0026#34;sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentJS = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipe = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js\u0026#34; integrity=\u0026#34;sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeUI = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js\u0026#34; integrity=\u0026#34;sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css\u0026#34; integrity=\u0026#34;sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipeSKIN = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css\u0026#34; integrity=\u0026#34;sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; #------------------------------------------------------------------- # 下面是关于评论系统，更新显示commit内容，谷歌搜索，文章打赏，访问数据统计等等，个人觉得不需要，全部false掉了 #------------------------------------------------------------------- [params.utteranc] # utteranc is a comment system based on GitHub issues. see https://utteranc.es enable = false repo = \u0026#34;xianmin/comments-for-hugo-theme-jane\u0026#34; # The repo to store comments issueTerm = \u0026#34;pathname\u0026#34; [params.gitment] # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments clientId = \u0026#34;\u0026#34; # Your client ID clientSecret = \u0026#34;\u0026#34; # Your client secret [params.livere] #LiveRe comment. see https://www.livere.com/ uid = \u0026#34;\u0026#34; [params.reward] # 文章打赏 enable = false wechat = \u0026#34;/path/to/your/wechat-qr-code.png\u0026#34; # 微信二维码 alipay = \u0026#34;/path/to/your/alipay-qr-code.png\u0026#34; # 支付宝二维码 [params.counter.busuanzi] # a Chinese visitor counter # 卜算子计数器 enable = false [params.counter.leancloud] # Chinese leancloud visitor counter # leancloud 计数器 enable = false appId = \u0026#34;\u0026#34; appKey = \u0026#34;\u0026#34; [params.commentCount.disqus] # show counts of comments for Disqus enable = false [params.search.google] # google custom search, see https://cse.google.com enable = false id = \u0026#34;002186711602136249422:q1gkomof_em\u0026#34; title = \u0026#34;Search\u0026#34; [params.gitInfo] gitRepo = \u0026#34;https://github.com/xianmin/xianmin.org\u0026#34; showCommitMessage = false #------------------------------------------------------------------- #社交链接，不需要可注释掉 #------------------------------------------------------------------- # [params.social] # a-email = \u0026#34;mailto:your@email.com\u0026#34; # b-stack-overflow = \u0026#34;http://localhost:1313\u0026#34; # c-twitter = \u0026#34;http://localhost:1313\u0026#34; # d-facebook = \u0026#34;http://localhost:1313\u0026#34; # e-linkedin = \u0026#34;http://localhost:1313\u0026#34; # f-google = \u0026#34;http://localhost:1313\u0026#34; # g-github = \u0026#34;http://localhost:1313\u0026#34; # h-weibo = \u0026#34;http://localhost:1313\u0026#34; # i-zhihu = \u0026#34;http://localhost:1313\u0026#34; # j-douban = \u0026#34;http://localhost:1313\u0026#34; # k-pocket = \u0026#34;http://localhost:1313\u0026#34; # l-tumblr = \u0026#34;http://localhost:1313\u0026#34; # m-instagram = \u0026#34;http://localhost:1313\u0026#34; # n-gitlab = \u0026#34;http://localhost:1313\u0026#34; # o-goodreads = \u0026#34;http://localhost:1313\u0026#34; # p-coding = \u0026#34;http://localhost:1313\u0026#34; # q-bilibili = \u0026#34;http://localhost:1313\u0026#34; # r-codeforces = \u0026#34;http://localhost:1313\u0026#34; # s-mastodon = \u0026#34;http://localhost:1313\u0026#34; #-------------------------------------------------------------------   到此，你可以启动 hugo server ，查看一下自己的博客了，若仍有不满意的，可以尝试继续修改。\n开始写帖子 hugo是对markdown支持的，若对markdown语法不了解，可参考另一篇帖子 markdown基本语法。这里只对hugo使用的markdown文件头部进行说明（其他参数可以查看hugo官方文档）:\n date ： 文件创建时间 draft ： 是否为草稿，草稿文件不会发布到站点 title ： 文件标题 tag ： 标签 categories ： 分类 toc ： 是否开启目录   1 2 3 4 5 6 7 8  +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; tags = [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] categories = [\u0026#34;分类1\u0026#34;] toc = true +++   可以开始书写你的博客内容了，顺便说一句，markdown的编辑器可使用typora。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":86,"section":"docs","tags":["hugo"],"title":"hugo的使用","uri":"https://www.wenhui.space/docs/04-build-blog-site/hugo_usage/"},{"content":"本文 主要介绍了如何为firefox手动安装flash player插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0 flash player版本：32.0  参考  firefox帮助：安装 Flash 插件 百度经验：deepin linux下firefox怎么升级flash player  安装过程 为什么安装Flash插件 由于deepin没有发现简单易用的图片处理软件，比如调整大小、拼图、裁剪等等，最佳选择就是使用美图秀秀网页版了，但是发现缺少可用的Flash插件，于是开始了安装过程。\n下载Flash插件  你可以到官网下载，请进入Adobe Flash Player下载页面，选择要下载的版本，我这里选择的是 .tar.gz 适用于 Linux 也可以选择我的百度网盘分享资源 链接：https://pan.baidu.com/s/18FLcCARtjnogcBB%5F950s-Q 密码：xbcu  解压安装 将下载的安装包解压，放到自己合适的位置，比如我的 “~/Treasury/tools_and_drives/flash_player/” ，“Treasure”的意思就是财富宝藏了，没错，我的所有“财富”都在这里。然后将下载的文件包中 libflashplayer.so 复制到firefox的插件目录 “/usr/lib/mozilla/plugins/” 。打开终端进入下载的文件包目录，输入如下命令(中途会提示输入用户密码)：\n1  sudo cp ./libflashplayer.so /usr/lib/mozilla/plugins/   如果没有firefox的插件目录，需要自己创建：\n1  sudo mkdir -p /usr/lib/mozilla/plugins/   查看 重启firefox，点击菜单打开 附加组件 或快捷键 Ctrl+Shift+A ，点击左侧的“插件”即可看到flash palyer的版本。\n  flash player版本为32.0    如果还没有的话，可以试试点击 齿轮图标 选择 从文件安装附加组件 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":87,"section":"docs","tags":["firefox"],"title":"为firefox安装flash player插件","uri":"https://www.wenhui.space/docs/01-software-install/install_flash_player_for_firefox/"},{"content":"本文 主要介绍emacs如何安装插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  安装过程 给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":88,"section":"docs","tags":["emacs"],"title":"emacs如何安装插件","uri":"https://www.wenhui.space/docs/02-emacs/emacs_package_install/"},{"content":"本文 主要介绍emacs的基本使用方法。\n   版本 说明     0.1 初版发布    获取教程的途径  子龙山人的《21天学会Emacs》电子书在线阅读 打开emacs，快捷键C-h t，获取emacs的快速指南  帮助的使用 使用emacs最重要的是学会查找帮助。 C-h 是使用帮助功能，下面描述常用的几种查找帮助：\n C-h ? Emacs会告诉你它提供了哪些帮助 C-h t 打开Emacs快速指南 C-h c 命令说明【C-h c后面加要查询的命令】 C-h k 查看某个快捷键对应的命令【C-h k后面加要查询的快捷键】 C-h w 查看某个命令对应的快捷键 (where-is) C-h m 查看某个mode的文档 C-h f 解释一个函数【需要输入函数名】 C-h i 阅读手册【也就是通常讲的 Info】 C-h r Emacs使用手册【也就是通常讲的 Manual】  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":89,"section":"docs","tags":["emacs"],"title":"emacs的基本使用","uri":"https://www.wenhui.space/docs/02-emacs/emacs_useguide/"},{"content":"本文 主要对正则表达式的常用语法进行整理和介绍。\n   版本 说明     0.1 初版发布   0.2 添加正则表达式在线测试网址    背景  Linux  什么是正则表达式？ 正则表达式（regular expression 简称regex），正则表达式是一种文本处理工具，用途就两种：一是进行搜索，二是进行搜索和替换。但是它比普通的搜索更强大，具体可以在如下场景中体现：\n 在某文本中搜索或搜索加替换单词car，但是并不将carry等包含car字符的单词作为目标 在某文本中搜索或搜索加替换单词car，但是只将行末位置作为目标 在某文本中搜索或搜索加替换begin****end，这里将begin和end以及中间任意字符作为目标  总之，正则表达式就是一个文本处理功能强大的工具，主要任务就是用正则表达式语言构造特定的目标来进行搜索和替换操作。但是它又不能算作一个独立的工具或语言，二是嵌入在其他语言和工具中，换句话说，其他大多数工具和语言都支持正则表达式。\n正则表达式知识点 任意字符“.”  “.”字符可以匹配任何单个字符、字母、数字以及“.”字符本身。 “.”字符可以在同一正则表达式在任意位置出现任意次数。 如果想搜索“.”字符本身，需要自“.”字符前加“\\”字符进行转义，即“\\.”。  字符集合[]  [ns]a\t匹配na和sa，将部分字符集合作为目标 [Rr]eg\t匹配Reg和reg，特定位置区分大小写和不区分大小写 [0-9]\t匹配任意数字，这里“-”为连字符（仅限于字符集合[]内，字符集合外为普通字符-），常用为0-9，A-Z，a-z [A-Za-z0-9]\t匹配任意大小写字母和数字，字符集合中可以出现多个区间 [^0-9]\t匹配非数字任意字符，取非字符“^”，主要取非的含义是对整个字符集合，而不是^后紧跟的那个集合  使用元字符  特殊字符需要转义，如\\\\匹配\\，\\.匹配.，\\[匹配[ 匹配空白字符，\\f换页符，\\n换行符，\\r回车符，\\t制表符（如匹配空白行，linux下将换行符作为文本结束标志，而windows将回车符换行符作为文本结束标志，所以linux匹配空白行即\\n\\n，windows下陪陪空白行即\\r\\t\\r\\t） 匹配某类字符，\\d匹配任何数字字符，\\D匹配任意非数字字符，\\w匹配任意字母数字下划线字符（不区分大小写），\\W匹配任意非字母数字下划线 匹配空白字符，\\s匹配任意空白字符（等同于[\\f\\n\\r\\t\\v]），\\S匹配任意空白字符（等同于[^\\f\\n\\r\\t\\v]）  重复匹配  [0-9]或\\d代表任意一个数字，[0-9]+或\\d+代表任意一个或多个连续数字 +和*和？的使用区别，+代表重复出现一次或多次，*代表重复出现0次或多次，？代表重复出现0次或1次。举例：https+匹配https和httpss…，https*匹配http和https和httpss…，https？匹配http和https。 设定重复次数，a{5}匹配aaaaa，重复5次；a{3,5}匹配aaa和aaaa和aaaaa，重复3-5次；a{3,}匹配a重复最少3次 防止过度匹配：+，*，{3,}这样的无限重复都属于贪婪型，容易造成过度匹配，举例如下，AxxxB 555 AmmmmB，正则表达式为A.*B，本意是将AxxxB和AmmmmB匹配，实际匹配为AxxxB 555 AmmmmB，显然不是我们希望的结果，在贪婪型元字符+和*和{3,}后加?可以将贪婪型转为懒惰型，如A.*?B，匹配结果为AxxxB和AmmmmB。  位置匹配  单词边界符\\b：例如匹配car，可能将carry也作为了目标，这时候需要使用单词边界，\\bcar\\b。这里对\\b的匹配说明一下，他并不知道什么是单词边界，只是找到构成单词的字符（字母数字下划线\\w）和一个不能构成单词的字符（\\W）之间位置。 字符串的边界：开头^，结尾$，比如^.*$，在语法上完全正确，而且总能匹配到一个结果，但是却无任何用途。这里字符串边界符要搭配分行匹配模式(?m)来使用的，举例说明：匹配verilog代码中的注释行内容：(?m)^\\s*//.*$，解释：(?m)分行匹配模式，将一行内容作为一个字符串处理；^字符串开头；\\s*任意一个或多个空白符，如空格、制表符、换行符等等；//为verilog中的注释符；.*为任意字符重复0次或多次，其实这里代表注释内容；$代表字符串结尾。 总之，比较难理解的是字符串边界的使用，这里对常用的几个举例：  ^\\s*：代表文本开头的有效内容处（这里有效内容是排除空行、空格、tab等） \\s*$：代表文本末尾的有效内容处（这里有效内容是排除空行、空格、tab等） 搭配(?m)作为行处理：(?m)^\\s*代表行首有效内容；(?m)\\s*$代表行尾有效内容    子表达式  什么是子表达式？举一个简单例子，as{2}匹配的内容是ass，因为{2}是以紧跟自己上一个字符作为操作对象的，而当你想匹配asas时，需要写为(as){2}，这里括号里内容就是子表达式，括号就是子表达式的标志，这样{2}以子表达式内容为操作对象。 另一举例：文本内容为1965，匹配年份数字，正则表达式为19|20\\d{2}，实际匹配到内容为19，而本意是将19xx和20xx的年份数字匹配出来，问题出在|操作，这里|或操作是将符号两边都作为整体来处理，即19和20\\d{2}，所以这里需要子表达式将19|20作为整体，即(19|20)\\d{2} 子表达式的嵌套，这里对于子表达式的嵌套没什么好讲的，就是支持无限嵌套，但是也要适可而止，以便于阅读分析。这里举个例子：匹配三个连续0-255的数字（注意，正则表达式不会有任何计算，它只关心字符），正则表达式为：((\\d{1,2})|(1\\d{1,2})|(2[0-4]\\d)|(25[0-5])){3}；这里就是将0-99，100-199，200-249,250-255分段描述。  回溯引用  回溯引用其实就是后面匹配引用前面匹配的结果，简单的就是前后一致匹配。例如：[ ]+(\\w+)+[ ]\\1，解释为[ ]+代表任意一个或多个空格；(\\w+)代表任意一个或多个数字字母下划线；[ ]+代表任意一个或多个空格；\\1为前面子表达式(\\w+)匹配的内容，这里就是回溯引用。这段表达式实际功能就是在匹配两个连续单词的出现，如and and，we we等等。 回溯引用通过\\1，\\2等来表达的，这里数字是通过相对位置来引用的，即此处\\1，代表表达式中第一个子表达式（嵌套表达式是如何暂不清楚，认为是指引用层级相同的子表达式），注意数字从1开始。 回溯引用在替换中的应用：  将电话号码重新排版，将313-555-1234和251-555-2031排版为(313) 555-1234和(251) 555-2031。匹配表达式：(\\d{3})(-)(5{3})(-)(\\d{4})，替换表达式：($1) $3-$5。 大小写转换：元字符（\\E作为结束标志；\\l把下一个字符转换为小写；\\u把下一个字符转换为大写；）举例：AaBbCcDd，匹配：([Aa]{2})([Bb]{2})([Cc]{2})([Dd]{2})，替换：$1\\U$2$3\\E$4，替换效果为AaBBCCDd（将第二第三表达式全部替换为大写）    前后查找  什么是前后查找？前后查找就是将匹配部分作为位置标记，选择前面内容还是后面内容，而作为位置标记的内容不作为匹配目标或者说不做内容提取。 向前查找?=，向后查找?\u0026lt;=，作为查找位置的匹配写在=后面，且必须作为子表达式，换句话说必须括起来，如(?=:)。 举例：http:xxxx和https:ssss，匹配：.+(?=:)，匹配结果http和https，注意无:本身。 举例：001:$0.23和002:\\(1.54，匹配：(?\u0026lt;=\\))[\\d.]+，匹配结果0.23和1.54，注意无$本身。向后匹配要注意内容的匹配条件，不要过多匹配，其实用的最多还是向前匹配，以及向前向后匹配合用。 举例：begin 12345678 end，匹配(?\u0026lt;=begin).+(?=end)，匹配结果 12345678 ，注意无begin和end。 之前描述的向前向后查找被称为正向前查找和正向后查找，除此外，还有负向前查找(?!)和负向后查找(?\u0026lt;!)，用法相同，只是将非匹配位置作为搜索条件，注意，对于使用负向前和符负向后查找时，可以适当加单词边界符\\b。举例：\\(30 for 10 apples，匹配：(?\u0026lt;!\\))\\d+，匹配结果为$30 for 10 apples，因为$30中的0并不是\\(开头，所以会作为匹配目标，只需加字符边界符\\b就可以解决：\\b(?\u0026lt;!\\))\\d+\\b。  嵌入条件  嵌入条件使用?来表示，在两种情况下使用：一是根据一个回溯引用来进行条件处理；二是根据一个前后查找来进行条件处理。 回溯引用使用嵌入条件，举例：123-456-7890和(123)456-7890，匹配：(\\()?\\d{3}(?(1)\\)|-)\\d{3}-\\d{4}，解释：(\\()?是一个可选（?为0或1个）的左括号(；\\d{3}是区号123；(?(1)\\)|-)是引用条件第一个子表达式成立则匹配右括号)，否则必须匹配-符号；\\d{3}-\\d{4}是后面7位号码。 前后查找条件的嵌入条件，举例：11111和44444-444，匹配：\\d{5}(?(?=-)-\\d{4})，解释：\\d{5}表示前五位数字；(?(?=-)-\\d{4}向前查找是否存在-，如果存在-再后续查找-\\d{4}也就是连字符-和三个数字。 总之，嵌入条件的模式还是很复杂的，建议先对该模式的各个组成部分一一调试，然后再组合到一起，还有，工作中使用到如此复杂的情况还是比较少见的，建议还是用更简单的方法实现同样的目的。  元字符列表 注意：因为org-mode下列表中“|”符号为特殊符号，为了防止描述真实的“|”符号时被转义，文中使用中文 “竖线” 替代。\n基本元字符    元字符 说明     . 匹配任意单个字符   竖线 逻辑或操作符   [] 匹配字符集合中的任意一个字符   [^] 对字符集合取非   - 定义一个区间，如A-Z   \\ 对下一个字符转义    数量元字符    元字符 说明     * 匹配前一个字符或子表达式零次或多次重复   *? *的懒惰型，懒惰型的理解可参考第五节内容重复匹配   + 匹配前一个字符或子表达式一次或多次重复   +? +的懒惰型   ? 匹配前一个字符或表达式重复一次或零次（可以理解为有无该字符）   {n} 匹配前一个字符或表达式重复n次，n为具体数值   {n,m} 匹配前一个字符或表达式重复m次至n次   {n,} 匹配前一个字符或表达式重复至少n次   {n,}? {n，}的懒惰型    特殊字符元字符    元字符 说明     [\\b] 匹配一个退格字符   \\c 匹配一个控制字符   \\d 匹配任意数字字符   \\D \\d的反义   \\f 换页符   \\n 换行符   \\r 回车符   \\s 匹配一个空白字符   \\§ \\s的反义(大写S)   \\t 制表符tab   \\v 垂直制表符   \\w 任意数字字母下划线   \\W \\w的反义   \\x 匹配一个十六进制数   \\0 匹配一个八进制数    回溯引用和前后查找    元字符 说明     () 定义子表达式   \\1 匹配第一个子表达式，若是\\2表示匹配第二个子表达式   ?= 向前查找   ?\u0026lt;= 向后查找   ?! 负向前查找   ?\u0026lt;! 负向后查找   ?() 条件if then   ?()加竖线 条件if then else    大小写转换    元字符 说明     \\E 结束\\L或\\U转换标志   \\l 把下面一个字符转义为小写   \\L 把下面字符转义为小写直至\\E   \\u 把下面一个字符转义为大写   \\U 把下面字符转义为大写直至\\E    匹配模式    元字符 说明     (?m) 分行匹配模式    其他说明 使用正则表达式的难点不在于将一个匹配情况考虑清楚并且写出一个符合要求的正则表达式，难点在于将不需要匹配的情况考虑清楚将其排除在外。\n在线测试  正则表达式在线测试  典型应用 待补充。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":90,"section":"docs","tags":["shell"],"title":"正则表达式语法简明教程","uri":"https://www.wenhui.space/docs/06-linux-skills/language-skills/regular_expression/"},{"content":"本文 主要对日常shell脚本使用中的一些技巧进行记录。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 shell：bash  字符串替换的小技巧 在一个文件里替换一个字符串  替换结果保存在临时文件   1  sed -e s/OLDSTRING/NEWSTRING/g src_file \u0026gt;tempfile    直接覆盖源文件   1  sed -i -e s/OLDSTRING/NEWSTRING/g src_file   在一个文件里进行有条件替换 我们经常有这样的需求，对某个文件中某些参数值进行修改，比如将TRUE改为FALSE，而且有些参数的keyword可能由多个单词构成（中间空格分离）。shell中for循环的默认分隔符是：空格、tab、\\n，，根据需求选择只将\\n作为分隔符（原分隔符暂存，处理完后恢复，为的是不影响后面的脚本运行）(for语句中的shell命令用反引号包起来)\n1 2 3 4 5 6 7 8 9 10  #!/bin/bash IFS_OLD=$IFS IFS=$\u0026#39;\\n\u0026#39; for key in `cat keywords`; do sed -i \u0026#34;/${key}/s/TRUE/FALSE/g\u0026#34; src_file done IFS=$IFS_OLD   在一组文件里替换一个字符串 1 2 3 4  for file in `cat flist` do sed -i -e s/OLDSTRING/NEWSTRING/g ${file} done   在一个文件里替换一组字符串 1 2 3 4  sed -i -e s/OLDSTRING1/NEWSTRING1/g \\  -e s/OLDSTRING2/NEWSTRING2/g \\  -e s/OLDSTRING3/NEWSTRING3/g \\  src_file   更多无耻要求 更多无耻要求可以基于以上简单脚本进行嵌套实现，不再一一说明。\n其他方案：Emacs 如果你是Emacs用户的话，可以使用emacs的批量替换，具体可查看我的另一篇帖子 emacs的使用技巧记录中 “Emacs 批量查找与替换” 章节。Emacs 批量查找与替换功能操作起来虽然比其他软件繁琐许多，但是你可以详细的看到要被替换的项，这一点相对于单纯的脚本替换是有安全性的。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":91,"section":"docs","tags":["shell"],"title":"shell脚本使用记录","uri":"https://www.wenhui.space/docs/06-linux-skills/script-skills/shell_script/"},{"content":"本文 主要介绍hugo和记录hugo的安装过程。\n   版本 说明     0.1 初版发布   0.2 添加特别说明 和 分享hugo_extended_0.65.3_Linux-64bit.tar.gz    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  Hugo中文文档  什么是hugo？ Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。简单来说就是你可以用它来生成自己的博客站点，而且安装极简单，无依赖。类似此功能的工具还有Hexo，， Jekyll, Ghost，我强烈推荐Hugo。更多内容可以查看Hugo中文文档。\n安装hugo 下载 推荐二进制安装，也就是直接下载可执行程序，方便简单。\n 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） 采用我的百度网盘分享资源（里面包含hugo_0.58和extend_hugo_0.61两个版本，选其一即可） 链接：https://pan.baidu.com/s/1ub-6LSw9VABaf0GNe7oeGQ 密码：pvb4  安装 将下载的文件解压，找到hugo文件，将其放入 “/usr/local/bin/” 目录，若其为非可执行文件，请更改文件属性。可参考以下执行命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./hugo #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./hugo /usr/local/bin/hugo   特别说明 如果使用某些主题时，提示HUGO版本不支持某些特性，首先考虑自己的版本是不是太低，然后最可能的情况是需要安装扩展版本。\n如错误信息为：\nBuilding sites … ERROR 2020/03/06 14:23:59 Transformation failed: TOCSS: failed to transform \u0026quot;main_parsed.scss\u0026quot; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information Built in 218 ms Error: Error building site: logged 1 error(s) 这里分享一个 hugo_extended_0.65.3_Linux-64bit 版本： *链接：https://pan.baidu.com/s/1DUleZmjcLCl7wJP9i3smJA 密码：n86i*。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":92,"section":"docs","tags":["hugo"],"title":"hugo的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_hugo/"},{"content":"本文 主要介绍图床工具PicGo和记录PicGo的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 PicGo版本： picgo-2.1.2-x86_64.AppImage  参考  在Linux上安装PicGO 简书：使用Picgo+Github搭建个人图床  什么是PicGo？ PicGo是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。网络上的图床工具有很多，PicGo算得上一款比较优秀的图床工具了，它可以支持微博， 七牛云， 腾讯云COS， 又拍云， GitHub， 阿里云OSS， SM.MS， imgur 等8种常用图床，功能强大，简单易用。\n为什么安装PicGo？ 写博客内容时，常常会用到图片，最初是将图片放在本地并随博客public一同上传至github，但是在本地网址显示好好的图片，上传至github就打不开了，其主要原因还是因为填写的是相对地址，上传github后，往往地址会发生变化，导致图片索引不到，所以只好通过图床工具转化为链接，作为全路径添加到博客内容，这样就可以解决了。网上搜索了一下图床工具，好像PicGo有点独步天下的意思，网上评价PicGo是最好的图床工具，没有之一。所以，开始折腾起来，下载安装。\n安装过程 下载PicGo  去PicGo官方github页面下载最新版本的PicGo，我这里选择的是picgo-2.1.2-x86_64.AppImage 采用我的百度资源分享 链接：https://pan.baidu.com/s/14ZhG87VBDfNi9w7%5FK4my1A 密码：4zvy ，另附有一张logo图  安装 安装很简单，其实下载的就是一个可执行程序，放到自己的 系统变量PATH 即可，我习惯是放在 “/usr/local/bin/” 。打开终端进入下载解压后的picgo目录，执行以下命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./picgo-2.1.2-x86_64.AppImage #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./picgo-2.1.2-x86_64.AppImage /usr/local/bin/picgo   添加到启动器 可参考另一篇帖子 将软件添加到deepin启动器 。\n安装依赖 虽然PicGo已经开始运行了，可是有些功能需要依赖其他程序来实现。在程序内实现粘贴板上传需要用到xclip，不装的话会报 \u0026ldquo;xclip not found\u0026rdquo; 的错误。可以通过包管理器安装，命令如下：\n1  sudo apt install xclip -y   创建自己的GitHub图床 注册/登陆GitHub账号 申请账号比较简单，不再赘述。\n创建Repository 创建的仓库要选择Public，否则别人没有浏览图片的权限。\n生成一个Token Token用于PicGo操作Github repository\n 回到主页，点击\u0026quot;Settings\u0026quot;按钮 点击\u0026quot;Developer settings\u0026quot;按钮 点击\u0026quot;Personal access tokens\u0026quot;按钮 创建新的Token 填写描述，选择\u0026quot;repo\u0026rdquo;,然后点击\u0026quot;Generate token\u0026quot;按钮 注意：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存  配置PicGo：  右键打开详细窗口 选择图床设置-Github图床  设定仓库名，按照“账户名/仓库名的格式填写” 分支名填写“master” 将之前保存的Token填在这里 存储的路径可以不填，也可以填写“image/”，就会在repository下创建一个“image”文件夹 自定义域名建议不填写    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":93,"section":"docs","tags":["PicGo"],"title":"PicGo的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_picgo/"},{"content":"本文 主要介绍词典工具GoldenDict和记录GoldenDict的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 GoldenDict版本：1.5.0-RC2+git  参考  安装使用 GoldenDict 查词神器  什么是GoldenDict？ GoldenDict是一款优秀的的词典软件，其特点如下：\n 免费 纯净无广告 跨平台：Windows / Mac / Linux 支持多种词典格式 支持查维基百科 / 支持在线翻译（需配置） 支持屏幕取词 支持听取 forvo.com 上的发音 更多特点可详见GoldenDict 官网    GoldenDict    安装GoldenDict  可选择使用deepin软件商店安装，操作简单 可通过软件包管理工具下载（版本不一定是最新的，但应该比软件商店提供的版本新，安装后按需手动添加到启动器），命令如下：   1 2 3 4 5  # Ubuntu / Debian sudo apt install goldendict -y # CentOS sudo yum install goldendict -y   添加离线词典  下载词典 ，我这里使用的是三个词典，百度网盘分享资源 链接： https://pan.baidu.com/s/1wXbxsUlLLsGl9namvO4q-g 密码：45o3  en-zh：牛津现代英汉双解词典 zh-en：朗道汉英字典 zh-zh：新华字典   存放词典 ，解压后根据个人喜好选择存放位置，且后续不能移动，我这里放在 “~/Treasury/tools_and_drives/GoldenDict/” 下 导入词典 ，菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【文件】\u0026gt;【添加】 ，选择上一步的词典位置打开，并勾选上递归搜索，点击 “重新扫描” 完成后点击 【应用】 即可 功能测试 ，在搜索栏分别输入“you”和“你”，回车，查看翻译结果。  添加网页翻译（有道）  菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【网站】\u0026gt; 【添加】 ，输入名称为“youdao”，输入地址， 勾选已启用，点击 【应用】 。 地址内容为“http://dict.youdao.com/search?q=%GDWORD%\u0026amp;ue=utf8” 功能测试，在搜索栏输入“you”，回车，查看youdao翻译结果 也可以使用其他网页翻译以及搜索引擎  添加google翻译（translate-shell） 以上添加的离线词典只能翻译词典里存在的词汇，不能对整句整段进行翻译，而有道翻译的页面广告多，让人不舒服，所以我们为词典添加一个google翻译。translate-shell是命令行版google翻译，在终端命令行可以直接通过 “trans” 命令使用，也可以将命令添加到GoldenDict使用。\n下载安装 translate-shell 安装方法有三种：\n 直接下载可执行文件，百度网盘分享资源 链接：https://pan.baidu.com/s/1kQYl%5F%5FhptxA5X0k9h7ZYcg 密码：sxeq ，打开终端进入下载目录，执行以下命令：   1 2  chmod 755 ./trans sudo mv trans /usr/local/bin/    手动安装，下载trans_shell安装包，以下是使用git工具进行下载，也可以登录网址通过浏览器下载压缩包，或使用我的百度网盘分享资源 链接：https://pan.baidu.com/s/1aHXNwKm6QYcXMtuk77roPg 密码：yzxu ，安装命令如下：   1 2 3 4  git clone https://github.com/soimort/translate-shell cd translate-shell make sudo make install    通过包管理器安装，命令如下：   1 2  sudo apt install translate-shell which trans   trans_shell的使用 本文目的主要是安装trans_shell给GoldenDictionary使用，不过在终端也可以使用，使用方法如下：\n1 2  trans en:zh \u0026#39;Hello World\u0026#39; trans zh:en \u0026#34;你好\u0026#34;   为GoldenDict添加trans_shell 菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【程序】\u0026gt; 【添加】 ，类型选择纯文本，勾选已启用，名字（可以自己命名）与命令行内容如下：\n 名字：google_2_en  命令行：trans -e google -s auto -t en-US -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”   名字：google_2_zh  命令行：trans -e google -s auto -t zh-CN -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages n -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”    填写完之后点击 【应用】 即可。\n为GoldenDict分组 分组的目的是为了方便快速翻译，更加快速准确的找到自己想要的内容。菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【群组】 ，此时左栏会看到已启用的词典（牛津现代英汉双解词典、google_2_zh、youdao、新华字典、朗道汉英字典5.0、google-2-en）。点击 【添加群组】 ，进行命名，选择词典加入该群组，并且可以在群组内调整词典的优先级，也可以根据个人需求为群组设置快捷键。我的分组如下：\n en_zh： google-2-zh、牛津现代英汉双解词典 zh_en： google-2-en、朗道汉英字典5.0 zh_zh： 新华字典 youdao： youdao    给词典进行分组    使用技巧 快捷键 Ctrl+C+C ，翻译剪切板中的内容，通过鼠标或快捷键选择群组，快速找到想要的内容。更多快捷键、屏幕取词以及其他使用技巧，可查看 【编辑】\u0026gt; 【首选项】 。（个人不太喜欢屏幕取词，工具会自动调用 Ctrl-C 命令，在终端中会误杀死进程）\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":94,"section":"docs","tags":["GoldenDict"],"title":"GoldenDict的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_goldendict/"},{"content":"本文 主要介绍了如何将手动安装的软件添加到deepin启动器中显示。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  操纵过程 手动安装的工具可在终端运行，但对于某些软件来说使用不方便，也可以将可执行程序放在桌面，但是又使桌面不整洁美观，也可以添加至任务栏，但会导致任务栏工具繁多杂乱，最好的方式就是将其加入到deepin的启动器，以firefox为例，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Name、Icon、Exec、Categories、Comment，其他建议不要修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":95,"section":"docs","tags":["deepin"],"title":"将软件添加到deepin启动器","uri":"https://www.wenhui.space/docs/01-software-install/add_software_to_deepin_launcher/"},{"content":"本文 主要介绍firefox浏览器和记录firefox浏览器的安装过程。\n   版本 说明     0.1 初版发布   0.2 添加 如何将firefox添加至deepin的启动器    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  参考  deepin linux如何安装最新版firefox火狐浏览器 firefox帮助中心 firefox官网  什么是firefox？ Mozilla Firefox，中文俗称 “火狐” ，是一个自由及开放源代码的网页浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS X及GNU/Linux等。\n为什么选择firefox？ firefox浏览器有如下特点：\n 风格简洁，同时支持多主题，可自行选择 据说相对其他浏览器，启动速度慢（这一点我没有明显体验，大多数用户的浏览器处于常开状态，启动速度也就无关紧要了） 安全性高，有隐私保护机制，拦截多种常见的跟踪器和有害的脚本，减少第三方搜集浏览行为数据的能力 拓展性强，有丰富的拓展性插件支持 多平台支持，同步数据无障碍  选择firefox主要因为其两个特点，一是丰富的插件，虽然谷歌插件也很丰富，但国内环境无法访问应用商店，导致安装起插件来比较麻烦，所以放弃；二是多平台支持，支持Linux、Windows、Mac OS以及移动端，同步数据无障碍。\n安装firefox deepin的软件商店自带firefox浏览器，不过不是最新版的，通过软件商店安装firefox就不介绍了，只介绍手动安装过程。\n 打开firefox下载中心，不要点击 “立即下载” ，而是点击下方 “高级安装选项和其他平台” ，选择 “Linux 64-bit” 进行下载 将下载的最新版的firefox压缩包进行解压 打开文件管理器，并进入刚刚解压后的目录，双击运行目录下的 \u0026ldquo;firefox\u0026rdquo; 可执行文件，firefox浏览器就启动了 在任务栏中右键点击firefox，选择驻留可添加至任务栏，也可以将执行程序发送到桌面 将firefox可执行文件放在 \u0026quot;/usr/local/bin/” 目录，可以在终端命令打开firefox，命令就是 “firefox”  如何将firefox添加至deepin的启动器 如果不想将firefox的可执行程序放在桌面，影响美观，又不想添加至任务栏，导致任务栏工具繁多，可以选择将其加入到deepin的启动器，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Icon和Exec两项，其他无需修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":96,"section":"docs","tags":["firefox"],"title":"firefox的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_firefox/"},{"content":"本文 主要介绍git和记录git的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 git版本： git version 2.11.0  参考  Deepin 系统下安装git  什么是Git？什么是Github？ Git是一个帮我们管理文件版本的程序，专业名称叫：分布式版本控制系统。GitHub是基于git的代码库托管站，也算是程序员的SMS（以码会友），其中一个主要的开源代码发布或托管站git的作用就是对文件进行版本管理，方便在不同版本进行切换修改，类似文件分不同时间备份然后需要时可以找回其中一个版本。GitHub某种程度上就是代码的网盘，也有开源开发商作为代码发布、存放、征集Bug和意见用。类似于相同功能的，国内版为Gitee（码云）。\n对了，还有人称gitub为世界上最大的同性交友网站，貌似也有道理。\n下载Git 打开终端，命令行输入以下命令，然后等待系统自动安装：\n1  sudo apt install git   结束后在终端输入命令 “git \u0026ndash;version” ，查看git是否安装成功，输出版本号则代表安装成功。\ngithub的使用指南 登录github，会显示 Learn Git and GitHub without any code! ，点击 Read the Guide 可查看使用指南，会点击这里。\ngit的使用指南 创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    克隆仓库到本地 github每个仓库页面都会有一个 [Clone or download] 绿色图标，点击后复制自己仓库的 \u0026quot;https://github.com\u0026hellip;\u0026hellip;/\u0026quot; 链接（其实就是仓库e页面网址后加.git），打开终端输入以下命令\n1  git clone https://github.com/......   等待克隆完成（终端会显示进度），克隆完成后在本地会看到自己的仓库文件。\npush 和 pull 首先搞清楚两个概念，本地仓库和远程仓库，本地仓库也就是你本地电脑的文件了，远程仓库就是指github。 pull 就是将远程仓库的最新文件下拉到本地（会输入用户名和密码），命令如下：\n1  git pull   push 就是将本地文件上传到远程仓库，不过需要经过三步，一是add，添加追踪或修改的文件，也就是想要把哪些文件提交上去就进行添加；二是commit，添加提交注释，提交到缓存区；三是push，刚刚提交到缓存区，也仅仅是在本地，我们需要上传到远程仓库。命令如下(会输入用户名和密码)（其中 add . 是指添加本地所有文件，也可以指定某文件，输入路径和文件名即可）：\n1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push   详细使用技巧 至此，其实已经可以基本使用git了，其他详细使用技巧请期待后续帖子更新。也可以参考网上教程廖雪峰git使用教程。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":97,"section":"docs","tags":["git"],"title":"git的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_git/"},{"content":"本文 主要介绍emacs和记录emacs的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本： Linux GNU Emacs 26.3  什么是emacs？ emacs是一款功能强大的编辑器，被公认为是最受专业程序员喜爱的代码编辑器之一，而另一个就是vim，在业界vim被称为编辑器之神，而emacs被称为神之编辑器。对于初学者可能都有这样的疑问，那就是究竟是Vim还是Emacs好呢？这样的问题已经争辩了十几年，但至今无解，不过为了让初学者有一定的了解，还是做个简单介绍。\nVim ：\n 开箱即用，大多数操作系统自带，不需要安装 体量小，启动快 采用双模式（命令模式和编辑模式），这样按键组合少，但是要频繁进行模式切换 vim的上下左右jkhl，右手控制相对舒服 相对emacs使用人群多，配置和使用技巧可参考内容较多  Emacs ：\n 需要自己安装，碰到依赖库的问题，还是有点麻烦的 体积大，启动慢，但功能强大 主模式操作，不用切换模式，但按键组合就多了，Ctrl、Alt、Shift是离不开的，让你的小拇指粗壮起来 emacs的上下左右pnbf放在了两个手，还要配合Ctrl键，需要适应 缓存机制个人感觉很有用 可扩展性极强，可重新定义变量和快捷键绑定，可自己定制插件，也可通过内置的包管理系统安装和卸载大神们的插件，目前可使用的插件还是很丰富的 不同的语言环境对应不同的模式，每个模式都有自己独特的功能，本人最常用的就是org-mode和verilog-mode，org写工程日记，verilog就不说了，IC工程师离不开的  总之，Vim和Emacs功能都很强大，选择一款适合自己的编辑器即可。\n安装emacs 下载emacs安装包  可查看emacs官网或国内镜像文件，当前最新版本是emacs-26.3（更新时间29-Aug-2019) 可查看我的百度网盘分享资源(linux emacs-26.3版本) 链接：https://pan.baidu.com/s/1VZ88kGZpBiC59qGU7sk7tA 密码：lki0 可直接使用我的可执行程序，无需安装，将其放在自己的 “/usr/local/bin/” 目录即可，百度网盘分享资源 链接：https://pan.baidu.com/s/18K8WNnr5ytIkx%5Fe7n%5FuAcQ 密码：rrtt  安装依赖库 开启终端，输入以下命令，安装相应的依赖库。\n1 2 3 4 5  sudo apt-get install libgtk2.0-dev --fix-missing sudo apt-get install libxpm-dev sudo apt-get install libjpeg62-turbo-dev sudo apt-get install libgif-dev sudo apt-get install libtiff5-dev   编译和安装 开启终端，进入emacs安装包目录，输入以下命令：\n1  sudo ./configure   已经安装了相应的依赖，此时应该不会发生error，经过configure后，执行以下命令：\n1 2  sudo make sudo make install   查看是否安装成功 终端中输入以下命令：\n1  emacs --version   正常显示emacs版本号，即安装成功，安装的可执行程序默认在 “/usr/local/bin/” 。\n启动emacs 启动命令为 emacs ，如下：\n1  emacs ~/Destop/demo.txt   启动页面会有简单的使用说明，熟悉熟悉即可上手操作。\n  emacs启动页面      emacs org mode    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":98,"section":"docs","tags":["emacs"],"title":"emacs的安装","uri":"https://www.wenhui.space/docs/01-software-install/install_emacs/"},{"content":"本文 主要介绍如何为deepin系统安装 rtl8821ce 无线网卡驱动。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11 无线驱动：rtl8821ce  参考  LINUX 下无线网卡 rtl8821CE/rtl8723de 驱动 无法驱动解决办法  查看自己的网卡型号 在终端输入以下命令：\n1  dmesg | grep -i eth   显示如下：\n1 2 3 4 5 6 7 8 9 10  [18690.091602] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19611.409023] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19669.877403] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19974.291420] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20093.240319] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20484.342884] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20605.303770] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20893.593415] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20937.945192] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20990.361341] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000   下载驱动  rtl8821CE git源网址 rtl8723de git源网址 百度网盘分享资源（rtl8821CE） 链接：https://pan.baidu.com/s/1zkMNEdvtXpuh8PnnJkfkLQ 密码：gxwh  安装驱动  解压rtl8821ce.zip 修改 Makefile 文件，将 TopDIR 变量改为 Makefile 文件所在路径，如下：   1 2 3  export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce #modify to export TopDIR ?= /home/caowenhui/Treasury/tools_and_drives/wireless/rtl8821ce    安装，打开终端，进入Makefile所在路径，输入以下命令：   1 2 3  make sudo make install sudo modprobe -a 8821ce   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":99,"section":"docs","tags":["deepin"],"title":"为deepin系统安装无线网卡驱动","uri":"https://www.wenhui.space/docs/01-software-install/install_rtl8821ce_wireless_drive/"},{"content":"本文 主要介绍deepin系统和记录deepin系统的安装过程。\n   版本 说明     0.1 初版发布    参考  deepin官网-如何安装 实操：安装深度DeepinLinux桌面操作系统（替代微软Windows的国产开源系统）  背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11  什么是deepin？ deepin操作系统是由武汉深之度科技有限公司开发的Linux发行版。deepin操作系统是一个基于Debian的Linux操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。它包含了所有您需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等。以上内容摘自百度百科，了解详细信息可登录deepin操作系统官网。\n简而言之，deepin是基于Debian内核、简单易用又美观的Linux操作系统，适合轻量应用的普通用户和初识Linux的学习者。deepin从使用习惯上是最接近Windows的Linux操作系统，它自带应用商店、文件管理器、系统监视器、深度截屏、深度录屏、深度录音、深度影院等等，深度应用商店中提供的软件还是很丰富的，涉及网络应用、社交沟通、音乐欣赏、视频播放、图形图像、游戏娱乐、办公学习、阅读翻译、编程开发和系统管理，比如微信、QQ、百度网盘、迅雷、网易云音乐等都可以使用，但是有些软件版本较低且部分功能不支持，不过好在还是可以用的，你也可以通过手动安装最新版本，也可以发掘其他好玩好用的Linux版软件。这里说一下，deepin对游戏支持不太好，如果玩游戏的话建议还是整个Windows稳定环境吧。\n安装deepin 下载安装包和启动盘制作工具 打开deepin官网下载页面，下载ISO镜像文件，我选择的是左边第一个的 “官方下载” ，启动盘制作工具下载链接在deepin官网下载页面最下面的 “下载深度启动盘制作工具” ，或者点击这里。官网下载的深度启动盘制作工具在Windows下运行总是提示内存无法访问，不知道其他使用者情况，我再提供一个自己使用过的启动盘制作工具，百度网盘分享资源 链接：https://pan.baidu.com/s/1ph70bhA4h70cgB1PLoxPOg 密码：mphc 。\n制作启动盘  准备好一个不小于8G的U盘，最好格式化 插入准备的U盘并打开启动盘制作工具，选择深度操作系统镜像文件以及准备好的U盘，这里会有勾选项 “格式化磁盘可提高制作成功率” ，若之前U盘未格式化，在备份好内容的前提下建议勾选上 点击 “开始” 即可制作  准备分区 我的存储系统是一块256G的固态硬盘，现在要压缩出50G给deepin系统使用，方法如下：\n 选中 “此电脑” ，右键选择 \u0026ldquo;管理\u0026rdquo; ，然后选择并打开 “磁盘管理” 选择要压缩的磁盘，我这里就一个256G盘，也就没什么选择的了，然后右键选中 “压缩卷” ，输入压缩空间大小，单位是MB，50G=1024MBx50=51200MB，点击 “压缩” 这里出现了一个未分配的50G磁盘，这就是留给deepin使用的磁盘空间了  安装系统  将制作好的启动盘插入电脑 重启电脑，在屏幕处于黑屏状态时连续敲 F12（Fn+F12） ，进入启动项选择页面，选择插入的U盘，回车 系统进入安装界面，选择需要安装的语言，简体中文 进入账户界面，输入系统用户名和密码 点击 “下一步” 进入选择安装位置页面，这里选择之前压缩出的未分配磁盘，并且选择默认的 “简单” 安装即可，若对Linux磁盘分区有了解的话可以选择 “高级” ，因为是双系统，所以不建议选择 “全盘安装” ，可能会影响Windows系统的数据。 点击 “继续” ，系统开始自动化安装了 安装完成后，拔掉U盘，开始体验deepin吧    deepin主页      deepin启动器      deepin应用商店    开机启动 安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，第一选项是deepin，其他选项有Windows和硬盘等，默认等待时间是5秒，在5秒内可以选择进入win10系统还是deepin系统，不选择默认第一启动项deepin。\n如何删除deepin系统 有可能deepin安装体验后，并不喜欢，没关系，我们可以删除它。\n删除磁盘：\n 重启电脑，在启动页面选择Windows启动，进入Windows系统 选中此电脑，右键选择管理，然后选择并打开磁盘管理，选中deepin的磁盘，右键选择删除卷 原deepin磁盘此时处于未分配状态，选择要扩展的磁盘（未分配空间会添加到此盘），右键选择 \u0026ldquo;扩展卷\u0026rdquo; ，进入使用扩展向导 点击 “下一步” ，选择扩展的空间容量，这里一般选择最大值即可，设置完毕，点击 “下一步” 完成扩展向导，点击 *“完成”*，即可扩展成功，扩展之后发现扩展磁盘空间增大了  设置开机启动顺序：\n安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，虽然删除了deepin的磁盘，但还会进入deepin的开机引导页面，这样会出现问题，所以需要修改开机启动项顺序。方法如下：\n 重启电脑，在屏幕处于黑屏状态时连续敲 F1（Fn+F1） ，进入BIOS页面 通过左右键选择 “Startup” 在 “Startup” 页面选择 “Boot” 项，回车 当前 “deepin” 是第一项，此时将 “Windows Boot Manager” 设为第一项 按 “F10” ，保存并退出 重启电脑，此时电脑直接进入Win10系统，与安装deepin系统前一样  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":100,"section":"docs","tags":["deepin"],"title":"deepin系统安装","uri":"https://www.wenhui.space/docs/01-software-install/install_deepin_os/"},{"content":"本文 主要介绍购买笔记本电脑前的选择和购买后的使用测评。\n   版本 说明     0.1 初版发布    背景 购置需求 本人IC工程师，但不会在个人电脑运行大型软件，不爱好游戏，不涉及图像视频相关工作，主要应用场景也就是轻量办公和轻量娱乐，所以对性能要求不高，对显卡要求不高，对屏幕显示要求不高。最大的要求就是小巧轻便，续航能力强，不想再背着联想大G跑来跑去了。\n购置理由 最终选择了这款Thinkpad S2，其购置理由如下：\n 13.3英寸，1.47Kg，厚度19.1mm，满足小巧轻便要求。 待机时长5~7小时，满足续航要求。 黑色机身，经典Thinkpad外观，商务风格（由于只有A面是金属的，其余为塑料材质，感觉银色款缺少了金属质感，所以放弃）。 接口丰富，USB3.0，Type-C，HDMI，同时具有可扩展性，足够满足日常使用（好像大多数电脑都满足这些要求了）。 可升级，ThinkPad的电脑的内存和存储都是可以升级的，内存最大升级为32G，所以买了基本配置8G+256G，后续可升级。 价格中等，6000上下，可以接受  为什么  为什么处理器不买i7？ 太贵！！！ 为什么不买x1？ 太贵！！！  图片 外观   Black Boy    接口   接口展示    参数    部件名称 部件描述     CPU型号 i5-8250U   CPU主频 1.60GHz   最高睿频 3.4GHz   总线规格 4 GT/s   CPU缓存 6 MB   核心/线程数 4/8   制程工艺 光刻 14nm   指令集 64-bit   功耗 15 W   内存容量 8GB   内存类型 2400MHz DDR4   插槽数量 2个内存插槽（一个插有8G内存，另一个空余供升级使用）   最大内存容量 32GB（每个插槽最大16GB）   硬盘容量 256GB (M.2 SSD) (可升级)   光驱 无   触控屏 不支持   屏幕尺寸 13.3英寸   显示比例 16:9   屏幕分辨率 1366x768   屏幕技术 LED背光TN显示屏，防眩目显示屏   显卡类型 集成显卡   显卡芯片 Intel UHD Graphics 620   显存容量 共享系统内存   DirectX版本 DirectX 12   摄像头 720p 高清摄像头   音频系统 HD Audio，Realtek ALC3287 codec   扬声器 立体扬声器 2Wx2   麦克风 DualArray Microphone（内置双阵列麦克风）   无线网卡 支持802.11AC协议的无线网卡   有线网卡 内置Intel Ethernet Connection I219-V（Jacksonville）   蓝牙 无线网卡集成   数据接口 2个USB3.0 Gen1（其中一个为Always On），2个USB3.0 Type-C   视频接口 HDMI   音频接口 Combo jack（麦克风/耳机二合一接口）   读卡器 MicroSD 读卡器   指纹识别 支持   键盘 6行全尺寸键盘（不带背光）   电池类型 3芯45Wh   续航时间 5-7小时   电源适配器 65W USB C型 AC Adapter   预装操作系统 Win10家庭中文版64位   WWAN 不支持    使用测评  整机算是比较轻，但算不上薄，毕竟不是超级本，不过也是thinkpad中小巧轻便的了，整体不错。 机身材料只有A面是金属的，其它全是塑料材质，这个买之前就已经知晓了，不过选的黑色款，外观还不错，不知道银色款怎么样，唯一的吐槽点是开箱时塑料味稍微有点大。 接口丰富，一个USB给无线键鼠使用，一个可供存储读取使用，其中一个USB口是Always On的，也就是在关机时直插可以给手机充电，两个Type-C都可以充电，HDMI可扩展屏幕，还有mini网口和SD卡读口，足够满足日常需求了，个别需求需要另购扩展坞或转换头。 电池续航能力亲测可以，满足日常办公待机5～6小时，可以设置电池充电至90%，这样接电源使用对电池比较好。 键盘手感还可以，本人要求不高，中间的红色指杆，是ThinkPad经典标志，不过我觉得现在挺鸡肋的，反正我不会去用，触控板已足够。 网上有人说风扇和散热的问题，我这里没发现什么异常 在Win10系统，无线网不自动刷新连接，手动刷新有时候找不到自己的网络，估计也不是电脑的问题，回头重装系统试试。 联想客服，可以添加微信公众号，绑定自己的设备，有啥问题都可以咨询人工客服  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":101,"section":"docs","tags":null,"title":"My Black Boy","uri":"https://www.wenhui.space/docs/01-software-install/thinkpad_s2/"},{"content":"  这就是我    你好，欢迎来到这里，我叫文辉，一位一直从事于CPU行业的IC工程师，这是我的个人博客站点，在此总结一些技术经验和记录生活中的点点滴滴。\n关于我 漂于北京的雄安土著 我是一个漂于北京的雄安土著。2017年4月1日，我多了个称号 “雄安土著” 。当时我还在西安上学，成立雄安新区的消息竟然还是室友告诉我的，想想也是有意思。2017年8月，我来到了长沙工作，一年后又到了北京，成为了一只漂于北京的雄安土著。\nCPU行业从事者 我是一个CPU行业从事者。CPU的启蒙是从 “计算机组成原理” 这门课程开始的，紧接着完成了 “基于MIPS指令集的多周期处理器” 的课程设计，对处理器产生了浓厚的兴趣，后续又完成了 \u0026ldquo;兼容ARM指令集的五级流水处理器\u0026rdquo; 的毕业设计，期间还读了一本姚永斌先生写的 《超标量处理器设计》 一书，对现代处理器的设计有了基础认识。毕业之后顺利进入一家处理器设计公司，任职 微处理器逻辑设计工程师 ，开启了我CPU领域的职业之旅。在长沙工作期间，要特别感谢王老师、高老师、赵老师、郑老师对我工作的指导，使我有了很大的进步。一年后来到北京，从事了一段时间CPU验证工作，要特别感谢文彬师兄，在CPU验证方面传授了很多经验给我，也感谢浩哥，从北京CPU产业方面了解到很多东西，相对于从前的我，视野更开阔了。更要感谢我的女朋友，对我一直以来的支持和鼓励，包括对一个工科男的包容和理解。总之，我很荣幸从事于自己喜欢的CPU行业，也很荣幸有一路帮助我的人们，我会一直坚持在CPU领域努力前行。\nEmacs User 我是一个忠实的 Emacs User 。开始使用Emacs是受王老师推荐，演示了一版 verilog mode 中 AUTO机制 的惊艳操作，从此开始成为一名 Emacs User 。对于 emacs 我主要使用 org mode 和 verilog mode ， org mode 主要用来写博客写笔记，支持大纲浏览和导出各种格式； verilog mode 主要用于代码编辑， AUTO机制 可实现自动顶层连线、自动声明端口列表、自动声明连线等等。\n美食爱好者（吃货） 我是一个美食爱好者（吃货）。本人自出生以来就喜欢吃，喜欢吃肉，喜欢吃甜食，绝对的 资深吃货 。出去旅游必去的是小吃街：\n 在西安吃过泡馍（包括小炒泡馍，牛羊肉泡馍，葫芦头泡馍\u0026hellip;）、葫芦鸡、定家小酥肉、贾三灌汤包、水盆羊肉、胡辣汤、葱油饼、凉皮、肉夹馍、油糕、柿饼、甑糕、各种面食\u0026hellip;\u0026hellip; 感觉可以发一个长帖了 “论在西安的吃喝四年（读大学）” 。 在兰州吃过灰豆、牛肉饼、甜蓓子、酿皮、牛肉面，都好吃，不过甜蓓子吃了不少，火车上我肚子胀的跟小皮球儿似的，难道在我肚子里发酵了 在天水吃过荞面凉粉、天水呱呱，不过个人不太喜欢，在天水吃的最好吃的竟然是永和豆浆的红烧肉盖饭 在洛阳吃过丸子汤，汤是牛肉汤，丸子焦酥，美味极了 在邢台吃过石头饼，很好吃 在长沙吃过小龙虾、辣椒炒肉、带皮羊肉、卜豆角炒肉、卜辣椒炒肉、梅干菜扣肉饼、糖油粑粑、葱油粑粑、臭豆腐\u0026hellip;\u0026hellip; 在我老家，要说好吃的，我强烈推荐五香流油烤鸭蛋和小鱼咸菜加贴饼  生活在一个地方，最喜欢逛的是菜市场和超市，在西安，我认识了火晶小柿子，认识了拐枣，认识了秦椒\u0026hellip; 在长沙认识了花生芽、擂辣椒、卜豆角、卜辣椒、凉薯、红菜苔、白菜苔、腊鱼腊肉和腊肠\u0026hellip; 在北京好像更国际一些，五道口的帝玛进口超市，认识了更多西餐使用的罗勒酱、迷迭香、鱼露、各种果醋、日本酱油、小洋葱\u0026hellip;\n对于吃，我还有个小癖好，那就是收集老菜谱，那些破烂的、发黄的、散发着陈年油墨味的老菜谱，就是我的收集对象了。目前我也收集了十几本老菜谱了，包括六十年代、七十年代、八十年代、九十年代，也有手写油印版的，也许研究他们就是我老了以后的主要工作了。\n在北京，一个不大的出租屋里，我却置办了很多炊具，想吃炒菜买了炒锅，想吃米饭和粥买了电饭锅，想吃粉蒸肉买了电蒸锅，想吃鸡蛋饼买了电饼铛，想吃红烧肉买了电压力锅，想喝豆浆买了豆浆机，想吃烤肉买了烤箱，不知道下一个我要买的会是什么。\n台球爱好者 我是一个台球爱好者。说到台球，不得不讲我大学期间的三个目标， “爱上一座城市 爱上一个人 爱上一项运动” ，完成这三个目标的大学生活才是圆满的。如果单从一项运动来讲，没有比在悠哉的大学生活时期去培养更适合了，我已经充分感受到了工作中的忙碌，很难有足够的时间和精力去认真学习一项运动，比如台球。\n我是从大三开始打台球的，那时候找来教学视频，一点点学起，包括手架、握杆、站位、瞄点、发力\u0026hellip;\u0026hellip; 不得不说，台球技巧性很强的，要想学好需要花费不少的时间和精力。我之前看的教学视频是庞卫国老师的，不过是斯诺克教学视频，本人也很喜欢庞卫国老师的解说，尤其是和主持人姜毅搭档。现在教学视频也多了，可以看看前斯诺克职业球手刘松的，还有新锐台球教练王桁的，也可以关注他们的公众号。以前看直播是在星期五台球网，现在有中国体育直播APP方便了，基本所有赛事都有直播，包括八球和斯诺克，而且一般的斯诺克赛事刘松都会主播，刘教练划线很准的。顺便说一句，我的球杆就是野豹中国体育定制款的，千元球杆，打感还可以。\n我平时斯诺克比赛看的多一些，八球比赛很少看，喜欢的球员当然是火老师，打球那叫一个行云流水，还有墨菲，喜欢他打球的节奏，还有中国一哥丁俊晖，喜欢的八球球员就是二宝郑宇伯，打球就两个字 “痛快” 。近年来国内台球很热，好多年轻小将涌现，进入斯诺克职业赛了，比如颜丙涛、周跃龙、袁思俊、赵心童、雷佩凡、斯佳辉\u0026hellip; 斯佳辉是刘松教练的徒弟，雷佩凡是陕西安康人，我室友也是安康人，还记得大二时跟他回家玩，去球厅看到小小的雷佩凡一个人在练球，那年他十一岁，如今也是职业球手了。今年的世界斯诺克中国公开赛在北京国家奥林匹克体育中心体育馆举行，我终于圆了自己一个梦想，看了一次现场斯诺克比赛，前几轮比赛的票价很便宜，毕竟斯诺克是小众运动，我买了99元票坐到了199的位置，还记得当时包括我只有两个观众看了布雷切尔的比赛，下半场我就偷偷溜到二号台，看了马叔两杆破败一杆50+，不过没坚持到比赛结束，太晚了就回家了。斯诺克的票价真的不贵，你可见过黄牛票都打折。在北京的朋友可以看一看中国公开赛，一般举行时间是4月1日到4月7日。\n再来说一说为什么喜欢台球。首先台球是一项绅士运动，不像足球篮球碰撞性那么强，我怕把别人撞坏了，更怕别人把我撞坏了。打台球最让人极致舒适的不是一杆进洞，而是一杆进洞的同时伴随着漂亮的走位，对白球的控制才是让人最爽的。打台球真正的敌人不是对手，而是自己，你需要的是自己的完美发挥。打台球像一场博弈，有进攻，有防守，有思考，有抉择，不仅需要娴熟的技艺，还需要沉着冷静的头脑。打台球更像是解决一道难题，目标就是一杆致胜，但达到目标需要解决一路障碍。我们看下图的球形，开球后9号球落袋，白球位置不太好打全色球，所以击打15号选定花色球，同时白球K停5号，这样12号和14号左下袋口进球线路打开，同时叫到11号左上袋口，击打11号时根据白球角度可以选择轻K12号，也可以单叫10号，打完10号可以顺势解决12号和14号，最后通过13号叫8号球，完成清台。当然这是A计划，如果击球过程中走位出现失误，那就要执行B计划了（防守）。找一个安全的位置，最好对手看不到目标球，其次是无进球线路，在其次是进球难度高的位置，贴库位置是个不错的选择，配合自己的球形大脑里快速评估一下防守成功率，然后进行方案决策以及实施。可是如果对手有袋口球，让你无处可防怎么办，此时要么破坏袋口球的同时白球走一个相对安全位置，要么将对手某目标球锁死，比如赌袋口，实在不行就大捅一杆，洗洗牌，也许会出现对自己有利的球形哦。总之，B计划的宗旨就一个，增加对手清台难度，一杆打不死我，老子就有机会上来收拾你。怎么样，也许看到这里你也喜欢上了台球。\n  台球    我喜欢的  节目  强烈推荐优酷的 《圆桌派》 ，这是一个聊天节目，一个圆桌，一个话题，一炉焚香，四位嘉宾开始畅谈，各自表述观点和想法，作为听众有时也会陷入深思，不知不觉融入其中。圆桌派的话题涉及很广，有发人深省的，也有幽默风趣的，最主要的是全部贴近生活。最喜欢的是陈晓卿参加的那期 饭局 ，还有李玫瑾老师的 失恋 与 渣男 。   音乐和歌手  郑钧：私奔、赤裸裸 李志：天空之城、梵高、和你在一起、不多、关于郑州的记忆 伍佰：再度重相逢、晚风 吴宁越：羊肉面 马条：阳光中的向日葵 赵雷：鼓楼 奇葩的歌：少林奥运、李伯伯、罗马表、我想我想\u0026hellip;\u0026hellip; 最近听的：Chris Stapleton的Tennessee Whiskey、北野武的浅草キッド、John Lennon的Imagine、老王乐队的我还年轻、杨学的泸沽湖、鱼大叔的后来的我、丢火车的火车日记、莫染的给英格兰友人、房东的猫的下一站茶山刘\u0026hellip;\u0026hellip;   喜欢的电影  我喜欢看轻松娱乐类的电影，比如无名之辈、情圣、人在囧途、让子弹飞\u0026hellip;\u0026hellip; 严重抵触悬疑惊悚类，天生胆小 有点喜欢战争类，非神剧，比如天空之眼、狂怒、猎杀红色十月、拆弹部队、美国狙击手、孤独的幸存者、兵临城下\u0026hellip;\u0026hellip; 不怎么看电视剧，感觉没时间追剧    关于本博客 本博客主要内容 本博客主要是总结一些工作中的技术经验，以及记录生活中的一些点点滴滴。\n本博客名字由来 我始终坚持一句话， “第一次问过或查过的问题，就应该记下来；第二次再问或再查的问题，就必须记下来。” 既然没有强大的大脑，那就多动动手，记录下来，正所谓好记性不如烂笔头，本博客就是我的 烂笔头 。\n本博客创建过程 实际上整个过程是这样的，最初自己只做一些工程上的笔记，使用工具就是word了；后来熟悉了emacs的org mode，开始用org来记笔记，可以导出html文件用浏览器查看；再后来从emacs china论坛中发现有人开发了基于org的笔记管理系统，但是已经不再维护了，所以只是简单了解了一下；接下来仍一直在寻找一种笔记管理方法，网上有人推荐了hexo，一个博客站点生成器，折腾了一段时间，从安装hexo工具到配置主题就要晕死了；在折腾hexo的过程中又发现了hugo博客站点生成器，免安装，还有天然支持org转markdown的插件，简直太舒服了。使用emacs和hugo构建自己的博客，目前对我来说是最舒服的方式没有之一。整个过程是不是很曲折，如果你看到这里，推荐你直接使用hugo搭建自己的博客站点，非emacs用户的话可以直接书写markdown文件，顺便推荐一款markdown编辑器 Typora 。这里就不对如何使用hugo搭建自己的博客站点进行介绍了，有单独的一篇帖子介绍详细的搭建过程。\n","description":"","id":102,"section":"","tags":null,"title":"About","uri":"https://www.wenhui.space/about/"}]
[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"https://wenhui.space/zh/updates/2019_may.html"},{"content":"Markdown here\n","description":"test post","id":1,"section":"updates","tags":null,"title":"April 2019","uri":"https://wenhui.space/zh/updates/2019_april.html"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"March 2019","uri":"https://wenhui.space/zh/updates/2019_march.html"},{"content":"Markdown here\n","description":"test post","id":3,"section":"updates","tags":null,"title":"February 2019","uri":"https://wenhui.space/zh/updates/2019_february.html"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"January 2019","uri":"https://wenhui.space/zh/updates/2019_january.html"},{"content":"本文 主要内容向大家推荐一款hugo主题，是目前我见过的所有主题中最完美的一个，名字叫zdoc。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.63 extend  主题介绍 之所以说它完美，主要是支持了文档结构的多层目录，可实现博客文章的多级分类，并且支持了搜索功能和评论功能，简单易用，配置文件内容非常清楚，可以开箱即用。话不多说，github地址为： https://github.com/zzossig/hugo-theme-zdoc。\n使用效果和安装步骤readme中都有说明，这里不再说明。后面会对我操作过程中遇到的问题简单记录。\n注意事项  hugo版本需要0.60或以上版本，并且必须是extend版本。 实现多级分类： 只需要创建多级目录，在每一个层级目录下存放一个_index.md文件，代表该级页面。 需要先添加自己的语言环境，包括theme内的i18n目录。  我的配置 具体内容不再介绍了，这里提供一个我整体配置后的模板，可参考，如有具体问题可邮箱联系。另外，主题一直在保持更新，意味着会有不断的新功能添加进来，注意及时追踪。\n分享如下： 链接：https://pan.baidu.com/s/1s3BWpKNKi1QpgaXruvLx7w 密码：3ryh 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":5,"section":"docs","tags":["hugo"],"title":"推荐一款hugo主题","uri":"https://wenhui.space/zh/docs/create_blog_site/hugo_theme_zdoc.html"},{"content":"本文 主要介绍一款emacs插件\u0026ndash;epa(emacs-application-framework)。\n   版本 说明     0.1 初版发布    参考  github网址：https://github.com/manateelazycat/emacs-application-framework/blob/master/README.zh-CN.md  什么是epa？ EPA 是一个全新的图形应用框架，通过扩展Emacs的多媒体能力，最终达到 Live in Emacs 的终极目标。换句话说，也就是用emacs做一切。\n如何安装？ 安装过程请参考如上链接，这里只对安装时遇到的问题列出来，供大家参考。\n解决pip3安装网络慢问题 可以使用国内源，如 sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pack_name\n其他还有地址：\n 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/  安装dbus前先安装依赖 sudo apt-get install libdbus-glib-1-dev\nemacs不支持dbus 这是在编译安装时没有对dbus做支持，可能设置了without\u0026ndash;dbus，这时候需要重新编译安装emacs，使其支持dbus功能。\n为什么使用epa？ 暂时还没体会到epa的有利之处，初次安装，就是尝试使用，也许后面会发现更多好处吧，待使用后再对使用场景进行总结。\n这里罗列一下epa目前支持的功能：\n   应用名称 启动命令     浏览器 `M-x eaf-open-browser` 在浏览器中打开或搜索    `M-x eaf-open-browser-with-history` 搜索历史或者打开URL   HTML邮件渲染 `M-x eaf-open-mail-as-html` 在 `gnus`，`mu4e`，`notmuch` 等邮件客户端中执行   PDF阅读器 `M-x eaf-open` 输入PDF文件   视频播放器 `M-x eaf-open` 输入视频文件   图片浏览器 `M-x eaf-open` 输入图片文件   Markdown预览 `M-x eaf-open` 输入Markdown文件   Org预览 `M-x eaf-open` 输入Org文件   摄像头程序 `M-x eaf-open-camera`   终端模拟器 `M-x eaf-open-terminal`   二维码下载文件 `M-x eaf-file-sender-qrcode` or `eaf-file-sender-qrcode-in-dired`   二维码上传文件 `M-x eaf-file-receiver-qrcode`   无线分享 `M-x eaf-open-airshare` 输入要分享给手机的字符串   RSS新闻阅读器 `M-x eaf-open-rss-reader`   演示程序 `M-x eaf-open-demo`    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":6,"section":"docs","tags":["emacs"],"title":"emacs插件之多媒体应用","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_epa_package.html"},{"content":"本文 主要介绍什么是UVM和验证平台，以及如何搭建UVM验证平台。\n   版本 说明     0.1 初版发布    参考 参考自文彬师兄的UVM培训资料。\n初识UVM 什么是UVM？  VMM(Verification Methodology Manual)，Synopsys在2006年推出的，VMM当中集成了寄存器解决方案RAL(Register Abstraction Layer)。 OVM(Open Verification Methodology)，Cadence和Mentor在2008年推出的，它引进了factory机制，功能非常强大，但是没有寄存器解决方案。 UVM(Universal Verification Methodology)，即通用验证方法学，其正式版本在2011年2月由Accellera推出的，UVM几乎完全继承了OVM，同时又采纳了VMM中的寄存器解决方案。  什么是UVM验证平台？  UVM是基于System Verilog的一种验证方法学，也可以看成是一个库，提供一系列的接口，可以利用UVM搭建验证平台，用于验证数字逻辑电路的正确性。 注意，UVM本身并不是一个验证平台，他只是一个库，而一个验证平台引入了UVM相关库，称为基于UVM的验证平台，或者简称为UVM验证平台。 支持UVM的EDA厂商：Cadence、Synopsys、Mentor\u0026hellip;  UVM基础 一个基于SV的简单验证平台 注：这里“基于SV”指平台仅仅使用SystemVerilog语言搭建。\n     一个基于UVM的简单验证平台      基于UVM验证平台原则  类： UVM中几乎所有的东西都是用类(class)来实现的，所以，搭建uvm平台第一条原则，所有的组件都用类来完成。 基于UVM类： 当要实现一个功能时，首先应该想到的是从UVM的某个类派生出一个新的类来实现期望功能，所以，搭建uvm平台第二条原则，所有的组件应该派生自uvm类。  UVM中两大最重要基类  uvm_object： 它是UVM最基本的类，几乎所有的类都派生自uvm_object，它的拓展性是最好的，当然能力也是最差的。它主要构成了环境的属性（例如配置）和数据传输。 uvm_component： 它派生自uvm_object ，却拥有自己独有的强大特性，它有两大独有特点，一是通过new形成树形结构，二是自动执行phase。它主要构成了环境的层次。  UVM中常用类的继承关系      什么是UVM Factory 所谓Factory就是工厂，是通过一个字符串（类名）创建一个此字符串所代表的的类的一个实例，并且能够自动调用其phase执行的机制，也就相当于加工工厂。理解上可能比较抽象，我们举例来说明。\n如下图，一个汽车工厂好比我们的验证平台，支持宝马和奔驰两条生产线，两位老板只需下令生产奔驰还是宝马，工厂按照生产线自动加工，最终产出汽车，这里指令（奔驰/宝马）就是上述中的字符串，生产线就是调用其phase执行的机制，整个验证平台也就相当于工厂，这就是UVM Factory。\n     我们的工厂可以支持生产哪些“汽车”，是由验证平台决定的，如果向验证平台输入不支持的指令，比如指定工厂生产“永久自行车”，会被视为错误指令。\n     如果就想生产“永久自行车”，我们需要添加永久自行车生产线:\n     然后我们就可以向工厂输入指令，生产“永久自行车”了。\n     总结 ：\n run_test()语句会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的phase，但是前提是你已经注册了这个类。 对于uvm_component类，注册是通过uvm_component_utils宏来进行的。所有派生自uvm_component以及其派生类都应使用uvm_component_utils来注册 对于uvm_object类，注册是通过uvm_object_utils宏来进行的。所有派生自uvm_object以及其派生类(除uvm_component外)都应使用uvm_object_utils来注册 由上述例子可以看出：run_test()是启动整个验证平台的UVM库函数。  UVM验证平台启动执行流程      搭建UVM验证平台 UVM验证平台基本组成      一个只有driver的测试平台 driver代码示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class my_driver extends uvm_driver; //继承uvm库中的uvm_driver类  `uvm_component_utils(my_driver) //将my_driver类注册到factory  virtual my_if vif; //声明driver的interface, interface my_if的定义这里不再介绍  extern virtual function void build_phase(uvm_phase phase); extern virtual task void main_phase(uvm_phase phase); endclass function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)) `uvm_fatal(“my_driver”, “virtual interface must be set for vif !!!”) endfunction task void my_driver:: main_phase(uvm_phase phase); //略去 endtask   top_tb代码示例： 1 2 3 4 5 6 7 8 9 10  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  run_test(“my_driver”); //实例化my_driver类，实例的名字是uvm_test_top，并执行类my_driver中的main_phase任务  end endmodule   注意: uvm_test_top是run_test产生的my_driver类的实例化对象名字，run_test(“my_driver”)可以简单的看成:\n1 2  my_driver uvm_test_top； uvm_test_top.main_phase();   这里，任何被run_test()实例化的类的对象的名字都会被UVM平台默认成uvm_test_top，这个被实例化的类也就是整个uvm平台的顶层，而且只允许有一个顶层，即一个验证平台只调用一个run_test()。\ntop_tb顶层与uvm树形结构的交互：  uvm_config_db   1 2 3 4 5  function void my_driver:: build_phase(uvm_phase phase); //将顶层实例化的interface指针传递给driver的insterface  super.build_phase(phase); if(!uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)) `uvm_fatal(“my_driver”, “virtual interface must be set for vif !!!”) endfunction   top_tb顶层与uvm树形结构的交互为什么要用这种看起来很怪的uvm_config_db方式获得top_tb的interface，不能直接调用得到吗？ 按道理来讲，是可以的，uvm本来就是基于sv的函数库，其底层肯定也是有sv去实现的，既然uvm将其封装为uvm_config_db，建议统一使用此方法，使用uvm提供的函数也是最好的避免出错的办法。\n top_tb顶层与uvm树形结构：        如果将top_tb中的第3点去掉，请回答以下问题：  top_tb如何获取dut内部信号？答：通过top_tb.my_dut.xxx可以获取。 top_tb如何获取右侧树形结构的内部信息？答：通过top_tb.uvm_test_top.xxx是不可行的，因为run_test实例化了一个脱离了top_tb层次结构的实例对象，建立了一个新的层次，所以不能通过top_tb.uvm_test_top.xxx直接访问。所以针对这种情况，UVM引入了config_db的机制，也就是前面分别在top_tb和my_driver类中build_phase提到的:     1 2  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if) uvm_config_db# (virtual my_if)::get(this, “”, “vif”, vif)   这样我们通过uvm_config_db将top_tb顶层与uvm树形结构打通。\n top_tb与树形结构中driver的交互流：       注意：top\\_tb与树形结构之间的交互用虚线，是因为my\\_driver.interface.output\\_xxx不是直接给top\\_tb.interface.input\\_xxx传值，而是在采用了config\\_db机制后，类似于两边在操作同一个指针地址，即改变my\\_driver.interface.output\\_xxx的值，就等于直接改变了top\\_tb.interface.input\\_xxx中变量的值。另外：uvm\\_config\\_db将top\\_tb顶层与uvm树形结构打通，我们可以将top\\_tb与树形结构任意组件进行交互，而不仅限于driver和monitor。      树形结构构造 目前，一个只含有driver驱动的UVM验证平台已经形成，那么接下来要考虑树形结构的构造，即添加新部件并使其层次化。\ndriver、monitor、agent和env：      注意：此时树形结构的顶层变成了my\\_env, 所以在top\\_tb中run\\_test(“my\\_driver”)应改成run\\_test(“my\\_env”)，之前讲过,run\\_test(“my\\_driver”)实例化之后对象的名字是uvm\\_test\\_top, 那么run\\_test(“my\\_env”)实例化之后顶层对象的名字是什么？答案是仍然为uvm\\_test\\_top。树形结构发生了层次改变，此时top\\_tb怎么和my\\_driver交互？如下top\\_tb代码： 1 2 3 4 5 6 7 8 9 10 11 12  module tob_tb my_if input_if(clk, rstn); //声明top_tb的interface，在dut实例化时可直接使用  dut my_dut(.clk(clk), .rst_n(rst_n), .rxd(input_if.data)); //dut实例化  initial begin // uvm_config_db# (virtual my_if)::set(null, “uvm_test_top”, “vif”, input_if)  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.agt.drv”, “vif”, input_if) //与driver的interface建立连接，将top_tb.input_if与my_driver.vif连接起来  // run_test(“my_driver”)  run_test(“my_env”); //实例化my_env类，实例的名字是uvm_test_top，并执行类my_env中的phase  end endmodule   加入checker：      注意：这里的checker是将reference model和scoreboard统一看成一个整体。reference model和scoreboard的定义和其他component的方式一样，这里不再赘述。  树形结构通信通道       加入sequencer：      这里sequencer是一个固定组件，sequencer主要将激励承接给driver，my\\_transaction是一个数据包，也就是测试激励，这里还要有一个sequence概念，sequence里存放一组trans，提供给sequencer，可见sequencer属于component类，sequence和trans属于object类。关于sequencer、sequence和trans，还有这样一个比喻，trans好比子弹，sequence好比弹夹，而sequencer是枪。 加入transaction：       transaction使用`uvm_object_utils注册。 transaction可以看成是数据包，把数据打包传输，便于交互。 在组件之间(driver,checker,monitor等)的信息传递都是基于transaction。  加入transaction后driver的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class my_driver extends uvm_driver #(my_transaction); //uvm_driver是参数化类，参数类型为my_transaction  `uvm_component_utils(my_driver) virtual my_if vif; …… endclass task void my_driver:: main_phase(uvm_phase phase); 将： vif.data \u0026lt;= 8’b1; 改成： req = new(“req”); //等价于my_transaction tr; tr = new(“tr”);  req.data = 8’b1; //等价于tr.data = 8’b1;  vif.data \u0026lt;= req.data; //等价于vif.data \u0026lt;= tr.data; endtask    req是父类uvm_driver中变量，类型是传递给uvm_driver的参数，这里传递的参数是my_transaction，所以父类uvm_driver中的req类型就是my_transaction。 my_driver继承了uvm_driver类，所以可以直接使用uvm_driver中的req，而不需要在my_driver中声明定义req。  加入sequence： 前面所示代码中激励都是在driver产生的，正常情况driver只是传递激励，而不是产生激励，所以要将激励产生从driver中移除，从外界获得激励，那driver的激励应该从哪里产生呢？这就是sequencer要做的事情，也就是说sequencer要提供req(这里为my_transaction)给my_driver。那么sequencer的transaction从哪里来？\n     `uvm_do(my_trans)实现了以下操作:\n 创建一个my_transaction的实例my_trans 将其随机化 最终将其传送给my_sequencer(此宏不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer)  sequence工作机制：\n      对于1， my_sequencer等待。 对于2， my_sequencer等待。 对于3， my_sequencer将my_sequence中的my_trans发送给my_driver。  待解决问题：\n my_driver如何向my_sequencer发送transaction接收请求？ my_sequence如何向my_sequencer发送transaction？  my_driver向my_sequencer发送申请：      注意：  seq_item_port是uvm_driver中的成员变量。 seq_item_export是uvm_sequencer中的成员变量。  my_sequence向my_sequencer发送my_transaction： 前面提到， my_sequence中的`uvm_do不能做到自动连接my_sequencer并将my_trans直接传送给my_sequencer，所以需要额外启动连接，以在当前顶层my_env中手工启动为例(一般都是在顶层启动)：\n1 2 3 4 5  task void my_env:: main_phase(uvm_phase phase); my_sequence seq; seq = my_sequence::type_id::create(“seq”); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask        my_sequence自动启动机制default_sequence： 前面my_sequence是在my_env中手工启动的，default_sequence可以自动启动my_sequence 。\n1 2 3 4 5 6 7 8 9 10  task void my_env:: main_phase(uvm_phase phase); 将下列代码去掉： my_sequence seq; seq = my_sequence::type_id::create(“seq”); seq.start(agt.sqr); //将此sequence产生的transaction发送给agent中的my_sequencer. endtask virtual function void my_env::build_phase(uvm_phase phase); uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endtask   树形结构通信通道变化： 原始：\n     现在：      注意：  蓝色部分: top_tb与树形结构的连接 紫色部分: transaction在my_checker和monitor之间的通信通道 红色部分: transaction在my_sequence,my_sequencer和my_driver之间的通信通道 单箭头虚线部分: 实际没有显性直接通道，均通过上一层connect实现 双箭头虚线部分: 代表同一模块  截至目前的树形结构：      目前，树形结构除my\\_case0顶层之后，均已构建完成，并全部打通。后面要添加my\\_case0。 加入base_test：      base_test.sv代码:\n1 2 3 4 5 6 7 8 9 10  class base_test extends uvm_test; `uvm_component_utils(base_test) my_env env; //my_env会在base_test中实例化,base_test取代env称为顶层。 endclass function void base_test::build_phase(uvm_phase phase); //my_sequence需要在顶层启动连接,因为base_test变成顶层,所以从my_env中移到此处  uvm_config_db# (uvm_object_wrapper)::set(this, “env.agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endfunction   top_tb.sv代码:\n1 2 3 4 5 6 7 8 9 10  module tob_tb initial begin // 将： // uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.agt.drv”, “vif”, input_if) // run_test(“my_env”); // 改成：  uvm_config_db# (virtual my_if)::set(null, “uvm_test_top.env.agt.drv”, “vif”, input_if) run_test(“base_test”); end endmodule   加入my_case0：      1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下重载了base_test中的my_sequence的启动，注意bast_test中的仍保留。  uvm_config_db# (uvm_object_wrapper)::set(this, “env.agt.sqr.main_pahse”, “default_sequence”, my_sequence::type_id::get()); endfunction   注意：\n my_case0是继承了base_test的一个子类, 是base_test的一个更具体的实现，也就从这里形成了testcase的概念，这个testcase的名字就是my_case0。 my_case0没有改变激励产生的方式，即仍然是启动了my_sequence，并利用my_sequence中`uvm_do(my_trans)来全随机产生激励。  加入my_case0_sequence： my_case0_sequence.sv代码:\n1 2 3 4 5 6 7 8  class my_case0_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8’hff;}) endtask endclass   注意：\n my_case0_sequence是继承了my_sequence的一个子类, 是my_sequence的一个更具体的实现。 my_case0_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’hff的数据激励。  my_case0.sv代码:\n1 2 3 4 5 6 7  class my_case0 extends base_test; `uvm_component_utils(my_case0) endclass function void my_case0::build_phase(uvm_phase phase); //以下将my_case0_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_case0_sequence::type_id::get()); endfunction   注：\n 这里制造了一个用例my_case0，此用例每个transaction产生8’hff数据的激励。 这里my_case0成为新的顶层。  将顶层base_test替换成my_case0： 1 2 3 4 5 6 7 8  module tob_tb initial begin // 将： // run_test(“base_test”); // 改成：  run_test(“my_case0”); end endmodule   run_test()作用：它会通过传入的字符串，创建一个类名为输入字符串的类的实例，并且会自动调用此类的main_phase。\nrun_test给我们最初的印象是构建了一个脱离了top_tb的树形结构，并完成了所有内部需要交互部件的打通。现在我们需要改变一下思维，这里当调用run_test(“my_case0”)时，不再考虑树形结构，我们用一个更抽象的概念来描述run_test的行为，那就是：它执行一个用例my_case0，而且只有一个用例在执行，这条用例每个transaction都在产生数值为8’hff的数据。我们平时所谓的跑各种各样的用例，这些用例其实都是基于这个去构造和命名的(在uvm平台中)。\n用例构造 构造另一个用例my_case1:\n my_case1_sequence.sv:   1 2 3 4 5 6 7 8  class my_case1_sequence extends my_sequence #(my_transaction); `uvm_object_utils(my_sequence) my_transaction my_trans; virtual task body(); `uvm_do_with(my_trans, {my_trans.data == 8’haa;}) endtask endclass   注意：my_case1_sequence重载了my_sequence 的body()任务，并利用`uvm_do_with()来产生次数值都为8’haa的数据激励。\n my_case1.sv:   1 2 3 4 5 6 7 8 9  class my_case1 extends base_test; `uvm_component_utils(my_case1) endclass function void my_case1::build_phase(uvm_phase phase); //以下将my_case1_sequence中的trans传递给了sequencer，最终传给driver。  uvm_config_db# (uvm_object_wrapper)::set(this, “agt.sqr.main_pahse”, “default_sequence”, my_case1_sequence::type_id::get()); endfunction   注意：这里制造了一个用例my_case1，此用例每个transaction产生8’haa数据的激励； 如果想要运行这个用例，那my_case1将成为新的顶层，也就是将top_tb中的 run_test(“my_case0”) 改为 run_test(“my_case1”)\nUVM测试用例启动 由于run_test在top_tb中只能调用一次，所以每次跑新的用例，都要手动改一下run_test()的参数名字，试想我们有10000个用例，如果都手动改，那肯定是不可行的，所以UVM提供了另外一种启动方式。\n1 2 3 4 5  module top_tb initial begin run_test(); end endmodule   此方式将run_test()中的参数去掉，并利用UVM_TESTNAME从命令行中获得测试用例的名字，例如:\n\u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case0 \u0026lt;sim command\u0026gt; … + UVM_TESTNAME=my_case1 注：sim command为eda厂商提供的仿真命令，后面会有介绍。\nUVM验证平台启动和封装 非基于uvm验证平台仿真启动 注意：.f文件里分别是验证环境和设计的代码文件列表。\n sysnopsys:  编译：vcs –f env_vcs.f –f design_vcs.f –verdi_compile_option –coverage_compile_option …… 仿真：./simv –verdi_rrun_option –coverage_run_option ……   cadence:  编译：irun –f env_irun.f –f design_irun.f –verdi_compile_option –coverage_compile_option …… 仿真：irun –verdi_irun_option –coverage_run_option …… 编译：xrun –f env_xrun.f –f design_xrun.f –verdi_compile_option –coverage_compile_option …… 仿真：xrun –verdi_run_option –coverage_run_option ……    基于uvm验证平台仿真启动  sysnopsys:  编译：vcs –f env_vcs.vf –f design_vcs.f –verdi_compile_option –coverage_compile_option –ntb_opts uvm …… 仿真：./simv –verdi_rrun_option –coverage_run_option +UVM_TESTNAME=my_case0 ……   cadence:  编译：irun –f env_irun.vf –f design_irun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：irun –verdi_irun_option –coverage_run_option +UVM_TESTNAME=my_case0 …… 编译：xrun –f env_xrun.vf –f design_xrun.f –verdi_compile_option –coverage_compile_option –uvm +UVM_TESTNAME=my_case0 …… 仿真：xrun –verdi_run_option –coverage_run_option +UVM_TESTNAME=my_case0 ……    注意：需要在env.vf中包含uvm的库文件：\n$UVM_HOME/src/uvm_macros.svh $UVM_HOME/src/uvm.sv $UVM_HOME/src/uvm_pkg.sv $UVM_HOME/dpi/uvm_dpi.sv +incdir+$UVM_HOME/src 对于vcs和irun/xrun还有一点需要注意：\n 对于vcs,使用uvm库时需: include ”uvm_pkg.sv” 对于irun/xrun,使用uvm库时需: import uvm_pkg::*  基于uvm验证平台的封装 为什么要对验证平台封装？ 到目前为止，我们就可以利用基于uvm的验证平台跑用例进行验证了。经历了漫长痛苦的uvm环境开发之后，当我们在自己独立开发的uvm验证环境中，成功跑完第一条用例my_case0仿真用例的那一刻，发现之前的付出都是值得的，当我们利用自己制造的人生第一条用例my_case0找到人生第一个设计bug的那一刻，发现人生已经达到了巅峰。但是作为一名优秀的验证工程师，我们的成就不仅如此，因为我们的目的不仅仅是找到bug，而是快速高效的找到bug。\n当基本验证平台可以使用，进入初期验证阶段之后，你会发现，可能会有不同的验证工程师在此验证环境中开发新的功能，可能会有不同的设计人员在此验证环境中复现bug，也可能包括自己在内的工程师需要在此验证环境中运行各种各样配置的用例，如果每次都需要自己去改变底层仿真命令或者告诉其它人怎么改底层仿真命令，你会发现整个人都不好了。而且如果所有人都自己去手动改环境底层代码跑用例，到最后整个验证平台也会变得非常杂乱，非常不好维护，并且就实际情况，大部分设计工程师是不接受每次跑用例都需要自己手动改代码的。\n为了解决这些问题，使环境变得更加整洁高效，维护简单，便于扩展，我们将环境进行封装。\n封装的原则是什么？  对自己白盒： 所有的底层运行验证环境的编译选项和仿真选项都要自己维护开发；所有的新的开发需求需要自己来指定结构和位置；所有的内部uvm固有部件骨架都要自己维护开发。 对验证工程师灰盒： 熟悉整体环境运行原理；熟悉各编译和仿真选项含义，验证过程中知道如何增减选项；在指定的结构和位置开发新的功能；不需要对此uvm环境固有骨架进行全面掌握。 对设计工程师黑盒： 不需要知道任何环境内部构造，只需要按照验证工程师提供的脚本命令运行用例即可。  如何对验证平台封装？ 环境采用脚本封装，一般只需提供命令和接口选项，脚本可以使用Makefile，python，perl，shell等。以python脚本封装为例。\n 仿真命令： ./runtest.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim  seed : 提供仿真种子号 -dump : 产生波形 -cov : 打开code coverage收集 -funcov : 打开function coverage收集 -debug : 仿真结束后自动弹出波形 -covermerge : 仿真结束后自动merge coverage数据 simpath : 指定生成log的文件夹    上述接口选项最终都会呈现在底层编译和仿真命令中，使用者可以根据需求打开关闭提供选项，而不必需要知道环境内部的细节。如果有新的需求，开发完毕后提供对应的接口即可，大大减少了使用的低效性。\n封装脚本的构造 封装脚本一般分为两部分： 单条用例运行脚本 和 回归用例运行脚本。\n  单条用例运行脚本：\n 用户提供testcase list。 根据脚本提供用例名字在tclist找到对应的用例属性，包括uvm中提供的test名字(如my_case0),用例所在路径等。 在sim下创建以用例名字+种子号命名的文件夹，后面生成的这条用例的所有相关信息，包括log和波形等都会存放在这里。 根据脚本提供选项进行整个环境的编译工作。 根据脚本提供选项进行整个环境的仿真运行。 用例运行结束后，根据仿真产生的log，得到并打印出pass还是fail的信息，方便使用者进行快速判断。 使用者到对应的sim/testcase_name_seed/下查找所有相关log和波形，进行相关debug。 添加其它功能，例如coverage的merge，但是一般只有回归才会涉及到merge的工作，所以这部分功能可以放到回归脚本中。    回归用例运行脚本：\n 识别脚本提供的tclist中提供的回归组名，将所有指定组的用例进行仿真回归。 内部调用单条用例脚本，并将回归用例脚本输入参数全部转换为单条用例脚本输入参数需要的格式。 监测每条用例的仿真结果，并累加计数得到总的tc数，总pass tc数，总fail tc数，和总的没有产生仿真log的tc数。 判断是否所有用例运行结束，并打印最终回归报告。 如果打开coverge merge选项，会自动merge所有回归用例的coverage数据。 回归结束后在sim下生成pass，fail的tclist, 同样每条用例的结果也都存在以用例名字+种子号命名的文件夹中，可以实时查看。    跑单条用例命令： ./rt.py testname=my_case0 seed=123456 –dump –cov –funcov –debug –covmerge simpath=./sim\n  跑回归用例命令： ./rt.py –regress –rgr_group=my_regression -seedrand –dump –cov –funcov –covmerge simpath=./sim\n  UVM验证平台的优化 优化目的是什么？  针对平台结构优化： 使环境结构简洁，清晰明了，重用性好，移植性强，拓展性高，让新的用户和开发者能够快速切入。 针对平台性能优化： 使环境运行速度提升，提高验证效率  如何优化验证平台？   针对平台结构优化：\n 加入readme，包含运行方法等必要信息。 加入setup脚本，所需一切配置均在此一键完成。 环境中用到所有路径宏均统一管理，方便更改和移植。 运行中间文件统一管理，方便查看和删除。 目录结构清晰，文件夹命名需简洁易懂。 删除开发过程中的无效代码和目录。 加入必要信息打印开关，方便读取层次结构。 撰写平台使用手册，进行环境详细说明。    针对平台性能优化：\n 检查变量定义，减少存储空间占用，如需要超大容量数组时，需使用关联数组。 检查哪些任务可以并行执行，改成fork_join*多线程机制。 检查是否transaction约束过多，如过多速度会明显变慢。 检查dut文件列表，去掉不必要文件，减少环境编译时间。 检查是否有不必要打印，关掉以减少log输出占用的时间。 检查model，checker，driver中是否有过多占用时间的函数，重新考虑是否有高效替代方案。 利用第三方工具得到平台各个部件的时间占用分布，分析占用最多的几个部件原因，寻找解决方案。    uvm验证平台目录组织结构 verif/my_ut/env下文件：\n agents/ ： agent文件目录，内含一个或多个agent，agent包含driver、sequencer、monitor组件，agent从行为上可以理解为与dut交互的模块或组织。 coverage/ ： coverage文件目录，内含一个或多个模块的覆盖率文件，也就是covergroup。 checker/ ： checker文件目录，也就是reference model和scoreboard文件，不过有时候会将两者融合成一个checker文件。 include/ ： include文件，一些环境路径的宏定义以及其他include文件存放在这里。 interface/ ： interface文件目录，内含一个或多个接口文件。 script/ ： script文件目录，一些验证平台封装的脚本文件存放在这里。 setup/ ： setup文件目录，一些平台初始化文件存放在这里，如环境变量的初始化和工具的配置。 tests/ ： tests文件目录，所有测试用例存放在这里。 readme ： readme文件，对环境和使用的说明文件。 tb.v ： tb文件，顶层testbench。 env_vcs.f ： env_vcs.f文件，针对vcs工具的filelist文件，包含设计和验证平台的文件列表。 env_xrun.f ： env_xrun.f文件，针对xrun工具的filelist文件，包含设计和验证平台的文件列表。 tc.list ： tc.list文件，包含所有测试用例信息，可为测试用例设定分组，方便回归测试。 my_env_cfg.sv ： my_env_cfg.sv文件，整个验证平台的配置文件，内含静态变量，可传递至平台任意模块，完成验证平台的配置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":7,"section":"docs","tags":["UVM"],"title":"UVM与验证平台","uri":"https://wenhui.space/zh/docs/digital_verifer/other/uvm_and_verification_platforms.html"},{"content":"本文 主要介绍一种有效解决RTL编译时依赖关系问题的方法。\n   版本 说明     0.1 初版发布    关于include 一般在文件中会用include来加载依赖的文件，其效果就好比将依赖文件的内容复制粘贴至此。当然你可以将所有依赖文件都进行include，也就是不仅仅是宏定义文件和函数文件，还包含子模块的文件，这样层层include，自然形成一个完整的编译顺序，而只需要给工具指定最顶层的文件和提供include路径即可。但是并不建议这样实现，因为除了影响代码整洁性（可能某模块子模块众多），还会使代码难以维护。所以我们一般只include宏定义文件和函数文件，这样指定的include路径也会很清楚。\n有时候一个文件可能会被多个文件include，为了防止被重复编译，往往会加上ifdef判断条件。虽然重复编译不一定带来问题，但毕竟也影响了编译效率，所以还是要尽量消除重复编译。方法如下：\n1 2 3 4 5 6 7 8  `ifndef __file_name `define __file_name  //....... //File content...... //.......  `endif   在文件的开头和结尾添加如上内容后，当第一次编译该文件时，不会有“__file_name”的宏定义，所以编译文件内容，当再次编译该文件时，已经定义“__file_name”，ifndef的判断会使该文件不被重复编译。这样的方法是被推荐的，建议所有文件的头尾都添加如上内容。\n关于filelist 一般工程中都会用filelist文件来进行维护，这也是最方便的。filelist文件描述的顺序，就是编译顺序，所以这里要小心，要将最底层模块定义到前列，优先编译，否则编译其他模块时找不到其依赖模块，会报编译错误。这里提供两个技巧：\n 较大设计中，分割子模块，定义各个子模块的的filelist，在上层filelist中采用“-f path/xxx_subfilelist”的形式引入子模块filelist（注意要指明路径），这样由子模块的设计师维护子模块的filelist，待合并系统时，再合并filelist。 加载某一目录下的文件，可以使用“-y”，而不必关心编译顺序，工具会自动识别顺序，使用方法为：  “+libext+.v+.sv”（指明加载后缀为.v和.sv的文件） “-y file_path”（加载该路径下所有后缀为.v和.sv的文件）   “-y” 的使用其实是加载库文件的方法，为了不将设计扁平化，需要在verdi打开时添加“-ssy”，这样可以保持设计的层次化。 include路径必须添加在filelist前部。  示例：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/other_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 “+define+”是传入define参数。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":8,"section":"docs","tags":["Verilog"],"title":"如何更好的解决RTL编译时依赖关系问题","uri":"https://wenhui.space/zh/docs/digital_designer/other/resolve_dependencies_rtl_compile.html"},{"content":"本文 主要介绍一款自动插入英文翻译的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  Emacs: 自动插入翻译后的字符串 Github：insert-translated-name  补充说明： 这个英文补全的emacs插件是基于google翻译的，可能需要先安装google翻译才可以使用，由于安装此自动插入英文翻译的插件时已经安装google翻译，所以并未考证。如果需要安装google翻译，请参考我的另一篇帖子 GoldenDict的安装 中 添加google翻译这一节。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":9,"section":"docs","tags":["emacs"],"title":"emacs插件之自动插入英文翻译","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_insert_english_translate.html"},{"content":"本文 主要介绍debug工具Verdi的使用，并对自己使用过程中的经验进行总结。\n   版本 说明     0.1 初版发布    参考  Verdi and Siloti Command Reference Verdi (Premier) Training  百度网盘分享资源 链接：https://pan.baidu.com/s/1h5xm8-poxOwjL14MzBH4pw 密码：4kb6\n专业术语与缩略语    缩略语 全称 含义     RMB Right Mouse Button 鼠标右键   MMB Middle Mouse Button 鼠标中键   LMB Left Mouse Button 鼠标左键   DC Double-click 双击   D\u0026amp;D Drag and Drop 拖拽   KDB Knowledge Database 知识数据库   FSDB Fast Signal Database 快速信号数据库   TFV Temporal Flow View 时序界面   BA Behavior Analysis 行为分析    Set Up the Environment 指定路径和环境变量  Binary File：   1 2  setenv NOVAS_INST_DIR \u0026lt;Path to Novas installation\u0026gt; set path = ($NOVAS_INST_DIR/bin $path)    License File：   1 2  setenv NOVAS_LICENSE_FILE \u0026lt;license_file\u0026gt;:$NOVAS_LICENSE_FILE   添加符号库  为什么使用符号库：  符号库提供了源代码到逻辑单元的映射，没有符号库，原理图将仅显示正方形而不是逻辑单元。\n 创建符号库：  syn2SymDB:适用于 ASCII格式的Synopsys logic library(.lib) map2SymDB:适用于已有的map file 参考\u0026lt;verdi_install\u0026gt;/doc/Symbol_Library.pdf   设置符号库环境变量：   1 2  setenv NOVAS_LIBS\u0026#34;LIB ROOT#1\u0026gt;\u0026lt;LIB ROOT#\u0026gt;…\u0026#34; setenv NOVAS_LIBPATHS\u0026#34;\u0026lt;Directory#1\u0026gt;\u0026lt;Directory#2\u0026gt;…\u0026#34;    通过GUI设置符号库：  菜单栏点击Tools–\u0026gt;Preferences 在打开的子窗口中 Find一栏 查找 Schematic \u0026ndash;\u0026gt;Symbol Library 填写Symbol Library Name 填写Symbol Library Path 保存，然后设置将被保存到novas.rc 源文件中。    使用Setup文件 novas.rc  指定路径：  setenv NOVAS_RC /novas.rc 直接通过命令行命令 -rcFile 来进行设置   搜索顺序：  -rcFile 命令行选项 NOVAS_RC环境变量 ./novas.rc $HOME/novas.rc /etc/novas.rc    首选项 通过Tools–\u0026gt;Preferences打开窗口，所有设置将被保存在novas.rc文件中，在Find窗口栏中根据关键字搜索。比如设置字体大小和颜色，在find栏搜索font，找到相关项，设置完毕后保存为novas.rc，可添加为Verdi的Setup文件，一劳永逸。\nFSDB   什么是FSDB文件：\n 压缩的二进制文件格式，包含仿真信号数据。 开放文件格式，其他的供应商工具可以dump波形，比如Verisity，Vera，Ikos，etc. 利用System Task来帮助dump。    常用的系统任务：\n fsdbDumpfile： 指定FSDB文件名和限制文件大小(单位MB，若超出限制只保留最新，也可不限制大小)，如 “$fsdbDumpfile(\u0026ldquo;top.fsdb, 500\u0026rdquo;);” 。 fsdbDumpvars： Dump指定变量，可以指定dump特定的实例和层次深度，可以指定FSDB文件名，以及指定其他option参数，如 “$fsdbDumpvars(0, top.dut1.u1, \u0026ldquo;+fsdbfile+u1.fsdb\u0026rdquo;, \u0026ldquo;+all\u0026rdquo;);”，也可以使用“$fsdbDumpvarsToFile(\u0026ldquo;dump.list\u0026rdquo;);”。 fsdbDumpon/fsdbDumpoff： 打开和关闭fsdb Dumping，如 “#0; #50000 $fsdbDumpvars; #50000 $fsdbDumpoff; #50000 $fsdbDumpon; #50000 $finish;”，指保存50000~100000和150000~200000时间段波形。 提示：更多信息请查看文档linking_dumping.pdf。    为FSDB dumping 链接Novas Object文件  创建环境变量：   1 2 3 4 5 6 7 8  #Setup license file for simulator setenv LM_LICENSE_FILE \u0026lt;simulator_license_file\u0026gt; #Setup path for simulator setenv \u0026lt;Simulator\u0026gt;_INST_DIR \u0026lt;simulator_tool_install\u0026gt; #Setup path for Novas tool setenv NOVAS_INST_DIR \u0026lt;Novas_install_path\u0026gt; #Setup LD_LIBRARY_PATH to specify the appropriate shared object files setenv LD_LIBRARY_PATH ${NOVAS_INST_DIR}/share/PLI/\u0026lt;simulator\u0026gt;/\u0026lt;platform\u0026gt;   FSDB文件处理  vfast： 将VCD文件转化为FSDB文件。 fsdb2vcd： 将FSDB文件转化为VCD文件。 fsdbextract： 在已经存在的fsdb文件中提取信号，范围，时间周期，而不用重新进行仿真。 fsdbmerge： 将多个文件进行合并。 fsdbreport： 针对一个特定的信号，将值得变化情况生成report。 提示： 使用 “ -h” 查找帮助，或参阅《 Verdi Command Reference》。  Import Design 命令行导入设计 1 2 3 4  verdi -f \u0026lt;file_list\u0026gt; +define+GETTHEMOSTOUTOFYOURTIME verdi -f \u0026lt;file_list\u0026gt; -top TopBlock verdi \u0026lt;source_file1.v\u0026gt; -sv \u0026lt;source_file2.sv\u0026gt;… verdi system.v ... alu.v -v lib.v -y ../special -ssv -ssy   推荐使用命令： “verdi -f run.f -ssv -ssy” ，其中run.f内容如下：\n+define+VCS_DUMPON=1 +incdir+$PROJ_ENV/include_dir1 +incdir+$PROJ_ENV/include_dir2 $PROJ_ENV/test_top_tb.v +libext+.v +libext+.sv -v $PROJ_ENV/lib_path/lib1.v -v $PROJ_ENV/lib_path/lib2.v -y $PROJ_ENV/design_sub_dir1 -y $PROJ_ENV/design_sub_dir2 -y $PROJ_ENV/design_sub_dir3 -y $PROJ_ENV/design_top_dir $PROJ_ENV/other_design_path/other_design1.v $PROJ_ENV/other_design_path/other_design2.v ............. 说明如下：\n -f代表读取flist文件。 -ssv和-ssy是对-v导入的库文件和-y指定的路径中的模块被视为普通模块，而不是库单元，如果库单元的话会无法显示Hierarchy。 -y指定文件目录的导入方式，无需关心具体模块的依赖关系。 +incdir+是指定include文件的路径。 “+libext+.v”是指定文件后缀，若文件为sv格式，则指定为sv。 +define+是传入define参数。  图形化界面上导入设计  命令行输入verdi ，打开verdi 图形化界面。 菜单栏File-\u0026gt;Import Design 或 菜单栏上的Import Design符号 导入设计。 选择language、run file或源文件，不建议使用VHDL。  Debug in Source Code View Open nTrace Window  导入设计后，Verdi会自动打开nTrace窗口。 nTrace窗口包含三个可调整大小的子窗口：左侧Hierarchy Browser Pane，右侧Source Code Pane，下方Message Pane。  Search and Collapse Hierarchy Browser  折叠全部区域： 在hierarchy browser pane，点击鼠标右键选择Collapse All Scopes 折叠和展开选中项： 在hierarchy browser pane，点击所选项的“+”即展开，“-”即折叠。 搜索： 在hierarchy browser pane，点击鼠标右键选择Show Navigation TextField（快捷键Ctrl+s）。  在搜索框输入通配符字符串并回车即可，如CH*，可匹配CHILD1、CHILD2、CHILD3\u0026hellip; 搜索框右侧提供了prev和next操作，并且可以选择搜索记录。 在Filter搜索框输入通配符字符串，选择匹配项（模块、函数、任务、类\u0026hellip;），回车显示所有匹配结果   所选项（一般指module）鼠标双击，即可显示Source Code 所选项鼠标右键可选择Copy Full Path（或快捷键Ctrl-H），这对验证环境中需要引用信号需要全路径时非常有用。 所选项鼠标右键可选择Set/Unset Bookmark，可设置和取消书签，在在hierarchy browser pane右键选择Manage Bookmarks可快速回到书签标记项。 Instance显示层级关系，也可以选择Declaration，将所有模块平铺显示，搜索功能与上文描述相同。 快捷键Shift-S打开Find Scope窗口，可以查找模块、任务、函数等，列出模块名和例化列表（全路径）， 查找模块推荐使用此方法 。  Traverse Source Code  快速搜索信号、实例或实例端口： 使用快捷键Shift-A打开Find窗口，编辑框内显示当前打开的Source Code模块全路径，如果此模块内查找则保留全路径，在最后编辑通配符字符串，如果全设计中搜索，则删除全路径，直接编辑通配符字符串， 查找信号推荐使用此方法 。 查找字符串： Source Code窗口上方工具栏有搜索框，编辑通配符字符串即可全文搜索，支持Prev和Next，以及历史记录（注：通配符为*，可代表任意字符串）。 使用书签： Source Code窗口上方工具栏有书签图形，点击可将当前Source Code的当前行设置/取消书签（也可使用快捷键Ctrl-F2），在菜单栏Source选中Manage Bookmarks打开Source书签管理窗口，可快速跳转至某书签位置。 多文件调试时推荐使用此方法 。 模块的层次跳转： Source Code窗口上方工具栏有向上直角箭头和向下直角箭头两个图标，向上箭头代表跳转到当前模块的例化语句，向下箭头代表进入此例化模块（选中例化名）/双击亦可。 双击模块名： 双击Source Code窗口打开的模块名，跳转到上层模块例化当前模块的语句，并且在message窗口列出例化此模块的文件全路径、文件名以及行号，双击message信息可跳转至该模块被例化语句。 撤销操作： Source Code窗口上方工具栏有向左箭头和向右箭头两个图标，代表操作的回退和前进。  Operate on Signals  信号的Driver and Loads： Source Code窗口上方工具栏有“D”和“L”图标和向上箭头和向下箭头图标，选中信号，D代表查看driver，L代表查看load，箭头代表Prev和Next，双击信号也可以达到查看Driver效果。 选中信号并右键可选择Copy Signal\u0026rsquo;s Full Path，这对验证环境中需要引用信号需要全路径时非常有用。 Load Simulation Results： 菜单栏File -\u0026gt; Load Simulation Results 加载FSDB文件，也可以在打开verdi时命令行添加参数-ssf nova.fsdb。 Source Code窗口显示信号值： 当加载FSDB文件后，光标停留在Source Code窗口，使用快捷键x，可以在代码中显示信号值，当前仿真时间在上方工具栏显示，且可调整，可选择信号下/上一个值变化（沿）来跳转模拟时间，注意信号值与波形窗口光标所在模拟时间保持一致，建议通过波形窗口来控制模拟时间的跳转。 将信号添加到波形窗口： 选中信号（按住Ctrl可选择多个信号），鼠标右键选择Add Signal(s) to Waveform， 建议使用快捷键Ctrl+w 。 选中信号鼠标右键选择Signal，可以设置Radix，默认十六进制。  Debug in Waveform View Open nWave Window  选择Tools -\u0026gt; New Waveform 或者 点击菜单栏波形窗口图标。 加载FSDB文件后，选中信号，使用快捷键Ctrl+w，将信号添加到波形窗口，工具会自动打开波形窗口。 使用命令行如“verdi –f run.f –ssf nova.fsdb”启动verdi时，会自动打开波形窗口。 在波形窗口也可以加载FSDB文件，波形窗口菜单栏File -\u0026gt; Open 或 使用工具栏打开文件图标。  Add Signals  Source Code窗口选中信号使用快捷键Ctrl+w可以添加信号到波形窗口。 波形窗口菜单栏Signal选择Get Signals 或 使用工具栏信号图标，将打开添加信号窗口，可以选择当前模块的输入、输出、寄存器、线网等信号，或搜索信号，添加至波形窗口。 提示： debug时往往边分析代码边查看波形，使用场景更多是一个个添加追踪，所以大多使用Ctrl+w； 而波形窗口菜单栏添加信号，往往在查看输入输出信号x态时使用，统一添加所有输入输出端口信号，而无需一一添加。  Organize Signals  创建信号组： RMB -\u0026gt; Group Operations -\u0026gt; Add Group to add groups； RMB -\u0026gt; Group Operations -\u0026gt; Insert Subgroup。 修改组名： 选中组，RMB -\u0026gt; Rename。 跳转至信号组： RMB -\u0026gt; Go To， 菜单栏也可操作。 折叠与展开组： 双击\u0026quot;+\u0026rdquo;/\u0026quot;-\u0026quot;。 添加空白分隔行： RMB -\u0026gt; Add Blank。  Operate on Signals  信号移动： 信号列表中金色标线代表移动至此，可通过鼠标中键调整金色标线位置，选中对应信号后，使用快捷键m，即可将信号移动至金色标线位置，并且金色标线移动至添加信号的下方（按住Ctrl或下拉可选择多个信号，按选择顺序添加）。 信号复制： RMB -\u0026gt; Copy， 快捷键Ctrl+P。 信号粘贴： RMB -\u0026gt; Paste， 快捷键Insert（粘贴至金色标线位置）。 删除信号： 选中信号按delet键（选中可以使用按住Ctrl或下拉选中多个信号）。 右键可复制信号全路径。 bus总线可以双击展开单bit信号显示，也可双击折叠。 bus总线可以分组显示，RMB -\u0026gt; Bus Operation -\u0026gt; Expand as Sub-bus， 可以设置每组bit数。 可将多个单比特信号组合为bus显示： RMB -\u0026gt; Bus Operation -\u0026gt; Create Bus。 可以添加注释： RMB -\u0026gt; Add Comment，添加注释行，在波形注释行右键可选择添加注释文本框，且文本框箭头可拖拽指向位置（个人觉得debug时使用不多，在做PPT展示讲解时很有必要）。 信号沿追踪和搜索信号值： 菜单栏有沿选择（任何变化、上升沿、下降沿、总线值等），左右操作图标（可向前跳转和向后跳转），当选择总线值时，左即向前搜索，右即向后搜索。 保存信号列表： 菜单栏File -\u0026gt; Save Signal，或快捷键Shift+s，打开Save Signal窗口，在默认路径后输入文件名（路径可修改），无需写文件后缀，默认后缀为“.rc”。注意：如果信号中有使用参数化表示范围，请在Options选项取消Events的选择，这样当参数变化时波形信号保持一致。 加载信号列表： 菜单栏File -\u0026gt; Restore Signal，如果在命令行则使用“–sswr .rc”。  Manipulate Waveform Display  设置标记： 菜单栏Waveform -\u0026gt; Marker 或 快捷键Shift+m，打开Marker窗口，可设置名称、时间、颜色、线的形状等，可对标记进行添加、删除、修改（标记也会保存至Signal文件），在debug时对信号的追踪使用标记很有用，可标记关键节点。 修改信号值显示进制： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Radix，可更改显示进制。 设置信号值显示别名： 在中间当前信号值显示窗口，光标停留在对应信号位置，RMB -\u0026gt; Edit Alias，打开Alias Editor窗口，可为数值设置别名，以及颜色（这对状态机State信号显示特别有用）， 使用apply可应用已设置的alias。 显示毛刺： View -\u0026gt; Display Glitch。 event报告： 选中信号，View -\u0026gt; Signal Event Report，可以显示信号信息，包括上升沿数量、下降沿数量、翻转频率，可选择统计起始和结束时间，这对统计某时间段clk（或其他信号）翻转数很有用，好像只能统计单比特信号。 添加网格： View -\u0026gt; Grid Options 打开Grid Options窗口，可以根据所选信号的上升/下降沿添加网格，也可以自定义周期在特定时间范围内添加网格，当波形窗口信号较多时添加参考网格非常有用。 选择一段时间： 鼠标中间设置起始位置， 鼠标左键设置终止位置。 选择无翻转信号： 首先选择一段时间，然后快捷键Ctrl+s，快速选择选择时间内无翻转信号。 波形显示窗口： Ctrl+鼠标滚轮，缩放窗口；鼠标拖拽选中区域填充整个窗口；Shift+鼠标滚轮，波形左右移动（时间前后）。  Debug in Schematic View 待补充\nDebug in FSM View 待补充\nDebug in Temporal Flow View 待补充\nFrequently Used Preferences 打开TCL命令窗口  Preferences -\u0026gt; General -\u0026gt; Enable TCL Command Entry Form(将其切换为选中状态)。 可以在TCL Command窗口输入TCL命令来执行，同时在Verdi中执行的任何操作，其对应TCL命令都将记录在此处（换句话说，你可以通过图形化操作来找到对应的TCL命令）。  Source Code 相关  关于Source Code窗口，最常用的设置无非是字体的大小，可以在这里找到，或直接搜索Font，找到Source Code的Font设置选项。  Waveform 相关  General： 可以设置以不同的颜色显示输入/输出信号。、 View Options： 可以设置进制、信号值与别名等。 Color / Font / Pattern： 可以设置外观和字体颜色大小等。  其他 关于首选项，可设置参数挺多的，不过一般不会使用到，也不建议做太多更改，我使用最多的就是对字符大小的更改，方便浏览代码。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":10,"section":"docs","tags":["EDA工具"],"title":"Verdi使用总结","uri":"https://wenhui.space/zh/docs/digital_verifer/other/verdi_userguide.html"},{"content":"本文 主要分享我摘自微博的关于美食系列漫画，作者为 心壹绘画 。\n展示   1      2      3      4      5      6      7      8      9      10      11      12      13      14      15      16      17      18      19      20      21      22      23      24      25      26      27      28      29      30      31      32      33      34      35      36      37      38      39      40      41      42      43      44      45      46      47      48      49      50      51      52      53      54      55      56      57      58      59      60      61      62    分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1elUURr8CgDQ4c91EEpZX3w 密码：1cz1\n","description":"","id":11,"section":"docs","tags":["美食"],"title":"我的收藏-美食漫画","uri":"https://wenhui.space/zh/docs/about_life/food-comics.html"},{"content":"本文 主要分享我收藏的中国烹饪古籍丛刊，文件为电子扫描版PDF格式。\n介绍 中国烹饪古籍丛刊是由中国商业出版社出版的，好像最早是1984年9月出版第一种《易牙遗意》，最晚是1993年出版的《太平御览·饮食部》，但始终不知总目，不知出版了多少种，我这里收藏的有33种。这些烹饪古籍，都是古代人智慧的结晶，也许对现在物质如此丰富且与时俱进的社会，不会有太多借鉴之道，但是由此可以了解到古人文人对吃文化的追求，以及关于吃的闲文趣事。\n我收藏的中国烹饪古籍丛刊共计33本，名录如下：\n 中国烹饪古籍丛刊 01 云林堂饮食制度集_11199761 中国烹饪古籍丛刊 02 易牙遗意_11404103 中国烹饪古籍丛刊 03 中馈录_11414100 中国烹饪古籍丛刊 04 醒园录_11131465 中国烹饪古籍丛刊 05 随园食单_11132930 中国烹饪古籍丛刊 06 素食说略_11132919 中国烹饪古籍丛刊 07 吕氏春秋本味篇_10508261 中国烹饪古籍丛刊 08 养小录_11404102 中国烹饪古籍丛刊 09 千金食治 食疗方_10807464 中国烹饪古籍丛刊 10 清异录（饮食部分）_10826528 中国烹饪古籍丛刊 11 闲情偶寄_10122795 中国烹饪古籍丛刊 12 齐民要术（饮食部分）_11122013 中国烹饪古籍丛刊 13 食宪鸿秘_11138805 中国烹饪古籍丛刊 14 随息居饮食谱_10093750 中国烹饪古籍丛刊 15 饮馔服食笺_11404150 中国烹饪古籍丛刊 16 饮食须知_10094041 中国烹饪古籍丛刊 17 能改斋漫录（饮食部分）_11476167 中国烹饪古籍丛刊 18 先秦烹饪史料选注_11476279 中国烹饪古籍丛刊 19 吴氏中馈录 本心斋疏食谱 （外四种）_11404172 中国烹饪古籍丛刊 20 居家必用事类全集（饮食类）_10508260 中国烹饪古籍丛刊 21 造洋饭书_11404173 中国烹饪古籍丛刊 22 菽园杂记（饮食部分）、升庵外集（饮食部分） 、 饮食绅言（饮食部分）_11404158 中国烹饪古籍丛刊 23 粥谱（二种）_10762172 中国烹饪古籍丛刊 24 山家清供_11046668 中国烹饪古籍丛刊 25 调鼎集_11550671 中国烹饪古籍丛刊 26 筵款丰馐依祥调鼎新录_11476281 中国烹饪古籍丛刊 27 饮膳正要_11500655 中国烹饪古籍丛刊 28 浪迹丛谈四种（饮食部分）_11622664 中国烹饪古籍丛刊 29 陆游饮食诗选注_11419091 中国烹饪古籍丛刊 30 随园食单补证_11473106 中国烹饪古籍丛刊 31 清嘉录_11622981 中国烹饪古籍丛刊 32 食疗本草_10444356 中国烹饪古籍丛刊 33 东京梦华录 都城纪胜 西湖老人繁胜录 梦粱录 武林旧事_10162520  分享 百度网盘分享资源： 链接：https://pan.baidu.com/s/1ald33jJK8y91vS7wwMNWYw 密码：srgf\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":12,"section":"docs","tags":["美食","读书"],"title":"我的收藏-中国烹饪古籍丛刊","uri":"https://wenhui.space/zh/docs/about_life/ancient_chinese_cooking_books.html"},{"content":"本文 主要介绍了一些verilog的编码风格准则。\n   版本 说明     0.1 初版发布    参考  RTL Coding Styles That Yield Simulation and Synthesis Mismatches（链接：https://pan.baidu.com/s/16fD72mrvHfSIA531h33J2A 密码：vzrl） VERILOG CODING STYLES FOR IMPROVED SIMULATIONEFFICIENCY (链接：https://pan.baidu.com/s/1r8RETSe3ehe2T%5FK5brZbjQ 密码：t2hp)  写在前头 本文主要从三个角度来对verilog编码风格进行说明：\n 利于模拟的编码风格：可以加快模拟速度或减少模拟占用内存。 利于综合的编码风格：可以减少综合前后模拟不一致问题。 利于维护的编码风格：有利于设计的维护、交互与修改，提高设计效率。  利于模拟的编码风格  多条件下尽量使用 case 语句，不使用嵌套 if-else if-else 语句，两者占用内存差不多，但模拟速度 case 比 if 要快。 不使用多余的 begin-end， always 或 if 语句中只有一条语句，是不需要使用 begin-end 的，多余的 begin-end 会占用更多内存和减缓模拟速度。 时钟信号产生，使用 always 语句描述模拟速度更快，如下代码：   1 2 3  reg clk； initial clk = 0； always #(`CYCLE/2) clk = ~clk;    尽量避免将赋值语句分散到多个 always 块，如寄存器的赋值，建议尽量将多个寄存器描述在一个 always 块语句，而不是将每个寄存器都用一个 always 块语句来描述，这样可以减少内存和提高模拟速度。 尽量减少模块的端口数，模块端口数越多，模拟速度越慢，因此需要对设计合理划分模块。 加载测试向量时，避免在时钟的上下沿变化，而是在延时一个时间单位后，这样更能够模拟真实电路的行为，为了便于维护，可以定义CYCLE数值，延时单位采用 “0.1*`CYCLE” 形式。 显示非阻塞赋值语句的变量值，使用 $strobe ，而不是 $display 和 $write 。下面介绍一下两者的区别，举例如下：   1 2 3 4 5 6 7  initial begin a = 0; $display(a); // displays 0 $strobe(a); // displays 1 ... a = 1; // ... 因为这条语句 end   可见 $strobe 是在整个块语句结束后执行的，而 $display 是在程序位置执行的。这里是一个顺序执行的块语句，而对于非阻塞赋值语句不是顺序执行的，所以在需要显示非阻塞赋值语句的变量值时，使用 $strobe ，确保能够取到稳定的赋值后的值。\n以上是公认的编码原则，强烈建议遵循，而下面内容，仅供参考：\n 尽量减少设计层次，层次越多模拟速度越慢。 parameter 比 define 更占用内存，但模拟速度相当。 `timescale 精度越高，模拟速度越慢。 $time 等系统调用程序非常影响模拟速度，可以使用但不要滥用。 不建议设计文件中写 `timescale ，建议写在单独文件，统一进行 `include ，或在仿真工具中参数化输入。  利于综合的编码风格  顶层模块不要有粘连逻辑，顶层模块甚至次顶层模块只用来例化和连接子模块，这样不仅可以节省顶层的编译时间，还有利于布局布线的实施。 减少不必要的设计层次，更多的层次会降低综合性能，当然也可以先使用工具将设计层次铺平，如 dc 的 ungroup 。 组合逻辑与时序逻辑尽量分开描述，换句话说，寄存器always语句描述中应该只有赋值，而无其他运算。 将不同类的逻辑分散到不同模块，这样综合工具可以针对不同的逻辑类型采用适当的优化技术。 相关的组合逻辑不要拆散到不同模块，否则会限制综合工具的优化力度，好的设计就是所有输出都是寄存器输出，对于组合逻辑分散到不同模块，虽然通过工具在综合前将设计铺平的方法可以缓解问题，但作为设计师还是尽量遵循此原则。 所有输出都是寄存器，这样所有组合逻辑都在前端，最后寄存输出，这也是所说的 “cloud-register原则” ，这样既可以得到更好的综合结果，而且简化了综合的约束设计。 敏感列表要完整，当然现在可以使用*代替，或者使用 SystemVerilog 的 always_comb 。 注意阻塞赋值的语句顺序。 避免 if/case 条件不完整，否则会产生 latch，可以使用 Systemverilog 中的 always_comb、always_latch、always_ff 语句，编译时会严格检查，也可以在块描述语句 if/case 前对信号赋初值。 用 always 语句描述组合逻辑使用阻塞赋值 = 。 描述 latch 时使用阻塞赋值 = 。 描述时序逻辑使用非阻塞赋值 \u0026lt;= 。 在同一个块语句中不要混用两种赋值方式。 不要使用 #0 延迟赋值。 FSM 中的状态名应该使用 parameter。 FSM 计算下一状态的组合逻辑应该放在一个单独的 always 块。 FSM 计算下一状态的组合逻辑应该使用 case 语句。 每个 FSM 使用单独的 module 描述。  利于维护的编码风格  每个项目都使用相同的目录结构，相同的目录结构有利于脚本移植，以及增加复用性和可维护性，同时利于工作交接。 项目中每个设计都保持类似的目录结构，理由同上。 项目内脚本尽量使用相对路径，需要全路径名称则使用环境变量。 对 `include 加载的文件尽量使用完整相对路径，方便设计的集成和移植，或者对所有设计的 include 文件规范命名规则。 每个文件只包含一个 module 。 文件名和模块名保持一致。 测试文件名与被测试模块名相对应，添加 _tb 后缀。 每个文件都添加头信息：版权声明、文件描述、创建时间、修改时间、原始作者信息、当前作者信息。 注释描述代码功能，而不是行为。 每个 parameter 声明后要注释。 function 要加注释。 每个主要逻辑段落要加注释。 信号名要有实际意义，并且输入输出信号名信息中要包含输入输出模块。 废代码删掉，而不是注释。 每个模块逻辑代码尽量不要超过400行，可读性可调试性强。 每级缩进建议四个空格，并且不建议使用TAB缩进，不同编辑器对TAB支持不同，可能会导致代码显示乱掉。 每行最多72个字符，在恰当的地方换行，并保持对齐。 控制流嵌套不超过三级。 每行只写一条语句。 连续声明语句对齐，并且每行只声明一个。 句尾的注释尽量对齐。 多次使用的逻辑使用 function 。 操作符周围使用一个空格与其他项隔开。 所有信号名尽量使用小写字母，并且用下划线将单词分隔开。 常数定义和宏定义使用大写字母。 模块的名字要体现层次结构。 模块的例化名与模块名基本保持一致，不过例化名可不体现层次结构，加 “i_” 或 “inst_” 前缀。 信号名要有意义，至少5个字符。 模块根据功能命名，不要依据类型或作者命名。 项目内命名要规范，避免模块重名。 根据功能或逻辑顺序声明端口，而不是方向。 低电平有效信号加后缀 “_n” ，如复位信号 “rst_n” 。 建议时钟信号统一加前置 “clk_” 。 建议复位信号统一加前缀 “rst_” 。 建议寄存器信号统一加后缀 “_ff” ，下一拍寄存器加载的值信号添加后缀 “_nxt” 。 总线范围定义为 “N-1:0” 。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":13,"section":"docs","tags":["Verilog"],"title":"verilog的编码风格","uri":"https://wenhui.space/zh/docs/digital_designer/other/verilog_coding_styleguide.html"},{"content":"本文 主要介绍Verilog语法中case，casex，casez的区别，以及建议使用方法。\n   版本 说明     0.1 初版发布    关于case  代码：   1 2 3 4 5 6 7 8 9  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 g default   xx g default   x0 c x0   1z f 1?   z1 g default    可见，case语法对四值0 1 X Z是严格匹配的，并且语义中“？”代表Z值。\n关于casez  代码   1 2 3 4 5 6 7 8 9  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 f 1?   xx g default   x0 c x0 (would have matched with z0(item 5) if item 3 is not present.)   1z d 1x (would have matched with z0(item 5) \u0026amp; 1?(item 6) also.)   z1 b 01 (would have matched with 1?(item 6) also.)    首先，casez的匹配顺序是从上到下。根据上面casez的匹配列表，可见casez语法将表达式的“z/?”与输入的任意值（0 1 X Z）匹配，而表达式的“x 0 1”和输入的“x 0 1”还是严格匹配。所以，一般我们对于不关心的信号位使用casez语句，并在选项中将该位设为\u0026quot;z/？\u0026quot;。这也是最推荐的写法。\n关于casex  代码   1 2 3 4 5 6 7 8 9  casex (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;bx0: y = c; 2\u0026#39;b1x: y = d; 2\u0026#39;bz0: y = e; 2\u0026#39;b1?: y = f; default : y = g; endcase    结果：     sel y case item     00 a 00   11 d 1x (would have matched with 1? also)   xx a 00 (would have matched with all)   x0 a 00 (would have matched with all items except 01)   1z c x0 (would have matched with all items except 00,01)   z1 b 01 (would have matched with 1x, 1? also)    同样，casex的匹配顺序也是从上到下。根据上面casex的匹配列表，可见casex语法将将表达式中“z/?/x”与输入的任意值（0 1 X Z）匹配，而表达式中的“0 1”与输入的“0 1”严格匹配。\n总结      总结如下：\n case、casex、casez的匹配顺序都是从上到下。 case严格匹配，casez中表达式z/?代表不关心该位的状态值(最好使用？)，casex中表达式x/z/?代表不关心该位的状态值。 case、casex、casez都是可综合的，不过在case中综合电路无法解析x/z/?，会将其认为不关心，这样会使RTL语义和综合电路间产生偏差，所以case语句表达式中不建议使用x/z/?。 尽量不使用casex，因为在初始条件下，控制信号可能存在大量x，使用casex会对电路的选择功能造成混乱，隐藏选择信号x值对电路功能的影响。  推荐使用casez，代码格式如下：\n1 2 3 4 5 6  casez (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b1?: y = c; default : y = d; endcase   代码功能等同于：\n1 2 3 4 5 6  case (sel) 2\u0026#39;b00: y = a; 2\u0026#39;b01: y = b; 2\u0026#39;b10,2\u0026#39;b11: y = c; default : y = d; endcase   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":14,"section":"docs","tags":["Verilog"],"title":"关于Verilog中的case、casex、casez","uri":"https://wenhui.space/zh/docs/digital_designer/other/about_verilog_cases.html"},{"content":"本文 主要记录我工作生活中遇到的英文，整理为单词本，一边巩固学习。其中主要记录的还是与专业相关的英语，因为对一个IC工程师来说，免不了要阅读英文文献。\n专业相关    单词 释义 场景     concept 概念 Small example to show VRQ concept.   algorithm 算法 sorting algorithm（排序算法）   Purpose 目标、目的    Requirement 要求    initialization 初始化 initialization issue（初始化问题）   expose 暴露 x value issue isn\u0026rsquo;t be exposed   hide 隐藏 hiding x values   Solution 解答、解决方案    verbose messages 详细信息 Debugging with verbose messages         生活相关    单词 释义 场景           待记录。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":15,"section":"docs","tags":["英语"],"title":"我的英语单词本","uri":"https://wenhui.space/zh/docs/about_life/my_english_wordbook.html"},{"content":"本文 主要介绍一些我生活中做的小菜，以及做菜的小心得，为自己的美好生活做个记录，同时与有兴趣的人一起分享。\n背景 为什么喜欢做菜呢？ 还不是为了嘴嘛！ 做自己喜欢吃的菜是一件多么愉悦的事，为自己爱的人做喜欢吃的菜又是一件多么幸福的事。\n西红柿炒鸡蛋 西红柿炒鸡蛋可以说是我的第一个菜。西红柿炒鸡蛋是最家常的菜了，也正是因为家常，所以每家的西红柿炒鸡蛋都有其独特的味道。\n材料 材料需要两个西红柿、两个鸡蛋、少许葱白、少许香葱末/青椒末、少许番茄沙司、盐、糖、油。其实我自己炒一人份的话，要败家一点，一个西红柿两个鸡蛋，咱这收入水平做不到财富自由，总能做到鸡蛋自由吧，想吃就吃。\n对于材料，这里要强调两点：\n 必须是葱白，用葱叶爆香是不好吃的，西红柿鸡蛋吃的是葱白的香甜味。 是番茄沙司不是番茄酱，番茄沙司是用水和糖调过味的，而番茄酱只是番茄酱，加入番茄沙司会使西红柿的味道更浓郁。  制作  西红柿顶部用刀轻划十字，开水锅里滚两下，然后冲凉，用手剥去外皮。 西红柿切块，不要太小，葱白切末，香葱/青椒切末。 打两个鸡蛋，如果想要颜色好看，可以使用柴鸡蛋或者多加一个蛋黄，用筷子朝一个方向打散。 坐锅烧油，油可以略多点，油热煎鸡蛋，待鸡蛋成熟打碎成块，同样不要太小，鸡蛋熟后取出待用。 不用刷锅，继续使用煎鸡蛋留下的底油，低油温放入葱白末，煸炒爆香。 葱白煸香后放入西红柿，快速翻炒，适当加一点点水，防止葱白炒糊，同时放入适量番茄沙司翻炒。 调味，放入盐和糖，糖多放一点，中和西红柿的酸味。 西红柿炒透出汁后，放入鸡蛋，继续慢慢翻炒，使鸡蛋吸满之水。 最后放入青椒末，翻炒两三下，如果是香葱末则在出锅后撒入即可。  心得  西红柿最好去皮，一是为了口感，二是去皮的西红柿更容易出汁水，更容易炒透，三是西红柿皮在炒熟过程中会打卷，影响美观。 如果西红柿成熟度不好，可以在切之前轻揉几下，这样更容易炒透。 鸡蛋一定要打散，使蛋清蛋黄充分融合，打散的蛋液炒起来更容易蓬松。 鸡蛋可以放一点点盐或不放，放盐会使炒出的鸡蛋稍稍发黑不黄亮。 炒鸡蛋油温一定要够，大概六七成，这样会使鸡蛋迅速蓬松起来，并且不要急于搅动，否则鸡蛋易碎而不成块状，待定型成熟至饼状时将其打散成块状。 鸡蛋炒的稍老会更香，蓬松的鸡蛋才能更好的吸收汁水。 鸡蛋打散成块状的时机也很重要，早了鸡蛋易碎不成块状，晚了容易产生焦边，影响颜色，最好的时候就是鸡蛋成熟至饼状时打散，然后快速翻炒几下，不至于边缘受热过度。 取出鸡蛋时要取干净，尤其边缘部分，否则煸炒葱白时残留鸡蛋容易糊，或者清洗锅后重新烧热，将鸡蛋滤出部分油淋入锅中，也可以避免此问题。 葱白要在低油温时下锅煸炒，大概三成油温时即可，并且尽量在锅底处煸炒，否则容易糊，出葱香味后放入西红柿，这时可以将火调小一点或者稍加一点点水，防止葱白在翻炒时烧糊。 西红柿出水后大火翻炒，一定要将西红柿炒熟炒透，但也切忌过度翻动，否则会将西红柿翻碎不成型。 西红柿炒透后进行调味，然后加入鸡蛋，加入鸡蛋后一定要大火快速翻炒，这样可以快速收汁，小火慢炖的话会是西红柿出太多汁水。 青椒末一定要在锅中翻炒几下，熟的青椒末才有香气，香葱末不要翻炒，成菜时撒入即可，否则会影响美观，其实香菜梗末也可以，或者黄瓜根部切圈，可以多尝试，找到自己最喜欢的味道，搭配点绿色成菜也更漂亮。 如何保证味道呢，一个诀窍就是尝一尝，缺啥加啥。 个人觉得，西红柿炒鸡蛋拌米饭才是最佳。  成品 成品效果主要有以下几个特点：\n 成菜红黄搭配，绿色点缀，颜色鲜亮。 鸡蛋黄亮，块大，吸足汁水。 西红柿炒透，无硬心，并且成块有口感。 成菜略有汁水，但不太多。 味道甜酸咸适中，先甜后咸。  图片待补充：\n声明 以上仅代表个人口味和心得，仅供参考。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":16,"section":"docs","tags":["美食"],"title":"我的美食拙作","uri":"https://wenhui.space/zh/docs/about_life/my_food_works.html"},{"content":"本文 主要介绍WPS如何使用文档模板。编辑文档时使用模板是一个好习惯，不仅能够使工作中的文档格式统一，还节省排版时间。Windows word创建模板操作应该类似。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 deppin版本： Deepin GNU/Linux 15.11 WPS版本：WPS Office 2019  写在前面 由于本人的办公系统基本已经从Windows转向了Linux，而且文档编写已经转向emacs org格式，但是与同事间交互时还是避免不了使用传统文档文件。典型的文档编辑器就是Windows Office word，但是Linux环境并不支持word，幸好WPS有Linux版本。有人说WPS不如word好用，两个工具来对比，其实功能基本完全对等，只是操作不同，可能大部分人习惯了word吧，还有就是彼此兼容略有问题，建议WPS完成的文档转为PDF格式再交付，这样可以避免兼容的问题。\n创建我的模板 由于网上并没有找到合适的模板，所以就根据自己的工作习惯，创建一个自己的模板，我对文档格式的需求主要有如下几点：\n 标题页面，需要有标题名称，作者信息，时间和版本信息。 目录页面，包括文档目录、图目录和表目录。 页码，前文页码为罗马数字，正文页码为阿拉伯数字。 正文第一项，文档介绍，需要介绍文档目的和参考文献。 水印为可选项，可加可不加。  根据以上需求，我完成了我的文档模板，分享给大家，仅供参考。网盘资源分享链接： 链接：https://pan.baidu.com/s/19C-LCnAOpcN0RBXoCGocPg 密码：27ys 。\n简单描述一下文档模板如何创建，其实和编写文档一样，设置完以上内容，通过 另存为 可选择输出为模板文件。\n如何使用模板文件 新建文档时选择 本机上的模板 ，一般这里只会显示空白模板，选中导入模板，在本地找到模板文件，即可使用模板创建新的文档。如果想在 本机上的模板 中显示自己的模板，请将模板文件移动到WPS的模板文件夹内，这里给出Linux下的路径： ~/.local/share/Kingsoft/office6/templates/wps/zh_CN 。\n其他使用技巧 关于水印 选择 插入-*水印*，可以选择去除水印或右键编辑水印。\n关于图表 文档中免不了会使用图表，选中插入的图表，选择 引用-题注-图 或 表 ，这里一般有几个重要参数，编号格式和是否包含章节编号，我一般选择默认的数字和包含章节编号，一般包含一级标题编号即可，另外一个参数是 位置 ，一般习惯上表格的题注在上方，图的题注在下方。\n关于目录 文档目录模板中已经添加好，可双击选择更新；图表目录需要删除后，将光标置于合适位置，选择 引用-插入表目录 ，选择图或表，即可自动插入目录。（如果需要添加公式目录，操作类似）\n关于操作符 这里操作符是指换行符等在文档中不可见的符号，在模板中添加了若干换行符、分页符和分节符等，若想显示它们，点击左上角的 文件-选项-视图-段落标记 。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":17,"section":"docs","tags":["Office"],"title":"WPS如何使用文档模板","uri":"https://wenhui.space/zh/docs/about_windows/create_wps_tepmlate.html"},{"content":"本文 主要介绍一款关于英文自动补全的emacs插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  内容请参考如下：  基于 Company 的英文助手 Github：company-english-helper  补充说明： 这个英文补全的emacs插件是基于Company插件的，可能需要先安装Company插件才可以使用，由于安装此英文补全插件时已经安装Company插件，所以并未考证。如果需要安装Company插件，请参考我的另一篇帖子 emacs如何安装插件。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":18,"section":"docs","tags":["emacs"],"title":"emacs插件之英文自动补全","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_company_english.html"},{"content":"本文 主要介绍数字电路设计中X-Propagation问题以及其解决方案。\n   版本 说明     0.1 初版发布   0.2 添加EDA工具的使用   0.3 添加verilog X-Prop插件VRQ介绍   0.4 添加综合后代码以及仿真结果    参考  文献1：《X-Propagation Woes: Masking Bugs at RTL and Unnecessary Debug at the Netlist》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YV%5FuOM1ech1zVkPMcqQ51w 密码：09wu 文献2：《X-propagation能在RTL仿真中发现X态问题》，百度网盘分享资源： 链接：https://pan.baidu.com/s/1YP3ZfIDgmX%5FmWFaOzkFKeQ 密码：3hq3  什么是 X-Propagation 问题? 什么是 X 状态？ SystemVerilog 标准中定义了四种逻辑状态，即“0”、“1”、“X”、“Z”，“0”代表低电平，“1”代表高电平，“X”代表不定态，“Z”代表高阻态。低电平和高电平很容易理解，而不定态和高阻态只有在模拟仿真时才会出现，真实电路中是不存在“X”和“Z”的。“X”和“Z”都代表不确定是“0”还是“1”的情况，比如未复位前的寄存器，在模拟仿真时是“X”状态，未赋值的悬空信号，在模拟仿真时是“Z”状态。\nX 状态的来源有哪些？ 数字电路中 X 状态的来源主要有以下几种：\n 未复位的寄存器和锁存器。 输入信号为 X 状态。 总线竞争。 地址越界。 跨时钟域逻辑（虽然在模拟仿真中不会直观看到X状态，但实际电路中由于跨时钟域是有采样到非理想值的风险，需要关注）。 多驱动（虽然在RTL编码中多驱动认为是一种错误，但实际电路中是有多驱动的技术的）。  总的来说，模拟仿真中 X 的状态更多来自未复位的寄存器和锁存器，尽管可以通过复位信号进行初始化解决这一问题，但是复位信号由于空间和延迟等布线的限制，也并非能够完全做到这一点。尤其现在低功耗设计，电路的睡眠和唤醒机制，对寄存器的初始化设计又带来了复杂性，同时也增加了隐藏 bug 的风险。但是需要注意的是，X 状态在真实电路中是不存在的，要么是“0”，要么是“1”。\n什么是 X-Optimism？ RTL 仿真中，对 X 状态是乐观处理的，什么是乐观处理呢？直观来说就是会将一个未知值在电路逻辑中传递为已知值。举例说明：\n if-else语句   1 2 3 4 5  always@(*) if (sel) out = a; else out = b;   结果如下：\n   sel out     1 a   0 b   x b    在if-else 的选择电路中，当选择信号为 X 时，判断 if 条件不满足，则会执行 else语句，所以 out 值为 b（如果没有 else 语句，则会产生锁存器，保持先前值）。这里补充一下，Z 状态同样会产生相同问题，只不过设计中很少存在 Z 状态，不再讨论。\n case语句   1 2 3 4 5  always@(*) case (sel) 1: out = a; 0: out = b; endcase   结果如下：\n   sel out     1 a   0 b   x prev    当选择信号为 X 时，非 0 非 1，不符合 case 语句中任何选项，则保持先前值，这也是将未知状态传递为已知状态的乐观处理。\n可见模拟仿真中对 X 状态的乐观处理，与实际电路是有差异的，这样比较容易隐藏功能bug。不过在门级网表仿真中是可以发现这些问题的，门级仿真对 X 状态是悲观处理的，会引入更多无效X状态，而且门级编译和仿真速度很慢，调试也是极其麻烦，将X-Propagation问题放到门级仿真来解决并不是一个好的选择。\n什么是 X-Pessimism？ 门级网表仿真中，对 X 状态是悲观处理的，什么是悲观处理呢？直观来说就是会将一个已知值在电路逻辑中传递为未知值。举例说明（这里只以assign语句为例，其实所有逻辑综合后都等效为门级电路，换句话说所有逻辑语句在门级电路仿真时都是悲观处理的）：\n1  assign out = (a \u0026amp;\u0026amp; selector) || (b \u0026amp;\u0026amp; ~selector);   结果如下：\n   selector a b out     X 0 0 X   X 0 1 X   X 1 0 X   X 1 1 X    以上是一个选择器逻辑，当 a 和 b 为相同值时，out结果应该与选择信号无关，也就是当 a和 b 都为“1”时，无论 selector 值为何，其结果值都应该为“1”。而实际门级仿真的悲观处理，在selector为X时，会将结果输出为“X”。\n可见门级仿真中对 X 状态的处理是悲观的，这样就会出现不必要的 X 值，与实际电路是有差异的，虽然不会隐藏功能 bug（因为 X 都会暴露出来），但是由此带来的门级仿真和RTL 仿真的差异，必须解决，带来了额外的工作量。\n关于clk的X-Prop 以上对选择逻辑的X-Prop问题进行了描述，而对于寄存器来说，clk的X态同样会带来问题，举例如下：\n 源代码：   1 2  always@(posedge clk) q \u0026lt;= d;    RTL仿真结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 0   0-\u0026gt;X or X-\u0026gt;1 1 0 1   0-\u0026gt;X or X-\u0026gt;1 1 1 1     真实电路结果：     clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 0   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 1     门级仿真结果：  （注意：猜测结果如下，未进行证实）\n   clk d q new q     0-\u0026gt;X or X-\u0026gt;1 0 0 x   0-\u0026gt;X or X-\u0026gt;1 0 1 x   0-\u0026gt;X or X-\u0026gt;1 1 0 x   0-\u0026gt;X or X-\u0026gt;1 1 1 x     总结：  可见对于寄存器关于clk的x态处理，也存在乐观和悲观问题。\n结论 通过上面内容，已经知道 X 状态的含义和来源，以及 RTL 仿真对 X 状态的乐观处理和门级仿真对 X 状态的悲观处理，总之由于 X 状态的存在，不同的处理方式，在 RTL 仿真、门级仿真和真实电路之间产生了差异，RTL 仿真的乐观处理，带来了隐藏功能 bug 的风险，门级仿真的悲观处理，当发现 X 状态时首先要确认是真实的 X 状态还是由悲观处理产生的，这带来了额外的工作量，尤其网表调试是极其麻烦的。综上，这就是关于 X-Propagation 问题。\n我的测试程序 RTL测试代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  module xprop_tb; reg clk; reg sel; reg a0,a1; reg b0,b1; reg din; /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire out1; // From i_xprop of xprop.v wire out2; // From i_xprop of xprop.v wire out3; // From i_xprop of xprop.v wire out4; // From i_xprop of xprop.v // End of automatics  initial begin //Two options have the same value  #0 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b0; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //Two options have the different value  #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bx; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;bz; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b0; #1 $display(out1,out2,out3); #10 a0=1\u0026#39;b1; a1=1\u0026#39;b1; b0=1\u0026#39;b1; b1=1\u0026#39;b0; #1 sel = 1\u0026#39;b1; #1 $display(out1,out2,out3); //test clk  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;bx; #1 $display(out4); #10 clk = 1\u0026#39;b0; din = 1\u0026#39;b0; #10 clk = 1\u0026#39;b1; #1 $display(out4);//set out4 pre_value is 0  #10 clk = 1\u0026#39;bx; din = 1\u0026#39;b1; #10 clk = 1\u0026#39;b1; #1 $display(out4); #10 $finish; end xprop i_xprop(/*AUTOINST*/ // Outputs  .out1 (out1), .out2 (out2), .out3 (out3), .out4 (out4), // Inputs  .clk (clk), .sel (sel), .a0 (a0), .a1 (a1), .b0 (b0), .b1 (b1), .din (din)); endmodule // xprop_tb  module xprop (/*AUTOARG*/ // Outputs out1, out2, out3, out4, // Inputs clk, sel, a0, a1, b0, b1, din ); input clk; input sel; input a0; input a1; input b0; input b1; input din; output out1; output out2; output out3; output out4; wire out1; reg out2; reg out3; reg out4; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule // xprop   综合后代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  ///////////////////////////////////////////////////////////// // Created by: Synopsys DC Expert(TM) in wire load mode // Version : O-2018.06-SP5 // Date : Mon Feb 24 10:57:14 2020 /////////////////////////////////////////////////////////////  module xprop ( out1, out2, out3, out4, clk, sel, a0, a1, b0, b1, din ); input clk, sel, a0, a1, b0, b1, din; output out1, out2, out3, out4; wire out3, n4, n5; assign out2 = out3; assign out1 = out3; DFFX1_LVT out4_reg ( .D(din), .CLK(clk), .Q(out4), .QN() ); MUX21X1_LVT U7 ( .A1(n4), .A2(n5), .S0(sel), .Y(out3) ); AND2X1_LVT U8 ( .A1(a1), .A2(a0), .Y(n5) ); OR2X1_LVT U9 ( .A1(b0), .A2(b1), .Y(n4) ); endmodule   RTL测试结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:03 2020 x00 x00 000 111 111 111 111 111 0 1 0 1 $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180 V C S S i m u l a t i o n R e p o r t Time: 180 CPU Time: 0.370 seconds; Data structure size: 0.0Mb Mon Feb 24 17:03:52 2020 门级仿真结果 Chronologic VCS simulator copyright 1991-2018 Contains Synopsys proprietary information. Compiler version O-2018.09-SP2_Full64; Runtime version O-2018.09-SP2_Full64; Feb 24 17:02 2020 xxx xxx 000 111 xxx xxx 111 111 0 x 0 x $finish called from file \u0026quot;xprop_tb.v\u0026quot;, line 39. $finish at simulation time 180000 V C S S i m u l a t i o n R e p o r t Time: 180000 ps CPU Time: 0.360 seconds; Data structure size: 0.0Mb Mon Feb 24 17:02:33 2020 总结  使用工具为VCS。 对于综合，无论是三目运算符还是if-else还是case，综合工具都将其转为相同的选择逻辑电路，也就是无论选择RTL何种表达方式，都不影响门级仿真悲观处理的问题，与综合工具也无关，而是仿真工具解析电路的悲观处理导致的。 对于模拟仿真，RTL仿真中if-else和case语句确实存在逻辑乐观处理的问题，而关于三目运算符的结果更符合真实的电路行为； 门级仿真是悲观处理的。  我们的需求是什么？ 验证工程师 对于验证工程师，需求是在 RTL 综合之前尽早消除设计中所有 X 传播问题，使其不会隐藏功能 bug，并且不至于在门级仿真中花费大量时间调试 X 传播问题。\n这里说明一下为什么在门级仿真中调试 X 传播问题需要消耗大量时间和精力。\n 综合后的网表不同于 RTL，难以调试定位问题。 由于门级仿真的悲观处理，增加了更多的 X 状态，而且大多是无害的，难以甄别。 门级仿真中发现 X 问题通常体现在输出的功能错误，而抓到错误与实际的 X 产生节点相隔可能多个周期，对调试增加了难度。 门级仿真速度慢.  设计工程师 对于设计工程师，更关心 X 源在设计中的位置，以及 X 在逻辑中的传播，更早的避免、发现和解决 X 传播问题，减少设计代码的迭代，并且最好不需要重新编码以及其他辅助性代码，这样可以依靠工具对代码结构进行静态检查，准确报告有可能存在 X 传播问题的代码信息。当然，对于复杂的低功耗设计，可能会带来更多的 X 传播问题，更有可能隐藏 bug，保证电路功能的正确性是他们最关心的，但对于验证难度也是非常大的。\n以往的解决方法 模拟仿真  波形调试工具：波形调试工具会显示 X 状态，在 RTL 仿真和门级仿真不一致时，可以通过波形工具进行调试分析 X 传播问题，当然这是最基础的手动调试方法，除了要排除悲观处理产生的不必要的 X 状态外，在表现为错误的节点和实际产生 X 乐观处理的电路间可能存在多个时钟节拍和复杂的电路层级，这对手动调试都带来了不小的工作，更别说大量的 X 传播问题的存在情况。 RTL X 乐观处理的检测：有些仿真工具可以对 X 乐观处理进行检测，当选择条件为 X 状态时，它将驱动 X 状态为 1’b1 和 1’b0，并在两种情况下输出结果不同时报错。这也同  样存在问题，首先是消耗更多的仿真时间，其次是很难保证所有组合状态都已覆盖。\n 随机初始化值：有些仿真工具支持设置寄存器的初始化值，这样通过初始化值随机化，可以减少大部分的 X 状态，这对于检测悲观处理是个好方法，但对于乐观处理，以及电路正确的初始化，不是一个好方法，首先会掩盖正确初始化的功能验证，其次是如果并未产生导致问题的初始值组合，依然无法发现功能 bug，通过多次随机仿真，不仅消耗了大量的仿真时间，但仍不能保证无隐藏的功能 bug。  代码结构分析 代码检查工具如 Lint，会对代码结构进行分析，以识别潜在的问题，并提醒设计人员可能导致 X 传播问题的危险信息。从代码结构分析来讲，工具会检测逻辑中是否使用了未驱动的信号，诸如这些可能导致 X 传播问题情况。但是代码检查工具并不能确定是否存在真正的问题，这样就需要设计人员去逐个分析。不过好在通过代码检查工具可以定位可能的X源以及与其敏感的电路信号，在发现功能bug时，根据代码检查报告快速定位问题。\n形式化验证  等价性检查：很多人都误以为等价性检查会捕获 X 传播问题，而实际并非如此。等价性检查是用于将设计的两个版本（或 RTL 和网表）验证为功能等效。其原理是基于端口信号、黑盒边界以及寄存器初始值的二进制状态空间的遍历。 注：对于此结论并没有完全理解，疑问是形式化验证工具是否对门级网表进行了悲观处理。 模型检查：设计或验证人员使用 SVA 语言编写设计属性，通过形式化验证是状态空间遍历，支持四态的验证工具会验证所有 X 值上无论是“0”还是“1”，都符合设计属性，从而解决 X 乐观和 X 悲观问题。但是需要设计或验证人员编写设计属性，工作量是一方面，还有设计属性描述的完备性以及大规模设计的状态空间爆炸问题难以解决。 符号模型仿真：符号模型仿真可以通过检查输出是否保持一致（无论是否存在 X）来彻底验证设计，并且可以提供反例，显示导致错误的信号状态。但是符号模型仿真也具有局限性，对于大规模的设计会导致内存迅速消耗。同时，设计中可能存在非法输入，可能提供假的反例。 注：对于什么是符号模型仿真本人暂时还不清楚，个人理解为支持X精确的抽象模型。  准确的代码编写 解决 X 传播问题最直接的方法就是准确代码编写，比如双目运算符（？：）是不会被仿真器乐观处理的，可以代替 if-else 和 case，但是它的可读性不强，并且没有避免 X 的悲观处理。那么什么是严格的代码编写呢？举例如下：\n X-optimistic Coding：当 sel 为 X 时，输出 g 为 2’b01。   1 2 3 4 5  always @(*) if (sel==1’b0) g = 2’b00; else g = 2’b01;    X-pessimistic Coding：当 sel 为 X 时，输出 g 为 2’bxx。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’bxx; else g = 2’b01;    X-accurate Coding：当 sel 为 X 时，输出 g 为 2’b0x（准确处理的话应该同时包含 Z 的处理，这里没有体现）。   1 2 3 4 5 6 7  always @(*) if (sel==1’b0) g = 2’b00; else if (sel===1’bx) g = 2’b0x; else g = 2’b01;   通过上面的描述感觉问题迎刃而解，仅仅是在编码时追求准确代码编写而已，但是对于赋值语句，很少是常量值，而是复杂的表达式。虽然通过悲观的编码方式可以解决 RTL 仿真的乐观处理问题，但对于门级仿真的悲观处理还是没有解决。\nverilog X-Prop插件VRQ 什么是VRQ？ Vrq是一个Verilog工具框架，带有用于处理源代码的各种插件。支持但不完全支持verilog 2005 语法规则。\n如何安装？  官网下载地址：https://altlinux.pkgs.org/sisyphus/autoimports-i586/vrq-1.0.130-alt1%5F4.i586.rpm.html 百度网盘分享资源： 链接：https://pan.baidu.com/s/11PXGNyhhFk3n9H5CtNQh9g 密码：3j40 ，其中包含安装包和可执行程序，可以直接使用可执行程序，也可以自行安装，安装方法参考readme文件。  如何使用？ Vrq支持的插件功能很多，这里仅以X-Prop为例，使用命令为： “vrq -tool xprop source.v -o target.v” 。这里也就是将source.v源代码进行X-Prop处理，处理完毕后的代码输出至target.v。效果如下：\nvrq xprop处理前：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  module top_module (); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0,a1; reg b0,b1; reg out4; reg din; assign out1 = sel ? a0 \u0026amp; a1 : b0 | b1; always@* if (sel==1\u0026#39;b1) out2 = a0 \u0026amp; a1; else out2 = b0 | b1; always@* case(sel) 1\u0026#39;b1: out3=a0 \u0026amp; a1; default: out3=b0 | b1; endcase always@(posedge clk) out4 \u0026lt;= din; endmodule   vrq xprop处理后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  //**************************************** // Warning! This file is machine generated //****************************************  module top_module(); reg clk; wire out1; reg out2; reg out3; reg sel; reg a0; reg a1; reg b0; reg b1; reg out4; reg din; assign out1=sel ? a0\u0026amp;a1 : ~sel ? b0|b1 : 1\u0026#39;hx; always @* if(sel==1\u0026#39;b1) begin out2 = a0\u0026amp;a1; end else if(~(sel==1\u0026#39;b1)) begin out2 = b0|b1; end else begin out2 = 1\u0026#39;hx; end always @* case(sel) 1\u0026#39;b1: begin out3 = a0\u0026amp;a1; end default: begin case(sel) 1\u0026#39;b0, 1\u0026#39;b1: begin out3 = b0|b1; end default: begin out3 = 1\u0026#39;hx; end endcase end endcase always @(posedge clk) out4 \u0026lt;= din; endmodule //**************************************** // Warning! This file is machine generated //****************************************   可见vrq xprop插件自动完成了将常规逻辑语句准确的xprop语句，简化了工程师的编码工作。关于vrq的xprop的详细功能，可通过“vrq \u0026ndash;help”或“man vrq” 查看。\n其他功能 vrq支持的verilog源代码处理插件很多，可通过“vrq \u0026ndash;help”或“man vrq” 查看。由于其他功能没有亲自实践，这里不再描述，待后续补充。\n最新EDA工具的支持 VCS 的 X-Propagation 功能 VCS X-Prop 的介绍 X-Propagation 是 VCS 开发的用于 RTL 阶段发现 X 态问题的新增特性。该特性主要有两种使用模式：T-merge 和 X-merge。T-merge 采用的算法是：当所有可能值不同时，结果为 X；X-merge采用的算法是：无条件的结果为 X（门级仿真的悲观处理）。下面对 T-merge 和 X-merge 举例说明：\n1 2 3 4 5  always@(*) if (select) out \u0026lt;= a; else out \u0026lt;= b;   看一下 T-merge 和 X-merge 的对比：\n   select a b T-Merge X-Merge     X 0 0 0 X   X 0 1 X X   X 1 0 X X   X 1 1 1 X    使用方法 只需在 VCS 仿真中添加-xprop 或者-xprop=xmerge 选项，默认是 T-merge 模式。也可以通过配置文件指定哪些模块使用 X-propagation 功能，以及指定使用哪种模式，其使用方法为： vcs -xprop=xp_config_file\u0026hellip; 配置文件内容格式如下：\ntree {bridge} {xpropOff}; instance{top.bridge.cpu}{xpropOn}; module {sram,cache}{xpropOff}; merge = tmerge; 另外boundscheck 的使用可以抓到数组下标不合法问题，不合法的下标分两类，下标越界和下标为 X。使用方法是在编译时添加-boundscheck 选项，运行仿真时会检查下标问题，输出报告。\n结论  X-Propagation 简单易用。 使用 T-merge 可以让各种语法结构中的 X 态问题有效传播，其效果可以代替门级仿真，但仿真速率要优于门级仿真。 建议使用方法为：先使用 T-merge 模式，当回归 pass 后再使用 X-merge 模式，如果 pass 则 OK，如果 fail 需要检查是否无效 fail。 使用 X-Propagation 对仿真性能影响可接受，T-merge 模式影响更小（注：与Cadence相反，待考证）。 对于低功耗设计由于其电源控制的复杂性，更有必要使用 X-Propagation。  INCISIVE 的 X-Propagation 功能 INCISIVE X-Prop 的介绍 INCISIVE13.1及更高版本，开始支持X-prop的功能，该功能通过命令行上的\u0026rsquo;-xprop \u0026lt;F / C\u0026gt;'选项启用。\nX-Prop工具目的是在RTL仿真中尽早的发现并解决X问题，其特点如下：\n 两种X-Prop模式  FOX模式 (“Forward only X”) CAT模式 (“Compute as Ternary”)   这两种模式可以区别LRM（Language Reference Manual）的行为 不需要更改现有的设计 减少门级调试  测试代码：\n1 2  if( sel) out = a; else out = b;   两种模式结果对比：\n   sel a b out(verilog LRM) out(FOX model) out(CAT model)     x 0 0 0 x 0   x 0 1 1 x x   x 1 0 0 x x   x 1 1 1 x 1    使用方法 只需要在 INCISIVE 仿真中添加-xprop选项，该选项包含在xrun中，命令为“xrun –xprop F|C”，这里F代表FOX模式，C代表CAT模式。而且可以提供配置文件以在选定的层次结构/实例上启用X-Prop，这也是最推荐的方式，命令为“xrun –xfile \u0026lt;file_name\u0026gt;”，Xfile格式如下：\n//在CAT模式下，在testbench以及其子模块中启用xprop SCOPE testbench… C //在FOX模式下，在testbench.dut以及其子模块中启用xprop SCOPE testbench.dut… F 为了降低调试的难度，在较大设计中，可以为少量模块添加X-Prop，这可以在Xfile中实现：\nSCOPE TB.DUT_TOP.AHB_MOD1…C SCOPE TB.DUT_TOP.CPU… C SCOPE TB.DUT_TOP.APB_MOD2… C SCOPE TB.DUT_TOP.AHB3… C 运行仿真时可以使用tcl命令控制开启和关闭X-Prop：\nxrun\u0026gt; xprop -off // Disable X-Propagation xrun\u0026gt; run 10ns xrun\u0026gt; xprop -on // Enable X-Propagation 结论  FOX模式比CAT模式仿真速度更快，因为FOX模式对x强制传播，无额外判断。 关于发现X bug，使用CAT模式更依赖于输入激励的质量，有可能由于判断逻辑选择值相同而继续被掩盖。 FOX模式更近似于门级仿真的行为。 建议从单元级模块运行X-Prop，待单元级模块清除X-Prop问题，然后在系统级运行X-Prop。 建议先使用CAT模式，将真实的X-Prop问题处理完毕后，再使用FOX模式。  JasperGold 的 X-Propagation 功能 JasperGold X-Prop APP 的功能  检查时钟和复位，以确保无Xs。 检查赋值逻辑，以确保无Xs 检查控制逻辑，以查看Xs可以传播到哪些区域。 检查输出信号，以查看Xs是否可以传播到设计之外。 检查黑盒输入，以查看Xs是否可以传播到黑盒上层模块。 可使用 assume-guarantee 的方法，使对X-Prop问题的证明尽可能收敛。  启动命令 jg -xprop\n待补充 以目前的了解，JasperGold X-Prop是需要工程师选定X源，然后工具为其进行0 1状态遍历，检查输出是否一致，若不一致则证明X传播至设计外部，可能存在设计bug，需要工程师去调试分析。形式化验证工具的好处就是工具自动采用状态空间全遍历的引擎，这对一个设计的完整验证似乎更有保证，防止模拟仿真中测试激励质量的问题而隐藏bug，但是形式化验证更适合单元级模块，较大模块会带来状态空间爆炸的问题，无法证明完全。这里另外说明一下可能的X源，其中最主要的就是输入信号和未复位状态的寄存器，如果选择输入信号作为可能的X源，我想不应该必然会影响设计输出吗？\n至于JasperGold X-Prop对X源的设定和分析，工具如何使用和调试，以及其工作原理，本人并未实际使用过，待通过工程实践后再补充。\n总结 X-Prop问题一直存在，由于现在设计规模越来越大，功耗控制技术越来越复杂，X-Prop问题显得更为重要，从以往的解决办法中，认为准确的代码编写最为有效，而且有工程师为其开发的脚本工具，但是个人认为不能很好的解决悲观问题，不过好在模拟工具都对X-Prop做了很好的支持，我们只要用好工具就能做到事半功倍。\n另外，如有兴趣欢迎详细交流和分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":19,"section":"docs","tags":["Verilog"],"title":"关于X-Propagation问题","uri":"https://wenhui.space/zh/docs/digital_verifer/other/x-propagation.html"},{"content":"本文 主要介绍了我的美食地图，大部分是旅行中亲自品尝并值得推荐的美食，还有部分列为TODO的美食清单。写本帖子的目的是对自己生活的一个美好记录，再有就是为志同道合之人（美食爱好者）提供参考。\n吃的信仰 这里借用一句黑面大叔陈晓卿的名言，那就是“ 最好吃的是人 ”。我十分认可这句话，这就是我关于吃的信仰。这句话的理解要从两方面去理解：\n 所谓美食，并不仅仅是入口那一瞬间带来的精神快感，背后的人文，更耐人寻味。 所谓美食，和谁吃远远比吃什么重要的多。  一个真正的美食爱好者，绝不仅仅是满足于入口的这一瞬间。比如我长沙出差经常去的一个牛肉粉馆，虽然吃的是一碗粉，但是会想到材料是什么，做法是什么，当地人喜欢吃扁粉还是圆粉，这个大叔又是做了多少年的粉，一辈子靠粉承担起全家的经济，也许还供养了两个大学生\u0026hellip;\u0026hellip; 如此，从一碗粉，想到材料，想到做法，想到做粉人的生活，耐人寻味，这就是吃背后的人文，这就是所谓最好吃的是人。\n西安 定家小酥肉 定家小酥肉在大皮院街口，接近广济北街的位置，也就是从鼓楼走向回民街正街，过了西羊市继续直走，到北院门左转进入大皮院路，直行大概五百米（接近北广济街）右手边。这家小酥肉是清真的，牛肉裹面糊，再上锅蒸制，入口绵缠酥软。大概30元左右，满满的一小盆都是牛肉，建议两个人一份肉一个凉菜两碗或一碗米饭就够了。小酥肉肉质很嫩，虽然卖相不太好，但是个人觉得十分美味。不过，写在前头，小酥肉调料味偏重，多胡椒，略偏麻，稍微油腻，如果你是南方人或口味偏轻的女生请慎重尝试，并且服务态度实在不敢恭维。整体来说，褒贬不一吧，不过个人觉得口碑还算不错。贴图如下：\n     老米家羊肉泡馍 来到西安，不得不吃的就是羊肉泡馍。西安卖羊肉泡馍的地儿很多很多，不过西安毕竟是旅游城市，如果随意找个地儿吃羊肉泡，又是很容易踩坑的，所以还是建议去回坊。回坊的羊肉泡最出名的是两家，老米家和老孙家，都是不错的。但是回民街无论春夏秋冬，都是摩肩擦踵、人山人海的火热场面，这里推荐一个案板街的老米家羊肉泡馍，清净很多，但是味道也很正宗。案板街离回民街也不远，在钟楼往东，沿着东大街走一二百米路左就是案板街了，走进案板街不远就能看到老米家羊肉泡馍。这里提醒一下，清真场所一定要避免展现非清真的东西。羊肉泡馍的馍是死面馍，半夹生，这样很耐煮，没错，羊肉泡馍就是煮的。一般馍要自己掰，这里不是店家偷懒，而是有意义的。自己掰馍可以掰成喜欢的大小，有人说馍掰的越碎煮着越入味，越好吃，不过个人觉得玉米粒大小刚好，而且，掰馍是一个乐趣，三五好友，放下手机，掰馍聊天，反现代科技的社交方式。听说掰馍时留一口放在碗里，是回民的标志，后厨师傅会给多加片肉，当然这个只是个传说，无从考证，不过有兴趣的可以试一试。羊肉泡一般会配糖蒜和辣椒酱，注意，辣椒酱很咸的，酌量加，糖蒜可以解腻，感觉是最佳搭配。其实一碗羊肉泡还是挺贵的，别听说西安人早上都吃羊肉泡，一碗羊肉泡40元左右，天天吃那得是大户，牛肉泡稍便宜些，但也要30多元，贵虽然贵了点，但味道香的很。回民街深处大皮院路，也有一些泡馍馆，味道也很好，还有小炒泡馍，这里的价格相对外面旅游区就便宜不少，有时间有兴趣的话也可以尝试。下面是贴图：\n     文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":20,"section":"docs","tags":["美食"],"title":"我的美食地图","uri":"https://wenhui.space/zh/docs/about_life/my_food_map.html"},{"content":"本文 主要介绍emacs org-model 的使用方法。\n   版本 说明     0.1 初版发布   0.2 添加Org-Mode导出如何禁用下划线转下标    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  什么是org-mode？ org-mode 是文本编辑器Emacs中一种支持内容分级显示的编辑模式。这种模式支持写 To-Do 列表，日志管理，做笔记，做工程计划或者写网页。\n安装 emacs 23以后默认自动安装 org-mode ，如果想安装最新版，可以手动下载安装包或通过emacs包管理器进行安装。手动下载和安装请参考org-mode下载页面。\n大纲 org-mode强大的操作能力源于它对大纲的支持。\n标题 文章中的标题可以通过 #+TITTLE: 来设置标题； 正文中的标题可以通过*，一个*表示一级，两个*表示二级标题。如：\n1 2 3 4  #+TITLE: emacs org-mode 的使用 *这是一个一级标题 ** 这是一个二级标题 *** 以此类推（最多10个*）   注意： ‘*’要位于行首；‘*’后面要有一个空格。\n大纲相关的快捷键 折叠    快捷键 说明     S-TAB 循环切换 整个文档 的大纲状态（三种状态：折叠，打开下一级，打开全部）   TAB 循环切换光标 所在大纲 的状态 （三种状态：折叠，打开下一级，打开全部）    大纲间移动    快捷键 说明     C-c C-n/p 下/上一标题   C-c C-f/b 下/上一标题（仅限同级标题）   C-c C-u 跳到上一级标题   C-c C-j 切换到大纲浏览状态    基于大纲的编辑    快捷键 说明     M-RET 插入一个同级标题   M-S-RET 插入一个同级TODO标题   M-LEFT/RIGHT 将当前标题升/降级   M-S-LEFT/RIGHT 将子树升/降级   M-S-UP/DOWN 将子树上/下移   C-c * 将本行设为标题/正文   C-c C-w 将子树或区域移动到另一标题处（跨缓冲区）   C-x n s/w 只显示当前子树/返回   C-c C-x b 在新缓冲区显示当前分支（类似C-x n s)   C-c / 只列出包含搜索结果的大纲，并高亮，支持多种搜索方式   C-c C-c 取消高亮    关于大纲显示 org的大纲显示模式会对不同级标题采用不同颜色显示，但是默认的大纲显示没有缩进，如果想添加缩进显示，可以用M-x，输入org-indent-mode。如果想让某个文件默认用这种方式打开，可以在文件头部增加：\n1  #+STARTUP: indent   如果希望打开所有org文件都默认用这种方式，可以在.emacs或.emacs.d/init.el中添加如下配置：\n1  (setq org-startup-indented t)   轻量级标记语言 Org现在已经成为一种专门的轻量级标记语言，与Markdown、reStructedText、Textile、RDoc、MediaWiki等并列。\n段落 可能我们习惯了回车下一行开启新的段落，而在org-mode中，需要回车两次，也就是段落间需要用空行隔开。\n字体 *粗体* /斜体/ +删除线+ _下划线_ 下标： H_2 O 上标： E=mc^2 等宽字： =git= 或者 ～git～ （ox-hugo并未将org中上下标的语法转为markdown，暂时没有解决方案）\n列表 列表语法  无序列表以\u0026rsquo;-'、\u0026lsquo;+'或者\u0026rsquo;*\u0026lsquo;开头 有序列表以\u0026rsquo;1.\u0026lsquo;或者\u0026rsquo;1)\u0026lsquo;开头 描述列表用\u0026rsquo;::\u0026rsquo; 列表层级用缩进体现  注意事项： 列表符号后面都要有空格；同级别的列表缩进要相同；空两行之后列表结束；\n举例如下：\n1 2 3 4 5 6  + treeroot + branch1 + branch2 + treeroot 1) branch1 2) branch2   列表快捷键    快捷键 说明     TAB 折叠列表项   M-RET 插入项   M-S-RET 插入带复选框的项   M-S-UP/DOWN 移动列表项   M-LEFT/RIGHT 升/降级列表项，不包括子项   M-S-LEFT/RIGTH 升/降级列表项，包括子项   C-c C-c 改变复选框状态   C-c - 更换列表标记（循环切换）    表格 表格语法 任何以‘|’为首个非空字符的行都会被认为是表格的一部分。’|‘也是列分隔符。一个表格是下面的样子：\n1 2 3  | Name | Height | Weight | Age | |----------+--------+--------+-----| | Abcdefgh | 178 | 123 | 18 |   创建表格时，首先输入表头（如下），然后在第二行按Tab键，会自动补全表格框架。表格的标题声明可有可无，看个人需求。\n1 2 3  #+CAPTION: 表格的标题 | Name | Height | Weight | Age| |-   有时候，表格的某一项特别的长，你可以在任意一个表格的空白项内输入数字来限制其所在列的长度，可以可以通过l、c、r来设置左中右对齐（默认左对齐）。比如(=\u0026gt;代表内容隐藏内容，实际为Abcedfgh)：\n1 2 3 4  | \u0026lt;5\u0026gt; | \u0026lt;l5\u0026gt; | \u0026lt;r5\u0026gt; | \u0026lt;c5\u0026gt; | | Name | Hei=\u0026gt; | Wei=\u0026gt; | Age | |-------+-------+-------+-------| | Ab=\u0026gt; | | | |   列表快捷键    快捷键 说明     C-c 竖线 创建或转换成表格   快捷键 说明   C-c C-c 调整表格，不移动光标   TAB 移动到下一区域，必要时新建一行   S-TAB 移动到上一区域   RET 移动到下一行，必要时新建一行   M-LEFT/RIGHT 移动列   M-UP/DOWN 移动行   M-S-LEFT/RIGHT 删除/插入列   M-S-UP/DOWN 删除/插入行   C-c - 添加水平分割线   C-c RET 添加水平分割线并跳到下一行   C-c ^ 根据当前列排序，可以选择排序方式    缺陷 目前表格不支持拆分和合并，只能使用如下格式替代。\n| 一级部门 | 二级部门 | 人数 | |----------+----------+------| | A | A.1 | 5 | | | A.2 | 6 | |----------+----------+------| | B | B.1 | 7 | | | B.2 | 3 | 分隔线 三条短线或以上显示为分隔线。‘\u0026mdash;’\n链接 链接语法 链接用于链接一些资源地址，如图片、文件、URL等。如下（可省略链接描述）：\n1 2 3  [[http://orgmode.org/orgguide.pdf][grgguid.pdf]]] [[file:/home/maple/图片/test.jpg][a picture]] [[file:/home/maple/图片/test.jpg]]   直接显示的图片在Emacs里默认不显示，需按C-c C-x C-v才能显示，在输出成其他格式（html、pdf……）后也能看到。\n链接快捷键    快捷键 说明     C-c C-l 插入链接和说明   C-c C-x C-v 显示链接图片    标签 Tag的作用 对于信息的管理，有分类(category)和标签(tag)两种方式。这两种方式各有特点：通常分类是固定的，很少变化，而tag随时可以增加。分类通常表现为树状结构，比较清晰，但是树状结构过于简单，不能表达复杂的信息。所以，这两种方式通常结合起来使用。\n标记Tag 在Org-mode中，可以对标题增加tag标记。标记的格式如下：\n1  标题 :标记1标记2:标记3:   而且Org-mode的标签自动按照大纲树的结构继承。即子标题自动继承父标题的标签。比如：\n1 2 3  *Meeting with the French group :work: ** Summary by Frank :boss:notes: ***TODO Prepare slides for him :action:   则最后一行标题具有 work, boss, notes, action 四个标签。如果希望文档中的所有标题都具有某些标签，只需要定义文档元数据：\n1  #+FILETAGS: :Peter:Boss:Secret:   如果手工输入标签，在标题后设置标签，键入\u0026rsquo;:\u0026lsquo;后，M-Tab自动提供标签的补齐。更方便的做法是在正文部分用C-c C-q 或直接在标题上用C-c C-c创建标签，这种方式可以列出所有预定义的标签以便选取。\n预定义Tag 预定义的方式有两种：\n 在当前文件头部定义，这种方式预定义的标签只能在当前文件中使用，每项之间必须用空格分隔，可以在括号中定义一个快捷键；花括号里的为标签组，只能选择一个，对标签定义进行修改后，要在标签定义的位置按 C-c C-c 刷新才能生效：   1  #+TAGS: { 桌面(d) 服务器(s) } 编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)    在配置文件中定义 上面的标签定义只能在当前文件生效，如果要在所有的.org 文件中生效，需要在 Emacs 配置文件 .emacs 中进行定义：   1 2 3 4 5 6 7 8 9  (setq org-tag-alist \u0026#39;( (:startgroup . nil) (\u0026#34;桌面\u0026#34; . ?d) (\u0026#34;服务器\u0026#34; . ?s) (:endgroup . nil) (\u0026#34;编辑器\u0026#34; . ?e) (\u0026#34;浏览器\u0026#34; . ?f) (\u0026#34;多媒体\u0026#34; . ?m) ))   Tag搜索 Tag搜索快捷键    快捷键 说明     C-c \\ 按tag搜索标题   C-c / m 搜索并按树状结构显示   C-c a m 按标签搜索多个文件（需要将文件加入全局agenda)    逻辑表达式限制条件 + 和 a+b 同时有这两个标签 - 排除 a-b 有 a 但没有 b | 或 a|b 有 a 或者有 b \u0026amp; 和 a\u0026amp;b 同时有 a 和 b，可以用“+”替代 在查询视图中 C-c C-c 退出。\nGTD（时间任务管理） 请参考org-mode，最强的任务管理利器，没有之一。我暂时并未使用org-mode进行时间任务管理，待使用后将总结进行补充。其实时间任务管理工具有很多，包括手机移动端，不一定非要使用emacs，不过emacs精神就是用emacs做一切。我用org-mode主要是做笔记和写博客，通过ox-hugo转为hugo识别的markdown文档，再通过hugo生成站点文件。\nOrg-Mode导出如何禁用下划线转下标 更多时候我们需要将org文件导出为pdf或html文件，这就会遇到一个问题，emacs org mode会将下划线转为下标格式，对导出的文件浏览很有影响。解决这个问题可参考如下两个方法：\n 在org文件添加OPTIONS：   1  #+OPTIONS: ^:nil    在配置文件（.emacs/init.el）添加如下设置：   1  (setq org-export-with-sub-superscripts nil)   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":21,"section":"docs","tags":["emacs"],"title":"emacs org-mode 的使用","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_org_mode.html"},{"content":"本文 主要介绍有关python的一些基础知识。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 python： Python 2.7.13  参考  菜鸟教程：Python基础教程  写在前头 什么是Python？ Python语言是少有的一种可以称得上即简单又功能强大的编程语言。它具有以下特点：\n 简单易学： 读Python程序就像是读英语，语法极其简单。 免费开源： Python是FLOSS（自由/开放源码软件）之一。 可移植： 多平台支持Python环境，方便程序移植。 面向过程和面向对象： Python既支持面向过程，也支持面向对象。面向过程，由过程或仅仅是可重用代码的函数构建起来；面向对象，由数据和功能组合而成的对象构建起来。（个人理解，在当做脚本语言时，主要是面向过程编程） 可扩展和可嵌入： Python程序可以使用其他语言，也可以被其他语言使用。 丰富的函数库： Python标准库很大，功能很强。  安装Python  如果你是Linux用户，系统应该已经自带Python，可以使用 python \u0026ndash;version 查看版本号。如果没有安装（可能性很小），可以使用系统的包管理器安装 sudo apt install python ，或者去Python官网下载页面下载最新Linux版本，也可以从别人那里copy可执行二进制文件。 如果你是windows用户，去Python官网下载页面下载最新Windows版本，手动安装，安装过程与其他软件类似，具体请自行百度。  运行方法  可以在python解释器直接运行python命令，打开终端，在命令行键入python，启动解释器，现在输入print \u0026lsquo;Hello World\u0026rsquo;，然后按回车，会看到屏幕输出Hello World。 使用源文件形式运行python程序： source HelloWorld.py 可执行的Python程序： 将程序源文件更改为可执行属性 chmod 755 HelloWorld.py ，在终端命令行直接运行 ./HelloWorld.py 。  获取帮助 help() 函数用于查看函数或模块用途的详细说明，按q退出。(注意：查看模块前，需要先import模块)\n\u0026gt;\u0026gt;\u0026gt;help('sys') # 查看 sys 模块的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help('str') # 查看 str 数据类型的帮助 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;a = [1,2,3] \u0026gt;\u0026gt;\u0026gt;help(a) # 查看列表 list 帮助信息 ……显示帮助信息…… \u0026gt;\u0026gt;\u0026gt;help(re.findall) # 显示re模块的findall方法的帮助 ……显示帮助信息…… 基本概念 数  整数： 1、 2、 3、 -1、 -2、 -3（默认十进制，也可以采用其他进制表示： 0b 二进制，0o 八进制，0x 十六进制） 浮点数： 3.14、 3.14E-4（也就是0.000314） 复数： (-1+2j)、 (1-2j)， 也可以complex(a,b)表示， 复数的实部 a 和虚部 b 都是浮点型  字符串  单引号： ‘Hello \\\u0026lsquo;World！\\'’，输出 Hello \u0026lsquo;World！\u0026rsquo; （也就是单引号中使用单引号，需要转义，使用其他符号无需转义） 双引号： \u0026ldquo;Hello \\\u0026ldquo;World！\\\u0026quot;\u0026quot;，输出 Hello \u0026ldquo;World！\u0026rdquo; （也就是双引号中使用双引号，需要转义，使用其他符号无需转义） 三引号（三个连续单引号）： \u0026lsquo;\u0026lsquo;\u0026lsquo;\u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026quot;'''，输出 \u0026lsquo;Hello\u0026rsquo; \u0026ldquo;World！\u0026rdquo; （三引号中使用双引号和单引号，无需转义） 转义符： 转义符是反斜杠 \u0026ldquo;\\\u0026rdquo; ，如\\\\代表\\符号，如‘Hello \\\u0026lsquo;World！\\'’，\\\u0026lsquo;代表\u0026rsquo;（注意：行末的\\，代表下一行继续，也就是不换行，而非转义符） 自然字符串： 引号表示的一般字符串时是支持转义的，如果不需要转义，可以使用自然字符串（字符串前加r或R）。举例：一般字符串\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \u0026lsquo;world\u0026rsquo;；自然字符串r\u0026rsquo;hello \\\u0026lsquo;world\\\u0026lsquo;\u0026lsquo;输出为hello \\\u0026lsquo;world\\\u0026rsquo; 。 自动拼接： print \u0026lsquo;Hello\u0026rsquo; \u0026lsquo;World\u0026rsquo; ，会输出 HelloWorld 。  变量 用标识符命名的存储单元的地址称为变量，变量是用来存储数据的，通过标识符可以获取变量的值，也可以对变量进行赋值。对变量赋值的意思是将值赋给变量，赋值完成后，变量所指向的存储单元存储了被赋的值，在Pyhton语言中赋值操作符为“=、+=、-=、*=、/=、%=、**=、//=”。声明变量的语法如： name=”Peter”\n标识符 标识符用于Python语言的变量、关键字、函数、对象等数据的命名。标识符的命名需要遵循下面的规则。\n 可以由字母（大写A—Z或小写a—z）、数字（0—9）和_（下划线）组合而成，但不能由数字开头； 不能包含除_以外的任何特殊字符，如：%、#、\u0026amp;、逗号、空格等； 不能包含空白字符（换行符、空格和制表符称为空白字符）； 标识符不能是Python语言的关键字和保留字； 标识符区分大小写，num1和Num2是两个不同的标识符。 标识符的命名要有意义，做到见名知意。  数据类型 Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。由于Python变量无需声明，所以它没有类型，我们所说的\u0026quot;类型\u0026quot;是变量所指的内存中对象的类型。标准的数据类型由如下几个：\n Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典）  对象 python中一切皆为对象，一个对象的特征也称为属性（attribute）。它所具有的行为也称为方法（method） Python中的对象包含三要素：id、type、value 其中id用来唯一标识一个对象， type标识对象的类型， value是对象的值 is判断的是a对象是否就是b对象，是通过id来判断的 ==判断的是a对象的值是否和b对象的值相等，是通过value来判断的。\n物理行和逻辑行 物理行是你在编写程序时所看见的。逻辑行是Python看见的单个语句。\n 如果你想要在一个物理行中描述多个逻辑行，那么你需要在逻辑语句末尾添加\u0026rdquo;;\u0026quot;，表示一个逻辑语句的结束（物理行末尾分号可写可不写）。 如果你想要在多个物理行中描述一个逻辑行，那么你需要在物理行末添加\u0026rdquo;/\u0026quot;，表示一个逻辑语句未结束，接下一行。  缩进 空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。也就是说，同一层次的语句必须有相同的缩进。\n运算符 运算符 特别说明：运算符左右可以存在空格，也可以不存在空格，不同于shell中赋值符'=\u0026rsquo;，左右是不能有空格的。\n 算数运算符：     运算符 名称 说明 例子     \u0026lsquo;+\u0026rsquo; 加 相加 3+5输出8; \u0026lsquo;a'+'b'输出\u0026rsquo;ab\u0026rsquo;   \u0026lsquo;-\u0026rsquo; 减 负数或相减 -5.2输出一个负数; 50-24输出26   \u0026lsquo;*\u0026rsquo; 乘 相乘或字符串重复 2*3输出6; \u0026lsquo;la\u0026rsquo;*3输出\u0026rsquo;lalala\u0026rsquo;   \u0026lsquo;**\u0026rsquo; 幂 x的y次幂 3**4输出81（即3 * 3 * 3 * 3）   \u0026lsquo;/\u0026rsquo; 除 x除以y 4/3输出1; 4.0/3或4/3.0输出1.3333333333333333;   ’%‘ 取模 返回除法的余数 8%3输出2; -25.5%2.25输出1.5   \u0026lsquo;//\u0026rsquo; 取整 返回商的整数部分（向下取整） 5.9//2输出2.0     比较运算符：     运算符 名称 说明 例子     \u0026lsquo;\u0026lt;\u0026rsquo; 小于 x是否小于y 是返回True，否返回False（首字母大写），5\u0026lt;3返回False； 3\u0026lt;5\u0026lt;7返回True   \u0026lsquo;\u0026gt;\u0026rsquo; 大于 x是否大于y 是返回True，否返回False（首字母大写），3\u0026gt;5返回False； 7\u0026gt;5\u0026gt;3返回True   \u0026lsquo;\u0026lt;=\u0026rsquo; 小于等于 x是否小于等于y x=3; y=6; x\u0026lt;=y返回True   \u0026lsquo;\u0026gt;=\u0026rsquo; 大于等于 x是否大于等于y x=4; y=3; x\u0026gt;=y返回True   \u0026lsquo;==\u0026rsquo; 等于 比较对象是否相等 x=2; y=2; x==y返回True; x='str\u0026rsquo;; y='stR\u0026rsquo;; x==y返回False   \u0026lsquo;!='或'\u0026lt;\u0026gt;\u0026rsquo; 不等于 比较两个对象是否不相等 x=2; y=3; x!=y返回True     赋值运算符：     运算符 名称 说明     \u0026lsquo;=\u0026rsquo; 简单的赋值运算符 a=2+3, a结果为5   \u0026lsquo;+=\u0026rsquo; 加法赋值运算符 a=7, a+=2, a结果为9   \u0026lsquo;-=\u0026rsquo; 减法赋值运算符 a=7, a-=2, a结果为5   \u0026lsquo;*=\u0026rsquo; 乘法赋值运算符 a=7, a*=2, a结果为14   \u0026lsquo;/=\u0026rsquo; 除法赋值运算符 a=7, a/=2.0, a结果为3.5   \u0026lsquo;%=\u0026rsquo; 取模赋值运算符 a=7, a%=2, a结果为1   \u0026lsquo;**=\u0026rsquo; 幂赋值运算符 a=7, a**=2, a结果为49   \u0026lsquo;//=\u0026rsquo; 取整除赋值运算符 a=7, a//=2, a结果为3     位运算符（避免表格中 或符号'|\u0026rsquo; 被转义，这里使用 \u0026lsquo;竖线\u0026rsquo; 代替）：     运算符 名称 说明 例子     ’\u0026laquo;’ 左移 一个数的比特形式进行左移 2\u0026laquo;2输出8，也就是0b10 \u0026laquo;2 结果为0b1000   ’\u0026raquo;‘ 右移 一个数的比特形式进行右移 11\u0026raquo;1输出5，也就是0b1011 \u0026raquo;1 结果为ob101   ’\u0026amp;’ 按位与 数的按位与 5\u0026amp;3输出1，也就是0b101 \u0026amp; 0b001 结果为0b001   ‘竖线’ 按位或 数的按位或 5'竖线\u0026rsquo;3输出7，也就是0b101 \u0026lsquo;竖线\u0026rsquo; 0b001 结果为0b111   \u0026lsquo;^\u0026rsquo; 按位异或 数的按位异或 5^1输出4，也就是0b101 ^ 0b001 结果为0b100   \u0026lsquo;~\u0026rsquo; 按位取反 x的按位取反，其值为-(x+1) ~5输出-6，也就是~0b0101 结果为0b1010(待补充)     逻辑运算（符布尔与和或，建议表达式为判断表达式，而非计算表达式，除非你明确知道返回结果的形式是什么）：     运算符 名称 说明 例子     \u0026lsquo;not\u0026rsquo; 布尔“非” not True 返回False x=2; y=3; not x!=y返回False   \u0026lsquo;and\u0026rsquo; 布尔“与” True and True 返回True 1\u0026lt;2 and 2\u0026lt;3 返回True； 1\u0026lt;2 and 2+3 返回2+3结果5   \u0026lsquo;or\u0026rsquo; 布尔“或” True or False 返回True 1\u0026lt;2 or 2\u0026gt;3 返回True； 1\u0026gt;2 or 2+3 返回2+3结果5     成员运算符     运算符 说明     \u0026lsquo;in\u0026rsquo; 如果在指定的序列中找到值返回 True，否则返回 False。   \u0026lsquo;not in\u0026rsquo; 如果在指定的序列中没有找到值返回 True，否则返回 False。     身份运算符     运算符 说明     \u0026lsquo;is\u0026rsquo; is 是判断两个标识符是不是引用自一个对象   \u0026lsquo;is not\u0026rsquo; is not 是判断两个标识符是不是引用自不同对象    是不是觉得is和==功能相同呢？那就理解错了，下面对is和==进一步说明。==是比较判断两个对象的value(值)是否相等；is比较判断两个对象id是否相同。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  \u0026gt;\u0026gt;\u0026gt; a = 1 #a和b为数值类型 \u0026gt;\u0026gt;\u0026gt; b = 1 \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 14318944 \u0026gt;\u0026gt;\u0026gt; id(b) 14318944 \u0026gt;\u0026gt;\u0026gt; a = \u0026#39;cheesezh\u0026#39; #a和b为字符串类型 \u0026gt;\u0026gt;\u0026gt; b = \u0026#39;cheesezh\u0026#39; \u0026gt;\u0026gt;\u0026gt; a is b True \u0026gt;\u0026gt;\u0026gt; id(a) 42111872 \u0026gt;\u0026gt;\u0026gt; id(b) 42111872 \u0026gt;\u0026gt;\u0026gt; a = (1,2,3) #a和b为元组类型 \u0026gt;\u0026gt;\u0026gt; b = (1,2,3) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 15001280 \u0026gt;\u0026gt;\u0026gt; id(b) 14790408 \u0026gt;\u0026gt;\u0026gt; a = [1,2,3] #a和b为list类型 \u0026gt;\u0026gt;\u0026gt; b = [1,2,3] \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42091624 \u0026gt;\u0026gt;\u0026gt; id(b) 42082016 \u0026gt;\u0026gt;\u0026gt; a = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} #a和b为dict类型 \u0026gt;\u0026gt;\u0026gt; b = {\u0026#39;cheese\u0026#39;:1,\u0026#39;zh\u0026#39;:2} \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 42101616 \u0026gt;\u0026gt;\u0026gt; id(b) 42098736 \u0026gt;\u0026gt;\u0026gt; a = set([1,2,3])#a和b为set类型 \u0026gt;\u0026gt;\u0026gt; b = set([1,2,3]) \u0026gt;\u0026gt;\u0026gt; a is b False \u0026gt;\u0026gt;\u0026gt; id(a) 14819976 \u0026gt;\u0026gt;\u0026gt; id(b) 14822256   总结：只有数值型和字符串型的情况下，a is b才为True，当a和b是tuple，list，dict或set型时，a is b为False。\n运算符优先级 优先级从高到低。\n   运算符 说明     ** 指数 (最高优先级)   ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)   * / % // 乘，除，求余数和取整除   + - 加法减法   \u0026raquo; \u0026laquo; 右移，左移运算符   \u0026amp; 位 \u0026lsquo;AND\u0026rsquo;   ^ \u0026lsquo;竖线\u0026rsquo; 位运算符   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   == 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not and or 逻辑运算符        虽然python解释器对运算符号优先级指明了顺序，但还是建议使用圆括号来更明确地指出运算的先后顺序，使程序尽可能地易读。例如，2+(3*4)显然比2+3*4清晰。\n控制流 if判断 Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。条件判断语句中，\u0026ldquo;判断条件\u0026quot;成立时（非零），则执行后面的语句，执行内容可以多行，以缩进来区分表示同一范围。其中else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  num = 5 if num == 3: # 判断num的值 print \u0026#39;boss1\u0026#39; print \u0026#39;boss2\u0026#39; print \u0026#39;boss3\u0026#39; elif num \u0026lt; 0: # 值小于零时输出 print \u0026#39;worker1\u0026#39; print \u0026#39;worker2\u0026#39; print \u0026#39;worker3\u0026#39; else: # 条件均不成立时输出 print \u0026#39;roadman1\u0026#39; print \u0026#39;roadman2\u0026#39; print \u0026#39;roadman3\u0026#39;   输出结果为：\nroadman1 roadman2 roadman3 while循环 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。while语句有一个可选的else从句，在不满足while条件时执行。举例如下：\n1 2 3 4 5 6 7 8  count = 0 while (count \u0026lt; 3): print \u0026#39;The count is:\u0026#39;, count count = count + 1 else: print \u0026#34;end while at count:\u0026#34;, count print \u0026#34;Good bye!\u0026#34;   结果如下：\nThe count is: 0 The count is: 1 The count is: 2 end while at count: 3 Good bye! for循环 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。for语句有一个可选的else从句，在执行完for内容时执行一次（除非遇到break）。举例如下：\n1 2 3 4 5 6 7 8  for i in [1,2,3]: print i else: print \u0026#39;end for i=\u0026#39;, i #------------------------ for letter in \u0026#39;ABC\u0026#39;: print \u0026#39;letter:\u0026#39;, letter   结果如下：\n1 2 3 end for i= 3 letter: A letter: B letter: C break语句 break语句可以强制终止循环语句，即使while循环条件仍为True或for循环序列还没有被完全递归。注意：break终止for或while循环 ，对应的循环else块将不执行。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: break print \u0026#39;there is break\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除break语句，将结果进行比较）：\n1 2 3 continue语句 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。举例如下：\n1 2 3 4 5 6 7 8 9  i = 1 while i\u0026lt;5: print i i += 1 if i \u0026gt; 3: continue print \u0026#39;there is continue\u0026#39; else: print \u0026#39;end while, i=\u0026#39;, i   结果如下（可以去除continue语句，将结果进行比较）：\n1 2 3 4 end while, i= 5 函数 函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。\n函数形参 函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为实参。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  def printMax(a, b): if a \u0026gt; b: print a, \u0026#39;is maximum\u0026#39; else: print b, \u0026#39;is maximum\u0026#39; #---------------------------------------------- printMax(3, 4) # directly give literal values x = 5 y = 7 printMax(x, y) # give variables as arguments   结果如下：\n4 is maximum 7 is maximum 局部变量 在函数内声明的变量，与函数外具有相同名称的其他变量没有任何关系，也就是变量的作用域仅限于函数内容，是局部的，这样的变量被称作局部变量。举例如下（注意，函数要先定义，才可以使用）：\n1 2 3 4 5 6 7  def local_test(num): num += num print \u0026#39;local_test\\\u0026#39;s num is\u0026#39;, num num = 10 local_test(num) print \u0026#39;main_program\\\u0026#39;s num is\u0026#39;, num   结果如下：\nlocal_test's num is 20 main_program's num is 10 默认参数 对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。注意：不能先声明有默认值的形参而后声明没有默认值的形参。如 def func(a, b=5, c=3) 是有效的， def func(a=5, b) 是无效的。举例如下：\n1 2 3 4 5  def say(message, times = 1): print message * times say(\u0026#39;Hello\u0026#39;) say(\u0026#39;World\u0026#39;, 3)   结果如下：\nHello WorldWorldWorld 关键字参数 如果某个函数有许多参数，只想指定其中某些参数的值，可以通过命名来为这些参数赋值，这种方法就是关键字参数。换句话说，关键字参数就是调用参数时使用名字（关键字）而不是位置来给函数指定实参。举例如下：\n1 2 3 4 5 6  def func(a, b=5, c=10): print \u0026#39;a =\u0026#39;, a print \u0026#39;b =\u0026#39;, b print \u0026#39;c =\u0026#39;, c func(c=1, b=2, a=3)   结果如下：\na = 3 b = 2 c = 1 return语句 return 语句就是讲结果返回到调用的地方，并把程序的控制权一起返回程序运行到所遇到的第一个return即返回（退出def块），不会再运行第二个return。举例如下：\n1 2 3 4 5 6 7 8 9 10 11  def add_sub (a, b): c = a + b d = a - b return c, d x = 3 y = 2 m, n = add_sub(x,y) print x, \u0026#39;+\u0026#39;, y, \u0026#39;=\u0026#39;, m print x, \u0026#39;-\u0026#39;, y, \u0026#39;=\u0026#39;, n   结果如下：\n3 + 2 = 5 3 - 2 = 1 文档字符串 DocStrings 文档字符串是一个重要工具，用于解释文档程序，帮助你的程序文档更加简单易懂。我们可以在函数体的第一行使用一对三个单引号 '\u0026rsquo;\u0026rsquo; 或者一对三个双引号 \u0026quot;\u0026rdquo;\u0026rdquo; 来定义文档字符串。你可以使用 __doc__（注意双下划线）调用函数中的文档字符串属性。举例如下：\n1 2 3 4 5 6  def function(): \u0026#39;\u0026#39;\u0026#39; The introduction to function. \u0026#39;\u0026#39;\u0026#39; pass print (function.__doc__)   输出结果如下：\nThe introduction to function. 特别说明：在函数的第一个逻辑行的字符串是这个函数的文档字符串（也适用于模块和类）。文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾，一般概括介绍函数的功能。第二行是空行，从第三行开始是详细介绍函数功能和使用方法。强烈建议，函数中使用文档字符串时遵循这个惯例。\n模块 什么是模块？ 在python中，一个文件（以“.py”为后缀名的文件）就叫做一个模块，每一个模块在python里都被看做是一个独立的文件。模块可以被其他程序引用，从而使用该模块里的函数等功能，使用Python中的标准库也是采用这种方法。\nPython中模块分为以下三类：\n 系统内置模块：如：sys、time、json模块等等； 自定义模块：自定义模块是自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用； 第三方的开源模块：这部分模块可以通过pip install进行安装，有开源的代码；  import模块 首先模块要先使用import语句导入到程序，如“import sys”导入sys模块，import的使用遵循以下规则：\n 使用关键词“import”，后面跟具体的模块名称，则可以导入某一个模块； 同一个模块不管你执行了多少次“import”，只会被导入一次，以防止模块一遍又一遍的被执行； “import”应该被放在代码的顶端；  再来你说一说import的搜索路径和顺序，如下：\n 当前目录 如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。  如果我们自定义一个模块（不能与系统模块重名），如何让python成功import呢？第一，我们可以将模块文件与引用模块的程序放在同一目录，可自动搜索到；第二，修改系统环境变量PYTHONPATH，比如自定义模板文件放在~/my_lib，可以将以下内容添加到~/.bashrc，并重启终端。\n1  export PYTHONPATH=~/my_lib/:$PYTHONPATH   from\u0026hellip;import 语句 Python 的 from 语句可以从模块中导入一个指定的部分到当前命名空间中。举例如下：\n1  from fib import fibonacci   也可以使用import modname from *语句，将模块中所有函数导入到当前命名空间中，但不建议这样做。举例如下：\n1  from fib import *   import和import\u0026hellip;from的区别 import和import\u0026hellip;from的区别，从函数引用来看就理解了，如下(support是自定义的模块，只为解释模块使用)：\n import   1 2  import support support.print_func(\u0026#34;Runoob\u0026#34;)    import\u0026hellip;from   1 2  from support import * print_func(\u0026#34;Runoob\u0026#34;)   从以上内容也看出，import和import\u0026hellip;from的区别，也知道为什么不建议使用import\u0026hellip;from * ，因为这样有可能带来函数命名上的冲突。总之，建议还是直接使用import。\npython中的包 包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。简单来说，包就是文件夹，但该文件夹下必须存在__init__.py 文件, 该文件的内容可以为空。__init__.py 用于标识当前文件夹是一个包。\n如定义一个包，文件目录如下：\npackage_runoob |-- __init__.py |-- runoob1.py |-- runoob2.py 使用程序：\n1 2  from package_runoob.runoob1 import runoob1 from package_runoob.runoob2 import runoob2   python的标准库 python的标准库内容很多，这也是Python强大之处，在这里不进行描述，后续会根据自己使用情况，对某些內建函数进行介绍。分享一个Python标准库介绍文档，可供查阅，百度网盘分享资源： 链接：https://pan.baidu.com/s/1o7G32%5FilSHhflfYTHuJq3g 密码：h2vv 。\n数据结构 在Python中有三种内建的数据结构——列表、元组和字典。我们将会学习如何使用它们，以及它们如何使编程变得简单。\n列表 列表中的元素应该包括在方括号中，并用逗号隔开。列表中，可以添加、删除或是搜索列表中的元素。由于可以增加或删除元素，所以列表是可变的数据类型。列表中的每个元素都分配一个数字（用来索引它的位置），第一个索引是0，第二个索引是1，依此类推。创建列表的方法如下：\n1 2 3  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5 ] list3 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;]   访问列表中的值（列表索引时，默认从左到右，负号‘-’可代表从右到左，冒号‘:’可定义区间，省略则代表起始或末尾）：\n1 2 3 4 5 6 7  list1 = [\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000] list2 = [1, 2, 3, 4, 5, 6, 7 ] print \u0026#34;list1[0]: \u0026#34;, list1[0] print \u0026#34;list1[-2]: \u0026#34;, list1[-2] print \u0026#34;list2[1:5]: \u0026#34;, list2[1:5] print \u0026#34;list2[1:]: \u0026#34;, list2[1:]   添加、修改和删除列表中的元素：\n1 2 3 4  list = [] ## 创建空列表 list.append(\u0026#39;Google\u0026#39;) ## 在列表末尾添加元素 list[0] = \u0026#39;Baidu\u0026#39; ## 修改列表第一个元素 del list[0] ## 删除列表中第一个元素   列表的操作符：\n   表达式 结果 说明     len([1, 2, 3]) 3 长度   [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合   [\u0026lsquo;Hi!'] * 4 [\u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!', \u0026lsquo;Hi!'] 重复   3 in [1, 2, 3] True 元素是否存在于列表中   for x in [1, 2, 3]: print x 1 2 3 迭代    Python列表函数：\n   函数 说明     len(list) 列表元素个数   max(list) 返回列表元素最大值   min(list) 返回列表元素最小值   list(seq) 将元组转换为列表    Python列表方法：\n   方法 说明     list.append(obj) 在列表末尾添加新的对象   list.count(obj) 统计某个元素在列表中出现的次数   list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）   list.index(obj) 从列表中找出某个值第一个匹配项的索引位置   list.insert(index, obj) 将对象插入列表   list.pop(obj=list[-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值   list.remove(obj) 移除列表中某个值的第一个匹配项   list.reverse() 反向列表中元素   list.sort([func]) 对原列表进行排序    元组 Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可(元组中只包含一个元素时，需要在元素后面添加逗号)。如下：\n1 2 3 4 5  tup1 = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34; tup4 = () tup5 = (33,)   元组的运算和索引与列表相同，可参考列表。唯一不同的是元组不可修改，不可删除，不可添加。\n元组的函数：\n   方法 说明     cmp(tuple1, tuple2) 比较两个元组元素   len(tuple) 计算元组元素个数   max(tuple) 返回元组中元素最大值   min(tuple) 返回元组中元素最小值   tuple(seq) 将列表转换为元组    字典 字典是另一种可变容器模型，且可存储任意类型对象。字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中，举例如下：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; }   多级字典嵌套：\n1 2 3 4 5  dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} }   访问字典数据（如果key不存在，则会报告异常）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  dict = { \u0026#39;Alice\u0026#39;: \u0026#39;2341\u0026#39;, \u0026#39;Beth\u0026#39;: \u0026#39;9102\u0026#39;, \u0026#39;Cecil\u0026#39;: \u0026#39;3258\u0026#39; } print \u0026#34;dict[\u0026#39;Alice\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;] #------------------------------------------ dict = { \u0026#39;Alice\u0026#39;: {\u0026#39;Height\u0026#39;: 168, \u0026#39;Weight\u0026#39;: 96}, \u0026#39;Beth\u0026#39;: {\u0026#39;Height\u0026#39;: 173, \u0026#39;Weight\u0026#39;: 126}, \u0026#39;Cecil\u0026#39;: {\u0026#39;Height\u0026#39;: 185, \u0026#39;Weight\u0026#39;: 148} } print \u0026#34;dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]: \u0026#34;, dict[\u0026#39;Alice\u0026#39;][\u0026#39;Height\u0026#39;]   修改、删除和添加字典元素：\n1 2 3 4 5 6 7 8 9 10 11  dict = {\u0026#39;Name\u0026#39;: \u0026#39;Zara\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} dict[\u0026#39;Age\u0026#39;] = 8 # update dict[\u0026#39;School\u0026#39;] = \u0026#34;RUNOOB\u0026#34; #add print \u0026#34;dict[\u0026#39;Age\u0026#39;]: \u0026#34;, dict[\u0026#39;Age\u0026#39;] print \u0026#34;dict[\u0026#39;School\u0026#39;]: \u0026#34;, dict[\u0026#39;School\u0026#39;] del dict[\u0026#39;Name\u0026#39;] # delete Name dict.clear() # clear dict del dict # delete dict   字典的特性：\n 不允许同一个key出现两次。创建时如果同一个key被赋值两次，后一个会覆盖前一个。 key必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行。  字典内置函数：\n   序号 说明     cmp(dict1, dict2) 比较两个字典元素   len(dict) 计算字典元素个数，即key的总数   str(dict) 输出字典可打印的字符串表示   type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型    字典内置方法：\n   序号 说明     dict.clear() 删除字典内所有元   dict.copy() 返回一个字典的浅复   dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始   dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default   dict.has_key(key) 如果键在字典dict里返回true，否则返回fals   dict.items() 以列表返回可遍历的(键, 值) 元组数   dict.keys() 以列表返回一个字典所有的   dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为defaul   dict.update(dict2) 把字典dict2的键/值对更新到dict   dict.values() 以列表返回字典中的所有   pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值   popitem() 返回并删除字典中的最后一对键和值    序列 列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。索引和切片的使用方法在列表和元组中已经有介绍，这里不再赘述。\n引用 创建一个对象并给它赋一个变量的时候，这个变量仅仅 引用 那个对象，而不是表示这个对象本身！j简单来说，创建的对象指向的是计算机中存储赋值对象的内存，而并非重新开辟一块内存对应被赋值对象。一般说来，使用者不需要关心，但是如果你想要复制一个列表或者类似的序列，必须使用切片操作符来取得拷贝，如果只是想要使用另一个变量名，可以直接赋值，不过两个名称都引用同一个对象，一不小心就可能会引来各种麻烦。特别给Perl程序员提示：python中序列的赋值语句不创建拷贝，需要使用切片操作符来建立序列的拷贝。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  print \u0026#39;Simple Assignment\u0026#39; shoplist = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;carrot\u0026#39;, \u0026#39;banana\u0026#39;] mylist = shoplist # mylist is just another name pointing to the same object! del shoplist[0] print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that both shoplist and mylist both print the same list without # the \u0026#39;apple\u0026#39; confirming that they point to the same object #--------------------------------------------------------------------- print \u0026#39;Copy by making a full slice\u0026#39; mylist = shoplist[:] # make a copy by doing a full slice del mylist[0] # remove first item print \u0026#39;shoplist is\u0026#39;, shoplist print \u0026#39;mylist is\u0026#39;, mylist # notice that now the two lists are different   中文 Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入 # -- coding: UTF-8 -- 或者 # coding=utf-8 就行了。注意： # coding=utf-8 的 = 号两边不要空格。如果以上教程中出现中文注释或其他中文内容，运行时报错，请添加中文支持。\n输入输出 打印的屏幕 最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式（显示时，Python会在逗号分隔处自动插入一个空格）。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：\n1  print \u0026#34;Python\u0026#34;,\u0026#34;是一个非常棒的语言，不是吗？\u0026#34;   读取键盘输入 raw_input函数，raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）：\n1 2  str = raw_input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   input函数，input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。\n1 2  str = input(\u0026#34;请输入：\u0026#34;) print \u0026#34;你输入的内容是: \u0026#34;, str   举例如下（input）：\n请输入：[x*5 for x in range(2,10,2)] 你输入的内容是: [10, 20, 30, 40] 文件操作 打开文件 语法规则如下：\n1  file object = open(file_name [, access_mode][, buffering])   参数说明：\n file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。  模式说明：\n   模式 说明     t 文本模式 (默认)   b 二进制模式   x 写模式，新建一个文件，如果该文件已存在则会报错   + 打开一个文件进行更新可读可写   r 以只读方式打开文件（默认模式）   r+ 打开一个文件用于读写   w 打开一个文件只用于写入（文件存在则覆盖，不存在则新建）   w+ 打开一个文件只用于读写（文件存在则覆盖，不存在则新建）   a 打开一个文件用于追加（文件存在则末尾添加内容，不存在则新建））   a+ 打开一个文件用于读写（文件存在则末尾添加内容，不存在则新建））    对r+、w+、a+进一步说明：\n   描述 r+ w+ a+     当前文件不存在时文件 抛出异常 创建文件 创建文件   打开后原文件内容 保留 清空 保留   初始位置 0 0 文件尾   写入位置 标记位置 标记位置 写入时默认跳至文件尾    文件对象属性    属性 描述     file.closed 返回true如果文件已被关闭，否则返回false   file.mode 返回被打开文件的访问模式   file.name 返回文件的名称   file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true    关闭文件 File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。语法：\n1  fileObject.close()   write和read write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。write()方法不会在字符串的结尾添加换行符('\\n\u0026rsquo;)，举例如下，创建foo.txt文件，并将内容写入该文件，并最终关闭文件：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;w\u0026#34;) fo.write( \u0026#34;www.runoob.com!\\nVery good site!\\n\u0026#34;) # 关闭打开的文件 fo.close()   read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 read需要传入一个参数，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。举例如下（读取上面创建的文件前10个字符）：\n1 2 3 4 5 6  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 关闭打开的文件 fo.close()   文件定位 tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 打开一个文件 fo = open(\u0026#34;foo.txt\u0026#34;, \u0026#34;r+\u0026#34;) str = fo.read(10) print \u0026#34;读取的字符串是 : \u0026#34;, str # 查找当前位置 position = fo.tell() print \u0026#34;当前文件位置 : \u0026#34;, position # 把指针再次重新定位到文件开头 position = fo.seek(0, 0) str = fo.read(10) print \u0026#34;重新读取字符串 : \u0026#34;, str # 关闭打开的文件 fo.close()   os模块 Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能，通过import导入模块可参考上文模块章节。\n rename：   1 2  # 重命名文件test1.txt到test2.txt。 os.rename( \u0026#34;test1.txt\u0026#34;, \u0026#34;test2.txt\u0026#34; )    remove：   1 2  # 删除一个已经存在的文件test2.txt os.remove(\u0026#34;test2.txt\u0026#34;)    mkdir：   1 2  # 创建目录test os.mkdir(\u0026#34;test\u0026#34;)    chdir：   1 2  # 将当前目录改为\u0026#34;/home/newdir\u0026#34; os.chdir(\u0026#34;/home/newdir\u0026#34;)    getcwd：   1 2  # 给出当前的目录 print os.getcwd()    其他，可参考os模块提供的内建函数手册。  异常处理 什么是异常？ 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在python无法正常处理程序时就会发生一个异常（异常是python对象，表示一个错误）。错误分两种：\n 语法错误： 这种错误，根本过不了python解释器的语法检测，必须在程序执行前就改正。 逻辑错误： 程序执行时遇到的错误，比如0做除数。  异常种类有哪些？ 常见的异常种类：\n   异常类型 说明     AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有属性x   IOError 输入/输出异常；基本上是无法打开文件   ImportError 无法引入模块或包；基本上是路径问题或名称错误   IndentationError 语法错误（的子类） ；代码没有正确对齐   IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]   KeyError 试图访问字典里不存在的键   KeyboardInterrupt Ctrl+C被按下   NameError 使用一个还未被赋予对象的变量   SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）   TypeError 传入对象类型与要求的不符合   UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它   ValueError 传入一个调用者不期望的值，即使值的类型是正确的    所有标准异常    异常类型 说明     BaseException 所有异常的基类   SystemExit 解释器请求退出   KeyboardInterrupt 用户中断执行(通常是输入^C)   Exception 常规错误的基类   StopIteration 迭代器没有更多的值   GeneratorExit 生成器(generator)发生异常来通知退出   SystemExit Python 解释器请求退出   StandardError 所有的内建标准异常的基类   ArithmeticError 所有数值计算错误的基类   FloatingPointError 浮点计算错误   OverflowError 数值运算超出最大限制   ZeroDivisionError 除(或取模)零 (所有数据类型)   AssertionError 断言语句失败   AttributeError 对象没有这个属性   EOFError 没有内建输入,到达EOF 标记   EnvironmentError 操作系统错误的基类   IOError 输入/输出操作失败   OSError 操作系统错误   WindowsError 系统调用失败   ImportError 导入模块/对象失败   KeyboardInterrupt 用户中断执行(通常是输入^C)   LookupError 无效数据查询的基类   IndexError 序列中没有没有此索引(index)   KeyError 映射中没有这个键   MemoryError 内存溢出错误(对于Python 解释器不是致命的)   NameError 未声明/初始化对象 (没有属性)   UnboundLocalError 访问未初始化的本地变量   ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象   RuntimeError 一般的运行时错误   NotImplementedError 尚未实现的方法   SyntaxError Python 语法错误   IndentationError 缩进错误   TabError Tab 和空格混用   SystemError 一般的解释器系统错误   TypeError 对类型无效的操作   ValueError 传入无效的参数   UnicodeError Unicode 相关的错误   UnicodeDecodeError Unicode 解码时的错误   UnicodeEncodeError Unicode 编码时错误   UnicodeTranslateError Unicode 转换时错误   Warning 警告的基类   DeprecationWarning 关于被弃用的特征的警告   FutureWarning 关于构造将来语义会有改变的警告   OverflowWarning 旧的关于自动提升为长整型(long)的警告   PendingDeprecationWarning 关于特性将会被废弃的警告   RuntimeWarning 可疑的运行时行为(runtime behavior)的警告   SyntaxWarning 可疑的语法的警告   UserWarning 用户代码生成的警告    异常处理的方法  如果错误发生的条件是可预知的，我们需要用if进行处理，在错误发生之前进行预防。   1 2 3 4 5 6 7 8  AGE=10 while True: age=input(\u0026#39;\u0026gt;\u0026gt;: \u0026#39;).strip() if age.isdigit(): #只有在age为字符串形式的整数时,下列代码才不会出错,该条件是可预知的 age=int(age) if age == AGE: print(\u0026#39;you got it\u0026#39;) break    如果错误发生的条件是不可预知的，则需要用到try..except：在错误发生之后进行处理。   1 2 3 4 5 6 7 8 9 10  try: f=open(\u0026#39;a.txt\u0026#39;) g=(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g)) except StopIteration: f.close()   try\u0026hellip;except\u0026hellip;的详细用法 我们把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，也可以处理一组圆括号中的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except。\n 异常类只能来处理指定的异常情况，如果非指定异常则无法处理：   1 2 3 4 5  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: # 未捕获到异常，程序直接报错 print e    多分支：   1 2 3 4 5 6 7 8 9  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e)    多分支＋Exception：   1 2 3 4 5 6 7 8 9 10 11  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) except Exception as e: print(e)    异常的其他机构（try\u0026hellip;finally语法）：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  s1 = \u0026#39;hello\u0026#39; try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) #except Exception as e: # print(e) else: print(\u0026#39;try内代码块没有异常则执行我\u0026#39;) finally: print(\u0026#39;无论异常与否,都会执行该模块,通常是进行清理工作\u0026#39;)    主动触发异常（raise语句）：   1 2 3 4  def functionName( level ): if level \u0026lt; 1: raise Exception(\u0026#34;Invalid level!\u0026#34;, level) # 触发异常后，后面的代码就不会再执行    自定义异常：   1 2 3 4 5 6 7 8 9 10  class Networkerror(BaseException): def __init__(self,msg): self.msg=msg def __str__(self): return self.msg try: raise Networkerror(\u0026#39;类型错误\u0026#39;) except Networkerror as e: print(e)    断言：assert条件：   1 2  assert 1 == 1 assert 1 == 2   总结： 使用异常处理方法，可以时代码程序拥有以下几个优点， 1）把错误处理和真正的工作分开来； 2）代码更易组织，更清晰，复杂的工作任务更容易实现； 3）代码更成熟，不至于由于一些小的疏忽而使程序意外崩溃了。 既然异常处理有这么多好处，是不是要为每一段程序都加上try\u0026hellip;except呢？首先try\u0026hellip;except是附加的一种异常处理逻辑，与主要的工作是没有关系的，这种东西加的多了，会导致代码可读性变差，其次只有在错误发生的条件无法预知的情况下，才应该做异常处理，而不是为自己不成熟的代码擦屁股。\n","description":"","id":22,"section":"docs","tags":["Python"],"title":"Python简明教程","uri":"https://wenhui.space/zh/docs/about_linux/python_tutorial.html"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第四篇，主要介绍类随机约束和分布、约束块控制、随机函数、数组约束、随机控制。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 路科验证。  概览      随机约束和分布 为什么需要随机？  芯片复杂度越来越高，在20年前定向测试已经无法满足验证的需求，而随机测试的比例逐渐提高。 定向测试能找到你认为可能存在的缺陷，而随机测试可以找到连你都没有想到的缺陷。 随机测试的环境要求比定向测试复杂，它需要激励、参考模型和在线比较。上百次的仿真不再需要人为参与，以此来提高验证效率。 随机测试相对于定向测试可以减少相当多的代码量，而产生的激励较定向测试也更多样。  为什么需要约束？  如果随机没有约束，产生有效激励的同时，还会产生大量的无效激励。 通过为随机添加约束，这种随机自由是一种合法的随机，产生有效的测试激励。 约束不是一成不变的，为了获取期望的测试范围或期待的数值范围，约束需要“变形”。 随机的对象不只是一个数据，而是有联系的变量集合。通常这些变量集合会被封装在一个数据类里，同时需要类中声明数据之间的约束关系。因此，约束之后要产生一个随机数据的“求解器”，即在满足数据本身和数据之间约束关系的随机数值解。 约束不但可以指定数据的取值范围，还可以指定各个数值的随机权重分布。  我们需要随机什么？  器件配置： 通过寄存器和系统信号。 环境配置： 随机化环境，例如合理的时钟和外部反馈信号。 原始输入数据： 例如MCDF数据包的长度、带宽，数据间的顺序。 延时： 握手信号之间的时序关系，例如valid和ready，req和ack之间的时序关系。 协议异常： 如果反馈信号给出异常，那么设计是否可以保持后续数据处理的稳定性。  声明随机变量的类  随机化是为了产生更多可能的驱动，我们倾向于将相关数据有机整理在一个类的同时，也用“rand”关键词来表明它的随机属性。 “randc”关键词表示周期性随机，即所有可能的值都赋过值后随机才可能重复，也就好比54张扑克牌抽牌游戏，rand代表每抽完一张放回去才可以下次抽牌，randc代表没抽完一张不需要放回就抽取下一张，如果抽完了，那就全部放回再次同样规则抽取。 rand和randc，只能声明类的变量，硬件域以及软件域的局部变量都不可以。 随机属性需要配合SV预定义的随机函数std::randomize()使用。即通过声明rand变量，并且在后期调用randomize()函数才可以随机化变量。 约束constraint也同随机变量一起在class中声明。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class packet; rand bit [31:0] src, dst, data[8]; randc bit [7:0] kind; constraint c { src \u0026gt;10; src \u0026lt;15; } endclass //----------------------------------  Packet p; initial begin p = new(); //assert语句保证randomize成功，否则会报fatal（如果约束冲突，如src\u0026gt;15 and src\u0026lt;10则会随机失败）  assert (p.randomize()) else $fatal(0, \u0026#34;Packet::randomize failed\u0026#34;); transmit(p); end   什么是约束  约束表达式的求解是有SV的约束求解器自动完成的。 求解器能够选择满足约束的值，这个值是由SV的PRNG（伪随机数发生器）从一个初始值（seed）产生。只要改变种子的值，就可以改变CRT的行为。 SV标准定义了表达式的含义以及产生的合法值，但没有规定求解器计算约束的准确顺序。也就是，不同仿真器对于同一个约束类和种子求解出的数值可能不同。 什么可以被约束？SV只能随机化二值数据类型，但数据位可以是二值或四值的，所以无法随机出x值和z值，也无法随机出字符串。   1 2 3 4 5 6 7 8 9 10 11  class date; rand bit [2:0] month; //note:  rand bit [4:0] day; rand int year; constraint c_data { month inside {[1:12]}; day inside {[1:31]}; year inside {[2010:2030]};} } endclass   请问：month=10，day=31，year=2020此组随机值可以产生吗？ 答案：不能，因为month的声明是3位，所以不可能出现数值10，这也是经常会犯的错误，当你约束数据时，一定要与声明数据的位数相匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class stim; const bit [31:0] CONGEST_ADDR = 42; //声明常数  typedef enum {READ, WRITE, CONTROL} stim_e; randc stime_e kind; rand bit [31:0] len, src, dst; bit congestion_test; constraint c_stim { len \u0026lt; 1000; len \u0026gt; 0; if(congestion_test) ( dst inside {[CONGEST_ADDR-100:CONGEST_ADDR+100]}; src == CONGEST_ADDR; ) else ( src inside {0, [10:20], [100:200]}; ) } endclass   权重分布  关键词dist可以在约束中用来产生随机数值的权重分布，这样某些值的选取机会要大于其他值。 dist操作符带有一个值的列表以及相应的权重，中间用 := 或 :/ 分开。值和权重可以是常数，也可以是变量。 权重不要百分比表示，权重的和也不必是100。 := 操作符表示值的范围内的每一个值的权重是相同的， :/ 操作符表示权重要平均分到范围内的每一个值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  rand int src, dst; constraint c_dist { src dist {0:=40, [1:3]:=60);} // src=1, weight=40/220  // src=2, weight=60/220  // src=3, weight=60/220  // src=4, weight=60/220  dst dist {0:/40, [1:3]:/60);} // dst=1, weight=40/100  // dst=2, weight=20/100  // dst=3, weight=20/100  // dst=4, weight=20/100 }   集合成员和inside  inside是常见的约束运算符，表示变量属于某个值的集合，除非还存在其他约束 ，否则随机变量在集合里取值的概率是相等的（集合里也可以是变量）。 可以使用 $ 符指定最大或最小值。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  rand int c; int lo, hi; constraint c_range{ c inside {[lo:hi]}; } //-------------------------------  rand bit [6:0] b; rand bit [5:0] e; constraint c_range { b inside {[$:4], [20:$]}; e inside {[$:4], [20:$]}; }   条件约束  可以通过 -\u0026gt; 或者 if-else来让一个约束表达式在特定条件有效。   1 2 3 4 5 6 7 8 9 10 11  constraint c_io { (i_space_mode) -\u0026gt; addr[31] == 1\u0026#39;b1; //i_space_mode!=0 } //--------------------------------------  constraint c_io { if(i_space_mode) //i_space_mode!=0  addr[31] == 1\u0026#39;b1; else; }   双向约束  约束块不是自上而下的程序代码，它们是声明性代码，是并行的，所有的约束同时有效。 约束是双向的，这表示它会同时计算所有的随机变量的约束，增加或删除任何一个变量的约束都会直接或间接的影响所有相关的值的选取。 约束块可以声明多个，但是它们仍旧是并行的，如果对同一变量进行约束，取两者约束的交集，也就是两个约束都会生效，与写在一个约束块效果相同。 子类会继承父类的约束。  约束块控制 打开或关闭约束  一个类可以包含多个约束块，可以把不同约束块用于不同测试。 一般情况下，各个约束块之间的约束内容是相互协调不违背的，因此通过随机函数产生的随机数可以找到合适的解。 对于其他情况，例如跟胡不同需求，来选择使能哪些约束块，禁止哪些约束块，可以使用内建函数constraint_mode()打开或者关闭约束。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class packet; rand int length; constraint c_short {length inside {[1:32];}} constraint c_long {length inside {[1000:1032];}} endclass //------------------------  packet p; initial begin p =new (); //create a long packet by disabling c_short  p.c_short.constraint_mode(0); assert(p.randomize()); transmit(p); //create a short packet by disabling all constraint and then enable only c_short  p.constraint_mode(0); p.c_short.constraint_mode(1); assert(p.randomize()); transmit(p); end   内嵌约束  伴随着复杂的约束，它们之间会相互作用，最终产生难以预测的结果。用来使能和禁止这些约束的代码也会增加测试的复杂性。 经常增加或修改类的约束也可能会影响整个团队的工作，这需要考虑类的OCP原则（开放封闭原则，也就是哪些对外部开放，哪些不对外开放）。 SV允许使用 randomize() with来增加额外的约束，这和在类里增加约束是等效的，但同时要注意类内部约束和外部约束之间应该是协调的，如果出现违背，随机数会求解失败（求解失败，不同的工具报告形式不同，有的是error，有的是warning）。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class packet; rand int length; constraint c_short {soft length inside {[1:32];}} endclass //------------------------  packet p; initial begin p =new (); assert(p.randomize() with { length inside {[36:46];}; length != 40; } ); transmit(p); end   上述例子中randomize() with{}约束与c_short产生可冲突，那会不会报错呢？答案是不会，因为c_short约束前加了soft（软约束）关键字，意义就在于当外部或子类的约束发生冲突时，其优先级降低，不会影响外部或子类的约束。\n随机函数 pre_randomize 和 post_randomize  有时需要在调用randomize()之前或之后立即执行一些操作，例如在随机前设置一些非随机变量（上下限、条件值、权重）,或者在随机化后需要计算数据的误差、分析和记录随机数据等。 SV提供两个预定义的void类型函数pre_randomize和post_randomize，用户可以类中定义这两个函数，分别在其中定义随机化前的行为和随机化后的行为。 如果某个类中定义了pre_randomize或post_randomize，那么对象在执行randomize()之前或之后会分别执行这两个函数，所以pre_randomize和post_randomize可以看做是randomize函数的回调函数（callback function）。  系统随机数函数 SV提供了一些常用的系统随机函数，这些系统随机函数可以直接调用来返回随机数值：\n $random()平均分布，返回32位有符号随机数。 $urandom()平均分布，返回32位无符号随机数。 $urandom_range()在指定范围内的平均分布。  随机化个别变量  在调用randomize()时可以传递变量的一个子集，这样只会随机化类里的几个变量。 只有参数列表里的变量才会被随机化，其他变量会被当做状态量而不会被随机化。 所有的约束仍然保持有效。 注意：类里所有没有被指定rand的变量也可以作为randomize()的参数而被随机化。 注意：未进行随机化的变量默认初始值为0。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class rising; byte low; rand byte med, hi; constraint up { low\u0026lt;med; med\u0026lt;hi; } endclass //----------------------------------  initial begin rising r; r =new(); r.randomize(); //随机化hi和med，不改变low  r.randomize(med); //只随机化med  r.randomize(low); //只随机化low end   数组约束 约束数组的大小  在约束随机标量的同时，我们也可以对随机化数组进行约束。 多数情况下，数组的大小应该给定范围，防止生成过大体积的数组或空数组。 此外，还可以在约束中结合数组的其他方法sum(), product(), and(), or(), 和xor()。   1 2 3 4 5 6  class dyn_size; rand logic [31:0] d[]; constraint d_size { d,size() inside {[1:10];}; } endclass   约束数组的元素  SV可以利用foreach对数组每一个元素进行约束，和直接写出对固定大小数组的每一个元素相比，foreach更简洁。 针对动态数组，foreach更适合于对非固定大小数组中每个元素的约束。   1 2 3 4 5 6 7 8  class good_sum5; rand uint len[]; constraint c_len{ foreach (len[i]) len[i] inside {[1:255]}; len.sum() \u0026lt; 1024; len.size() inside {[1:8]}; } endclass   产生唯一元素值的数组  如果想要产生一个随机数组，它的每一个元素值都是唯一的，如果使用randc数组，嘛呢数组中的每一个元素只会独立的随机化，并不会按照我们期望的使得数组中的元素值是唯一的。 解决方案1：   1 2 3 4 5 6  rand bit [7:0] data; constraint c_data{ foreach(data[i]) foreach(data[j]) if(i != j) data[i] != data[j]; }    解决方案2：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class randc_data; randc bit [7:0] data[64]; endclass class data_array; bit [7:0] data_array [64]; function void pre_randomize(); randc_data rcd; rcd = new(); foreach (data_array[i]) begin assert(rcd.randomize()); data_array[i] = rcd.val; end endfunction endclass    特别示例如下，首先“\u0026lt;=”代表小于等于，其次限定da.size为（3/4/5），实际不可能取到5，原因是da.size的约束体现在“da[i] \u0026lt;= da[i+1]”时，约束的是i和i+1为为（3/4/5）。   1 2 3 4 5  rand bit [7:0] da[]; constraint c_da { da.size() inside {[3:5]}; foreach(da[i]) da[i] \u0026lt;= da[i+1]; }   随机化句柄数组  随机句柄数组的功能是在调用其所在类的随机函数时，随机函数会随机化数组中的每一个句柄所指向的对象。因此随机句柄数组的声明一定要添加rand来表示其随机化的属性，同时在调用随机函数前要保证句柄数组中的每一个句柄元素都是非悬空的，这需要早随机化之前为每一个元素句柄构建对象。 如果要产生多个随机对象，那么你可能需要建立随机句柄数组。和整数数组不同，你需要在随机化前分配所有的元素，因为在随机求解器不会创建对象。使用动态数组可以按照需要分配最大数量的元素，然后再使用约束减小数组的大小。在随机化时，动态句柄数组的大小可以保持不变或减小，但不能增加。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  parameter MAX_SIZE = 10; class RandStuff; bit[1:0] value = 1; endclass class RandArray; rand RandStuff array[]; constraint c_array { array.size() inside {[1:MAX_SIZE]}; } function new(); //分配最大容量  array = new[MAX_SIZE]; foreach (array[i]) array[i] = new(); endfunction endclass //---------------------------  RandArray ra; initial begin // 构造数组和所有对象  ra = new(); // 随机化数组，但可能会减小数组  assert(ra.randomize()); foreach(ra.array[i]) $display(ra.array[i].value); end    问题1：执行ra.randomize() with {array.size=2}时，array[0].value 和 array[0].value分别是多少？ 答案都是1，首先value没有加rand，所以randomize不会随机value，仍然保持为1。 问题2：为什么要分配最大容量？ 答案是只有创建对象，并且分配最大容量，才能保证随机化时可能会碰到句柄数组悬空，无指向对象，随机会报错。 总结：句柄数组的随机，首先查看句柄指向的对象内有没有rand变量，其次对句柄数组按最大容量进行例化。  随机控制  产生事务序列的另一个方法是使用SV的randsequence结构。这对于随机安排组织原子（atomic）测试序列很有帮助。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  initial begin for (int i=0; i\u0026lt;15; i++) begin randsequence (stream) stream: cfg_read := 1 | //权重不一样  io_read := 2 | //权重不一样  mem_read := 5; //权重不一样  cfg_read: (cfg_read_task;) | (cfg_read_task;) cfg_read; mem_read: (mem_read_task;) | (mem_read_task;) mem_read; io_read: (io_read_task;) | (io_read_task;) io_read; endsequence end end    我们也可以使用randcase来建立随机决策树，但它带来的问题是没有变量可供追踪调试。   1 2 3 4 5 6 7 8 9  initial begin int len; randcase: 1: len = $urandom_range(0,2); //10%  8: len = $urandom_range(3,5); //80%  1: len = $urandom_range(6,7); //10%  endcase $display(\u0026#34;len=%0d\u0026#34;, len); end    总结：  randsequence和randcase是针对轻量级的随机控制的应用。而我们可以通过定义随机类取代上述随机控制的功能，并且由于类的继承性使得后期维护代码时更加方便。 randsequence的相关功能我们在协调激励组件和测试用例时，可能会用到。 randcase则对应着随机约束中的dist权重约束 + if-else条件约束的组合。    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":23,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（四）","uri":"https://wenhui.space/zh/docs/digital_verifer/study_sv/study_sv_four.html"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第四篇，主要介绍验证周期、验证管理三要素、验证的收敛、问题追踪、团队建设、验证的专业化。\n   版本 说明     0.1 初版发布    参考  路科验证。  概览      验证的周期 验证菜鸟的成长  确定验证的模块，与设计人员交流，熟悉模块，进行模块验证，所有的精力专注在这个模块。 考虑验证时间，尽可能又快又多的发现bug，在项目节点前完成验证。 在模块验证完后不知做什么，被动安排工作。 不清楚每个节点应该做什么、上一个节点和下一个节点的联系、不同节点对整个项目周期的意义，这些需要有一个宏观的认识。 随着经验增长，被赋予更多的责任，从模块到子系统，再到系统。 接到富有挑战性的任务会感受到压力，但是学到的东西也更多。 每一个验证人员能够充分了解各个验证环节，那么就可以更好的贯彻验证任务，保持信息通畅，整体的风险就会降低。  验证的里程碑 RTL0 -\u0026gt; RTL1 -\u0026gt; RTL2 -\u0026gt; RTL3 -\u0026gt; GLS -\u0026gt; TO -\u0026gt;流片\n RTL0： 芯片框架和模块功能定义完成，制定验证策略。 RTL1： 模块和子系统的功能信号定义完成，定制需要的存储模型。 RTL2： 完成所有模块的设计，以及80%以上的模块和子系统的验证，核心功能全部完成验证。 RTL3： 完成芯片系统的连线集成和验证，覆盖所有的功能验证点。 GLS： 完成门级网表的验证。 TO： 回顾验证的各项检查清单，最终流片。  RTL0    任务 内容     团队验证环境准备 项目的工作目录、采取的验证进度跟踪方法   验证人力和进度安排 模块、子系统、系统需要的人力和进度安排   验证工具和方法选择 仿真工具和形式化验证工具的版本、验证方法学   验证文档 记录验证策略、验证平台环境、方法学    RTL1    任务 内容     搭建模块验证环境 按照设计接口搭建验证环境   生成寄存器模型 由设计XML文件生成UVM寄存器模型   验证文档 模块验证环境、寄存器模型 、环境编译   验证计划回顾 模块级验证计划的回顾    RTL2    任务 内容     语义检查（linting） 检查常见的设计规范问题   跨时钟域检查（CDC） 模块、子系统级的CDC检查   仿真验证、形式化验证 选择合适的方法学完成模块/子系统80%以上的验证   创建测试用例 将测试用例同功能验证点完成匹配   回归测试 创建和更新模块级/子系统级的回归测试表   bug修复和跟踪 记录发现的bug，完成修复后的回归测试    RTL3    任务 内容     跨时钟域检查（CDC） 完成系统级的CDC检查   能效仿真（PA） 完成系统级的PA仿真   仿真验证和形式化验证 完成系统级的验证   创建测试用例 创建系统级测试用例   回顾测试用例 系统级测试用例和功能点回顾   bug修复和跟踪 修复系统级测试的bug，并跟踪和回归测试   回归测试 集中提交所有模块的测试用例，评估整体进度   代码/功能覆盖率收集 合并模块/芯片覆盖率，创建新的用例完备覆盖率    GLS    任务 内容     门级验证环境准备 需要从RTL芯片验证环境做更新，使用门级仿真   网表仿真验证 从RTL级选择测试用例，在网表环境测试逻辑一致性   网表+SDF仿真验证 伴随门级延迟仿真，完成时序验证   bug修复和验证 伴随设计ECO流程，完成RTL和门级验证    TO    任务 内容     验证功能点回顾 确保所有待验的功能点全部被测试用例覆盖   测试用例回顾 检查最终回归测试表结果，检查用例是否全部通过   覆盖率回顾 检查最终合并的覆盖率，功能覆盖率100%，代码覆盖率在90%以上   门级仿真用例回顾 所有的时序违例均被修正和过滤，功能全部通过    验证管理的三要素 时间管理  早行动：  各个模块和系统验证人员早参与到项目的前期定义环节，可以尽早知道设计的改动，从而考虑如何对原有的环境做出更新。同时，在选用IP和定义新模块的过程中，验证人员也可以更早的考虑选用什么验证IP、验证方法以及相应的工具。 有经验的验证团队，在项目开始之前就考虑更新的验证环境、流程、工具选择、方法学、技能训练、自主工具脚本开发等。 将验证环境搭建工作和测试用例创建工作分开，也就是少数人搭建维护验证环境，剩下的绝大部分人专心创建测试用例，通过这种让验证人员更专注的进行功能验证的模式来提高产出率。   少依赖：  一旦有了充分的意识，懂得验证过程并非是在设计完备后开始，那么验证人员就应该想出各种办法来减轻或者消除对于设计进度的依赖性。 尤其对于验证经理而言，让团队因为依赖一些未完成的事情而白白浪费时间，这对于项目进行来讲是大忌。 同时，验证团队往往需要在多个项目中一边开展新项目一边维护老项目，这更需要做好人力协调安排，避免出现项目之间人力冲突的情况。   大局观：  验证人员不但要专注于自己的“一亩三分地”，还要清楚共同的关键节点，以及各个模块之间的依赖性， 面临选择验证方法和工具时，需要考虑的不单单是该方法或该工具可以提高多少仿真速度或覆盖率，同时也要考虑人员的技能培训投入、学习曲线、新工具整合、新环境维护等与项目进度密切相关的因素。    人力安排  团队建设：  由于验证技术的趋势变化加快，新的方法、工具层出不穷，验证团队成员组成往往需要不同的技术背景。 招聘或培养人员时，要考虑所要具备的基本技能，和在某些技术领域拥有着丰富经验。比如软件编程、验证环境建设、形式化验证、硬件加速等。 一个经验丰富的验证团队，成员之间的技能一般会有重叠和差异部分。这种方式可以保证在人员任务分派时会有多种选择，同时团队共同工作时可以实现技能互补。 不同经验层次的梯队可以保持技术的传承，梯队培养，同时在任务分派的时候，也可以考虑将新的任务交给老员工，将老的任务交给新员工，满足老员工新技能培养、接受新的挑战，也使得新员工快速使用项目环境。   技术和管理：  技术功底深厚的人少有管理同样出色的，而善于在不同部门、技术组之间沟通的人善于协调、计划和监督却又无法很好的兼顾技术层面。 往往技术优秀的人才会被委以团队和项目管理的职责，但是这种选择不一定是最合适的。 伴随着验证项目的要求越来越复杂，芯片公司也越来越需要有经验的项目管理者，因为这样一位管理者会对整个项目起到组织和推动的作用。 好的验证组织既需要有技术良好的梯队，也应该具备贯彻执行验证计划的执行力，一个验证团队需要不同技术专长的验证人员，也需要可以统管全局的验证经理。    任务拆分和重组  项目启动初期，由于系统结构和设计功能描述尚未确定，相邻模块间的接口上不稳定，这时候在这些不确定中找到确定因素，来安排验证进度、估算所需的验证资源，对于验证经理的经验有很高的要求。 任务拆分指的是可以将一件用时较长或较复杂的任务拆分为相对独立的小任务。拆分任务的好处：  更容易清楚要做的任务和技术难易度、时间长短。 帮助分辨不同小的任务间的依赖性。 发现哪些部分是核心，哪些部分存在风险。 在有多人参与情况下，可以合理的分配任务，并发执行。 细化的任务有助于进度的跟踪和工作的量化。   任务重组指的是验证经理在统筹各个模块、不同验证节点之间的任务时，可以合理的对不同任务进行合并、转接、排序等，它的目的是更有效利用整体的验证资源。常见的任务重组场景包括：  发现各个验证模块中共同的可利用资源，指派专人维护（验证IP、回归工具、环境、脚本、仿真工具）。 模块A和模块B都需要创建一个类似的环境或组件时，考虑两个组件间共同规划同一个环境或参数化组件，以便减少整体工作量，提高模块复用性。 在发现不同模块之间有依赖性的时候，就需要安排优先级，消除依赖路径，尽可能使全员都行动起来。    验证的收敛 概述 随机验证的方式使得回归测试更加有意义。一般来讲，我们基于两种目的来提交回归测试表：\n 由于随机环境每次产生激励序列不同，这样每次回归测试均会对覆盖率收集做出贡献。 当设计bug修复后，回归测试保证bug的修复且不会引入新的bug。  回归测试具体指的是每次直接将所有测试用例提交到服务器运行，并且检查测试结果，对于模块级的回归测试，这种方法在时间和计算资源上也许是可行的，但对于系统级回归测试，这种方式每次要消耗的时间和资源需要重新考虑，一般考虑的因素是：回归流程、回归质量、回归效率。\n回归流程   流程阶段：\n RTL1：模块级基本功能验证、模块级高级功能验证。 RTL2：模块级回归测试和收集覆盖率、系统级基本连接验证、系统级模块交互功能验证。 RTL3：系统级回归测试和收集覆盖率、模块级和系统级副覆盖率合并。    流程细节：\n 模块设计阶段，除了准备验证环境，在验证的基本功能完成之时就应该创建一些基本的测试用例，并逐渐形成回归列表，在RTL2时要全部测试通过。 保证基本功能回归列表时，一些高级功能或附件功能，以及corner场景尽可能的在RTL2前完成验证。但是这些功能可能有部分需要在RTL2和RTL3之间完成验证，所以按照优先级划分功能回归列表也需要作为模块验证完成的检查项。 由于RTL2节点可以保证基本功能的正常工作，这份回归测试表单也是的RTL3开始时进行系统验证得到保障。 RTL2和RTL3之间，需要完成模块级的高级功能验证，之后反复进行回归测试，通过大规模的随机测试来验证设计的稳定性，并且完成覆盖率的收集。 模块级验证必须在RTL3之前完成，而系统级验证必须在门级仿真之前完成，并且尽可能减小落后于节点的差距。    备注： 这里提到的基本功能回归表，能够初步保证设计代码的正确性，在代码提交前设计师先通过代码编译检查和基本功能回归测试，通过后再提交到git库，交验证人员进行更多的高级功能回归测试，可以减少因提交代码质量导致时间的浪费，也可以将其集成到git提交管理。\n  回归质量  芯片设计在每次完成后，我们可以通过回归测试工具将设计、验证环境的编译、仿真、结果检查集成为一体，也可以通过一些简单的命令由设计者先查看基本功能是否正常工作。 只有保证基本功能回归列表测试通过，代码版本管理工具才可以允许提交，同时通知验证人员更新设计代码，展开高级功能的回归测试。 如果验证人员发现了bug，设计人员在bug修复后，先通过基本功能测试，再递交给验证人员检查之前的bug场景，确定修复后再进行高级功能或更高层次的验证工作。     回归测试列表 任务     基本功能测试表 设计提交检查项、设计基本功能覆盖   高级功能测试表 设计稳定后开展高级功能测试   覆盖率收集测试表 高级功能测试之后，随机测试收集覆盖率     总结：  前期设计不稳定时，主要定期提交基本功能测试来快速检查功能是否通过。 设计比较稳定后，规划用时较短、测试场景简单的用例，检查核心功能是否正确。 设计后期，应该一方面实现复杂场景测试，一方面大量提交回归测试表类完善功能覆盖率。    回归效率  影响回归效率的几个方面：  模块验证阶段，随机测试方式倾向于反复提交测试表来产生各种可能场景，而到了后期覆盖率难以得到更多提升，那么如何 精细控制随机约束 使得每次回归测试总有新增覆盖率的收获就显得额外关键。 在设计bug修复后，如何快速检查设计基本功能，保证设计版本提交的质量，这对提高回归测试效率也很关键，一个低质量的设计代码会降低回归测试的收益。 系统级验证阶段，由于测试用例时间明显加长，每次回归整个测试表需要消耗很长时间，但是越到后期反复回归的收益就越低，但是验证管理需要这样的数据，这种矛盾也需要化解。   提升回归效率：  切分测试场景，将较长的测试用例切分为多个序列，这样做的好处是避免过于冗长复杂的测试用例，划分多个用例可以方便并行提交，用计算资源来节省时间。 对于较难切分场景的测试用例，比如系统级仿真时需要先完成上电、复位、时钟使能等一系列初始化操作之后才能进行有效测试场景，可以考虑快速跳转到特定状态来实现缩短测试时间。 针对第二条所描述的特定状态，也就是需要长时间的运行来到达某一测试状态，建议分为两个阶段，第一阶段来检查跳转该状态的条件以及跳转功能是否正常，第二阶段在第一阶段测试通过的前提下，可以直接初始化到测试状态，例如强行置位寄存器、状态信号等方式，使得设计快速到达测试状态，缩短测试时间。 尽可能给予充分的计算资源，目前用于仿真的普遍方式是，中心化服务器集群来提供计算和数据存储资源，通过资源分配管理办法来实现充足的并行运算资源，缩短回归测试的运行时间。 后期回归测试，使用定向用例或精确控制随机约束，提高覆盖率收集的效率。    问题追踪 问题类型  系统功能定义问题。 硬件设计问题。 芯片验证环境问题。 综合时序问题。 硅前工具问题。 引用库和IP问题。  追踪工具  关于bug追踪需要的功能：分类、派发、查找、追溯、报告等。 标准化的问题追踪工具可以加速芯片开发的进度：  商业工具：Team Foundation Server(Microsoft), JIRA, Rational cLEARqUEST(IBM) 开源工具：Bugzilla(Mozilla), Redmine, Trace    工具的功能  记录：记录问题标题、内容、出错场景、背景描述、发布版本、测试用例、复现命令以及其他相关文件。 分类：归属哪个项目、哪一层次、哪个模块、哪一类型以及问题的严重性。 派发：问题提交即代表追踪的开始，管理者或提交人员可以指定谁来修复。 查找：查找功能可以方便bug追踪的查看，也可以在新bug发生时查找是否之前出现过此bug或有其他同事已经提交相同bug。 追溯：追溯是跟踪bug的状态迁移，从提交、派发、解决、完成等一系列状态的迁移。 报告：将整个数据库中的bug统计，从不同的维度形成报告，方便管理者查看。  团队建设 7个好习惯之从全局入手  同一个问题，专家的考虑角度总会比新手更高，更广、更丰富，解决问题的方案也会有高低的区别，所以无论处于哪个专业水平，总会有更高更全面的视角等待挖掘。 对于一个团队而言，在项目启动的时候，如果团队负责人能够对项目的周期、难点、人力估计、环境建设做出响应，与团队分享他的视野，保证团队清楚接下来大家如何作战、清晰每个阶段的作战目标，对于整个项目的推进很有意义。 团队中每一个成员在思考问题时都保持一种全局观，往往对于项目的中长期运行，可以更少资源、更高效率的去实现目标，另外对个人成长也很有意义。  7个好习惯之追求百分百  如果一个问题从硅前隐藏到门级仿真，那么代价是数倍的，如果隐藏到硅后测试，代价是数十倍的，这就需要每个人的严谨工作态度，百分百的工作努力。 如果遇见了问题就要及时解决它，以往的经验来看，凡是没有验证过的场景就一定存在bug，在发现问题或预测到问题的存在时，就尽早的去解决它，否则隐藏的风险会在后期不对放大，如果你认为没问题，那么问题很快就会来找你。 如果发现一个会影响大家的问题，主动去修复它，避免问题的延续导致影响更多的人，以及更长的影响时间。 维护好自己的TODO list，确保有序高效的完成它们，切记不能遗忘否则可能会带来灾难，并且当自己不确定时及时请高层次的人员或负责人来帮助自己确认。  7个好习惯之保持面向对象的开发习惯  对于设计人员，面向对象的开发方式不一定要熟悉，但对于验证人员，它的重要性尤为显著。 无论使用SV、SC、C++还是Python，如果需要开发一个长期维护的环境或工具，请先考虑面向对象的方式。  7个好习惯之合理复用  复用是高效验证的核心理念，无论是方法学的推陈出新还是验证环境的搭建维护，都需要考虑复用。 复用所涉及的范围很广，除了设计模块复用。验证环境复用、测试用例复用之外，也包括项目环境复用、脚本复用等。 验证目前占到整个芯片开发60%以上的工作量，提高复用性可以加快验证速度和减少维护成本。 为了提高复用性，在构建验证环境时，尽可能考虑验证环境参数化、脚本自动化、提交文档等方式，使得验证环境的维护和使用。  7个好习惯之保持创新  从新手逐渐变为“老司机”之后，往往会有一段倦怠期或自满期，因为验证人员觉得：他对所属的模块已经足够掌握，验证环境也熟悉，似乎没有那么多再需要深挖的地方了。 这个时候，不放争取新的模块和任务，往往“老司机”和新任务的搭配，能够发现更多的问题和改善措施。 我们相信验证总会有需要不断完善的地方，在新的空余你的思想还会保持一段活跃的时间，从而提出一些新的改善方法。 如何让大脑保持不断创新？除了不断学习。不断交流外，那就是永远追求验证效率的提高。实际工作中的创新，一旦被证明它对整个团队的价值，那么不单单是它的作用会逐渐放大，而且你也可以感染和吸引更多的人，一同加入到你们的创新队伍中去。  7个好习惯之高效的沟通  首先，多人团队可以进一步拆分为5人以内的小组，平行执行任务，保持各组之间的独立。 其次，在可行的情况下优先考虑面对面谈话，次者打电话，再次者写邮件，我们相信口头表达是最高效的方式。 再者，尽量少开会、开短会，只邀请必要的人参加，节省他人时间，也节省自己的时间（最害怕白图标开会，晚上加班coding）。 最后，如果有条件，可以将团队在一些关键项目节点前，聚集在一起办公进行团队作战，减少沟通成本。  7个好习惯之突破责任边界  在设计的边界划分上，我们可以通过定义模块层次和结构来实现，而在验证工作中，我们无法很清晰的划分出边界，因为模块间有互动功能。 一般情况下，我们会遵循主从端、上下行数据传输和功能实现工作量大小的方式来确定，互动功能由哪一方来验证。 尽管我们希望以一种合理的方式来划分验证边界，但仍然难免有一些边界不清晰的功能交互部分。 如果有关联的模块A、B双方可以突破责任边界，积极承担各自的部分，或者从项目整体出发，去定义验证的完整方案，在考虑工作的承担问题，毫无疑问这对于整体验证质量是有益的。 主动突破责任边界，会对自己的成长很有帮助，学到更多东西。  验证的专业化 对于验证的偏见  A公司目前的设计复杂度低，而且有面向市场的进度压力，所以他们更愿意将设计做完后经过简单的测试直接将原型验证通过FPGA来实现和测试，至于RTL验证的投入则少的可怜。 B公司的验证平台已经很多年没有更新，尽管设计越来越复杂，但是因为一直缺少经验丰富的验证师来更换升级公司的验证平台，所以在项目开始，尽管能听到越来越多对于验证平台老旧不方便的抱怨，项目管理者还是以缺少合适的人力为理由，让大家通过加班来弥补验证平台的效率缺失。 C公司没有专门的验证团队，而验证的工作几乎是公司内部的设计人员之间相互合作验收的，在缺少验证标准、计划、环境和文档的情况下，设计师同时也兼任了验证师的角色。如果询问设计师，实施验证是否困难？他们会回答，这不就是添加激励，看看行为是否异常吗？在他们眼里，设计工作才是应该受到公司最多关注的。 D公司验证团队整体实力与设计团队有不小差距，通过分析我们可以发现，该公司的验证团队是由公司不合格或暂时没经验的设计师和新进公司的新手拼凑组成的。公司的管理层认为，验证的好处不单单是可以发现一些漏洞，还可以让那些不合格或暂时没经验的设计师先到验证环境去熟悉，至少不会因为一些简单的错误给设计种下一些严重的漏洞。看起来D公司的验证团队接收到的，是一种隐形的“二等公民”。不过通过验证工作，debug过程可以熟悉设计，进而在对设计有一定理解之后，逐渐承担设计任务，也是很多公司目前采用的培养方式。 E公司的设计团队和验证团队比较健全，然而他们之间的沟通经常不顺。当验证人员在项目前期发现bug时，还可以和设计人员探讨修复bug的问题，而到了项目的后期，如果再发现什么严重的漏洞，设计人员就显得不那么愉快了。因为漏洞越到了后期才被发现，修复漏洞的难度和代价越大，同时由于项目进度的压力，有时候设计人员不得不加班加点去完成，这就是为什么不愉快的原因。  验证的专业化认识  A公司虽然看起来在用FPGA可以快速得到测试结果，但是更多地是将设计作为黑盒验证，缺少内部信号的检查调试，同时缺少随机激励的场景来达到验证的完备性，缺少边缘场景错误场景保证设计的稳定性。 B公司为什么缺少合适的人？深层次的原因恐怕与公司对验证不重视有很大关系。如果一开始从验证人员招聘和对验证贡献的充分肯定上入手，那么验证人员的培养不会滞后于设计人员太多。 C公司除了对与设计师的验证能力充分“信任”之外，也没有觉得验证是一项单独需要培养的技能，或者说缺乏对一个专业验证团队的认识。事实上，验证确实不是一项技能，而是需要很多知识综合起来的技能。 D公司看起来倒是通过这种小聪明，使得烫手的员工没有做出什么可能让公司无法挽回的损失。但除了让员工被感到不信任之外，公司又如何能够保证他们的验证工作做的足够好？要知道验证和设计一样重要，设计种下了漏洞，验证没有发现，同样是致命的。 E公司的设计人员越到后期越不情愿听到自己的设计被发现漏洞，而且和验证人员沟通起来也颇为困难。除了对于设计和验证的关系需要理清之外，该公司还需要多鼓励验证团队，让他们在关键时刻顶住压力，该报告的设计漏洞需要义无反顾的提交，并且到后期每报出一个漏洞都应该值得庆幸，因为幸好它没在流片后回来才被发现。  验证面临的现状  芯片业对验证的偏见不单单来源于公司和业界的成见，就连教育行业也是如此。高校的教育与芯片行业的脱节十分严重，基本很少看到有高校开设关于芯片验证的课程，哪怕是导论。 国内芯片验证领域可参考的书目也不多，而国外优秀的图书又没有得到及时的翻译和引进。 对于从事验证的工程师，业界优秀的图书本身也是实际工作联系不够紧密，而大多数人缺少时间和资源来查阅每年最新的验证领域的相关论文。 国内缺少验证行业广泛交流大会，使得验证工程师在经验积累和技术交流上，缺少途径。 就公司而言，对于验证工程师的培养以及职业发展路径上，应该给出明确的信息，从公司层面给出对验证工程师的认可，让验证工程师对于自己的职业发展感受到动力。  验证的标准化  如果想让验证技术呈现出更清晰的理念，首先要将验证的流程标准化和量化，就像软件测试的环节一样。无论对于团队还是个人，只有趋于标准化、量化的验证才能更稳固地推进项目，从而做到心里清楚，手中不慌。 验证团队除了需要优秀的验证工程师，也需要经验丰富的验证经理，这一要求的着眼点不只在于日常管理，也包括针对芯片整体验证去规划验证框架、环境、流程、制定验证计划、评估人力、时间节点等。 验证经理会就所有项目、之前的项目和未来的项目之间验证环境的复用和优化两方面考虑，要求模块、子系统和系统级验证环境可以保持垂直复用和水平迁移的要求。同时验证经理也需要考虑采样哪一种验证方法、选派合适的人进行验证等。  验证经验的积累和突破  经验分享是需要长期贯彻的事情，包括公司的内部分享和公司的外部分享两方面。验证的事务做久了容易让人产生倦怠，原因主要在于验证工程师对于验证环境逐渐掌握，趋向于按照现有的环境框架去思考问题，也容易对现有环境的效率感到满足，很难做到主动突破现有框架、做出改善甚至验证环境换代的举措。 公司内部的交流值得推荐，除了沟通成本小，不同验证团队、不同事业部或者分公司之间都可以就验证技术展开交流。 请EDA技术支持工程师，为大家培训，或咨询。 通过总结自己的验证经验，完成体系的验证思想，发表到行业技术大会以及其他技术交流会议，同其他公司分享，也查看和听取其他公司的技术分享和探讨。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":24,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（四）","uri":"https://wenhui.space/zh/docs/digital_verifer/beginner_verification/beginner_verification_four.html"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第三篇，主要介绍计划的概述、计划的内容、计划的实现、计划的进程评估。\n   版本 说明     0.1 初版发布    参考  路科验证。  概览      计划的概述 验证计划是什么  选择验证方法和构建验证环境前，首先需要知道验证计划是什么。 展开设计之前，设计人员和验证人员都会阅读功能描述文档，以理解设计的各项功能为前提，考虑如何实现和验证它。 实际项目执行中，功能描述文档和设计会不断更新，验证工程师要做好相应验证计划的更新。 验证计划在设计启动之前就已经诞生，且伴随着整个设计周期。  计划的步骤  创建验证计划 选择验证方法 人力资源调配 构建验证平台和环境组件 开发测试用例  收集的材料  结构功能描述 设计的各种操作使用模式 正常输入和错误输入场景下设计的行为 设计的接口 边界场景下设计的行为 设计在实际使用中的场景描述  计划的好处  使得设计和验证人员对于功能描述文档的理解保持一致。 将自然语言描述的功能通过可测试性语言来描述。 可以更合理的评估出工作量、人力安排和进度节点。 为验证人员提供明确的验证目标、任务和进度安排。 为功能文档提供反馈，修改文档中不明确、有歧义的描述。  影响计划的因素  验证计划是团队协作的产物，需要系统、设计、验证共同参与制定。 需要更新成百上千的测试用例，并且与计划中待测试功能一一对应。 考虑选中不同的验证方法，针对不同的设计，需要考虑使用模拟仿真、形式化验证或硬件加速验证，如需使用多平台验证，还要考虑如何实现技术平台上的兼容和跨越式复用。 添加新的设计需求，需要更新验证计划。新添加功能，要考虑额外的人力和进度影响。 多组参与验证，需要团队合作协调，以及测试用例的复用。  计划的内容 概述  技术角度考虑，需要有验证的功能点、验证的层次、测试用例、验证方法和覆盖率要求。 项目角度考虑，需要有使用工具、人力安排、进度安排和风险评估。  验证的功能  基本功能： 时钟、电源、复位、寄存器访问和基本功能特性，这些可以仿真模块级完成验证。 交互功能： 需要与其他模块交互的特性，需要在更高层次的子系统级或系统级完成验证。 次要功能： 这些会在项目后期完成验证，比如性能验证，即便没有达到要求不会存在致命影响，所以风险较低，放在最好验证。  验证的层次  结合验证功能点，需要清楚该功能点在何层次验证。 从验证效率和激励自由度来看，应该尽量在较低层次验证更多功能点。 在较高层次，应该侧重于系统集成测试。  验证的方法  方法： 模拟仿真 or 形式化验证 or 硬件加速验证。 透明度： 黑盒 or 白盒 or 灰盒（建议尽可能使用黑盒）。 激励： 定向激励 or 随机约束激励。  验证的用例 选择：\n 更随机的测试方法，尽可能遍历可能的状态空间？ 适中的随机约束，倾向于更贴近实际场景的随机激励？ 采用定向测试，针对一些边界情况可以更有效的收集覆盖率？  建议：\n 验证初期，应该只发送一些基本的测试数据，约束范围尽可能窄。 验证中期，由于设计基本稳定，可扩大约束范围，以此更有效地完成验证。 验证后期，有一些边界场景通过随机约束激励无法有效收集覆盖率，需要采用定向用例。  覆盖率的要求  覆盖率是衡量激励生成质量和功能点验证的量化指标。 无论何种验证，都需要采用覆盖率来确保给出了足够的激励，遍历设计可能的状态。 覆盖率可以分为代码覆盖率、功能覆盖率和断言覆盖率。 除了给出合法的激励之外，也要考虑给出错误的激励，来测试设计的稳定性和纠错能力。  工具的选择  模拟仿真工具 形式化验证工具 验证IP（如商用接口协议的验证IP） 断言IP 调试工具 硬件加速器 高层次验证语言  人力安排  不同验证方法对人力安排存在明显差别，除了考虑个人的实际经验外，也需要考虑他们是否熟悉该模块，也就是验证人员的知识和技术背景越贴合，越倾向于选择这样的验证人员，对于人力成本和验证风险都可以降低。 推荐一个完整的项目周期内，固定人员跟踪同一个设计模块，从搭建环境、用例编写、覆盖率收集，以及模块级、子系统级、系统级整个验证过程，这样安排项目风险较低，人员成长较快。  进度安排  首先进度往往是从上向下传达的，项目有时间进度，验证工程师会有一个大概的进度要求。 工作量 = 人力 X 时间。 验证经理经常会处于人力不够充分或时间不够宽松的境地。时间往往是固定的，做好任务的安排和动态的人力分配，实现高效的资源配置是关键。 时间进度可修改吗？ 这无法回答，如果能更细致的量化和评估时间和人力安排，delay的风险会较低。  风险评估  芯片结构不稳定： 添加或修改新的功能，会增加新的工作量。 工具的不稳定： 新的版本工具会增加新的特性，有可能提高工作效率，但是也会存在适应期。新的工具面临环境流程更新、技术培训等问题。 人力不稳定： 处于各种原因导致验证人员被临时替换，会加大验证风险。 设计交付时间的不稳定： 设计的delay会直接影响到验证。  计划的实现 概述  一份细致的验证计划也包括项目动向、更新内容和工程进度，清晰的计划更能保证时间和人力的平衡。 验证计划需要时常保持更新，给出合理的安排，从计划到实践的反馈，再到计划修改。  如何制定验证计划  邀请相关人员参加会议（设计、验证、系统等）。 开会讨论验证方案。 确定测试场景。 创建验证环境。  邀请人员    项目角色 关注角度 期望验证点     设计人员 设计实践 设计内部时序、状态机、内部逻辑   硅后测试人员 硅后模块功能测试 硅前测试用例移植到硅后测试   软件人员 模块在系统中的应用 软件正确的配置序列被测试   系统人员 结构和性能要求 设计框架符合要求，性能和效能可以早期测试   验证经理 进度、人力和优先级 给出合理安排，定期更新计划   验证人员 验证方法和环境 综合衡量其他角色意见，给出统一的解决方案    开会讨论 作为会议组织者，首先明确开会的目的和议题：\n 报告验证计划的内容。 确定验证功能点。 确定验证方案和时间节点。  一份验证计划的模板应该包含以下内容：\n 设计功能简要概述。 硬件实现结构框图。 待验证的功能点。 验证环境结构。 测试用例构成。 编译脚本和回归测试。 覆盖率分析。 风险评估。  确定测试场景  电源开关。 复位测试。 常规场景。 边缘场景。 错误场景。 性能压力测试。 选择验证层次和验证方法。  创建验证环境  搭建环境时，创建不同的接口信号和激励组件来构建场景。 是否可复用验证资源，以及可用的vip。 监测组件收集数据，确定采样时序和事件，捕捉有效信号。 构建参考模型，模拟DUT行为。 检查组件比对结果，输出报告信息。  计划的进程评估 概述 在验证过程中，需要不断更新验证进度，从各项参数综合评估验证的完备性。\n 回归测试pass率。 代码覆盖率。 断言覆盖率。 功能覆盖率。 bug曲线。  回归测试pass率  一份回归测试表是将测试设计的所有功能点的用例合并为一个测试集。 回归测试表的主要功能是用来在设计bug修复后或性能优化后，对原有的功能仍然正常工作。 回归测试不仅确保设计修改不影响原功能，且不影响其他模块功能。 回归测试表中的测试用例，需要确保可以重现激励场景。这对于定向测试是容易实现的，而对于随机约束测试，需要保存随机种子，方便重新激励场景。 如果某层次回归测试通过，可向上迁移到新的验证层次，展开新的回归测试流程。 同一测试用例，不同层次回归测试，仿真时间不同，不同层次、不同设计规模、不同测试场景的复杂度，都会影响测试用例的仿真时间。 回归测试中，对验证平台的优化（运算资源和运算效率）的要求更高。 如果系统级回归测试发现bug，修复后需要从模块级回归测试开始运行。  代码覆盖率  代码覆盖率是用来衡量RTL代码是否被充分运行的指标。 通过工具开关可自动收集代码覆盖率，且可以将不同批次回归测试覆盖率数据进行合并。  常见的代码覆盖率：\n 语句覆盖率（statement coverage）： 程序每一行代码是否执行过。 条件覆盖率（condition coverage）： 每个判断条件中的操作数被覆盖情况。 分支覆盖率（branch coverage）： if、case、while、repeat、for等语句中各个分支执行情况。 事件覆盖率（event coverage）： 记录某个事件被触发的次数。 翻转覆盖率（toggle coverage）： 记录信号数据位 0-\u0026gt;1 和 1-\u0026gt;0 的翻转情况。 状态机覆盖率（FSM coverage）： 记录状态机各个状态的进入次数，以及状态间的跳转情况。  断言覆盖率  断言描述本身也支持覆盖率收集，一般可以模拟仿真、形式化验证和硬件加速仿真都可以收集。 仿真过程中，会判断断言的先决条件是否被触发，以及判断语句的成功与否。 依据仿真工具不同，断言覆盖率可分为动态仿真和形式化验证两种。  功能覆盖率 功能覆盖率衡量设计的各项功能是否实现。功能覆盖率会关注设计的输入、输出和内部状态。\n 输入： 检测数据端的输入和命令组合类型，以及控制信号与数据传输的组合情况。 输出： 检测是否有完整的数据传输类别，以及各种场景的反馈时序。 设计内部： 检查信号与功能点相对应，通过单一覆盖、交叉覆盖或时序覆盖来检查功能场景是否被触发。  注意： 功能覆盖率的收集需要依据功能点文档编写covergroup，且fail用例的覆盖率数据不能合并到回归测试的覆盖率数据中。\nbug曲线  验证过程中要记录和统计bug，bug管理工具一般具有提交、修改、完成、挂起四个状态。 每周统计新增bug数量和修复bug数量，绘制bug曲线。 依据bug曲线，如果能尽早的收敛，意味着后期发现bug的数量和可能性就越小，是设计稳定性的有效指标。 注意： 如果验证后期发现一个基本功能的严重bug，意味着我们很可能在之前验证过程中遗漏了一些重要场景的测试。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":25,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（三）","uri":"https://wenhui.space/zh/docs/digital_verifer/beginner_verification/beginner_verification_three.html"},{"content":"本文 主要介绍一种verilog语言中获取随机数的方法。\n   版本 说明     0.1 初版发布    代码展示  设计代码   1 2 3 4 5  function [31:0] get_random; input signed [31:0] min_num; input signed [31:0] max_num; get_random = min_num + {$random}%(max_num-min_num+1); endfunction // get_random    验证代码（如果范围包括负数，请将random_num声明为有符号类型）   1 2 3 4 5 6 7 8 9 10 11 12  reg signed random_num initial begin #0 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #10 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end #20 begin random_num = get_random(-10,10); $display(\u0026#34;RANGE_NUM: %d\u0026#34;, random_num); end end   应用场景 实际设计中并不会使用随机数的生成逻辑，因为本身逻辑也是非可综合的。使用随机数生成逻辑往往用于测试逻辑。典型的应用如，为时钟添加时钟偏移（多用于跨时钟域设计的验证，如异步fifo验证）。\n1 2 3 4 5 6 7 8 9 10  parameter CLK_PERIOD = 50; reg clk; reg signed [31:0] random_num; reg [31:0] clk_shift_period; initial clk = 0; always begin random_num = get_random(-CLK_PERIOD/5,+CLK_PERIOD/5);//skewing 20%  clk_shift_period = CLK_PERIOD + random_num; #clk_shift_period/2 clk = ~clk; end   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":26,"section":"docs","tags":["Verilog"],"title":"Verilog中获取随机数","uri":"https://wenhui.space/zh/docs/digital_designer/other/random_in_verilog.html"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第三篇，主要介绍类和对象的概述、类的成员、类的继承、句柄的使用、包的使用。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 路科验证。  概览      类和对象的概述 类和对象  面向对象的编程语言更符号人对自然语言的理解（属性property和功能function）。 这个世界由无数的类（class）和对象（object）构成的。 类 是将相同的个体抽象出来的描述方式， 对象 是实体，其具备有独立行为能力。 具有相同属性和功能的对象属于同一类，而不同的类之间可能有联系（继承关系）或没有关系。 在C语言中，编程基于过程方法（function）；在verilog中，提供了笨拙的“类对象编程”可能性，也就是在module中定义方法（function/task/always/initial），而后调用module实例中的方法。 verilog中module+method的方式与sv中class定义有本质的区别，即面向对象的三要素：封装（encapsulation）、继承（inheritance）、多态（polymorphism）。本节只阐述类的封装和继承，多态在后续高级章节介绍。 类的定义核心是属性声明和方法定义，所以类既可以保存数据，也可以处理数据。这与struct结构体的重要区别就是，结构体只是数据的集合，而类不仅保存数据，还可以进行数据处理。  为了直观说明类的属性和方法，举例如下：\n 类名： 鸟 属性： 翅膀：有，羽毛：有 方法： 飞  例化一个类的过程，就是创建类的一个实例，类的实例就是对象。比如家里养了一只喜鹊，这就是对象，它属于鸟类，满足鸟类的属性，具有鸟类的方法，同时也可以拥有自己的属性，如下：\n 实例名： 喜鹊1 属性： 翅膀：有，羽毛：有，颜色：黑白，体重：700g \u0026hellip;\u0026hellip; 方法： 飞  验证为什么需要OOP（面向对象编程） 验证环境的各个组件具有以下特点：\n 验证环境中不同组件其功能和所需处理的数据内容是不同的。 验证环境中同一类组件其所具备的功能和数据内容相似。  所以，基于以上两点，验证环境中各个组件角色明确、功能独立，使用面向对象编程与验证环境的构建原则十分吻合。\n第一个transaction事务类：\n1 2 3 4 5 6 7  class transaction; bit [31:0] addr, crc, data[8]; function void display; $display(\u0026#34;transaction: %h\u0026#34;, addr); endfunction endclass   可见class的定义和module的定义类似，不过module和class完全不同：\n module属于硬件域，class属于软件域。 module内的变量是静态的，代表硬件电路，class内的变量是动态的，代表软件行为。 class内可以并且建议定义软件变量（bit等），而module只能定义硬件变量（reg、wire等）（其实也可以定义bit，只不过最后工具还是默认为reg类型）。 class例化后称为对象，module例化后称为实例。 class内不能出现initial和always。  OOP的概念要素  class类： 基本模块包含成员变量（属性）和方法。module也可以存在变量和方法，不过属于硬件域。 object对象： 类的实例。module也可以例化，属于硬件域。 Handle句柄（指针）： 用来指向对象的指针。module通过层级索引找到设计的实例。 property属性（变量）： 在类中声明的存储数据的变量。在module中就是reg和wire。 method方法： 在类中可以使用function/task来定义方法，在module中定义function/task，也可以定义always/initial。  创建对象  再次强调v module和sv class的区别：  两者共同点在于均使用“模板”来创建内存实例。 不同点在于v module例化是静态的，编译时完成，而sv class例化是动态的，可以任意时间点发生，这也使得类的例化方式更加灵活和节省空间。 v module中没有句柄概念，而是通过层级索引方式找到实例（A.B.C.sig1），而sv class通过句柄使操作更加灵活。   创建对象时，需要清楚什么是声明，什么是创建（例化）：  声明： transaction trans; 创建： trans = new();   创建对象时创建了什么？ 开辟了新的内存空间，用来存放对象的成员变量和方法。 创建对象时可以通过自定义构建函数来完成变量的初识化和其他操作。   1 2 3 4 5 6 7 8  class transaction； bit [31:0] addr, crc, data[8]; function new(); addr = 3; foreach(data[i]) data[i] = 5; endfunction endclass    构建函数new()系统预定义的函数，不需要指定返回值，函数会隐式的返回例化后的对象指针，所以并不是没有返回值，不能加void。 new函数也可以定义多个参数作为初始化时外部传入数值的手段。   1 2 3 4 5 6 7 8 9 10 11 12 13  class transaction； bit [31:0] addr, crc, data[8]; function new(bit[31:0] a=3, d=5); addr = a; foreach(data[i]) data[i] = d; endfunction endclass initial begin transaction trans; //声明  trans = new(10, 20); //带初始化数据的创建 end   句柄的传递 区分了类（抽象）和对象（具体）之后，还需要区分对象（存储空间）和句柄（对象指针）。也就是说，在创建了对象之后，该对象的存储空间位置不会变，而指向该空间的句柄可以有多个。\n1 2 3 4  transaction trans1, trans2; //声明句柄 trans1和trans2（此时句柄悬空，无指向对象） trans1 = new(); //例化对象，将其句柄赋予trans1 trans2 = trans1; //将trans1的值赋予trans2，也就是句柄trans1和trans2指向同一对象 trans1 =new(); //例化第二个对象，并将其句柄赋予trans1   首先两个new就代表创建了两个对象，最终trans1指向第二个对象，trans2指向了第一个对象。\n对象的销毁  软件编程的灵活在于动态的分配内存空间，在资源闲置时可以回收空间。 C++语言中的类除了有构建函数，还有析构函数，析构函数的作用就是手动释放空间，这对编程人员的细心和经验提出了要求；而Java和Python等后续的OOP语言不再需要手动定义析构函数，而是自动回收释放空间。 sv也采用自动回收空间的处理方式。回收原则：当一个对象在整个程序中没有任何地方再需要它时，便会被销毁，也即是回收空间。不需要的意思就是没有句柄指向该对象。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class word; byte nb[]; //声明动态数组  function new(int n); nb = new[n]; //创建动态数组（创建类的对象是使用\u0026#34;new()\u0026#34;）  endfunction endclass initial begin : initial_1 word wd; for(int i=1; i\u0026lt;=4; i++) wd = new(i); end initial begin : initial_2 #1p3 $display(\u0026#34;How many Bytes are allocated for word instances??\u0026#34;); end   根据以上代码，假设wd=new(1)需要分配1Byte空间，那么在initial_2中当打印语句时，需要为例化开辟多少空间呢？答案是4Byte，原因是wd是静态的；如果将wd声明改为“automatic word wd;”，答案就是0Byte，原因是wd是动态的，且#0ps时刻被创建，而#1ps打印时，wd变量已经消失，空间被回收了。\n句柄的使用  句柄可以用来创建多个对象，也可以前后指向不同对象。 可以使用句柄来使用对象中的成员变量或者成员方法，如下：   1 2 3 4  transaction trans; //声明句柄 trans = new(); //例化对象 trans.addr = 32\u0026#39;d10; // 为对象的成员变量赋值 trans.display(); //调用对象的成员方法   静态变量  与硬件域不同的是，class中声明的变量默认是动态的，其生命周期在仿真中的某一时间点，也就是对象的创建到对象的销毁。 如果使用关键字static来声明class内的变量，则其为静态变量。静态变量的生命周期贯穿整个仿真阶段。 如果类中声明了静态变量，那么可以直接引用该变量class::var，或者通过例化对象引用object.var。类中静态变量声明后，无论例化多少个对象，只可以共享一个同名的静态变量，因此类的静态变量的使用可以打通各个对象，但是要注意共享资源的保护，换句话说，任何地方修改静态变量，大家都会看到它的修改。  静态方法  类似与静态变量，在class中定义的方法默认为动态的，我们可以通过static关键字将其声明为静态方法。 静态方法内可以声明并使用动态变量，但是不能使用类的动态变量。原因是咋调用静态方法时，可能还没有创建具体的对象，对应的动态变量也就没有被创建，这时候是无法使用类的动态变量，编译时就会报错；静态方法中可以使用类的静态变量，因为静态变量和静态方法一样，编译时就创建了。  类的成员 概述  类是成员变量和成员方法的载体，这些成员可以完成保存数据和处理数据的功能，并且类的变量和方法应该遵循“聚拢”原则，也就是一个类的功能要尽可能单一，做好专职工作。 类作为载体，天生具备了闭合属性，也就是将其属性（变量）和方法封装在类的内部，不会直接暴露给外部，并且可以通过protected和local的关键词，设置变量和方法的外部访问权限。 如果没有指明访问类型，成员默认为public（public并不是关键字），意味着子类和外部都可以访问。 如果指明访问类型为protecd，那么只有该类及其子类可以访问，外部无法访问。 如果指明访问类型为local，那么只有该类可以访问，子类和外部无法访问。 访问类型的设定是为了更好的封装类，尤其是发布供他人使用的软件包，如果验证环境应用范围较窄，可以使用默认的public访问类型，方便类的外部更好的使用变量和方法。  定义和调用成员方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class transaction1； bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction1\u0026#34;); endfunction endclass class transaction2； bit [31:0] addr, data[8]; // ......  function void display(); $display(\u0026#34;dispaly transaction2\u0026#34;); endfunction endclass   1 2 3 4 5 6 7 8 9  transaction1 t1; //声明句柄t1 transaction2 t2; //声明句柄t2 initial begin t1 = new(); //创建对象  t1.display(); //调用transaction1::display()  t2 = new(); //创建对象  t2.display(); //调用transaction2::display() end   类的封装  类和结构体的异同：  二者本身都可以定义数据成员。 类变量在声明后，需要构造才会创建对象实体，而struct在变量声明时已经开辟内存。（有时候类没有new函数，也并不会出错，并不是不需要new，而是系统自动调用了new函数） 类除了可以声明数据变量，还可以声明方法，而struct不能。换句话说，struct就是个数据结构，而class包含了数据成员以及对数据成员处理的方法。   类与module的异同：  从数据和方法来看，两者都可以作为封闭容器来定义和存储。 从例化来看，module必须在仿真开始时就确定是否要例化，而类可以在仿真的任意时刻被例化。换句话说，module是硬件域，静态的，class是软件域，动态的。 从封装性来看，module内的变量和方法是对外部公共开发的，而类可以定义为公共的、受保护的和私有的。 从继承性来看，module没有继承性可言，也就是无法在原有的module的基础上进行module的功能扩展，而继承性是类的一大特点。    思考  可以在哪里定义类？ 答案：module、interface、program和package，也就是所有“盒子”。 可以在类中再声明类成员吗？ 答案：可以，类也是一种数据载体。 What is this ？ 答案：如果在类中使用 this ，即表明this.X所调用的成员是当前类的成员，而非同名的局部变量或者形式参数等。   1 2 3  function new(string name); this.name = name; //将参数传递的name赋值给当前类的name变量 endfunction    类有编译顺序吗？ 答案：有，建议的编译顺序是先编译基类，再编译高级类，或者说先编译将被引用的类，再编译引用 之前已经编译过的类 的类，其实就是个依赖关系。  类的继承 概述  继承也符合我们的认识世界的观点，我们对世界的认识无外乎归纳法和演绎法。 归纳法就是从个别特别到一般属性的方法，从具体对象中抽象出类的属性和方法，这就是定义类的思维方式。 “白猫黑猫都是猫，抓住老鼠就是好猫”，这里白猫黑猫都继承于猫类，他们有一个属性是颜色，另一个属性是好坏。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class cat; protected color_t color; local bit is_good; function set_good(bit s); this.is_good = s; endfunction endclass class black_cat extends cat; function new(); this.color = \u0026#34;BLACK\u0026#34;; endfunction endclass class white_cat extends cat; function new(); this.color = \u0026#34;WHITE\u0026#34;; endfunction endclass black_cat bk; white_cat wt; initial begin bk = new(); wt = new(); bk.set_good(1); wt.set_good(0); end   由上面代码得出结论：\n 不可以通过外部修改黑/白猫的颜色，因为声明的是受保护的变量。 黑/白猫不可以自己初始化时设置is_good夸自己是好猫，因为cat类定义的is_good是local类型。 外部不可以通过访问黑/白猫的is_good属性来得知是不是好猫，因为cat类定义的is_good是local类型，无法访问。 黑/白猫是不是大脸猫，无从得知，因为没有这个属性。  案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class basic_test; int def = 100; //成员变量赋予默认值  int fin; task test(sim_ini ini); $display(\u0026#34;basic_test::test\u0026#34;); endtask function new(int var); //......  endfunction endclass class test_wr extends basic_test; function new(); super.new(def); $display(\u0026#34;test_wr::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_wr::test\u0026#34;); //......  endtask endclass class test_rd extends basic_test; function new(); super.new(def); $display(\u0026#34;test_rd::new\u0026#34;); endfunction task test(stm_ini ini); super.test(ini); $display(\u0026#34;test_rd::test\u0026#34;); //......  endtask endclass    类test_wr和test_rd是子类，其父类为basic_test，也叫基类。 子类在定义new函数时，应该首先调用父类的new函数，即super.new()。如果父类的new无任何参数，也可以省略super.new()，因为系统会自动调用。 要想继承父类的属性和方法，必须调用（显式或隐式）super.new()。 从创建对象的初始化来看，用户应该注意如下的规则：  子类的实例对象在初始化时首先会调用父类的构造函数。 当父类构造函数完成时，会将子类实例对象中各个成员变量按照他们定义时的默认值初始化，如果没有默认值则不初始化。 在成员的变量默认值赋予后（声明的同时即赋值），才会最后进入用户定义的new函数中执行剩余的初始化代码。    成员的覆盖 在父类和子类里，可以定义相同名称的成员变量和方法（形式参数和返回值也应该相同），而在引用时，也将按照句柄类型来确定作用域。举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class basic_test; int def = 100; //成员变量赋予默认值  function new(int var); //......  endfunction endclass class test_wr extends basic_test; int def = 200; //成员变量赋予默认值  function new(); super.new(def); $dispaly(\u0026#34;test_wr::super.def =%0d\u0026#34;, super.def); //super.def为100  $dispaly(\u0026#34;test_wr::this.def =%0d\u0026#34;, this.def); //this.def为200  endfunction //...... endclass module tb; //...... basic_test t; test_wr wr; initial begin wr = new(); t = wr; //将子类对象句柄赋值给父类句柄（实际上父类句柄t仍旧只能访问父类变量，而并没有扩大作用域至子类，如果想扩大作用域，只能使用$cast，而不是等号）  $display(\u0026#34;wr.def = %0d\u0026#34;, wr.def ); $display(\u0026#34;t.def = %0d\u0026#34;, t.def ); end endmodule   最后打印的wr.def和t.def的值分别为多少？答案是200和100。首先声明了父类的句柄t和子类句柄wr，创建了子类的实例wr，又将子类的句柄wr赋给了父类句柄t。此时句柄t和wr都指向了这个对象，这里就有区分了，虽然都指向同一对象，但是子类句柄wr可以访问这个对象中的全部变量，也就是def默认值为200，而父类句柄t只能访问子类继承自父类的变量，也就是def默认值为100。这里有两个关键点，一是父类和子类都声明了相同名字的变量，二是子类句柄赋值给了父类句柄，在此场景下需要特别注意。\n总结：\n test_wr类新定义的变量test_wr::def和basic_test::有冲突（同名），但是在类的定义里， 父类和子类拥有同名的变量和方法也是允许的 。当子类作用域中出现父类同名的变量和方法，则 以子类作用域为准 。同时也可以使用this/super来指明使用子类/父类的变量/方法。 父类和子类拥有同名或非同名的变量或方法时，子类使用变量和方法，如果不指明super/this，则依照由近及远的原则来引用变量。  首先看变量是否是在函数内部定义的局部变量。 其次看变量是否是当前类定义的成员变量。 最好再看变量是否是父类或更底层类的变量。    句柄的使用 句柄的传递  句柄可以作为形式参数通过方法来完成对象指针的传递，从外部传入方法内部（注意：传递的参数是句柄，而不是对象，并且对象是创建在一块内存里的，永远不可能作为参数传递）。   1 2 3 4 5 6 7 8 9  task generator; tranctions t; t = new(); transmit(t); endtask task transmit(transaction t); //...... endtask    句柄也可以在在方法内部首先完成修改，而后再由外部完成使用。   1 2 3 4 5 6 7 8 9 10 11 12 13  function void create(tranction tr); //Bug, miss ref  tr =new(); tr.addr = 100; //initialize other fields  //...... endfunction transaction t; initial begin create(t); t.addr = 10; $display(t.addr); end   问题：最后显示的t.addr的数值是多少？ 答案：报错。分析：create函数的参数默认为input，没有返回值，也就是create函数内所做的操作都是局部的，而在外部看来，句柄t还是个null，没有实例，所以在引用t.addr时会报错。改进方法是：参数声明为inout 或 添加ref关键字。\n句柄的动态修改 程序执行时，可以在任何时候为句柄创建新的对象，并将新的指针赋值给句柄。\n1 2 3 4 5 6 7 8 9 10 11 12  task generate trans(); transaction t; //声明句柄  tranction fifo[$]; //声明存放句柄的队列  t =new(); //创建对象  for(int=0; i\u0026lt;3; i++) begin t.addr = i\u0026lt;\u0026lt;2; fifo.push_back(t); end t = fifo.pop_front(); endtask   问题：最后t.addr数值多少？ 答案：8。分析：首先循环对t.addr的赋值依次为0 4 8，队列依次存入三个t，最后弹出第一个赋给t，仿佛最后t.addr的值应该是第一个数字0，为什么会是8，原因就一个，队列里存放的是句柄，不是对象，三次存入的句柄t的内容不变，都指向对象t，而对象t的addr变量是8。所以牢记： *传递和传递的是句柄，而不是对象*。\n包的使用 包的意义  sv语言提供了一种在多个module、interface和program中共享parameter、data、type、task、function、class等的方法，即利用package（包）的方式来实现。如果装修一个大房子（完整的验证环境）来看的话，我们喜欢将不同的模块的类定义归整到不同的package中。 这么做的好处在于将一簇相关的类组织在单一的命名空间下，使得分属于不同模块验证环境的类来自于不同package，这样便于通过package来解决类的归属问题。  包的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package regs_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage package arb_pkg; `include \u0026#34;stimulator.sv\u0026#34; `include \u0026#34;monitor.sv\u0026#34; `include \u0026#34;checker.sv\u0026#34; `include \u0026#34;env.sv\u0026#34; endpackage //导入包 module tb; import regs_pkg::*; import arb_pkg::*; regs_mon mon1 = new(); arb_mon mon2 = new(); endmodule    两个package regs_pkg和arb_pkg中都定义了4个与模块验证相关的类，即stimulator、monitor、checker、env。两个不同的package内存在同名的类，但是它们的内容是不同的。 如果我们将这些重名的类归属到不同的package中去编译，不需要担心命名冲突的问题，因为package会将命名空间分隔开率，在使用同名类时，注明要使用哪个package的即可。   1 2  regs_pkg::monitor mon1 = new(); arb_pkg::monitor mon2 = new();   包与库的区分  package可以对类名做一个隔离的作用，使用不同的package管理同名的类，可以解决命名冲突问题。（使用域名索引符“::”） package更多的意义是将软件封装在不同的命名空间中，以此来与全局的命名空间进行隔离。 library是编译的产物，硬件都会被编译到库中，如果不指明编译库，会被编译到默认的库中（worklibrary），同样可以解决命名冲突的问题（不过设计中我认为都会依靠一套完整的命名规则来命名，这样不仅解决同名冲突问题，还可以从名字上了解到模块的更多信息）。 库既可以容纳硬件、也可以容纳软件，包括package。  包的命名规则  在创建package的时候，已经在指定包名称的时候隐含地指定了包的默认路径，即包文件所在的路径，如果在package中要include该路径之外的文件，需要额外指定搜索路径“+incdir+PATH”。 如果遵循package的命名习惯，不但要求定义的package名称独一无二，其内部定义的类也应该尽可能独一无二。 如果不同package中定义的类名也不相同，在顶层的引用可以通过“import pkg_name::*”的形式，来表示在tb中引用的类如果在当前域中没有定义，会搜寻regs_pkg和arb_pkg中定义的类（前提是所有类不同名）。 类的命名上，建议加上指明特定身份的前缀，比如package名。  包的使用建议  在包中可以定义类、静态方法和静态变量。 如果将类封装在某一个包中，那么它就不应该在其他地方编译，这样可以方便后面对类的引用。 类和包是好朋友，包是类的归宿，类是包的子民。 一个完整模块的验证环境组件类，应该由一个对应的模块包来封装。 使用`include关键词完成类在包中的封装，要注意编译的前后顺序。 编译一个包的背后实际是将各类文件平铺在包中，按照顺序完成包和包内各类的有序编译。 使用类的可以通过`import完成包中所有类或者某个类的导入，使得新环境可以识别出来，否则类会躺在包外不被外部识别。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":27,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（三）","uri":"https://wenhui.space/zh/docs/digital_verifer/study_sv/study_sv_three.html"},{"content":"本文 主要介绍辅助verilog编码的三款工具，简化编码工作。\n   版本 说明     0.1 初版发布    三大利器  Emacs verilog-mode 的使用 代码预处理工具ep3的使用 verilog中reg和wire的自动声明  verilog编码我们需要写什么？ 如下代码，我们实际要写的，也就是真正的逻辑部分，而其他部分基本全部由以上三大利器完成。注意，正常使用顺序为：先ep3进行代码预处理，再verilog-mode进行AUTO处理，最后自动声明reg和wire。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  module demo(/*AUTOARG*/); input clk; input din1; input [3:0] din2; @for i=0 to 5 output dout@i; @endfor /*AUTOWIRE*/ /*AUTOREG*/ /*AUTO DECLARE*/ assign sig1 = \u0026amp;din_b[3:0]; //.........other logic  sub_mod i_sub_mod(/*AUTOINST*/); endmodule   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":28,"section":"docs","tags":["Verilog"],"title":"简化verilog编码的全套解决方案","uri":"https://wenhui.space/zh/docs/digital_designer/other/verilog_coding_three_tools.html"},{"content":"本文 主要介绍一款代码预处理工具：ep3（基于Perl语言开发）。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Perl： v5.24.1  参考  https://metacpan.org/search?q=ep3 http://www.lujun.org.cn/?p=2099  什么是ep3？ ep3是一款基于Perl语言开发的脚本工具，主要对代码中一些重复代码，通过脚本处理自动生成，以节省编码工作。\n下载与安装 下载  github（安装包）：https://github.com/weiqi7777/ep3 百度网盘分享资源（安装包）： 链接：https://pan.baidu.com/s/1VU3%5FbI0HXdhopquccYHo2Q 密码：co5s 百度网盘分享资源（可执行程序）： 链接：https://pan.baidu.com/s/1GKROlch5GDqglpbbUs09mw 密码：andt  安装  下载可执行程序的话，将其放到/usr/local/bin/目录（也可以是其他PATH变量下目录）下即可使用，无需安装。 下载安装包的话（详情可见readme），安装到/usr/local/bin/（需要root权限）：   1 2 3 4 5  su perl Makefile.PL make make test make install    下载安装包的话（详情可见readme），安装到~/tool/bin/：   1 2 3 4  perl Makefile.PL PREFIX=~/tools/usr make make test make install   使用命令 1  ep3 [option] source_file \u0026gt;result_file   option选项：\n1 2 3 4 5 6 7 8 9  Usage:\t/usr/local/bin/ep3 [-include dir] [-define key [value]] [-delimeter string] [-module modulename] [-[no]comments] [-[no]protect] [-[no]depend] file1 [file2 .. filen]    -include： 指明include路径 -define： 定义参数， 如 -define TYPE=1（参数赋值等号左右无空格） -nocomments: 去除文件中的注释 -noprotect: 注释保护，默认是不对注释内容进行处理的，如果设为-noprotect，会处理注释内容 -delimeter string: 默认是@，可以指定其他字符 其他参数：待学习，暂不清楚  使用场景 删除注释 使用命令 ep3 -nocomments filename.v \u0026gt;filename.v ，即可删除代码中所有注释内容。\n循环  原代码   1 2 3  @for i =2 to 5 reg mem@i; @endfor    ep3 filename.v \u0026gt;filename.v 处理后   1 2 3 4  reg mem2; reg mem3; reg mem4; reg mem5;   传递参数和条件判断 注意：ep3传递参数和带参数值的条件判断（@if和@elif和 @else 和@endif关键字），只能使用命令行传参使用。\n 原代码   1 2 3 4 5 6 7 8 9  @if TYPE == 0 reg TYPE_0; @elif TYPE == 1 reg TYPE_1; @elif TYPE == 2 reg TYPE_2; @else reg TYPE_3; @endif    ep3 -define TYPE=2 filename.v \u0026gt;filename.v 处理后（注意，TYPE=2，等号左右无空格；如果多个参数，每一个参数前都要有-define）：   1  reg TYPE_2;   定义宏  原代码（也可以将宏定义内容放到某文件，在使用宏前进行include，效果相同，关于include的使用请参考下文)：   1 2 3  @macro `A_WIDTH 8 reg [`A_WIDTH-1:0] sig1;    处理后：   1  reg [8-1:0] sig1;   def判断 关键字：@ifdef和@ifndef和@else和@endif。\n 原代码（也可以将define定义内容放到某文件，在def判断前进行include，效果相同，关于include的使用请参考下文）：   1 2 3 4 5 6 7  @define TYPE0_ON @ifdef TYPE0_ON reg TYPE_0; @else reg TYPE_1; @endif    处理后：   1  reg TYPE_0;    还可以使用@enum定义宏，一行定义多个，与@define效果相同   1  @enum a,b,c,d   include  原代码：   1 2  //include @include \u0026#34;inc1.v\u0026#34;    创建inc1.v文件，其内容如下（如果是@define或@macro，换成对应内容即可）：   1 2  reg mem1; reg mem2;    ep3关于include的查找默认是当前目录，使用 ep3 filename.v \u0026gt;filename.v 命令即可 ，如果非同一目录，可以在命令行指定目录 ep3 -include ./include/ filename.v \u0026gt;filename.v ，也可以在@include语句中指明文件目录，处理后如下：   1 2 3  //include reg mem1; reg mem2;   replace  原代码  replace以空格为分隔符，第一个参数作为被替换对象，其余作为替换内容。\n1 2 3  @replace AA BB MM CC This is AA;    处理后   1  This is BB MM CC;   perl_begin和perl_end ep3支持在代码中使用perl语言生成代码，关键字是@perl_begin和@perl_end。\n 原代码：   1 2 3 4 5  @perl_begin for($i=0;$i\u0026lt;3;$i++) { print \u0026#34;reg mem${i};\\n\u0026#34;; } @perl_end    处理后：   1 2 3  reg mem0; reg mem1; reg mem2;   也可以使用perl语言定义子函数，辅助生成代码：\n 原代码（定义了@hello函数）：   1 2 3 4 5 6 7 8 9 10  1 Text to be printed ... @perl_begin sub hello { my $self = shift; print \u0026#34;Hello there\\n\u0026#34;; } @perl_end 2 Text to be printed ... @hello 3 Text to be printed ...    处理后（在“2 Text”后引入@hello）：   1 2 3 4  1 Text to be printed ... 2 Text to be printed ... Hello there 3 Text to be printed ...   更多无耻要求 以上是常用场景，基本满足日常需求了，如有更多无耻要求，请查看相关资料，并且有解决方案的话，欢迎分享。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":29,"section":"docs","tags":["Verilog"],"title":"代码预处理工具ep3的使用","uri":"https://wenhui.space/zh/docs/about_linux/ep3_tool.html"},{"content":"本文 主要介绍一款自己开发的Python脚本： verilog中reg和wire的自动声明 。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 Python： Python 2.7.13  功能  该脚本会统计always块和assign语句中的赋值对象，并且自动识别wire类型和reg类型，以及信号位宽，完成自动声明。 会滤除已声明的wire和reg信号，以及output信号，不会对已声明的信号重复声明。 支持位宽使用宏定义，建议使用 [`XXX_WIDTH-1 : 0] 方式定义（对于使用宏定义的信号，需要对自动生成的声明结果再次确认，如有修改，可将修改后的信号声明置于/*AUTO DECLARE*/之前，脚本不会对已声明的信号重复声明）。 自动滤出注释内容。 其他功能，待添加（如begin end匹配检查）  脚本源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304  #!/usr/bin/env python #-*- coding:utf-8 -*- import sys import operator import re import os import os.path #Ignore comments Begin #-------------------------------------------------------- def ignore_comments(line_val, nextline_is_comment): line_nocomment=re.sub(\u0026#39;//[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_val) #Ignore comments(//) line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments(/* */) line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) #Ignore comments(/* */ Cross-line_nocomment) currentline_is_comment=nextline_is_comment if \u0026#34;/*\u0026#34; in line_nocomment: nextline_is_comment=True line_nocomment=re.sub(\u0026#39;/\\*[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if \u0026#34;*/\u0026#34; in line_nocomment: nextline_is_comment=False currentline_is_comment=False line_nocomment=re.sub(\u0026#39;[\\s\\S]*\\*/\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments if currentline_is_comment: line_nocomment=re.sub(\u0026#39;[\\s\\S]*\u0026#39;, \u0026#39;\u0026#39;, line_nocomment) #Ignore comments line_nocomment=line_nocomment.strip() #Ignore Spaces(head and tail of line_nocomment) if line_nocomment == \u0026#39;\u0026#39;: line_nocomment=\u0026#34;/*LINE_IS_COMMENT*/\u0026#34; return line_nocomment, nextline_is_comment #-------------------------------------------------------- #Ignore comments End #Fetch Keywords Add To Dict Begin #-------------------------------------------------------- def fetch_keywords(line_val): line_val=re.sub(\u0026#39;input \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;output \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;wire \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;reg \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;assign \u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=re.sub(\u0026#39;[\u0026lt;]?=[\\S\\s]*\u0026#39;, \u0026#39;\u0026#39;, line_val) line_val=line_val.strip() signal_width=re.findall(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, line_val) if len(signal_width) != 0 : signal_name=re.sub(\u0026#39;\\[[` a-zA-Z0-9_:\\-]+\\]\u0026#39;, \u0026#39;\u0026#39;, line_val) signal_name=signal_name.strip() signal_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;\\[[\\s]*([`a-zA-Z0-9_\\-]+)\u0026#39;, line_val)) signal_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;([`a-zA-Z0-9_\\-]+)[\\s]*\\]\u0026#39;, line_val)) else: signal_name=line_val.strip() signal_width_max=\u0026#39;0\u0026#39; signal_width_min=\u0026#39;0\u0026#39; return signal_name, signal_width_max, signal_width_min #-------------------------------------------------------- #Fetch Keywords Add To Dict End #Add Keys To Dict Begin #-------------------------------------------------------- def add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, key_val, key_width_max, key_width_min): if type_val == \u0026#39;output_type\u0026#39;: output_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;input_type\u0026#39;: input_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;wire_type\u0026#39;: wire_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return if type_val == \u0026#39;reg_type\u0026#39;: reg_dict.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return input_check=input_dict.has_key(key_val) output_check=output_dict.has_key(key_val) reg_check=reg_dict.has_key(key_val) wire_check=wire_dict.has_key(key_val) addwire0_check=addwire_dict0.has_key(key_val) addreg0_check=addreg_dict0.has_key(key_val) addwire1_check=addwire_dict1.has_key(key_val) addreg1_check=addreg_dict1.has_key(key_val) if key_width_max.isdigit() and key_width_min.isdigit(): if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: signal_width_max=addwire_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addwire_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addwire_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addwire_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif output_check or addwire1_check or wire_check: pass else: addwire_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: signal_width_max=addreg_dict0[key_val][\u0026#39;width_max\u0026#39;] signal_width_min=addreg_dict0[key_val][\u0026#39;width_min\u0026#39;] if int(key_width_max) \u0026gt; int(signal_width_max): addreg_dict0[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if int(key_width_min) \u0026lt; int(signal_width_min): addreg_dict0[key_val][\u0026#39;width_min\u0026#39;]=key_width_min elif addreg1_check or reg_check: pass else: addreg_dict0.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) else: update_width_max=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;`[a-zA-Z0-9]+[\\s]*\\-[\\s]*1\u0026#39;, key_width_max)) update_width_min=\u0026#39;\u0026#39;.join(re.findall(\u0026#39;0\u0026#39;, key_width_min)) if type_val == \u0026#39;addwire_type\u0026#39;: if addwire0_check: addwire_dict0.pop(\u0026#39;key_val\u0026#39;) if addwire1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif output_check or wire_check: pass else: addwire_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) if type_val == \u0026#39;addreg_type\u0026#39;: if addreg0_check: addreg_dict0.pop(\u0026#39;key_val\u0026#39;) if addreg1_check: if update_width_max != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_max\u0026#39;]=key_width_max if update_width_min != \u0026#39;\u0026#39;: addwire_dict1[key_val][\u0026#39;width_min\u0026#39;]=key_width_min pass elif reg_check: pass else: addreg_dict1.update({key_val:{\u0026#39;width_max\u0026#39;:key_width_max, \u0026#39;width_min\u0026#39;:key_width_min}}) return #-------------------------------------------------------- #Add Keys To Dict End #Print Declare Begin #-------------------------------------------------------- def print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1): addwire_dict0_keys=addwire_dict0.keys() addwire_dict1_keys=addwire_dict1.keys() addreg_dict0_keys=addreg_dict0.keys() addreg_dict1_keys=addreg_dict1.keys() print \u0026#34; // Begin auto declaration\u0026#34; print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict1_keys: if addwire_dict1[key][\u0026#39;width_max\u0026#39;] == addwire_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addwire_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict1_keys: if addreg_dict1[key][\u0026#39;width_max\u0026#39;] == addreg_dict1[key][\u0026#39;width_min\u0026#39;]: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict1[key][\u0026#39;width_max\u0026#39;] + \u0026#34;:\u0026#34; + addreg_dict1[key][\u0026#39;width_min\u0026#39;] + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // Please double check the declaration with macro\u0026#34; for key in addwire_dict0_keys: if addwire_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; wire \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; wire \u0026#34; + \u0026#34;[\u0026#34; + addwire_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addwire_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration for key in addreg_dict0_keys: if addreg_dict0[key][\u0026#39;width_max\u0026#39;] == \u0026#39;0\u0026#39;: declaration=\u0026#34; reg \u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; else: declaration=\u0026#34; reg \u0026#34; + \u0026#34;[\u0026#34; + addreg_dict0[key][\u0026#39;width_max\u0026#39;].rjust(4) + \u0026#34;:\u0026#34; + addreg_dict0[key][\u0026#39;width_min\u0026#39;].rjust(4) + \u0026#34;]\u0026#34; + \u0026#34; \u0026#34; + key + \u0026#34;;\u0026#34; print declaration print \u0026#34; // End auto declaration\u0026#34; #-------------------------------------------------------- #Print Declare End #Main Program Begin #-------------------------------------------------------- #open verilog file #================= try: vfile=open(sys.argv[1], \u0026#39;r\u0026#39;) alllines=vfile.readlines() except (IOError,OSError) as reason: print(\u0026#39;文件出错了！错误原因是：\\n\u0026#39; + str(reason)) finally: vfile.close() #================= #line process #================= input_dict={} output_dict={} wire_dict={} reg_dict={} addwire_dict0={} addreg_dict0={} addwire_dict1={} addreg_dict1={} nextline_is_comment=False currentline_is_comment=False line_num=0 for line in alllines: line_num+=1 line_nocomment, nextline_is_comment=ignore_comments(line, nextline_is_comment) if line_nocomment == \u0026#34;/*LINE_IS_COMMENT*/\u0026#34;: continue #print \u0026#34;Line Nocomment:\u0026#34;, line_nocomment output_regex=re.compile(\u0026#39;(output[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) input_regex=re.compile(\u0026#39;(input[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) wire_regex=re.compile(\u0026#39;(wire[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) reg_regex=re.compile(\u0026#39;(reg[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[a-zA-Z0-9_]+[\\s]*)\u0026#39;) addwire_regex=re.compile(\u0026#39;(assign[\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) addreg_regex=re.compile(\u0026#39;([\\s]*[a-zA-Z0-9_]+[\\s]*(?:\\[[` a-zA-Z0-9_:\\-]+\\])?[\\s]*[\u0026lt;]?=[^=\u0026gt;\u0026lt;!~]+)\u0026#39;) output_line=output_regex.findall(line_nocomment) input_line=input_regex.findall(line_nocomment) wire_line=wire_regex.findall(line_nocomment) reg_line=reg_regex.findall(line_nocomment) addreg_line=addreg_regex.findall(line_nocomment) addwire_line=addwire_regex.findall(line_nocomment) if len(output_line) != 0: type_val=\u0026#34;output_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(output_line)) elif len(input_line) != 0: type_val=\u0026#34;input_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(input_line)) elif len(wire_line) != 0: type_val=\u0026#34;wire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(wire_line)) elif len(reg_line) != 0: type_val=\u0026#34;reg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(reg_line)) elif len(addwire_line) != 0: #Note: wire should be judged before reg type_val=\u0026#34;addwire_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addwire_line)) elif len(addreg_line) != 0: type_val=\u0026#34;addreg_type\u0026#34; signal_name, signal_width_max, signal_width_min = fetch_keywords(\u0026#39;\u0026#39;.join(addreg_line)) else: continue # print \u0026#34;##Type Vale :\u0026#34;, type_val # print \u0026#34;##Signal_Name :\u0026#34;, signal_name # print \u0026#34;##Signal_Width_Max:\u0026#34;, signal_width_max # print \u0026#34;##Signal_Width_Min:\u0026#34;, signal_width_min # print \u0026#34;\\n\u0026#34; add_keys_to_dict(type_val, input_dict, output_dict, wire_dict, reg_dict, addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1, signal_name, signal_width_max, signal_width_min) #================= #print declare #================= #print addwire_dict0 #print \u0026#34;\u0026#34; #print addwire_dict1 #print \u0026#34;\u0026#34; #print addreg_dict0 #print \u0026#34;\u0026#34; #print addreg_dict1 print_declare(addwire_dict0, addreg_dict0, addwire_dict1, addreg_dict1) #================= #-------------------------------------------------------- #Main Program End   使用方法 写在前头  此脚本要求所有自声明的wire和reg要在/*AUTO DECLARE*/之前 要添加自动声明的位置，严格使用/*AUTO DECLARE*/关键字。 本脚本不支持以下赋值语句，请不要使用同时给多个信号赋值的语句：   1  assign {sig_a, sig_b} = 2\u0026#39;b11;    此脚本只自动声明被赋值信号，如有例化模块的输出信号，请使用emacs verilog-model 的AUTOWIRE。  手动添加 可以使用脚本将自动声明结果打印的屏幕或重定向到文件，手动赋值粘贴，使用命令如下(脚本文件名为verilog_auto_declare.py)：\n1 2  python verilog_auto_declare.py verilog_filename.v python verilog_auto_declare.py verilog_filename.v \u0026gt;autodeclare.log   shell封装 如果想将声明结果自动添加到文件，需要用shell将脚本进行封装。\n print_declare.sh（请更改为自己的verilog_auto_declare.py路径）   1 2 3 4 5 6  #!/bin/bash  python ~/Treasury/tools_and_drives/verilog_auto_declare/verilog_auto_declare.py $1 \u0026gt;autodeclare.log sed \u0026#39;/\\/*AUTO DECLARE/r autodeclare.log\u0026#39; $1 \u0026gt; print_declare.v mv print_declare.v $1 rm -rf autodeclare.log    delete_declare.sh   1 2 3 4  #!/bin/bash  sed \u0026#39;/\\/\\/ Begin auto declaration/,/End auto declaration/c \\\u0026#39; $1 \u0026gt;delete_declare.v mv delete_declare.v $1   使用时 source print_declare.sh verilog_filename.v 和 source delete_declare.sh verilog_filename.v 即可。也可以将shell脚本文件属性改为可执行，通过设置alias或将其放到linux的PATH变量路径，可以在终端直接使用。如下：\n 更改文件属性   1 2  chmod 755 print_declare.sh chmod 755 print_declare.sh    设置alias（将下面内容添加到~/.bashrc文件）   1 2 3  #verilog_auto_declare alias print_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/print_declare.sh\u0026#39; alias delete_declare=\u0026#39;~/Treasury/tools_and_drives/verilog_auto_declare/delete_declare.sh\u0026#39;   效果 verilog源码 以下代码无实际意义，仅作为测试使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   print_declare后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module auto_declare_test(/*AUTOARG*/ // Outputs dout_a, dout_b, // Inputs clk, din_a, din_b, din_c, dout_c ); input clk; input din_a; input [3:0] din_b; input [`C_WIDTH-1:0] din_c; output dout_a; output [5:0] dout_b; input [`C_WIDTH-1:0] dout_c; wire w_aaaa; wire [3:0] w_bbbb; wire [`WC_WITH-1:0] w_cccc; reg r_aaaa; reg [3:0] r_bbbb; reg [`RC_WITH-1:0] r_cccc; /*AUTO DECLARE*/ // Begin auto declaration  // Please double check the declaration with macro  wire [`YYYYWIDTH] marco_yyyy; wire [`XXXXWIDTH-1:0] marco_xxxx; reg [`AAAAWIDTH-1:0] marco_aaaa; reg [`BBBBWIDTH-1:0] marco_bbbb; // Please double check the declaration with macro  wire w_yyyy; wire w_xxxx; wire [ 1: 1] wccy; wire [ 2: 2] wccx; reg r_yyyy; reg r_zzzz; reg r_xxxx; // End auto declaration  //wire w_aa; //wire [3:0] w_bb; //wire [`WC_WITH-1:0] w_cc; //reg r_aa; //reg [3:0] r_bb; //reg [`RC_WITH-1:0] r_cc; //assign w_aa = 1\u0026#39;b1; //assign w_xx = 1\u0026#39;b1; //assign w_yy = w_aa ? 1\u0026#39;b1 : // 1\u0026#39;b0 ; //always(*) r_bb[3:0] = 4\u0026#39;b1100; //always(*) // r_aa = 1\u0026#39;b1; //always@(posedge clk)begin // r_xx \u0026lt;= w_aa; // r_yy \u0026lt;= w_bb[0]; // r_zz \u0026lt;= w_cc[3]; //end  /* wire w_aaa; wire [3:0] w_bbb; wire [`WC_WITH-1:0] w_ccc; reg r_aaa; reg [3:0] r_bbb; reg [`RC_WITH-1:0] r_ccc; assign w_aaa = 1\u0026#39;b1; assign w_xxx = 1\u0026#39;b1; assign w_yyy = w_aaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbb[3:0] = 4\u0026#39;b1100; always(*) r_aaa = 1\u0026#39;b1; always@(posedge clk)begin r_xxx \u0026lt;= w_aaa; r_yyy \u0026lt;= w_bbb[0]; r_zzz \u0026lt;= w_ccc[3]; end */ assign w_aaaa = 1\u0026#39;b1; assign w_bbbb = 1\u0026#39;b1; assign w_cccc = 1\u0026#39;b1; assign w_xxxx = 1\u0026#39;b1; assign w_yyyy = w_aaaa ? 1\u0026#39;b1 : 1\u0026#39;b0 ; always(*) r_bbbb[3:0] = 4\u0026#39;b1100;/*coment comment comment*/ always(*)//assign wccx[3:0] = 4\u0026#39;b1011;  r_aaaa = 1\u0026#39;b1;/*assign wccxxxx[3:0] = 4\u0026#39;b1011;*/ always@(posedge clk)begin//wire yywcc;  r_xxxx \u0026lt;= w_aaaa;/*wire [3:0] yywccy; */ r_yyyy \u0026lt;= w_bbbb[0]; r_zzzz \u0026lt;= w_cccc[3];/*assign dyyyy[3:0] = 4\u0026#39;b1011; */marco_aaaa [`AAAAWIDTH-1:0] = 8\u0026#39;h45; marco_bbbb [`BBBBWIDTH-1:0] = 8\u0026#39;h45; end assign marco_xxxx [`XXXXWIDTH-1:0] = 8\u0026#39;h45; assign marco_yyyy [`YYYYWIDTH] = 1\u0026#39;b1; assign wccx [2] = 1\u0026#39;b1; assign wccy [1] = 1\u0026#39;b1; endmodule // auto_declare_test   下载  百度网盘分享资源 链接：https://pan.baidu.com/s/1WEzfSkeZsgYp8gITMsWtqQ 密码：7ui9  其他说明 此版本为初步完成，可能存在部分bug，如有发现bug或有新的需求，欢迎交流。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":30,"section":"docs","tags":["Python","Verilog"],"title":"verilog中reg和wire的自动声明","uri":"https://wenhui.space/zh/docs/about_linux/verilog_auto_declare.html"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第二篇，主要介绍接口、采样和数据驱动、测试的开始和结束、调试方法。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书 路科验证。  概览      接口 什么是接口？  接口主要用作验证，国外有些团队使用sv设计，接口会用作设计。 验证环境中，接口可以使连接变得简洁而不易出错。 interface和module的使用性质很像，可以定义端口，也可以定义双向信号，可以使用initial和always，也可以定义function和task。 interface可以在硬件域和软件域间传递信息，也就是可以作为module的端口列表，也可以作为软件方法的形式参数。 对于interface的初步认识，可以看作“插排”，DUT与TB之间的数据驱动就是靠这个“插排”来完成的。  接口的定义与使用  interface的定义结构与module类似。 interface的端口列表只需定义时钟、复位等公共信号，或者不定义任何端口信号，而在变量列表中定义DUT与TB连接的各个变量，建议用logic来定义。 interface也可以依靠参数化方式提高复用性。 interface在例化时，与module例化方式相同。 对于有对应interface的DUT和TB组件，在例化时，传递匹配的interface变量名也就完成了interface内变量的传递，换句话说就是两者打通，对应interface的不同组件之间变量信号实时传递。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  interface arb_interface(input bit clk); logic [1:0] grant, request; logic reset_n; endinterface module arb(arb_interface arb_if); //......  always@(posedge arb_if.clk or negedge arb_if.reset_n)begin if(!arb_if.reset_n) arb_if.grant \u0026lt;= 2\u0026#39;b00; else arb_if.grant \u0026lt;= next_grant; end //...... endmodule module test(arb_interface arb_if); //......  initial begin @(posedge arb_if.clk) arb_if.request \u0026lt;= 2\u0026#39;b01; $display(\u0026#34;@%0t: Drove req=01\u0026#34;, $time); repeat(2) @(posedge arb_if.clk); if(arb_if.grant != 2\u0026#39;b01) $display(\u0026#34;@%0t: a1: grant != 2\u0026#39;b01\u0026#34;, $time); $finish; end endmodule module tb_top; bit clk; initial clk = 1\u0026#39;b0; always #5 clk = ~clk; arb_interface arb_if(clk); arb a1(arb_if); test t1(arb_if); endmodule   接口的优势  将有关信号封装在接口，对于设计和验证环境都便于维护，如需修改、添加、删除信号，只需修改interface文件即可。 接口在硬件域（module）和软件域（class）都可以使用，是硬件域和软件域交互的唯一媒介。 接口可例化，对于多组相同总线，通过例化可灵活使用，简化代码且便于维护。 每一个agent使用对应的interface，简化验证平台结构，便于维护。 tb顶层例化时，无需定义信号连线，只需例化interface。  采样和数据驱动 竞争问题  为了避免RTL仿真行为中发生信号竞争问题，建议使用非阻塞赋值(\u0026lt;=)。（简单来说阻塞赋值是顺序执行，非阻塞赋值是并发执行，硬件电路行为是并发执行） 在仿真行为中，为了避免时序电路中时钟和驱动信号的时序竞争，我们需要尽量明确的驱动时序和采样时序。 默认情况下，时钟对于组合电路的驱动会添加一个无线最小时间（delta-cycle）的延迟，而该延迟无法用绝对时间单位衡量，它要比最小时间单位精度还要小。这是仿真工具为了符合硬件电路真实行为（建立时间保持时间以及线延迟）而做出的处理。（注意： #0并不代表0延迟，而是指延迟delta-cycle）  为了说明delta-cycle的概念，举例如下：\n 源代码：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  `timescale 1ns/1ps module top_module (); bit clk1,clk2; bit rstn; logic [7:0] d1; initial begin clk1 = 0; forever #5 clk1 \u0026lt;= ~clk1; end always@(clk1) clk2\u0026lt;=clk1; initial begin #0 rstn \u0026lt;= 0; #10 rstn \u0026lt;= 1; #20 $finish; end always@(posedge clk1 or negedge rstn) if(!rstn) d1 \u0026lt;= 0; else d1 \u0026lt;= d1+1; always@(posedge clk1) $display(\u0026#34;clk1: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); always@(posedge clk2) $display(\u0026#34;clk2: %0t ns d1 value is 0x%0x\u0026#34;, $time, d1); endmodule    仿真结果：   Running Icarus Verilog simulator... VCD info: dumping is suppressed. clk1: 5000 ps d1 value is 0xxx clk2: 5000 ps d1 value is 0x0 clk1: 15000 ps d1 value is 0x0 clk2: 15000 ps d1 value is 0x1 clk1: 25000 ps d1 value is 0x1 clk2: 25000 ps d1 value is 0x2 Hint: Total mismatched samples is 0 out of 0 samples Simulation finished at 30000 ps Mismatches: 0 in 0 samples 为什么同样在25000ps时刻，d1在clk1和clk2下的采样值不同？首先clk2是在clk1下驱动的，也就是clk2比clk1延迟一个delta-cycle时间，clk1驱动了d1，d1也比clk1延迟一个delta-cycle时间。25000ps，当在clk1下采样时，d1的值还未更新，所以采到的是0x1；而在clk2下采用时，d1已有clk1驱动更新，所以采到的是0x2。如果还未完全理解，可以打开波形窗口，不过要打开delta-cycle的开关，可以看到delta-cycle的存在，对电路的数据驱动和采样时序会有更直观的理解。\n 总结：  如果处于各种原因，clk与被采样数据之间存在若干个delta-cycle的延迟，那么对数据的采样会存在问题。 采样数据的竞争问题会成为潜在困扰仿真采样准确性的问题。 避免采样的竞争问题： 1）在驱动时，添加相应的人为延迟，使clk与驱动变量之间的延迟加大，提高DUT使用驱动信号时的准确度；2）在采样时，依靠采样前某段时刻进行采样，来模拟建立时间的采样要求，确保采样的可靠性。    接口中的clocking  在接口中声明clocking（时序块）和采样的时钟信号，可以用来实现信号的同步和采样。 clocking块基于时钟周期对信号进行驱动或采样的方式，使testbench不再苦恼于如何准确及时地对信号驱动或采样,消除了信号竞争的问题。   1 2 3 4 5 6  clocking bus @(posedge clk1); default input #5ns output #2ns; input data, ready, enable; output negedge ack; input #1step addr; endclocking   对上述clocking描述代码进行说明：\n 第一行定义clocking块bus，使用上升沿来驱动和采样。 第二行指出输入信号在clk1上升沿之前5ns采样，输出信号在clk1上升沿之后2ns采样（输入为采样，输出为驱动）。 第三行声明输入信号，采用默认的输入事件（clk1上升沿5ns前采样）。 第四行声明输出信号，并且指明为clk1下降沿驱动，覆盖了原有的clk1上升沿后2ns驱动。 第五行定义了输入信号addr，采用了自定义的采样事件，clk1上升沿后的1 step，覆盖了原有的clk1上升沿前5ns采样，这里1 step使得采样发生在clk1上升沿的上一个时钟片采样区域，即可以保证采样到的数据是上一个时钟周期数据。  clocking块的总结：\n clocking块不仅可以定义在interface中，也可以定义在module和program中。 clocking中列举的信号不是自己定义的，而是interface或其他声明clocking的模块定义的。 clocking在声明完名字后，应该伴随着定义默认的采样事件，也就是“default input/output event”，如果没有定义，会默认使用时钟上升/下降沿前1step进行采样，时钟上升/下降沿后#0进行驱动。 除了定义默认的采样和驱动事件，定义信号方向时同样可以用新的采样/驱动事件对默认事件进行覆盖。  结论  为了避免采样竞争问题，验证工程师应该在验证环境的驱动环节添加固定延迟，使得在仿真波形中更容易体现出时钟与被驱动信号之间的时序前后关系，同时这样也便于对DUT的准确处理和TB的准确采样。 如果TB在采样从DUT送出的数据，在时钟与被驱动信号之间存在delta-cycle时，应该考虑在时钟采样沿的更早时间端段去模拟建立时间要求，这种方法也可以避免由于delta-cycle问题带来的采样竞争问题。 当我们把clocking运用到interface中，用来声明各个接口与时钟的采样和驱动关系后，可以大大提高数据驱动和采样的准确性，从根本上消除采样竞争的可能性。  测试的开始和结束 写在前头  各个设计自身可以作为一个大的线程，内部有包含多个并行的线程，而模块之间即线程的通信，主要依靠信号的变化。 可以想象，对于一个设计，如果在仿真开始没有任何激励，那么仿真不具备执行条件，也可以认为已经结束，因为在设计内部没有产生任何新的事件，也不会触发组合逻辑和时序逻辑。 如果仿真开始后仅提供时钟和复位信号，验证会持续下去，而对设计不会产生实质的功能影响。从设计角度来看，复位信号是为了让设计进入一个确定的初识状态，而时钟就是脉搏跳动。 verilog测试中，可以通过系统函数“$finish()”来结束仿真，也可以通过“$stop()”来暂停仿真。  program  program是作为验证而提出的，可以有效控制仿真的进程，但是目前验证平台更多基于UVM，UVM有独特的控制机制，所以program在实际项目中使用并不多。 program的提出，将验证部分和设计部分进行有效隔离，每一个program作为一个独立测试，当testbench中所有program中最后一个initial块完成后，结束仿真。这是program的隐式结束。 有些program内的initial块无法正常结束，这时候需要使用显示结束，使用“$exit()”来结束program。 program被看做软件域，所以不可以出现always、module、interface等硬件相关语句，并且不可以例化其他program。 program被看做软件域，可以在program内部定义变量和发起多个initial块，并且建议使用阻塞赋值（软件方式的顺序执行）。 program对于数据采样也可以消除delta-cycle竞争问题，详细内容可见红宝书“SV环境构建篇之程序和模块”。（待了解）  总结  硬件域（module）、软件域（program）、中间域（interface）。 不仅可以使用interface clocking来消除采样竞争问题，可以使用program（建议使用clocking）。 program可以控制仿真的结束。 使用“$stop()”和“$finish()”可以结束仿真。  调试方法 调试工具 大多工程师选择使用verdi作为调试工具，主要有三个窗口：层级列表窗口、源代码窗口、波形窗口。verdi的具体使用方法，请参考我的另一篇帖子 Verdi使用总结。\n打印消息 打印消息是调试循环语句、顺序执行语句等查看路径和当前变量值的简便方式，除此之外，由于验证平台更多变量是动态的，无法在调试工具查看动态变量值，所以对与验证环境的调试，更多使用打印消息。\n打印消息命令“$display()”：\n $time代表仿真时间变量。 显示格式： %x（十六进制）、%d（十进制）、%b（二进制）、%s（字符串）、%t（时间）。 $display（消息级别）、$warning（警告级别）、$error（错误级别）、$fatal（严重错误级别） 字符串变量格式化：string s = $sformatf(\u0026ldquo;Hello, %s!\u0026quot;, name_s);  设置断点  可以通过调试工具为程序设置断点。 通过设置断点（breakpoint）可以查看程序执行到断点处（程序暂停）的变量数值，而设置断点要求验证工程师对程序执行顺序足够了解。 设置断点可以便于查看软件程序（function、task、object）中局部变量的数值。注意：动态变量是无法添加到波形查看的。 设置断点还可以方便调试程序执行的顺序，例如在顺序执行语句执行的多个位置设置断点，通过仿真执行，查看程序是否在断点处暂停，如果没有，那么程序的挂起（hang-on）原因就在上一个断点和此断点之间。通过此方法可定位可疑程序的范围。 如果查看局部变量，需要使用局部变量窗口（Local Windows），继而通过断点查看变量（暂时不知verdi是否支持，待学习）。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":31,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（二）","uri":"https://wenhui.space/zh/docs/digital_verifer/study_sv/study_sv_two.html"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第二篇，主要介绍测试平台、硬件设计描述、激励产生器、监测器、比较器。\n   版本 说明     0.1 初版发布    参考  路科验证。  概览      测试平台 什么是测试平台？  测试平台是整个验证系统的总称，包括验证结构中的各个组件、组件之间的连接关系、测试平台的配置和控制。 广义来讲，测试平台还包括编译仿真流程、结果分析报告和覆盖率检查等。 狭义来讲，测试平台主要关注结构和组件，如何产生所需输入，以及设计的功能检查。  经典的测试平台 经典的测试平台包含Clock/Reset组件、Driver组件、Monitor组件、Checker组件，其特性如下：\n 各个组件相互独立。 验证组件与设计之间需要连接。 验证组件之间也需要相互通信。 验证环境也需要时钟和复位信号的驱动。  验证语言趋势  SystemVerilog使用比例为主导地位。 SystemC和C/C++在验证部分也有应用空间。 验证方法学UVM的统一已经形成。  硬件设计描述  硬件设计描述要介绍它的结构、功能、寄存器和时序。 熟悉硬件设计描述的方式，是验证工程师的一项基本技能。 这里对硬件设计描述不具体举例说明。  Clock/Reset组件 Clock/Reset组件就是指在testbench中产生时钟和复位信号，驱动DUT和Driver。严格来讲，算不得组件，此功能在testbench完成。\nDriver组件  Driver主要职责是模拟与DUT交互模块的接口协议，模拟真实的接口信号驱动DUT。 Driver的激励驱动要符合接口协议，但不局限于真实的硬件行为，可使用抽象的语言方法产生丰富的测试激励。 对于接口协议，如果是成熟的商业协议，建议使用第三方的商用接口ip/vip，这很大程度上节省时间和人力。 如果接口协议为非标准，应该查看功能描述文档，明确接口协议。 Driver主要是与DUT相连接，也应该有时钟和复位的输入，确保driver的驱动激励与DUT接口保持时序同步。 Driver与DUT的连接包含两部分：initiator（发起器）和responder（响应器）。发起器是指主动发起DUT接口驱动，响应器是指接收DUT接口信号，做出响应。  Monitor组件 监测DUT的信号 Monitor主要功能是监测DUT的边界或者内部信号，并且经过打包处理传送到其他组件：\n DUT边界信号：对于系统信号如时钟，可以监测频率变化；对于总线信号，可以监测传输类型和数据内容，以及总线时序是否符合协议。 DUT内部信号：从灰盒验证的手段来看，往往需要监测内部关键信号，来反馈给Driver控制激励产生，或者完成覆盖率收集，以及其他内部功能检查。  Monitor的结构建议  独立性： 建议不同接口信号采用独立的Monitor。 复用性： 尽可能将组件做成验证IP，方便复用到其他环境。 可维护性： 保持代码和验证环境的可维护性，对后期设计修改导致验证环境维护更新很有帮助。 封装性： 将Monitor和Driver一一对应，封装为一个小的单元，这样的小单元可以按照统一的方法实现，但又各自独立。  监测内部信号的建议  如没有特殊需求，采取灰盒验证，而非白盒。 监测内部信号应该尽量少（收集覆盖率除外），且应当为状态信号，不建议监测中间变量信号，因为其本身手受时序的原因信号留存不稳定，这种不稳定有可能影响到验证环境。 可以通过接口信息计算的，尽量少监测内部信号，这样有悖于假定设计有bug的验证思想，如需采用内部信号，也要以动态检查或断言形式确保其逻辑正确性。  Checker组件 checker主要功能 checker主要承担模拟设计和功能检查的任务，主要包含以下功能：\n 接收缓存各个monitor收集的数据。 将DUT接口数据驱动给Reference Model（参考模型），参考模型扮演了模拟DUT功能的角色。 通过数据比较，检查DUT输出接口是否与Reference Model产生的期望数据一致。 检查过程中保存整理验证信息，纳入检查报告中，便于仿真后的追溯。  总结来讲，Checker主要负责数据接收缓存、参考模型和检查报告。\nchecker比较方式 对于checker的数据比较，又可以分为两类：\n 线上比较（Online Check）： 仿真时收集数据与参考模型实时比较，实时报告。 线下比较（Offline Checker）： 将仿真时的数据结果保存到文件中，仿真结束后通过脚本或其他手段，进行数据比较。  checker实现结构建议  对于复杂的系统，建议集中管理checker，将不同monitor信息汇集于此，检查各个模块的功能，统一输出报告。 monitor和driver相对独立且一一对应，建议封装在agent单元组件，而checker在验证环境中心化位置。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":32,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（二）","uri":"https://wenhui.space/zh/docs/digital_verifer/beginner_verification/beginner_verification_two.html"},{"content":"本文 主要介绍emacs folding-mode的使用。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  什么是folding-mode? emacs 的folding-mode是一种emacs的副模式，提供代码折叠功能，方便代码阅读和编辑。emacs用户肯定知道org-mode的大纲模式，但是只能在阅读或编辑org文档时才可以使用，而folding-mode可以对任何模式实现类似于org-mode大纲模式的功能。\n安装folding-mode 最简捷的安装方式，是通过emacs的包管理器安装，安装方法请参考我的另一篇帖子 emacs如何安装插件 。\nfolding-mode的使用 修改emacs配置文件 安装folding-mode后，需要修改emacs配置文件，.emacs或.emacs.d/init.el，开启folding-mode功能，请将下面代码添加到emacs配置文件。注意：如需为新的格式添加folding-mode功能，请参照folding-add-to-marks-list完成添加。\n1 2 3 4 5 6 7 8  (if (load \u0026#34;folding\u0026#34; \u0026#39;nomessage \u0026#39;noerror) (folding-mode-add-find-file-hook)) (folding-add-to-marks-list \u0026#39;verilog-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;c-mode \u0026#34;//{{{\u0026#34; \u0026#34;//}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;latex-mode \u0026#34;%%{{{\u0026#34; \u0026#34;%%}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;lisp-mode \u0026#34;;;{{{\u0026#34; \u0026#34;;;}}}\u0026#34;) (folding-add-to-marks-list \u0026#39;shell-script-mode \u0026#34;##{{{\u0026#34; \u0026#34;##}}}\u0026#34;)   个人配置 为了使用方便，我对folding-mode的常用命令设置了别名，如下：\n1 2 3 4 5 6 7 8  (defalias \u0026#39;me-folding-mode \u0026#39;folding-mode) (defalias \u0026#39;me-folding-reg \u0026#39;folding-fold-region) (defalias \u0026#39;me-folding-in \u0026#39;folding-shift-in) (defalias \u0026#39;me-folding-out \u0026#39;folding-shift-out) (defalias \u0026#39;me-folding-hide-all \u0026#39;folding-whole-buffer) (defalias \u0026#39;me-folding-show-all \u0026#39;folding-open-buffer) (defalias \u0026#39;me-folding-hide \u0026#39;folding-hide-current-entry) (defalias \u0026#39;me-folding-show \u0026#39;folding-show-current-entry)   使用 folding-mode，我主要是以命令的形式使用，其实也支持快捷键，快捷键比较复杂且难以记住，如folding-shift-in，快捷键是 C-c @ \u0026gt;，所以我还是以快捷键使用为主，其他快捷键可以查看folding-mode文档或使用emacs help。\n 打开文件（支持folding-mode的类型）， M-x folding-mode ，打开folding-mode。 选中一块区域，输入 M-x me-folding-reg，此时会在buffer中仅显示选中的内容，且上下插入了folding的注释符，输入标题（也就是第一行注释符后的内容），添加标题后 M-x me-folding-out 可以显示所有内容；或者可以手动添加folding的注释符，通过 M-x me-folding-hide/show 打开或关闭折叠区。 其他命令可自行尝试，不再说明。  效果  hide：   1  # {{{ Title1...    show:   1 2 3 4 5 6 7  # {{{ Title1 aaabbbccc=123456 aaabbbccc=123456 aaabbbccc=123456 # }}}   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":33,"section":"docs","tags":["emacs"],"title":"emacs使用folding-mode","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_folding_mode.html"},{"content":"本文 SystemVerilog学习系列主要介绍SystemVerilog语言的基础知识，是验证工程师必须熟练掌握的语言基础。此为第一篇，主要介绍数据类型、过程块和方法、设计例化和连接。\n   版本 说明     0.1 初版发布    参考  《SystemVerilog验证》，也就是所谓的绿皮书。 路科验证。  概览      数据类型 写在前面：SystemVerilog完全兼容Verilog语言\n內建数据类型 verilog中数据类型区分寄存器型（register）和线网型（net），分别用reg和wire去声明，而sv中并不区分reg和wire，而是引用新的数据类型logic（sv中也可以使用reg和wire，不过并不建议这样做）。\n除了logic，还有bit数据类型，它们默认都代表一位数据，也就是它们都可以构建矢量类型（logic/bit [7:0] signal_name）。其区别之处为：\n logic为四值逻辑： 0 1 X Z，四值逻辑类型还包括 integer、 reg、 wire。 bit为二值逻辑： 0 1（引入二值逻辑其目的是将验证软件化），二值逻辑类型还包括 byte、 shortint、int、longint。  数据类型除了二值四值之分，还存在有符号无符号之分：\n 有符号：byte、shortint、int、longint、integer 无符号：bit、logic、reg、wire  关于数据类型的几个注意点：\n 尽量避免两种不同数据类型变量进行操作，包括有无符号，四值二值，不同位宽，如必须进行操作，请先转换为同一类型。 四值变量的x和z态转换为二值变量的0（不过尽量避免四值和二值变量的转换） 多位数据赋值给少位数据，高位被截取忽略；少位数据赋值给多位数据，二值类型的话高位赋值为0，四值类型的话高位赋值为x（如果是有符号类型，高位赋符号位，不过尽量避免不同位宽数据赋值）。 有符号变量转无符号变量，直接赋值的话会将原始比特数据赋给无符号变量，但其原符号位失去含义；使用转换语句转换的话，会将有符号变量取模赋值给无符号变量（不过尽量避免有无符号数据之间转换）  数据类型转换（待补充）：\n 静态转换（不对转换值进行检查）：   1 2 3  unsigned_data = unsigned\u0026#39;(signed_data); int_data = int\u0026#39;(real_data); real_data = real\u0026#39;(int_data);    动态转换（仿真时对转换值进行检查，并输出检查和转换结果）：   1 2  //$cast(tgt,src); $cast(unsigned_data,signed_data);   定宽数组 数组声明（变量左侧为矢量宽度，右侧为维度，且从左至右代表维度从高到低）： 1 2 3 4 5 6 7 8  //二维数组（习惯上左右顺序是从低到高，这对初始化很重要） int data_a[0:15]; // 16个整数[0]...[15] int data_a[16]; // 紧凑型声明  //多维数组（左边为高维度） int data_a[0:7] [0:3]; int data_a[7] [3]; // 紧凑的多维数组声明 int data_a[7][3] = 1; // 为最后一个元素赋值   数组的初始化和赋值： 1 2 3 4  int data_a[4] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[0:3] = \u0026#39;{0,1,2,3}; //data_a[0]为0 ... data_a[3]为3 int data_a[4] = \u0026#39;{4{1}}; //全赋值为1 int data_a[4] = \u0026#39;{5,default:-1}; //data_a[0]为5，其他为-1   存储空间考量： 1 2 3 4  bit [3][7:0] b_pack; bit [7:0] b_unpack [3]; logic [3][7:0] b_pack; logic [7:0] b_unpack [3];   一般变量左侧的宽度代表矢量宽度，右侧代表数组维度，也可以称为数组的合并与非合并，以上都可以代表24bit数据容量。二值逻辑bit声明，每bit位占用1bit空间，第一种声明占用1WORD空间，3x8bit，第二种声明占用3个WORD空间，3WORD x 1x8bit；四值逻辑logic声明，每bit位占用2bit空间，第一种声明占用2WORD空间，3x16bit，第二种声明占用3WORD空间，3WORD x 1x16bit。所以，在合适的时候选用合并数组，能够节省存储空间。（软件仿真时计算机空间占用都是以word为单位的）\n数组操作之for和foreach循环： 1 2 3 4 5 6 7 8  bit [31:0] src[5]; bit [31:0] dst[5]; for(int i=0; i\u0026lt;$size(src); i++) src[i] = i; foreach (dst[j]) dst[j] = src[j] * 2;   $size(src)是获取最高维度变量个数，也可以指定维度$size(src，1)，其中1代表最高，2次之\u0026hellip; foreach语句会遍历数组变量，这也是最推荐的使用方法，多维度遍历可以使用foreach(dst[i,j])。\n 数组操作之复制和比较：  赋值可以直接使用赋值符号“=”，直接进行数组的复制；对于比较，也可以使用“==”或“！=”来比较，不过结果仅限于内容相同或不相同。\n1 2 3 4 5 6 7  bit [31:0] src[5] = \u0026#39;{0,1,2,3,4}; bit [31:0] dst[5] = \u0026#39;{4,3,2,1,0}; if(src == dst) $display(\u0026#34;src == dst\u0026#34;); //比较数组  dst = src; //数组复制  src[0] = 5; //修改数组中某元素   动态数组  定宽数组类型宽度编译时已经确定，若在程序运行时在确定数组宽度就要使用 动态数组 。 动态数组特点就是仿真运行时灵活调节数组的大小，也就是存储量。 动态数组开始时使用“[]”来声明，此时数组为空，其后使用“new[]”来分配空间，方括号中传递数组宽度。 调用“new[]”时也可以将数组名一并传递，将已有数组的值复制到新的数组中。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int dyn[]; int d2[]; //声明动态数组  initial begin dyn = new[5]; //分配5个元素  foreach(dyn[j]) dyn[j] = j; //对元素初始化  d2 = dyn; //复制动态数组，d2初始元素个数为零，复制后元素个数为5，且dyn和d2各自独立  d2[0] = 5; //修改元素值，此时dyn[0]仍为0，d2[0]为5  dyn = new[20](dyn); //分配20个数值并进行复制，也就是dyn初始值5个元素复制给了新的dyn低5个元素，高15个元素为0.  dyn = new[100]; //重新分配100个数值，而旧值不复存在  dyn.delete(); //删除所有元素 end   队列  队列结合了链表和数组的优点，可以在任何地方添加和删除元素，并且通过索引实现对任一元素的访问。 队列的声明是使用美元符号的下标：[$]，队列元素标号从0到$。 队列不需要new[]去创建空间，只需要使用队列的方法为其增减元素，队列初始空间为为零。 队列的简单使用是通过push_back()和pop_front()的结合来实现FIFIO的用法。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int j = 1; int q2[$] = {3,4}; int q[$] = {0,2,5}; //队列的赋值不需要单引号  initial begin q.insert(1, j); //{0,1,2,5} 在1位置插入1  q.insert(3, q2); //{0,1,2,3,4,5} 在队列q 3位置中插入队列q2  q.delete(1); //{0,2,3,4,5} 删除队列中1位置元素  //下列操作才是队列中最常用方法  q.push_front(6); //{6,0,2,3,4,5} 在队列头部插入  j = q.pop_back(); //{6,0,2,3,4} 在队列尾部弹出  q.push_back(8); //{6,0,2,3,4,8} 在队列尾部插入  j = q.pop_front(); //{0,2,3,4,8} 在队列头部弹出  foreach(q[j]) $display(q[j]); //打印整个队列  q.delete(); //删除整个队列 end   关联数组  如果需要一个超大容量存储空间，而有相当部分数据不会被存储和访问，不管使用定宽数组还是动态数组，都会造成存储的浪费，这时候需要使用关联数组。 关联数组可以保存稀疏矩阵元素，当你对一个非常大的地址空间进行寻址时，该数组只为写入的元素分配空间，所以关联数组需要的空间远小于定宽或动态数组。 此外关联数组的灵活应用，在其他高级语言中都有类似的存储结构，比如Perl语言中称为哈希(Hash)，Python中称为词典(Dictionary)，可以灵活赋予key和value。   1 2 3 4 5 6 7 8 9 10 11 12 13 14  bit [63:0] assoc[int]; //声明关联数组，关联数组中[]内声明数据类型，也就是index类型 int idx = 1; repeat(64) begin //对稀疏分布的元素初始化  assoc[idx] = idx; idx = idx \u0026lt;\u0026lt;1; //1 2 4 8 16 ...... end foreach(assoc[i]) //使用foreach变量关联数组，注意：并不一定按index大小顺序依次执行（可以使用sort排序）  $display(\u0026#34;assoc[%d] = %h\u0026#34;, i, assoc[i]); //找到并删除第一个元素，使用if(assoc.first(idx)) 可以判断数组是否为空 assoc.first(idx); assoc.delete(idx);   结构体  sv中可以使用struct语句创建结构，与c语言类似。 sv中struct功能较少，只可以定义一个数据的集合，也就是将若干相关变量组合到一个struct结构定义中。 通过使用typedef和struct，可以定义新的数据类型，并利于新的数据类型声明变量。   1 2 3 4 5 6 7 8 9  typedef struct { bit[7:0] r; bit[7:0] g; bit[7:0] b; } pixel_str; //使用typedef和struct创建新的数据类型 pixel_str  pixel_str my_pixel; //使用新的数据类型声明变量 my_pixel = \u0026#39;{8\u0026#39;h10, 8\u0026#39;h20, 8\u0026#39;h30}; //结构体赋值，此时赋值与声明时一一对应 my_pixel = \u0026#39;{b: 8\u0026#39;h30, g: 8\u0026#39;h20, r: 8\u0026#39;h10}; //结构体赋值，也可以指明结构体内赋值变量   枚举类型  规范的操作码和指令有利于代码的编写和维护，如ADD、WRITE、IDEL等。 枚举类型enum经常和typedef搭配使用，由此便于用户自定义枚举类型的共享使用。 枚举类型保证一些非期望值的出现，增加代码可维护性和降低设计风险。   1 2 3 4 5 6 7 8 9 10  typedef enum {INIT, DECODE, IDLE} fsmstate_e; //声明枚举类型和自定义数据类型 fsmstate_e pstate, nstate; //通过自定义枚举数据类型 声明变量  case(pstate) //枚举类型主要应用于状态机  IDEL: nstate = INIT; INIT: nstate = DECODE; default: nstate = IDLE; endcase $display(\u0026#34;Next state is %s\u0026#34;, nstate.name()); //显示状态名   字符串  verilog语言中是不存在字符串的，而sv中添加了字符串string类型。 所有相关的字符串处理，都使用string来保存和处理。 字符串处理相关的格式化函数可以使用$sformatf()，如果只是打印输出，可以直接使用$display()。   1 2 3 4 5 6 7 8 9 10  string s; //声明字符串，此时为空。  initial begin s = \u0026#34;IEEE\u0026#34;; $display(s.tolower()); //显示 ieee (转小写)  s = (s, \u0026#34;-P1800\u0026#34;); //字符串拼接， \u0026#34;IEEE-P1800\u0026#34;  $display(\u0026#34;@%t: %s\u0026#34;, $time, $sformatf(\u0026#34;%s %d\u0026#34;, s, 42)); //$sformatf返回字符串 end   过程块和方法 initial和always  initial是不可综合的，为验证而生，always是可综合的，代表硬件电路。 module、interface可视为硬件域，program、class可视为软件域，区分硬件域和软件域对理解initial和always很有帮助。 always是为了描述硬件行为，可综合，使用时需要区分时序电路描述和组合电路描述。 initial是软件行为，只执行一次。 initial块和always块之间，以及不同initial块，不同always块，在仿真一开始都是同时执行的。 initial块内语句顺序执行的。 在verilog时代，所有的测试都放在initial块中，并且为了便于统一管理，建议放在同一个initial块中。 initial块可以放在module、interface和program中。 对于过程块，使用begin\u0026hellip;end将其作用域包住，对于控制语句和循环语句，同样适用。  函数function  可以在参数列表指定输入参数(input)、输出参数(output)、输入输出参数(inout)或者引用参数(ref)。 可以有返回值，也可以无返回值(void)。   1 2 3 4 5 6 7  function int double(input a); return 2*a; endfunction initial begin $display(\u0026#34;double of %0d is %0d\u0026#34;, 10, double(10)); end   函数其他属性：\n 默认数据类型为logic。 数组可以作为形式参数传递。 function可以返回或不返回结果，返回结果需要使用关键字return，不返回需要声明为void function。 只有数据变量可以在形式参数列表被声明为ref类型，而线网类型则不能声明为ref类型。 使用ref时，有时为了保护参数对象只被读取不被修改，可以通过const的方式限定ref声明的参数。 在声明参数使，可以设置默认值（input a=10），同时如果在调用时省略参数的传递，则函数中使用默认值。  任务task 任务相比函数更加灵活，且有以下不同点：\n task无法通过return返回结果，因此只能通过output、inout或ref的参数来返回。 task内可以使用耗时语句，而function不能。常见的耗时语句如：@event、wait event、#delay等。   1 2 3  task double(output [31:0] b, input [31:0] a); //不指明方向则默认为input  b = 2*a; endtask   function和task的使用建议：\n 初学者傻瓜式用法，可以全部采用task来定义方法，因为它可以内置耗时语句，也可不以内置耗时语句。 经验者要区分两种方法，非耗时方法使用function，耗时方法使用task，也就是function中完成纯粹的逻辑运算，而task更多完成需要耗时的信号采样或者驱动等场景。 调用function，在function和task内均可以调用其他function，而调用task，如果被调用task内使用了耗时语句，只能在task调用。  变量的生命周期  sv中数据的生命周期分为动态(automatic)和静态(static)。 局部变量的生命周期与其所在域共存亡，也就是在function/task中的临时变量，在其被调用结束后，临时变量的生命周期也将终结。 全局变量在程序执行开始到结束一直存在。 如果数据变量被声明为automatic，那么在进入该进程/方法后，automatic变量会被创建，离开该进程/方法后，automatic变量被销毁。而static在仿真开始时被创建，而在进程/方法执行过程中，不会被销毁，且可以被多个进程和方法所共享。 module内全部是静态变量，代表真实的电路结构。 对于automatic方法，其内部所有变量默认也是automatic。 对于static方法，其内部所有变量默认也是static。 对于static变量，声明时应该对齐做初始化，而初始化只会伴随它的生命周期执行一次，不会随着方法调用而多次初始化。 在module、program、interface声明的变量，以及其他在task/function之外声明的变量，默认是静态变量，存在于是整个仿真阶段。 也就是说，只要用户不注明automatic变量或方法，其变量就是static变量。  设计例化和连接 模块定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  module xprop ( // Outputs out1, // Inputs clk, sel, din0 ); input clk; input sel; input [7:0] din0; output out1; //...... //......  endmodule   模块例化 1 2 3 4 5 6 7 8 9 10 11 12  module testbench; //...... //......  xprop dut( // Outputs  .out1 (out1), // Inputs  .clk (clk), .sel (sel), .din0 (din0)); endmodule   模块连接 模块连接就是将硬件电路在测试平台进行例化，传统的verilog验证方法，在initial过程块产生激励，驱动硬件电路完成仿真。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":34,"section":"docs","tags":["SystemVerilog"],"title":"SV学习（一）","uri":"https://wenhui.space/zh/docs/digital_verifer/study_sv/study_sv_one.html"},{"content":"本文 主要介绍芯片相关公司的组织架构，和职级与职位及对应的英文缩写。\n   版本 说明     0.1 初版发布   0.2 增加常见职级职位英文缩写    写在前头 本文主要属于科普，目的是避免像我一样，在与别人聊天中对关于职级职位的英文，自己一脸懵逼。\n一般芯片公司的组织架构      公司一级部门由董事长/总经理和副董事长/副总经理负责（也可以称为总裁、副总裁）：\n 董事长/总经理： 向董事会负责。 董事长/总经理助理： 负责协助完成董事长的行程安排、计划实施和会议总结等其他事项。 副董事长/副总经理助理： 负责分管的具体事项，如财政、人力、市场、研发。  公司二级部门由各部门总监负责（芯片公司研发是重中之重，往往研发属于一级部门，研发下设二级部门）：\n 人事部： 负责薪酬、考核、招聘、培训等。 财务部： 负责报销、发票、进帐、出账、税务等。 行政部： 负责会议记录、办公室、后勤、车辆的调度使用等。 市场部： 负责市场、销售、客服等。 运营部： 负责生产管理和运营管理等。 品控部： 负责供应商品质、设计品质、流程体系、可靠性品质等。 研发部： 下设项目部 、验证部、IP部、SOC部、软件测试部、固件开发部、后端设计部等。  项目部： 负责项目立项调研，牵头项目规划和执行。 验证部： 负责项目中验证任务（此验证部与IP部和SOC部的验证团队功能有交叉，不同公司分设不同）。 IP部： 负责IP的开发，其中下设验证团队和设计团队，以及可能还有算法模型设计团队。 SOC部： 负责芯片的集成，包括存储、互连、总线等。 软件测试部： 完成芯片的软件测试。 固件开发部： 完成芯片的固件驱动开发。 后端设计部： 完成芯片的后端版图设计，包括行布局布线和物理验证。    公司三级部门由各部门经理或项目经理负责：\n 设计团队： 负责芯片的前端RTL设计。 验证团队： 负责芯片的验证。  公司职位与职级，以及对应的英文 公司规模和企业性质不同，都会有不同的组织架构，以下只是列举出常见的职位名称，以及其职能，仅供参考：\n GM： 是英文 General Manager 的缩写，指总经理，总经理（General manager）传统意义上是一个公司的最高领导人或该公司的创始人。但实际上，总经理所在的层级，还是会因公司的规模而有所不同。 CEO： 是英文 Chief Executive Officer 的缩写，指首席执行官，是在一个企业中负责日常事务的最高行政官员，又称作行政总裁、总经理或最高执行长 COO： 是英文 Chief Operating Officer 的缩写，指首席运营官，主要是负责公司的日常营运，辅助CEO的工作。对CEO负责，负责企业的运营管理。COO在某些公司中同时任职 总裁 ，但他们通常是常务或资深的副总裁。 CFO： 是英文 Chief Finance Officer 的缩写，指首席财务官，CFO是绝对的二号人物，对公司上市全权负责，对公司长远发展的了解，和对公司整体战略的把握，都要远超其他C级人物。再者，很多时候CFO是董事会直接委派的，有间接地监督CEO和管理团队的职责，所以CFO地位绝对超然。 VP： 是英文 Vice President 的缩写，指副总裁，副总裁是总裁的助手，受总裁委托分管公司日常经营管理工作，对总裁负责，并在副总裁职责范围内签发有关业务文件，总裁因故不能履行职务时，副总裁受总裁委托代行总裁的职权。 HRD： 是英文 Human Resource Director 的缩写，指人力资源总监，人力资源总监要从战略高度努力构建高效实用的人力资源管理系统，成功进行人才选拔，建立科学的考核与激励机制，最大限度地激发人才潜能，创建优秀团队，塑造卓越的企业文化，推动组织变革与创新，最终实现组织的持续发展。 HRM： 是英文 Human Resource Manager 的缩写，指人力资源经理，分管组织管理、人事信息管理、招聘管理、培训管理、绩效管理、福利管理、工资管理等全部或部分职责。 HRBP：是英文 Human Resource BUSINESS PARTNER 的缩写，指人力资源业务合作伙伴，实际上就是企业派驻到各个业务部门或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。 MD： 是英文 Marketing Director 的缩写，指市场总监，企业中负责市场运营工作的高级管理人员，主要负责在企业中对营销思想进行定位；把握市场机会，制定市场营销战略和实施计划，完成企业的营销目标；协调企业内外部关系，对企业市场营销战略计划的执行进行监督和控制；负责企业营销组织建设与激励工作。  以上列出的是公司各大部门的管理层职位（可能不全），下面我们来看一下职级：\n   职级名称 英文 职级名称 英文       总裁 CEO/GM   首席科学家 Chief Scientific Officer 副总裁 VP   研究员 Researcher Engineer 总监 Director   专家 Proficient Engineer 经理 Manager   高级工程师 Senior Engineer 主管 Header/Leader   中级工程师 Middle Engineer     初级工程师 Junior Engineer      以上信息仅是自己简单的个人理解，实际公司中职级分的可能更细，并且会设有类似于Senior Management Engineer这样的研发管理职位，总之，本篇文章仅为科普，如有幸更专业的人士看到此帖子，欢迎指正。\n常见职级职位英文缩写    缩写 英文 中文     PL Project Leader 项目负责人   FAE Field Application Engineer 现场技术支持工程师/售前售后服务工程师    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":35,"section":"docs","tags":["职级与英文缩写"],"title":"你应该知道的职级与英文缩写","uri":"https://wenhui.space/zh/docs/polular_science/rank_and_abbreviation.html"},{"content":"本文 主要介绍本人使用形式化验证的一些经验总结。\n   版本 说明     0.1 初版发布    背景  验证工具： Cadence 公司的 JasperGold  写在前头 形式化验证是一种验证方法，而实际应用方向主要有两方面，一是综合前后的等价性检查，二是RTL设计的功能验证。本文所讲的是形式化验证方法在RTL设计功能验证方向的应用。\n模拟仿真验证和形式化验证 芯片验证的两个方法，一个是模拟仿真验证，另一个是形式化验证。\n模拟仿真验证是目前最主流的验证方法，主要是以 UVM 为代表的验证方法学，特点就是搭建模拟仿真环境，通过随机化激励进行模拟仿真，reference module作为验证标准进行结果数据的check，以收集覆盖率的方式作为验证进度的参考，当代码覆盖率和功能点覆盖率达到100%时，做到sign off。由此看来，模拟仿真的优点就是基本不受设计复杂度的影响，而缺点就是验证环境搭建较复杂，测试激励手动添加，收集覆盖率周期较长，尤其是Corner场景的覆盖很让人头疼。\n形式化验证从某层面看似乎让人省心。形式化方法简单的说就是用数学工具进行定义、开发和验证，它会对设计电路进行数学建模，然后穷举系统运行过程中电路所能达到的所有状态，以断言的形式完成设计电路的功能验证和规则检查（也可以通过reference model的形式，做结果数据的check）。听起来似乎完美，但是这要依赖强大的运算系统和EDA工具，否则会发生状态爆炸问题，长时间无法得出证明结果。以目前的形式化验证工具来看，还不足以吃进一个超复杂的设计电路，来完全替代模拟仿真的验证方法。\n所以，在芯片的验证中，随机仿真验证和形式化验证往往是相辅相成，一个更适合系统级功能验证，一个更适合模块级的功能验证。除此之外，还有FPGA的硬件加速测试，这三种验证手段可谓是三位一体，相辅相成。\n什么是形式化验证 个人认为，形式化验证是基于严格的数学算法和模型，根据设计功能提取电路规则的属性描述，并穷举系统运行过程中电路所能达到的所有状态，自动进行数学分析和证明。验证过程如下：\n  形式化验证示例    以上的形式化验证过程就像做一道数学证明题，用数学方法证明该命题是否成立，而这个证明过程是验证工具完成的，工程师不需要关心。目前，业界主流的形式化验证工具主要有Cadence的 JasperGold 和 Synposys 的 VC-Formal。\nSVA语法 形式化验证使用的是 SVA (SystemVerilog Assertion) 语言，属于SV的一部分，下面对SVA基本的使用语法进行说明。\nSVA的语法主要分为三种使用类型：assume、assert、cover。使用的基本规则为，先描述一个property，然后为property设置为assume或assert或cover，命名时习惯性将property名字添加“P_”前缀，将assume名字添加“ASM_”前缀，将assert名字添加“AST_”前缀，将cover名字添加“COV_”前缀。注：建议所有属性带时钟沿触发条件。\nAssume Assum即假定之意，也就是假定某些信号符合某规则特性，最常见的就是给输入信号添加约束，下面对assume语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty ASM_property_name: assume property (P_property_name);    精简写法   1  ASM_property_name: assume property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   Assert Assert即断言之意，也就是认为某些信号符合某规则特性，出现反例则报错，最常见的就是给关键信号依据特定属性设置断言，来进行特性检查，下面对assert语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty AST_property_name: assert property (P_property_name);    精简写法   1  AST_property_name: assert property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   Cover cover即覆盖之意，也就是对某些信号的某规则特性进行采样，反馈是否覆盖该特性，下面对cover语法的使用做简单介绍：\n 标准写法   1 2 3 4  property P_property_name; @(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1); endproperty COV_property_name: cover property (P_property_name);    精简写法   1  COV_property_name: cov property (@(posedge clk) (condition==1’b1) -\u0026gt; (result==1’b1));   JasperGold的使用 本文使用的形式化验证工具是JasperGold，其常用的使用方法有两种类型，一个是SEC，对模块功能做对等性检查，另一个是FPV，基于规则特性的功能验证。这里只对FPV进行介绍，也就是 Formal Property Verifycation。\n验证环境       FPV_project_name：整个FPV的验证环境。 Report：用来存放验证报告。 Source：整个FPV环境的文件源。 FPV_project_name.tcl：FPV验证环境的启动脚本。 Design：文件源中的设计文件，也可以不存放设计文件，而由design.flist指定设计文件。 Property：文件源中的验证文件（SVA），提取设计文件的属性。 Refer_model：此文件为参考模型文件，根据需求创建，非必须。  启动脚本  设置环境变量   1 2 3  set FPV_ROOT /FPV_project_path set DES_PATH $FPV_ROOT/source/design set PRO_PATH $FPV_ROOT/source/property    设置功能点收集选项   1 2  set_capture_elaborated_design on check_cov –init –exclude_bind_hierarchies –enable_prove_based_proff_core    编译设计文件 (注：v2k指IEEE 2001 标准)   1  analyze -v2k –f $DES_PATH/design.flist    编译验证文件   1  analyze –sva –f $PRO_PATH/property.flist    设置顶层   1  elaborate –top top_module_name    设置时钟和复位 (注：如果复位是低位有效，则为 ~reset_signal_name)   1 2  clock clock_signal_name reset reset_signal_name    设置最长验证时间   1  set_prove_time_limit 24h    启动验证   1  prove -all    生成报告   1  report –summary –force –result –file “report/FPV_project_name.rpt”    其他  以上只说明了基本设置，其他详细设置可参考手册或JasperGold的Tcl Command Help。\n启动命令 启动验证环境很简单，验证流程主要依靠启动脚本的设置，而验证环境的启动只需在终端敲下启动命令即可，如下：\n1  jg FPV_project_name.tcl   关于形式化验证的个人总结 什么样的设计适合用形式化验证  规模较小：设计模块太大对应验证复杂度较高，导致验证时间过长。 功能独立：功能独立的设计更容易提取规则属性。 时序较短：时序较长会导致验证复杂度增大，验证时间指数增长。 接口清晰：接口清晰便于对输入添加约束，避免非法输入影响验证结果。  形式化验证中影响验证时间的因素  设计复杂度：设计复杂度高，肯定验证时间长，这也是为什么形式化验证不适合大的设计模块。 时序较长：形式化验证是所有状态的全遍历，时序每增加一个cycle，所增加的遍历空间并非只是此cycle，还包括此cycle与前几个cycle的状态组合，换句话说，时序增加，遍历空间指数增长。 设计中存在时序控制：比如advance_pipeline对pipeline进行使能控制的此类信号，以及所有影响流水线不能依次脉动流出的控制信号。 设置的特性检查：设置的特性检查越多越复杂，对应的验证时间越长，如果以reference model形式进行数据结果check，所需验证时间最长，但是若只提取设计特性又很难做到signoff标准。  形式化验证不能验证完全是不是就无任何作用 当然不是！\n 形式化验证工具进行了语法检查，可确定设计逻辑语法无误。 形式化验证工具进行了部分特性检查，可确定已验证的特性符合设计规则。  换句话说，形式化验证不能验证完全，虽然不能做到sign off，但是可以将前期暴露的语法bug和设计bug进行修复，最终验证不完全，无非表明我不一定是对的，但也没找到我的错误，说明设计代码已经达到一定成熟度。\n形式化验证工具的其他用途  完成设计不加任何特性检查，直接启动形式化验证工具，可将暴露的语法错误和警告修复，提高设计代码质量。当然反过来，验证人员可先启动形式化验证工具，将暴露的语法错误和警告提单给设计人员。 设计时对于显而易见的规则特性边设计边记录，待设计交付验证人员时，可先启动形式化验证，修复前期bug，提高设计代码质量。 模拟仿真中收集覆盖率，对于较难收到的功能点可利用形式化验证工具去设置cover，辅助模拟仿真创建定向用例。这里提两点，一是需要确定输入的场景作为输入约束，二是无需保证形式化验证的正确性，因为只是提取测试激励，正确性由模拟仿真保证。  复杂设计如何完成验证 复杂的设计验证时间通常较长，不容易完成验证，但是，依据设计的特性，也是可以通过一些手段完成验证，下面以典型设计举例。\n设计结构      此设计有以下几个特点：  设计中stage1输入，stage5输出，中间需寄存四拍。 设计中分为流水线控制信号、数据信号和控制信号、组合逻辑三个部分，流水线控制信号带复位。 设计中为单向流动，无bypass，也就是流水线前后独立，无反馈。 设计中带advance_pipeline，流水线的使能控制，也就是流水线可能锁定n拍后重新启动。 设计中模块支持多功能类型，也就是op_type。  复杂设计的形式化验证方案  依据功能类型，分类验证，各个功能依次验证。 约束输入，单功能验证仅提交一次，运算数据由工具遍历，验证功能正确性。 除流水线控制寄存器之外，其他寄存器不加复位，工具会将其初始值进行遍历，可等效为激励输入前模块的任何状态。 凡是影响流水线行进的输入，全部添加约束，可以约束停顿周期为1~2，或直接约束为无停顿，暂不验证流水线控制功能。 数据check语法采用单比特，如“data_a[3:0]==data_b[3:0]”改为“data_a[3]==data_b[3], data_a[2]==data_b[2] ……”，前者遍历空间是2^4，后者遍历空间2*4。 对流水线控制功能的验证，在其算法功能验证的正确基础上，将数据进行适当约束，减少遍历空间，主要验证流水线控制功能。 其他手段有待后续补充。  其他减少状态空间的方法  抽象模型：如fifo或其他存储类模块，设计本身主要验证的是控制逻辑，从而可以减少存储单元来针对设计完成抽象模型，可以有效的减少状态空间。 黑盒化：将不关心的设计设置黑盒，可以有效的减少状态空间 断点：待了解  以上方法还未在实际工程中使用过，待后续总结\n推荐书籍  《SystemVerilog Assertion应用指南》 《Formal Verification: An ESSential Toolkit For Modern VLSI Design》 以及其他EDA厂商提供的使用手册和培训资料（如哪位读者有此类资料，感谢分享）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":36,"section":"docs","tags":["Formal"],"title":"Formal验证技术总结","uri":"https://wenhui.space/zh/docs/digital_verifer/other/formal_verify.html"},{"content":"本文 主要介绍一个破解版的谷歌访问助手工具。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 google版本： 78.0.3904.97（正式版本） （64 位）  谷歌访问助手能做什么  解决chrome扩展程序无法自动更新的问题 可以访问google搜索、gmail邮箱和google+  下载  进入github网址进行下载 我的百度网盘分享资源 链接：https://pan.baidu.com/s/1nVTXRinSBhOz17C23ytM7w 密码：j0lt  使用  打开google浏览器（Windows和Linux均支持） 点击功能栏右侧三个点，选择设置，打开设置页面 选择扩展程序，进入扩展程序页面 打开 开发者模式 ，选择 加载已解压的扩展程序包 ，选择刚刚下载的压缩包解压后的文件夹 可以开始访问了（该插件通过代理服务器访问Google，代理服务器的地址和密码以及PAC脚本均由插件动态获取。研究发现，即使将PAC脚本替换掉，依然只能访问Google和GMail，其余网站无法打开，表明服务器端已进行了限制。）    谷歌访问助手页面    注意 该插件是在使用网络代理访问外网，建议仅在安装扩展程序以及google查资料时使用，尽量不要长时间访问外网。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":37,"section":"docs","tags":["google"],"title":"最简单易用的谷歌访问助手","uri":"https://wenhui.space/zh/docs/install_software/google_assistant.html"},{"content":"本文 初识芯片验证系列主要介绍芯片验证的背景和基础知识，使读者对芯片验证有一个初步认识。此为第一篇，主要介绍芯片开发概述、验证任务和目标、验证职业前景、验证周期。\n   版本 说明     0.1 初版发布    参考  路科验证。  概览      芯片开发概述 芯片开发流程  市场调研和客户需求。 项目立项。 架构师按照芯片功能划分子系统。 子系统划分为功能模块，设计工程师完成逻辑设计。 验证工程师对设计功能进行验证，发现bug并提交给设计工程师修正，如此迭代，直至无bug。 验证收敛无bug后，后端工程师综合、布局、布线。 后端工程师将核心数据交FAB厂商进行流片。  验证和设计的关系  设计如果没有经过充分验证、量化验证，无法保证流片的成功。 验证工程师要懂设计，否则无法更好的发现和定位bug，更无法与设计工程师好好沟通。 设计工程师要懂验证，否则无法体会验证逐渐趋向于软件化。 设计工程师要验证尽早尽快尽量的发现设计bug，越到后期修正设计bug的代价越大，首先设计的修改可能牵一发而动全身，修正后需要完整的回归测试，甚至后端重新综合布局布线。 设计工程师和验证工程师围绕功能描述文档展开工作。 设计初步完成时验证就要启动，甚至更早启动。 发现验证结果与预期不符，明显bug可提交给设计工程师，若无法判定，需要与设计工程师依据功能描述文档进行沟通，统一对功能的理解。 设计从底层模块向系统集成过程中，验证与设计要各自开展工作，验证要保证每一个层次验证的充分性和完备性。  验证的三个方向  设计功能是否符合功能描述文档？ 设计工程师是否有遗漏的边界场景？ 设计是否足够稳定来处理错误场景？  验证的挑战  如何穷尽所有场景为设计产生激励？  划分有效的测试空间。 给出随机约束激励。   如何发现和判断设计的bug？  根据不同类型设计提供相应的测试激励，选择相应的比对方法。 根据不同类型设计选择相应的验证工具，仿真验证和形式验证。 根据复杂度不同，选择黑盒验证、白盒验证以及灰盒验证。    验证职业前景  目前工作中设计与验证同等重要。 验证需求量大，与设计的比例接近2:1。 学习和掌握验证知识，对后期从事设计或验证都有帮助。 公司研发团队越正规化，对验证的规范性越重视。 验证工作越来越趋向软件化，知识迭代比设计快，更富有挑战性。 验证的充分性和完备性，才能保证高质量流片。  验证的目标 按时：  验证工程师需要按照项目的预期进度来考虑验证节点。 协调安排各模块验证工作进度，任何一个模块验证的延迟都会影响整体验证进度。 团队协作，所有验证工程师都要有时间节点观念。  保质：  尽可能保证验证的充分性和完备性，减少硅后bug的出现。 bug出现的阶段越到后期，代价越大。 提前做好验证计划，设计与验证定期沟通，保证验证计划的充分性和完备性。  低耗：  人力和时间成本低耗，保证工作的高效率。 资金成本低耗，尽早保证验证的充分性，防止bug出现在硅后甚至客户端，就是在保证资金成本低耗。  验证的周期 验证流程  创建验证计划：参照设计人员提供的设计功能描述文档创建验证计划，并且与设计工程师完成多次review，确保验证计划无明显缺陷。 搭建验证环境：验证工程师搭建验证环境平台，准备测试激励。 模拟仿真和debug：开始跑测试激励，进行验证环境和设计电路的debug（如果是环境问题择优化环境，设计问题定位具体bug，提交给设计人员）。 回归测试：当设计电路通过了一定量的测试激励，验证人员需要准备回归测试，也就是将已有的所有测试通过的用例重新测试一遍。 验证代码检查：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等。 收集覆盖率：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标。 完备性检查：此项任务由验证项目经理完成，主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押。 硅后测试：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训。  review节点  验证计划review： 设计工程师与验证工程师依据功能描述文档沟通，检查验证计划，确保无明显遗漏和功能偏差。 验证代码review： 回归测试前，设计工程师与验证工程师对验证代码进行review，检查是否有遗漏的测试用例、不恰当的随机约束等。 覆盖率review： 回归测试后，对当前覆盖率进行review，确保验证的完备性。 验证总结review： 其一是分析bug逃逸，总结经验，吸取教训；其二是验证流程、工具使用、团队协作等经验总结。  功能描述文档  接口信息： 描述接口信号的时序信息和数据传输信息等。 结构信息： 描述模块的逻辑结构，包含各个功能组件，以及各个功能组件的逻辑关系。 交互信息： 描述模块与其他模块的交互信息，包括逻辑示意图和时序信息，确保集成后模块间按照预期功能完成交互。  验证计划  验证方法： 定向验证、随机约束验证、形式化验证等。 验证工具： 选择需要的验证工具来支持验证方法，如VCS、XRUN、JasperGold等。 验证完备性： 量化一些参数（功能点覆盖率、代码覆盖率、断言覆盖率）可以衡量验证任务是否完成。 验证资源和进度： 人力、时间、硬件、软件等预算。 验证功能点： 流出验证功能点，以及明确在什么层次去验证它，甚至选择何种激励去验证它。  开发验证环境  搭建环境，实现激励产生、参考模型和数据比较。 不同的验证方法，验证环境的结构和使用软件不同。 随着bug的发现和修正，设计趋于稳定，验证环境保持更新，补充测试用例。 添加covergroup或assert，使环境支持覆盖率收集。  debug  环境是否存在bug。 测试激励是否合理。 参考模型是否遵循设计功能描述文档。 硬件设计是否存在bug。  回归测试  确保改动没有引入新的bug。 随机种子不同，测试激励不同，有利于收集覆盖率，往复的回归测试和补充的定向测试，可逐步提供验证的完备性。  芯片流片  经过回归测试（RTL回归和门级网表回归），项目负责人、设计负责人、验证负责人、后端负责人一同回顾整个checklist，确保通过各项指标，交给FAB厂商进行流片。 特别提示： 即便已经交给FAB厂商进行流片，继续保持回归测试，并尽可能创造新的测试激励，覆盖更多状态空间，进一步保证验证的完备性。 如果交给FAB厂商进行流片后发现设计bug，一考虑是否有软件补救办法，二提交设计修改意见，下次流片前准备好设计和验证方案。  硅后测试  流片后系统测试工程师会将芯片植入测试系统或依靠测试开发板，进行硅后测试。 硅前工程师（设计、验证）和硅后工程师保持沟通，出现测试问题，第一时间判断测试问题还是设计bug，以及如何修补。  逃逸分析  验证无法保证设计没有任何bug，而是尽可能发现所有bug。 硅后测试发现bug，设计工程师和验证工程师要和系统测试工程师沟通，尝试在硅前的仿真环境中复现。 逃逸分析后，对下一个芯片周期，设计工程师如何规避设计bug、完善设计经验，验证工程师如何完善验证方案、如何产生更多有效测试激励都是很有意义的。也就是总结经验、吸取教训  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":38,"section":"docs","tags":["SystemVerilog","UVM"],"title":"初识芯片验证（一）","uri":"https://wenhui.space/zh/docs/digital_verifer/beginner_verification/beginner_verification_one.html"},{"content":"本文 主要介绍芯片验证工程师的成长之路，包括职位概述、技术入门、能力提升和角色转换。\n写在前头，本文内容是根据自己的工作经验和行业了解，以及师兄的经验传授和网络资源，集合而成。并且我还在不断继续努力中。\n   版本 说明     0.1 初版发布   0.2 添加验证流程    背景 本人工作IC设计和IC验证同时涉及，工作领域为CPU相关，经验三年。\n参考  路科验证  芯片验证职位概述  以往设计地位高于验证，随着芯片复杂度越来越高，流片成本越来越大，目前芯片验证地位与设计同样重要 验证的岗位需求量大，与设计的比例接近2:1 了解验证知识对于将来从事芯片设计也有很大帮助 公司越规模化，团队越正规化，对芯片验证的规范性和重要性就越突出 芯片验证相对设计，更讲究团队协作 芯片验证软件化，工具和语言等知识迭代快（目前相对稳定，统一使用sv语言和UVM方法学），需要不断学习 芯片验证也要懂设计代码，否则无法更好的完成芯片验证 芯片验证不仅限于发现设计bug，还包括对设计的理解以及提出修改意见  芯片验证的技术入门 芯片验证相对于芯片设计，技术门槛较低，但要学习的知识宽度要大于芯片设计。所谓技术门槛低，换句话说也就是即便你对项目领域（如射频、通信、CPU等）完全不通，但并不妨碍你做基础的验证工作。以下是个人认为芯片验证工程师入门需具备的基础：\n 基本的数字电路知识 systemverilog语言和UVM验证方法学 RTL硬件描述语言，如verilog 芯片设计项目的了解（对于前期入门阶段并不是硬性要求） 基础的脚本语言，如Makefile、shell  芯片验证工程师与FPGA验证工程师、芯片设计工程师、软件测试工程师的比较 芯片验证工程师与FPGA验证工程师  FPGA验证是更高层次的黑盒验证 FPAG验证相对于模拟仿真，缺点是难以调试IC设计的内部信号，难以深入debug FPGA验证相对于模拟仿真，优点是仿真速度快，可模拟芯片真实环境，发现隐藏bug FPGA验证工程师的技能更多是工具的使用，看到的IC设计更上层（一般IC设计完整度较高时才会上FPGA平台）  芯片验证工程师与芯片设计工程师  芯片设计工程师更加硬件化，只需verilog语言，但重点在于对设计领域的深刻理解和项目经验 芯片设计工程师对芯片验证领域无需了解太多，而验证工程师也需要对设计有一定了解 芯片验证工程师往往有机会转型到设计，debug过程对设计逐步了解，并且有时候需要给出修改意见 芯片验证工程师不仅与设计工程师协作紧密，与后端和软件工程师有时也有交互 芯片设计工程师关注的是功能结构如何转换为电路实现，芯片验证工程师关注的是电路层次是否符合功能场景 芯片设计工程师学习深度更深，芯片验证工程师学习广度更广，换句话说，验证工程师相对于设计工程师更容易转行（指项目领域，如射频、通信、CPU） 芯片设计门槛高于芯片验证，需要更强的项目领域相关背景知识（一般要求重点学校硕士学历）  芯片验证工程师与软件测试工程师 芯片验证与软件测试，对于非芯片领域或刚毕业的学生，是很容易产生误会的。\n 所处芯片开发阶段不同，芯片验证在流片前，软件测试在流片后（不仅限于流片后） 软件测试纯软件化，看不到或不关心电路结构 软件测试与软件设计的薪资差异，远远大于芯片验证和芯片设计的薪资差异，普遍来讲（排除技术大牛），芯片验证薪资往往高于软件测试（这也是为什么产生误会的原因）  芯片验证工程师的能力提升  深入学习设计领域知识和IC设计架构（对于IP验证及其重要） 深刻学习理解SV语言，可以学习与SV类似的面向对象编程语言，帮助对SV语言特性的理解 深刻学习理解UVM验证方法学，可以从软件的设计模式深入理解 优化代码结构和项目层次，增强可复用性，增强集成度和自动化 多平台验证工具的使用，如formal、FPGA等，对于覆盖率收敛很重要 脚本语言，如shell、Makefile、Python、Tcl、Perl等，掌握脚本语言是使验证平台自动化的基础 虚拟建模和VIP的开发，可增加验证效率，并且可复用性强 制定和优化验证流程，验证计划的制定和实现，验证进程评估 验证管理，包括时间和人力，以及任务安排  芯片验证工程师的角色转换 一个芯片验证工程师经历五到七年的技术积累，此时工作任务得心应手（或者说固化），往往会产生工作倦怠的态度，对于新工具和新知识的学习也不再渴望，这时候需要考虑角色的转换。\n 承担全新设计模块的验证，比如对于CPU项目，可以从DPU模块验证转为LSU模块验证 转为芯片设计，从事不同的工作内容 专职做验证平台优化，学习或自研更好的验证工具和验证方法，提高验证效率（前提是公司同意） 做技术培训者 做验证技术专家或验证管理（前提是能力出众，一般工作十年经验） 离职（需慎重，芯片行业大公司不多，跳一个少一个）  芯片验证工程师的职业规划（也是写给自己）  一年时间，完成芯片验证工程师的入门 三年时间，从初级芯片验证工程师到独立承担模块验证 三年时间，从独立承担模块验证到验证leader（也有可能转向芯片设计） N年时间，从验证人员到验证主管（或技术专家）  验证流程  创建验证计划：参照设计人员提供的设计功能描述文档创建验证计划，并且与设计工程师完成多次review，确保验证计划无明显缺陷 搭建验证环境：验证工程师搭建验证环境平台，准备测试激励 模拟仿真和debug：开始跑测试激励，进行验证环境和设计电路的debug（如果是环境问题择优化环境，设计问题定位具体bug，提交给设计人员） 回归测试：当设计电路通过了一定量的测试激励，验证人员需要准备回归测试，也就是将已有的所有测试通过的用例重新测试一遍 验证代码检查：也就是对验证环境和当前验证结果的review，检查是否有遗漏的测试用例、不恰当的随机约束等 收集覆盖率：覆盖率包括功能覆盖率和代码覆盖率，覆盖率是对验证进度以及验证完备性的重要数据指标 完备性检查：此项任务由验证项目经理完成，主要根据验证计划、验证进度、数据结果等信息来综合评定是否全部完成验证任务，并签字画押 硅后测试：当硅后测试发现bug时，不仅要协助测试人员定位和修复bug，更重要的是分析硅前测试bug逃逸的原因，总结经验教训  除了技术，我们还需要做什么？ 虽然我们是技术从业者，但是毕竟人的社会是复杂的，那么除了技术，我们还需要做什么？\n 提高团队合作性，让更多的人乐于和自己合作，是对自己人品和性格的最好肯定 提高行业敏锐度，多关心了解行业领域的一些事情，相信我这样是有好处的 跟对一个好领导，作为领导的主要干将，相信我这样是有好处的 保持好同事和前同事的联系，相信我这样是有好处的  顺便，对于新入职的毕业生，教你如何快速与同事和领导建立起社交关系，那就从吃食堂开始。\n书单 基础  《SystemVerilog验证》 《UVM实战》 《芯片漫游指南：从系统理论到UVM的验证全视界》 《全面的功能验证：完整的工业流程》 《Verilog与SystemVerilog的编程陷阱》 《综合与时序分析的设计约束：Synopsys设计约束（SDC）实用指南》  提升  《设计模式：可复用面向对象软件的基础》 《敏捷软件开发：原则、模式与实践》 《代码大全》 《代码阅读》 《重构：改善既有代码的设计》 《改善程序与设计的55个具体做法》  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":39,"section":"docs","tags":null,"title":"芯片验证工程师","uri":"https://wenhui.space/zh/docs/digital_verifer/other/digital_verifer.html"},{"content":"本文 主要介绍对word编辑文档的一些建议。\n   版本 说明     0.1 初版发布    背景 本篇文章参考自王老师。\n写在前面 出于各方面原因，我们编辑文档时，主要还是使用微软的office工具word。word不敢说是最好的文档编辑工具，但是功能最强，使用最广的文档编辑工具，而我们在使用word编辑文档时，是否有好好利用了其强大的功能呢？这是一个值得思考的问题。\n我们在编辑文档时，是在编辑什么？一篇文档包含两方面，一是内容，指文档的表述文字、图表、公式等，二是表现，指文档的表现形式，比如字体字号、页边距页面大小等。那么关于是否有好好利用word强大的功能的思考，答案就有了，如果你编辑文档时，是在编辑内容，而表现形式由word工具完成，那你就好好利用word强大的功能。而往往大多数人在使用word时，还在花费大量的时间在人工排版上。换句话说，word被当做了记事本来使用。\n建议 一定要使用样式 word除了提供已有的标题和正文等样式，还可以自定义样式，也就是说，当你发现自己当前文字使用的格式会多次被使用，那就请定义一个样式吧。建议坚持使用样式，这样不仅可以减少出错和节省时间，而且方便样式替换，以及可以自动生成目录和索引。\n一定使用交叉引用 一定使用交叉引用，不要手敲编号，否则会对你的文档修改维护带来无穷后患。使用交叉引用不仅可以自动更新编号，还可以自动生成图表目录。\n一定不要敲空格来对齐 一般只有英文单词前后才会出现空格，中文文档不会出现空格，对齐应该采用制表符、对齐方式和段落缩进等，而绝不是空格。\n绘图 建议使用visio，如果是统计图建议使用excel生成。（其他visio可替代工具亦可）\n数学公式 建议使用MathType，可集成在word使用，会在word增加一个菜单项，一定要使用MathType的自动编号和引用功能，使用方法参考 MathType在Word中的使用。\n使用节 如果你希望在一篇文档中使用不同的页眉页脚等，可以插入分节符，并设置当前节与上一节格式不相同。\n使用子文档 如果你的文档过于大（几十页），且包含大量图片、公式、表格等，所有内容保存到一个文件里，一是打开、保存文件较慢，二是有破坏和丢失内容的风险。建议对于大文件的编辑，可以将每一章定义为一个子文档，在主文档中定义格式，这样既提高了文件访问速度也降低了破坏和丢失内容的风险。建议在主文档中创建子文档。\n及时保存 编辑文档时，一定要多按Ctrl+s，及时保存。\n多做备份 对编辑的文档多做版本备份。不仅word不可靠，windows也不可靠，越是重要的、工作量大的文档，越要多做备份。\n另存图片、表格和公式 文档中一张好图胜过千言，而一张好图所需的时间也不只于千言，所以对于文档中的图片、表格和公式，最好另存到其他文件夹，防止以后因为工具、格式或其他问题，导致文档中的图片、表格和格式无法正常显示，到时候哭都来不及。\n使用大纲视图 使用大纲视图，可以方便调整章节顺序。\n使用文档导航窗口 使用文档导航窗口可以方便的对文档定位。\n使用文档保护 使用文档保护可以方便对文档审阅和修改。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":40,"section":"docs","tags":["Office"],"title":"关于word编辑文档的一些建议","uri":"https://wenhui.space/zh/docs/about_windows/some_advices_of_word.html"},{"content":"本文 主要介绍用emacs auto-insert命令实现用模板文件创建新文件。\n   版本 说明     0.1 初版发布   0.2 添加两个函数    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs中那些简化输入的方法\u0026ndash;Autotyping Auto Insert Mode Emacs如何使用文件模板  创建模板文件 在.emacs.d目录下新建文件夹 templates，并创建verilog模板文件 templates.v，内容如下(文件名、路径、内容均可根据个人喜好进行定义，这里只是举例说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //------------------------------------------------------------------------- // Title : // Project : //------------------------------------------------------------------------- // File name : // Author : // Created : // Last modified : //------------------------------------------------------------------------- // Description : // // This block does the following operations: // - // - //------------------------------------------------------------------------- // This file is a confidential and proprietary property of XXX and the // possession or use of this requires a written license from XXX. // // Copyright (c) 2020 XXX Technology Co., Ltd. ALL rights reserved. //-------------------------------------------------------------------------  module xx(/*AUTOARG*/); /*AUTOWIRE*/ /*AUTOREG*/ endmodule   修改配置文件 我们创建了模板文件，还需要在配置文件中进行配置，打开.emacs或.emacs.d/init.el，添加以下内容(除了verilog文件模板，我还添加了shell等其他模板，不再一一说明)：\n1 2 3 4 5 6 7 8 9 10 11 12 13  ;;about template file ;;---------------------------------------------------- (auto-insert-mode) ;; Adds hook to find-files-hook (setq auto-insert-directory \u0026#34;~/.emacs.d/templates/\u0026#34;) (setq auto-insert-query nil) ;; If you don\u0026#39;t want to be prompted before insertion (setq auto-insert-alist (append \u0026#39;((verilog-mode . \u0026#34;template.v\u0026#34;) (python-mode . \u0026#34;template.py\u0026#34;) (c-mode . \u0026#34;template.c\u0026#34;) (shell-mode . \u0026#34;template.sh\u0026#34;) ) auto-insert-alist)) ;;----------------------------------------------------   添加两个函数 插入当前时间 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前时间时， M-x now 即可。\n1 2 3 4 5  (defvar current-date-time-format \u0026#34;%Y/%m/%d %H:%S\u0026#34;) (defun now () (interactive) (insert (format-time-string current-date-time-format (current-time))) )   插入当前文件名 将下面代码添加到.emacs或.emacs.d/init.el文件，需要插入当前文件名时， M-x name 即可。\n1 2 3 4  (defun name () (interactive) (insert (file-name-nondirectory buffer-file-name)) )   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":41,"section":"docs","tags":["emacs","verilog"],"title":"emacs 中使用模板文件","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_auto_insert.html"},{"content":"本文 主要介绍如何使用 Verilog-Perl 脚本对verilog代码进行神奇操作。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3 Verilog-Perl版本：Verilog-Perl-3.468  参考  Verilog-Perl使用手册  安装verilog-perl 下载  Verilog-Perl主页 我的百度网盘分享资源(Verilog-Perl-3.468) 链接：https://pan.baidu.com/s/18cqcuv3MwtlGheuy2wWl8g 密码：73wd 也可以直接使用我安装后的可执行程序，百度网盘分享资源 链接：https://pan.baidu.com/s/1w1AykoGr0AFmfnoar87FRQ 密码：9nzf  安装 安装过程中，发现有依赖错误，先下载依赖文件(我也并不知道这些依赖有何作用，无非就是报出了依赖错误，乖乖安装罢了)：\n1 2 3 4  sudo apt install flex sudo apt install bison sudo apt install g++ sudo apt install gcc   接下来进行安装(详情可查看安装包中RENAME)：\n1 2 3 4  perl Makefile.PL make make test sudo make install   vrename的使用 使用场景 vrename的使用主要有两个场景：\n 一是同一文件，修改某信号名称，不用一一修改，通过vrename即可完成全部信号名的修改（好像查找替换也行，不过修改信号名较多时，vrename还是方便一些） 二是交互文件，子模块与顶层模块间的实例化，此时修改信号就需要在不同的文件里修改或查找替换，当需要修改的信号较多时，就会繁杂且易出错，此时vrename将信号统一到一个文件里，修改此文件后使用vrename \u0026ndash;change即可完成修改，方便快捷。  使用方法 vrename可以比较方便的从多个文件中为信号和模块重命名。操作过程分为两步：\n 读取文件，你将会得到 signals.vrename 文件，其中包含了所有信号的列表。   1  vrename --list file1.v file2.v file3.v ...    可以编辑此文件，修改信号名，然后在运行第如下命令，就可以把新的信号名应用到源文件上了。   1  vrename --change file1.v file2.v file3.v ...   展示 signals.vrename 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Generated by vrename on Fri Jan 3 16:56:31 2020 # # Files read for this analysis: vfile\t\u0026#34;testbench.v\u0026#34; vfile\t\u0026#34;dut.v\u0026#34; # #\tOriginal Signal Name\tName to change to #\t--------------------\t----------------- # sigren\t\u0026#34;clk\u0026#34;\t\u0026#34;clk\u0026#34; sigren\t\u0026#34;din0\u0026#34;\t\u0026#34;din0\u0026#34; sigren\t\u0026#34;din1\u0026#34;\t\u0026#34;din1\u0026#34; sigren\t\u0026#34;din2\u0026#34;\t\u0026#34;din2\u0026#34; sigren\t\u0026#34;dout\u0026#34;\t\u0026#34;dout\u0026#34; sigren\t\u0026#34;dout_a\u0026#34;\t\u0026#34;dout_a\u0026#34; sigren\t\u0026#34;dout_b\u0026#34;\t\u0026#34;dout_b\u0026#34; sigren\t\u0026#34;dout_c\u0026#34;\t\u0026#34;dout_c\u0026#34; sigren\t\u0026#34;dout_x\u0026#34;\t\u0026#34;dout_x\u0026#34; sigren\t\u0026#34;dout_y\u0026#34;\t\u0026#34;dout_y\u0026#34; sigren\t\u0026#34;dout_z\u0026#34;\t\u0026#34;dout_z\u0026#34; sigren\t\u0026#34;dut\u0026#34;\t\u0026#34;dut\u0026#34; sigren\t\u0026#34;i_dut\u0026#34;\t\u0026#34;i_dut\u0026#34; sigren\t\u0026#34;rst_n\u0026#34;\t\u0026#34;rst_n\u0026#34; sigren\t\u0026#34;sig1\u0026#34;\t\u0026#34;sig1\u0026#34; sigren\t\u0026#34;testbench\u0026#34;\t\u0026#34;testbench\u0026#34; # # Use M-x compile in emacs to automatically perform the changes: ## Local Variables: *** ## compile-command: \u0026#34;./vrename -change testbench.v dut.v \u0026#34; *** ## End: ***   多目录问题的解决 如果文件分布到不同目录里，可以创建新的工作目录，并将源文件复制软链接至工作目录，此时就可以操作了。不过，vrename并不建议一次打开太多文件，以免信号过多。\nvhire的使用 待补充，如有使用者，欢迎传授使用技巧。\nvpassert的使用 待补充，如有使用者，欢迎传授使用技巧。\nvsplitmodule的使用 待补充，如有使用者，欢迎传授使用技巧。\nvppreproc的使用 待补充，如有使用者，欢迎传授使用技巧。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":42,"section":"docs","tags":["emacs","verilog"],"title":"Emacs Verilog Perl 的使用","uri":"https://wenhui.space/zh/docs/about_emacs/verilog_perl_useguide.html"},{"content":"本文 主要介绍使用emacs verilog-mode 编辑verilog的神奇操作。\n   版本 说明     0.1 初版发布   0.2 添加快捷键插入内容    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  verilog-mode  什么是verilog mode verilog-mode是Emacs的一种编辑模式，主要面对verilog的开发环境，拥有很方便的自动缩进机制和AUTO机制。AUTO机制是Emacs verilog-mode中一些自动化实现的脚本功能，比如自动填充模块参数列表、自动完成模块例化、自动声明连线等等。\n为什么使用verilog-mode verilog语法中有很多内容是冗余的，模块中必须出现却起不到什么功能作用，列举如下：\n 模块参数列表和模块端口声明input/output reg语句和已经声明为输出的信号 子模块实例化的连线声明 子模块的实例化语句和子模块的端口声明 组合逻辑always语句的敏感信号表（不过已经可以使用*来代替了）  可见verilog语法中的垃圾信息还是不少的，不过这是语法规则导致的，是语言本身的缺陷，作为使用者只能遵守语法规则。这些冗余信息中比如参数列表和模块例化连线，不仅需要花费时间去编写，而且还特别容易出错，给RTL编写以及后续的修改维护都带来很多问题。那么如果解决这些问题，会带来什么效果呢？个人认为有以下几点：\n 代码整洁，便于阅读 提高编码效率，尤其是顶层实例化 减少拼写错误 便于维护，比如修改、增加和删除端口，无需修改参数列表，比如修改、增加和删除子模块端口，无需修改顶层实例化  AUTO机制的使用 Emacs verilog-mode的AUTO机制，就是在代码中相应的位置写一些/*AUTO*/类似的注释，verilog-mode可以自动替换为所需的内容。Emacs编辑器和verilog-mode的AUTO机制结合，可以很方便的看到AUTO的效果，而且AUTO是以注释形式添加到verilog文件，在语法上本身是合法的，不会影响EDA工具的使用。举例如下：\n 原代码  top module     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  module top_md(/*AUTOARG*/); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ /*AUTOWIRE*/ wire din_a; wire din_b; always@(/*AUTOSENSE*/) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md    sub_module   1 2 3 4 5 6 7 8 9  module sub_md(/*AUTOARG*/); input din_a; input din_b; output [1:0] dout_a; wire [1:0] dout_a; assign dout_a[1:0] = {din_b,din_a}; endmodule // sub_md    AUTO之后   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  module top_md(/*AUTOARG*/ // Outputs dout1, dout2, // Inputs din1, din2 ); input din1; input [1:0] din2; output dout1; output [1:0] dout2; /*AUTOREG*/ // Beginning of automatic regs (for this module\u0026#39;s undeclared outputs) reg dout1; // End of automatics /*AUTOWIRE*/ // Beginning of automatic wires (for undeclared instantiated-module outputs) wire [1:0] dout_a; // From i_sub_md of sub_md.v // End of automatics  wire din_a; wire din_b; always@(/*AUTOSENSE*/din1 or din2) dout1 = din1 | din2[1]; assign din_a = din2[0]; assign din_b = din2[1]; sub_md i_sub_md(/*AUTOINST*/ // Outputs  .dout_a (dout_a[1:0]), // Inputs  .din_a (din_a), .din_b (din_b)); assign dout2[1:0] = dout_a[1:0]; endmodule // top_md   使用 AUTOSENSE 自动生成敏感表 在Verilog 2000中，已经对语法做出了简化，比如使用 @(×) 来代替敏感信号列表，但是需要EDA工具的支持。不过现在EDA工具都已经支持verilog 2005了，可以将敏感信号列表直接写为 @(×) 即可，所以 AUTOSENSE 功能可以不使用。\n1 2 3 4  always @ (/*AUTOSENSE*/) begin outin = ina | inb; out = outin; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4  always @ (/*AUTOSENSE*/ina or inb) begin outin = ina | inb; out = outin; end   使用AUTOARG自动生成模块参数表 1 2 3 4  module ex_arg (/*AUTOARG*/); input i; output o; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_arg (/*AUTOARG*/ // Outputs  o, // Inputs  i); input i; output o; endmodule   不支持带 `ifdefs 等条件限制的端口声明，如有此需求，可以将其写在 AUTOARG 之前， AUTOARG 不会对其进行重新声明。不过不建议这种方式，因为在 AUTOINST 中会引入更多的 `ifdefs 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  module ex_arg ( `ifdef need_x_input x, `endif /*AUTOARG*/ // Outputs  o, // Inputs  i); `ifdef need_x_input input x; // This is an optional input, if `need_x_signal is defined `endif ...   使用AUTOINST自动实例化 子模块：\n1 2 3 4 5  module fanout (o,i) input i; output [31:0] o; wire [31:0] o = {32{i}}; endmodule   顶层模块：\n1 2 3 4 5  module ex_inst (o,i) input i; output [31:0] o; fanout fanout (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9  module ex_inst (o,i) output o; input i; fanout fanout (/*AUTOINST*/ // Outputs  .o (o[31:0]), // Inputs  .i (i)); endmodule   注意，子模块需要与顶层例化模块保存在同一文件目录，否则会索引不到子模块，而且实例化的端口名与子模块的端口名，默认是一致的。一般来讲，提倡实例化的端口名与子模块的端口名一致，这样对综合及维护都会带来好处，但是由于某些原因无法使其一致，那最简单的方法就是在 AUTOINST 之前指定实例化的端口名，所有在 AUTOINST 之前定义的端口不会再次生成，但是你最好加上 //Inputs //Outputs 注释，否则 AUTOWIRE 不知道信号方向。举例如下:\n1 2 3 4 5 6  fanout fanout ( // Inputs  .i (my_i_dont_mess_with_it), /*AUTOINST*/ // Outputs  .o (o[31:0]));   如果你被端口名不一致所困扰，可以参考我的另一篇帖子 Emacs Verilog Perl 的使用中vrename的使用章节。\n使用AUTO_TEMPLATE创建模板 如果一个模块被实例化多次，你可以使用verilog的 generate 语法，也可以使用Emacs verilog-mode的 AUTO_TEMPLATE 和 AUTOINST 。Verilog-mode向上索引最近的模板，这样对于一个子模块可以写多个模板，只需要将模板写在实例化之前即可。\n1 2 3 4  /* psm_mas AUTO_TEMPLATE ( .PTL_MAPVALIDX (PTL_MAPVALID[@]), .PTL_BUS (PTL_BUSNEW[]), ); */   TEMPLATE中的模块名称必须与实例中的模块名称相同，并且只需列出每次实例化时名字不同的那些信号就好了。如上文的例子，要遵守此格式（每行只有一个端口，并且以逗号结尾，最后以分号结尾，就像AUTOINST产生的一样）。实际上，最简单的方法是完成一个AUTOINST，并将其修改后复制到AUTO_TEMPLATE。\n1  psm_mas ms2 (/*AUTOINST*/);   AUTO效果：\npsm_mas ms2 (/*AUTOINST*/ // Outputs .INSTDATAOUT (INSTDATAOUT), .PTL_MAPVALIDX (PTL_MAPVALID[2]), // Templated .PTL_BUS (PTL_BUSNEW[3:0]), // Templated .... @ 字符非常有用，他将被实例名的末尾数字代替（不限于1位数字），比如ms2，@替换为2。AUTO机制把模板中的 [] 替换为子模块中该信号真实的字段范围，比如 PTL_BUSNEW[] 替换成了 PTL_BUSNEW[3:0] ，因为子模块中PTL_BUSNEW信号声明就是 [3:0]。这样写的好处就是子模块的修改自动响应到顶层模块。（其实如果端口信号位宽一致，实例化端口也可以不指明位宽字段，不过为了便于维护和减少出错，建议指明位宽字段）\n神奇的 @ 不仅支持数字，还可以支持字母，这需要在模板做以下操作（模板支持正则表达式）：\n1 2 3 4 5 6 7  /* InstModule AUTO_TEMPLATE \u0026#34;_\\([a-z]+\\)\u0026#34; ( .ptl_mapvalidx\t(@_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_@), ); */ InstModule ms2_FOO (/*AUTOINST*/); InstModule ms2_BAR (/*AUTOINST*/);   AUTO效果如下：\n1 2 3 4 5 6 7 8  InstModule ms2_FOO (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(FOO_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_FOO)); InstModule ms2_BAR (/*AUTOINST*/ // Outputs  .ptl_mapvalidx\t(BAR_ptl_mapvalid), .ptl_mapvalidp1x\t(ptl_mapvalid_BAR));   在模板中使用Lisp 在AUTO_TEMPLATE中指定简单的线名称并不能够解决所有需求，尤其是在多个实例化中使用同一信号不同数据位时。因此，Verilog-Mode允许你编写一个程序来进行计算并为实例化端口进行命名，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* InstModule AUTO_TEMPLATE ( .a(in[@\u0026#34;(+ (* 8 @) 7)\u0026#34;:@\u0026#34;(* 8 @)\u0026#34;]), );*/ InstModule u_a0 (/*AUTOINST*/ // Inputs  .a (in[7:0])); // Templated InstModule u_a1 (/*AUTOINST*/ // Inputs  .a (in[15:8])); // Templated InstModule u_a2 (/*AUTOINST*/ // Inputs  .a (in[23:16])); // Templated InstModule u_a3 (/*AUTOINST*/ // Inputs  .a (in[31:24])); // Templated   这里对上述Lisp代码部分解释一下， 也就是 @\u0026quot;(+ (* 8 @) 7)\u0026quot;:@\u0026quot;(* 8 @)\u0026quot; ：\n 基础结构为 @\u0026quot;\u0026quot; 代表@为输入参数，引号内为计算处理 每个括号内容为一步计算，形如 (* 8 @) ，意思是 @参数乘8 (+ (* 8 @) 7) 就是将 (* 8 @) 的结果加7  AUTOINSTPARAM的使用 如何在实例化时自动填充参数列表？AUTOINSTPARAM可以做到，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  module InstModule; parameter PARAM1 = 1; parameter PARAM2 = 2; endmodule module ModnameTest; InstModule #(/*AUTOINSTPARAM*/ // Parameters  .PARAM1 (PARAM1), .PARAM2 (PARAM2)) instName (/*AUTOINST*/ ...);   verilog-mode中如何使用正则表达式 在顶层实例化时，有大量的信号需要重新命名，使用模板的话会增加大量的注释内容，不过往往这些信号命名有特定的规律，我们可以使用正则表达式来处理，下面举几个例子：\n 提取信号中固定位置的数字   1 2 3  .pci_req\\([0-9]+\\)_j (pci_req_jtag_[\\1]), .pci_req12_j (pci_req_jtag_[12]),    删除末尾下划线内容   1 2 3  .\\(.*\\)_j (\\1_[]), .pci_req_j (pci_req[7:0]),    对信号矢量化处理(\\1内容代表提取末尾数字之前的内容，\\2内容代表提取末尾数字)（将@改为\\([0-9]+\\)也是可以的）   1 2 3 4 5 6  .\\(.*[^0-9]\\)@ (\\1[\\2]), .pci_req0 (pci_req[0]), .pci_req1 (pci_req[1]), .pci_req2 (pci_req[2]), .pci_req3 (pci_req[3]),   AUTOWIRE 的使用 顶层实例化时，需要将连线进行声明， AUTOWIRE 可以完成此项任务。 AUTOWIRE 将声明所有子模块输出的连接线。这对于在两个子模块之间互连但未在顶部模块中使用的信号特别有用。\n1 2 3 4 5 6 7 8 9  module top (o,i) output o; input i; /*AUTOWIRE*/ inst inst (/*AUTOINST*/); other other (/*AUTOINST*/); endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module ex_wire (o,i) output o; input i; /*AUTOWIRE*/ // Beginning of automatic wires  wire [31:0] ins2oth; // From inst of inst.v  wire [31:0] oth2ins; // From other of other.v  // End of automatics  inst inst (/*AUTOINST*/ // Outputs  .ins2oth (ins2oth[31:0]), .o (o), // Inputs  .oth2ins (oth2ins[31:0]), .i (i)); other other (/*AUTOINST*/ // Outputs  .oth2ins (oth2ins[31:0]), // Inputs  .ins2oth (ins2oth[31:0]), .i (i)); endmodule   AUTOREG的使用 如果模块输出来自寄存器，则需要将信号声明为寄存器和输出端口。 AUTOREG 将完成输出信号的寄存器声明，并且如果输出来自非寄存器，则不会添加reg声明。\n1 2 3 4 5 6 7 8  module ex_reg (o,i) output o; input i; /*AUTOREG*/ always o = i; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11  module ex_reg (o,i) output o; input i; /*AUTOREG*/ // Beginning of automatic regs  reg o; // End of automatics  always o = i; endmodule   AUTOINPUT、AUTOOUTPUT的使用 在top层中，一般只有子模块的例化，没有任何其他粘合逻辑，这也是最期望的。这时top层通过 AUTOWIRE 声明了子模块的输出连线， AUTOINST 实现了子模块的实例化，其余未声明的信号，就是top模块的输入输出信号，我们可以通过 AUTOINPUT AUTOOUTPUT 完成输入输出信号的声明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module top_md(/*AUTOARG*/); /*AUTOINPUT*/ /*AUTOOUTPUT*/ /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/); endmodule // top_md  module sub_md(/*AUTOARG*/); input din_a; input [1:0] din_b; output [2:0] dout_a; assign dout_a[2:0] = {din_b,din_a}; endmodule // sub_md   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  module top_md(/*AUTOARG*/ // Outputs dout_a, // Inputs din_b, din_a ); /*AUTOINPUT*/ // Beginning of automatic inputs (from unused autoinst inputs) input din_a; // To i_sub_md112 of sub_md.v input [1:0] din_b; // To i_sub_md112 of sub_md.v // End of automatics /*AUTOOUTPUT*/ // Beginning of automatic outputs (from unused autoinst outputs) output [2:0] dout_a; // From i_sub_md112 of sub_md.v // End of automatics  /*AUTOREG*/ /*AUTOWIRE*/ sub_md i_sub_md112(/*AUTOINST*/ // Outputs  .dout_a (dout_a[2:0]), // Inputs  .din_a (din_a), .din_b (din_b[1:0])); endmodule // top_md   AUTORESET的使用 寄存器类型的变量往往需要赋初值。描述时序逻辑的always时，最好对复位条件下进行寄存器变量的初始化；描述组合逻辑的always时，最好对寄存器变量赋缺省值，这样不会产生latch。对于多信号的always语句，手动添加不仅费时，而且容易出错，此时我们可以使用 AUTORESET 自动完成。这里默认初始化赋值为0，如需其他值，需要将其手动添加到 AUTORESET 之前，AUTO不会对其重复添加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  reg dout_a; reg [1:0] dout_b; reg [2:0] dout_c; reg dout_x; reg [1:0] dout_y; reg [2:0] dout_z; always@(*) /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_a = 1\u0026#39;h0; dout_b = 2\u0026#39;h0; dout_c = 3\u0026#39;h0; // End of automatics if (sig1==1\u0026#39;b1)begin dout_a = din0; dout_b[1:0] = {2{din1}}; dout_c[2:0] = {3{din2}}; end always@(posedge clk or negedge rst_n) if (!rst_n)begin /*AUTORESET*/ // Beginning of autoreset for uninitialized flops  dout_x \u0026lt;= 1\u0026#39;h0; dout_y \u0026lt;= 2\u0026#39;h0; dout_z \u0026lt;= 3\u0026#39;h0; // End of automatics end else begin dout_x \u0026lt;= din0; dout_y[1:0] \u0026lt;= {2{din1}}; dout_z[2:0] \u0026lt;= {3{din2}}; end   注意，要先声明reg， AUTORESET 才会自动加上位宽，如果仍然不能自动将位宽加上，请在.emacs或.emacs.d/init.el文件添加以下设置：\n1  (setq verilog-auto-reset-widths t)   如果对时序逻辑always语句中的复位赋值需要添加延迟，请在.emacs或.emacs.d/init.el文件添加以下设置（注意：#1后必须有空格）：\n1  (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;)   AUTOREGINPUT的使用 在写测试激励时，往往将设计模块（也可以叫dut）作为一个子模块在testbench中进行实例化，这事需要定义一些reg类型的信号，作为dut的输入激励。 AUTOREGINPUT 可以帮你完成此任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  module testbench; /*AUTOREGINPUT*/ initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   快捷键 C-c C-a 之后，实现AUTO机制，快捷键 C-c C-k 可取消AUTO效果。AUTO效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  module testbench; /*AUTOREGINPUT*/ // Beginning of automatic reg inputs (for undeclared instantiated-module inputs) reg din1; // To i_dut of dut.v reg din2; // To i_dut of dut.v // End of automatics  initial begin #0 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b0; din2 =1\u0026#39;b1; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b0; end #10 begin din1 = 1\u0026#39;b1; din2 =1\u0026#39;b1; end end dut i_dut(/*AUTOINST*/ // Outputs  .dout (dout), // Inputs  .din1 (din1), .din2 (din2)); endmodule // testbench  module dut(/*AUTOARG*/ // Outputs dout, // Inputs din1, din2 ); input din1; input din2; output dout; assign dout = din1 \u0026amp; din2; endmodule   其他使用技巧 多目录问题（如果文件在同一目录，可忽略） 我们的项目工程会有很多代码，存放在不同的文件目录里，而Verilog-mode进行 AUTOINST 只会自动查找当前目录，这时候就会遇到问题了。那我们就来讲一讲verilog-mode是如何查找的吧。首先如果您在单文件中定义了多个模块，则会优先选择当前文件中的模块，然后在当前文件所在目录查找，如果定义了verilog-library-extensions，则继续查找附加扩展名的文件中查找模块，最后，它在verilog-library-directories中定义的每个目录中查找。 因此，如果您有一个顶层模块需要实例化其他目录的子模块，则需要告诉Verilog-Mode在哪些目录中查找，最好的方法是在每个需要它们的Verilog文件的末尾定义库变量：\n1 2 3 4 5  // Local Variables: // verilog-library-directories:(\u0026#34;.\u0026#34; \u0026#34;subdir\u0026#34; \u0026#34;subdir2\u0026#34;) // verilog-library-files:(\u0026#34;/some/path/technology.v\u0026#34; \u0026#34;/some/path/tech2.v\u0026#34;) // verilog-library-extensions:(\u0026#34;.v\u0026#34; \u0026#34;.h\u0026#34;) // End:   define问题（如果AUTO相关内容不涉及define，可忽略） 使用AUTOINST或AUTOSENSE时，有些场景中信号会带有define，这时候需要verilog-mode将define信息读进来，才可以正确完成AUTO功能。使用如下：\n1 2 3 4  // Local Variables: // eval:(verilog-read-defines) // eval:(verilog-read-defines \u0026#34;group_standard_includes.v\u0026#34;) // End:   第一行是读取当前文件中的define，第二行是读取define文件。\ninclude file问题（如果AUTO相关内容不涉及include，可忽略） 出于速度原因，Verilog-Mode不会自动读取include文件。这意味着include文件中定义的常量将不被作为AUTOSENSE的常量。解决方法如下：\n1 2 3  // Local Variables: // eval:(verilog-read-includes) // End:   verilog-mode 的AUTO使用方法 上文也看到了，可以通过打开emacs，使用快捷键来完成AUTO和取消AUTO，除此之外还可以当做脚本来处理，使用方法如下：\n1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   由此可见，我们可以通过脚本进行批量处理代码文件，完成AUTO机制，并且可以通过将不同目录文件复制其软连接到同一目录，再通过脚本实现AUTO机制，这样解决了不同目录对 AUTOINST 的影响。\nemacs的配置（关于verilog-mode） 以下是我的关于verilog-mode的emacs配置内容，“;;”代表注释符号。(所有设置参数均已添加注释，查看其他参数可以在verilog-mode模式下快捷键C-h m，查看verilog-mode.el)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  ;;my verilog mode config (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.vp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.vp file with verilog-mode (add-to-list \u0026#39;auto-mode-alist\u0026#39; (\u0026#34;\\\\.svp\\\\\u0026#39;\u0026#34; . verilog-mode)) ;;open *.svp file with verilog-mode (setq verilog-date-scientific-format t) ;;dates are written in scientific format (e.g. 1997/09/17) (setq-default indent-tabs-mode nil) ;;false tab indent mode (setq verilog-indent-level 4) ;;Indentation of Verilog statements with respect to containing block (setq verilog-indent-level-module 0) ;;Indentation of Module level Verilog statements (eg always, initial) (setq verilog-indent-level-declaration 0) ;;Indentation of declarations with respect to containing block (setq verilog-case-indent 4) ;;Indentation for case statements (setq verilog-cexp-indent 4) ;;Indentation of Verilog statements split across lines (setq verilog-indent-lists t) ;;Indentation of lists, look the under content. ;; \u0026#34;How to treat indenting items in a list. ;;If t (the default), indent as: ;;\talways @( posedge a or ;; reset ) begin ;; ;;If nil, treat as: ;;\talways @( posedge a or ;;\treset ) begin\u0026#34; (setq verilog-indent-level-behavioral 4) ;;Absolute indentation of first begin in a task or function block (setq verilog-indent-level-directive 4) ;;Indentation to add to each level of \\\\=`ifdef declarations (setq verilog-auto-indent-on-newline t) ;;Non-nil means automatically indent line after newline (setq verilog-tab-always-indent t) ;;Non-nil means TAB should always re-indent the current line. ;;A nil value means TAB will only reindent when at the beginning of the line. (setq verilog-indent-begin-after-if t) ;;Non-nil means indent begin statements following if, else, while, etc. Otherwise, line them up. (setq verilog-auto-newline t) ;;Non-nil means automatically newline after semicolons and the punctuation mark after an end (setq verilog-auto-endcomments t) ;;Non-nil means a comment /* ... */ is set after the ends which ends cases, tasks, functions and modules. The type and name of the object will be set between the braces. (setq verilog-auto-reset-widths t) ;;True means AUTORESET should determine the width of signals (setq verilog-assignment-delay \u0026#34;#1 \u0026#34;) ;;Text used for delays in delayed assignments. Add a trailing space if set (setq verilog-auto-lineup \u0026#39;all) ;; ;; \u0026#34;Type of statements to lineup across multiple lines. ;;If `all\u0026#39; is selected, then all line ups described below are done. ;; ;;If `declarations\u0026#39;, then just declarations are lined up with any ;;preceding declarations, taking into account widths and the like, ;;so or example the code: ;;\treg [31:0] a; ;;\treg b; ;;would become ;;\treg [31:0] a; ;;\treg b; ;; ;;If `assignment\u0026#39;, then assignments are lined up with any preceding ;;assignments, so for example the code ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f; ;;would become ;;\ta_long_variable \u0026lt;= b + c; ;;\td = e + f;   有些参数目前我也不清楚具体用法和含义，如有其他好用的配置参数，欢迎推荐给我。\n忘了C-c C-a怎么办 有时候我们会忘记 C-c C-a ，显然这样会导致代码错误，如果是全部未实现AUTO还好，很容易及时发现，但是如果是在修改代码，并且仅仅是很小的改动，在功能仿真时不能及时发现，那就成了隐藏的bug，后果还是很严重的。比如组合逻辑always块的 AUTORESET ，功能仿真时并不容易被发现。 所以为了防止忘记 C-c C-a ，这里提供两种方案：\n 将verilog-auto与保存文件的 C-x C-s 绑定（注意，只有使用 C-x C-s 才有效，功能栏点击保存不会实现AUTO），请将以下代码添加到.emacs或.emacs.d/init.el（只在verilog-mode下有效，不会影响其他模式）   1 2 3 4 5 6 7  (add-hook \u0026#39;verilog-mode-hook \u0026#39;(lambda () (local-set-key (kbd \u0026#34;C-x C-s\u0026#34;) \u0026#39;(lambda () (interactive) (verilog-auto) (save-buffer)))))    使用脚本处理，将自己的源文件通过脚本处理后生成新的文件，比如我将原始文件命名为 *.vp 或 *.svp，最终处理后的文件为 *.v 或 *.sv，这样可以避免忘记完成verilog-auto。以脚本的形式进行处理还有一个好处，那就是对vim以及其他编辑器使用者比较友好，因为并非所有开发者都使用emacs。脚本处理命令如下：   1  emacs --batch --no-site-file -l verilog-mode.el filename.v -f verilog-auto -f save-buffer   快捷键插入内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  C-c C-t a Insert an always @(AS) begin .. end block. C-c C-t b Insert a begin .. end block. C-c C-t c Insert a case block, prompting for details. C-c C-t f Insert a for (...) begin .. end block, prompting for details. C-c C-t g Insert a generate .. endgenerate block. C-c C-t h Insert a header block at the top of file. C-c C-t i Insert an initial begin .. end block. C-c C-t j Insert a fork begin .. end .. join block. C-c C-t m Insert a module .. (/*AUTOARG*/);.. endmodule block. C-c C-t o Insert an OVM Class block. C-c C-t u Insert an UVM Object block. C-c C-t U Insert an UVM Component block. C-c C-t p Insert a primitive .. (.. );.. endprimitive block. C-c C-t r Insert a repeat (..) begin .. end block. C-c C-t s Insert a specify .. endspecify block. C-c C-t t Insert a task .. begin .. end endtask block. C-c C-t w Insert a while (...) begin .. end block, prompting for details. C-c C-t x Insert a casex (...) item: begin.. end endcase block, prompting for details. C-c C-t z Insert a casez (...) item: begin.. end endcase block, prompting for details. C-c C-t ? Insert an if (..) begin .. end block. C-c C-t : Insert an else if (..) begin .. end block. C-c C-t / Insert a comment block. C-c C-t A Insert an assign .. = ..; statement. C-c C-t F Insert a function .. begin .. end endfunction block. C-c C-t I Insert an input declaration, prompting for details. C-c C-t O Insert an output declaration, prompting for details. C-c C-t S Insert a state machine definition, prompting for details. C-c C-t = Insert an inout declaration, prompting for details. C-c C-t W Insert a wire declaration, prompting for details. C-c C-t R Insert a register declaration, prompting for details. C-c C-t D Define signal under point as a register at the top of the modul   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":43,"section":"docs","tags":["emacs","verilog"],"title":"Emacs verilog-mode 的使用","uri":"https://wenhui.space/zh/docs/about_emacs/verilog_mode_useguide.html"},{"content":"本文 主要记录了emacs使用过程中的小技巧。\n   版本 说明     0.1 初版发布   0.2 添加参考链接    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  参考  Emacs Wiki 子龙山人的emacs学习记录  文本编辑相关 Emacs 中的批量查找与替换 Emacs 有很强大的批量查找与替换功能。操作如下：\n 切换到源码项目目录，然后 M-x find-dired ，输入 . ，表示查找当前目录下的所有文件，回车，在输入 -name \u0026ldquo;.el\u0026rdquo;* ，表示只查找.el文件。再次回车后，Emacs 会打开一个缓冲区显示出项目中所有的.el后缀的文件 在显示所有查找文件的缓存页面，可以直接按t来标记所有文件，或者按m来一个一个的进行标记，如果标记错误了，可以按u来取消标记 标记完所有要进行查找替换的文件之后按Q快捷键，使用正则表达式来查找与替换被标记文件中的内容，第一次需要输入的是被查找项，回车之后在输入替换项，之后在回车，Emacs 会逐个打开被标记的文件，然后用高亮显示被正则搜索到的要替换的语句，逐个的问你是否要进行替换 显示的高亮替换项，你可以按y来确认替换，也可以按n取消替换，或者按!强制不提示而进行所有替换 替换完成后 C-x s 保存所有修改项，会逐个询问是否保存，yes代表保存，no代表不保存，！代表强制保存所有  Emacs 的查找与替换功能看似比其他软件繁琐与麻烦许多，实际上这是非常稳健的操作方式，查找与替换的过程非常透明化，你可以详细的看到要被替换的项，仔细谨慎的进行确认替换，之间也有非常多的机会来中断查找替换过程，来恢复文件中被错误替换的内容。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":44,"section":"docs","tags":["emacs"],"title":"emacs的使用技巧记录","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_use_tips.html"},{"content":"本文 主要介绍了为firefox安装插件的小技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  安装插件  打开firefox浏览器 打开菜单栏（右侧三杠图标），选择附加组件，打开附加组件管理器（也可以使用快捷键Ctrl-Shift-A） 附加组件管理器可以搜索、添加和删除插件  解决安装插件时浏览器无反应问题 有时候进入插件页面，点击 添加到Firefox 之后无反应，具体原因不知道，不过经过尝试，可以右键选择 在新建窗口打开链接 ，问题解决。\n推荐几个我使用的插件  侧边翻译：可以将选中的内容快速翻译，也可以选择有道或谷歌翻译整页（谷歌翻译好像不太行，不知道原因） 网页截图 Bitwarden（免费密码管理器，妈妈再也不用担心我忘记密码了） OneTab（以列表形式显示标签页，解决功能栏标签繁杂的问题）  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":45,"section":"docs","tags":["firefox"],"title":"为firefox安装插件","uri":"https://wenhui.space/zh/docs/install_software/install_plugins_for_firefox.html"},{"content":"本文 主要介绍一款开源密码管理工具 Bitwarden 。\n   版本 说明     0.1 初版发布   0.2 更正 验证器秘钥（TOTP） 的理解    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  什么是Bitwarden？ Bitwarden是一款开源的密码管理器，所谓密码管理器，就是将所有密码交由工具管理，我们只需要记住主密码就行，生成密码、记忆密码和填写密码都由工具来自动完成。类似于此功能的还有PassWord、KeePass 、Lastpass等等，不过他们都是付费的，而Bitwarden是开源免费的。关于Bitwarden的详细信息可查看Bitwarden官网。\n这里简单列出个人认为Bitwarden的优点：\n 这是一款免费、开源的密码管理软件 支持 Windows、Mac、Linux 操作系统 通过插件可支持主流的浏览器，如google和firefox 提供苹果、安卓的原生应用 支持浏览器自动填写以及二次验证 可以使用官方的免费服务，也可以自建服务器  关于安全性 就安全性而言，这些密码管理工具采用的是高强度 AES-256 加密算法，想要破解几乎是不可能的事。也有人会担心把密码放在别人的服务器上不安全？个人认为是安全的，它们的加密方法，是把帐号和主密码通过算法得到一个值，然后用这个值去加密用户的各个密码，最后储存在服务器上。而加密解密都需要在本地进行，也就是说，黑客即使攻破了服务器，但无法破解密码数据库，除了把你的密码数据库删除外，其他什么也做不了。\n不过还有一句话，互联网没有绝对的安全，所以我一般把各个密码分级。\n 三级： 一般社交平台账户密码和其他应用账户密码 二级： 邮箱以及其他带有注册性的账户密码 一级： 带有支付性的账户密码 特级： 支付密码  三级交由密码工具管理，二级和一级由密码工具加个人前缀码组合，特级只放在脑子里。\n安装Bitwarden Bitwarden可以网页访问，可以安装浏览器插件，也可以下载应用程序。下载应用程序和网页登录可以选择进入Bitwarden官网，安装浏览器插件这里以firefox为例，参考我另一篇帖子 为firefox安装插件。\n如何使用Bitwarden?  打开firefox浏览器，点击插件Bitwarden，注册登录，注意， 一定要记住主密码，一定要记住主密码，一定要记住主密码 添加项目，项目内容有名称、用户名、密码、验证器密钥、网址、文件夹、笔记等等，其中网址会根据当前打开网页自动添加，密码可以选择工具生成也可以自动输入，验证器密钥TOTP（与二次验证相关，不开启二次验证可忽略），文件夹可以根据个人需求创建和选择，笔记以及其他根据个人需求填写，也可不写。 打开网页，Bitwarden插件会自动识别，打开Bitwarden，可以选择自动填充也可以手动复制  什么是 验证器秘钥（TOTP） 验证器秘钥与二次验证相关，二次验证就像除了密码之外还需要短信验证码一样，这里的两步验证也是相当于给帐号多加一把“锁”(多一步的验证)，在输入正确的账号密码之后，用户同样还需要额外输入一个每 30 秒自动变化一次的 6 位数字「二步验证码」才能完成登录。这里的验证器秘钥通过基于时间和加密算法生成“每 30 秒变化一次的 6 位数字验证码”，也叫做 TOTP (Time-Based One-time Password) 或 OTP 一次性密码。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":46,"section":"docs","tags":["firefox"],"title":"Bitwarden的安装","uri":"https://wenhui.space/zh/docs/install_software/install_bitwarden.html"},{"content":"本文 主要对日常linux系统使用中的一些技巧进行记录。\n   版本 说明     0.1 初版发布   0.2 添加VNC和分辨率设置    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  使用命令记录 查看系统信息  查看系统版本： “cat /etc/issue” 查看内核版本（具体可以查看etc目录下关于系统和内核的文件内容）：  RedHat内核： “cat /etc/redhat-release” Debian内核： “cat /etc/debian_version”    查看命令是否存在  which perl alias print_declare  head和tail  读取前10行： head -n 10 file 读取后10行： tail -n 10 file 读取前200字符： head -c 200 file 读取前200x512字符： head -c 200b file（200k=200x1024） 读取动态文件末尾，适合动态输出的log文件：tail -f file.log 读取中间内容，如读取101行到150行内容： cat file | head -n 150 | tail -n 50  批量重命名rename  替换单个字符（小写变大写）： rename \u0026lsquo;y/a-z/A-Z/\u0026rsquo; * （替换表达式中y代表替换字符一一对应，即a替换为A，b替换为B\u0026hellip; 最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件） 替换特定字符串： rename \u0026lsquo;s/abc/123/\u0026rsquo; * （替换表达式中s代表特定字符串替换，即abc替换为123，最后*代表当前目录下所有文件，也可以*.v，代表所有带.v后缀的文件）  TODO tc替换；sort排序； 安装工具记录 安装tree命令 tree命令在deepin系统中没有自带，需要手动安装，此命令可以通过代码显示方式列出文件结构，在有些编写文档需对文件结构进行描述时很有用（如何使用可以通过man tree查看），安装命令如下：\n1  sudo apt install tree   系统设置记录 VNC使用笔记  开启VNC：第一步在终端通过ssh登录用户，win系统也可以使用putty；第二步开启VNC服务，会显示开通的端口号，根据此端口可以使用ip加端口号进行VNC登录；第三步设置VNC登录密码。（每个用户可以开启多个端口，另外，VNCSERVER的大部分配置文件及日志文件都在用户home目录下.vnc目录下）   1 2 3  ssh username@ip_addr vncserver vncpasswd    开启指定端口的vnc（注意冒号前有空格，若该端口已占用，VNC会自动创建新的端口）   1  vncserver :2    开启指定分辨率的vnc   1  vncserver -geometry 1920x1080    查看自己已开启的VNC端口   1  vncserver -list    杀死已开启的VNC端口（冒号前有空格）   1  vncserver -kill :2   修改分辨率 选择系统提供的分辨率选项： 菜单栏系统 -\u0026gt; 首选项 -\u0026gt; 硬件 -\u0026gt; 显示器 -\u0026gt; 选择分辨率\n选择自定义分辨率：  生成自定义的分辨率modeline   1 2 3 4  cvt 1600 850 60 #宽 高 刷新频率 #显示如下 # 1600x850 59.92 Hz (CVT) hsync: 52.91 kHz; pclk: 111.75 MHz Modeline \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    xrandr创建新的mode   1  xrandr --newmode \u0026#34;1600x850_60.00\u0026#34; 111.75 1600 1696 1856 2112 850 853 863 883 -hsync +vsync    查看xrandr输出设备（也包含可使用的分辨率）   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  xrandr #显示如下，×代表当前使用的分辨率 Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192 eDP-1 connected primary 1366x768+0+0 (normal left inverted right x axis y axis) 277mm x 156mm 1366x768 60.00*+ 48.00 1360x768 59.80 59.96 1024x768 60.04 60.00 960x720 60.00 928x696 60.05 896x672 60.01 960x600 60.00 960x540 59.99 800x600 60.00 60.32 56.25 840x525 60.01 59.88 800x512 60.17 700x525 59.98 640x512 60.02 720x450 59.89 640x480 60.00 59.94 680x384 59.80 59.96 576x432 60.06 512x384 60.00 400x300 60.32 56.34 320x240 60.05 DP-1 disconnected (normal left inverted right x axis y axis) HDMI-1 disconnected (normal left inverted right x axis y axis) DP-2 disconnected (normal left inverted right x axis y axis) HDMI-2 disconnected (normal left inverted right x axis y axis)    选择输出设备添加自定义分辨率mode   1  xrandr --addmode DP-1 1600x850_60.00    自定义的分辨率已经添加到系统可选项，可以回到上文的选择系统提供的分辨率选项进行设置 其他说明：首先系统提供的分辨率可选项已经很多，并且多数设备系统可以自适应，以上的添加自定义分辨率的操作不常用到  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":47,"section":"docs","tags":null,"title":"Linux常用操作记录","uri":"https://wenhui.space/zh/docs/about_linux/note_of_linux.html"},{"content":"本文 主要介绍如何使用org-mode和ox-hugo写博客。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58 emacs版本：Linux GNU Emacs 26.3  参考  ox-hugo的使用手册 Org to Markdown for Hugo 使用emacs中的包管理器安装插件 Blogging with org-mode and ox-hugo  声明 当你看到此帖子，我必须要声明一下，如果你是非emacs用户，并不强烈推荐你使用emacs org-mode来写博客，除非你有足够的兴趣了解和学习emacs。\n什么是org-mode？什么是ox-hugo？  org-mode是文本编辑软件Emacs的一种支持内容分级显示的编辑模式，是一个基于快速高效的文本方式来实现做笔记、管理待办事项（TODO list）以及做项目计划的模式。本人使用感受最好的就是大纲显示模式。 ox-hugo是emacs的一个插件，可以将org格式文件转换为hugo识别的markdown格式文件。  安装emacs和安装ox-hugo插件 安装emacs就不介绍了，可参考我的另一篇帖子 emacs的安装。\n这里主要介绍一下如何安装ox-hugo插件。给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   emacs的基础使用 emacs的使用可以简单了解一下emacs启动页面的使用手册，简单了解就可以上手了。这里把最基础的使用粘贴出来。\nEmacs的快捷键都是绑定在ctrl和alt上的，例如C-x就是ctrl+x，M-x就是alt+x。\n 文件操作  C-x C-f 打开文件 C-x C-s 保存文件 C-x C-c 退出Emacs   编辑操作  C-f 前进一个字符（方向键也可以） C-b 后退一个字符（方向键也可以） C-a 移到行首 C-e 移到行尾 C-p 后退一行（方向键也可以） C-n 前进一行（方向键也可以） M-g M-g 跳到指定行 M-\u0026lt; 文档头部（配合Shift键） M-\u0026gt; 文档尾部（配合Shift键） C-d 删除一个字符（delete键也可以） C-k 删除一行 C-Shift-空格 标记开始区域 C-w 删除标记区域 C-y 粘贴删除的内容，注意：C-y可以粘贴连续C-k删除的内容；先按C-y，然后按M-y可以选择粘贴被删除的内容 M-w 复制标记区域 C-/ or C-x u 撤消操作   窗口操作  C-x 0 关闭本窗口 C-x 1 只留下一个窗口 C-x 2 垂直均分窗口 C-x 3 水平均分窗口 C-x o 切换到别的窗口 C-x s 保存所有窗口的缓冲 C-x b 选择当前窗口的缓冲区   缓冲区列表操作  C-x C-b 打开缓冲区列表 C-x k 关闭缓冲区   搜索模式  C-s 向前搜索 C-s 查找下一个 ENTER 停止搜索 C-r 反向搜索 C-s C-w 以光标所在位置的字为关键字搜索 M-% (配合Shift键) 替换， 输入y表示同意此处替换，否则输入n，全部替换使用！   帮助  C-h t 入门指南 C-h ? 查看帮助列表    org-mode和ox-hugo写博客 ox-hugo 支持两种方式来管理 org 格式的博客文章，一种是多个文章放在同一个 org 文件里，另一种是对不同的文章使用独立的 org 文件。本人喜欢第一种方式，我会将同一类的博客文章放在同一个org文件来管理。如下：\n  emacs org mode    文件头部说明  HUGO_BASE_DIR：这里是博客的根目录，因为我的org文件放在博客根目录下的 orgposts ，所以这里博客的根目录就是 “../” ，也就是本目录的上一层目录 HUGO_SECTION：生成的markdown文件的位置，比如 “./post/create_blog_site/” 就会将markdown文件生成在博客根目录下的 “content/post/create_blog_site/” hugo_auto_set_lastmod：最后修改的时间，也就是org转markdown时的时间，t的话会自动生成，也可以选择f，这个时间在jane主题也就是文章末的最后更新时间 hugo_custom_front_matter：这里是markdown文件头部参数的设置，比如toc，是否开启目录，不开启的话浏览时无目录显示，为了阅读方便建议开启 hugo_categories：分类名称，我是将同一类博客放在了一个org文件，这里就是分类名，然后每个subtree就是一个博客，会生成一个markdown文件 author:nil：这里是作者名称，在hugo的配置文件中已经配置了作者名称，这里将作者名称的控制关掉   1 2 3 4 5 6 7  #+HUGO_BASE_DIR: ../ #+HUGO_SECTION: ./post/create_blog_site/ #+hugo_auto_set_lastmod: t #+hugo_custom_front_matter: :toc true #+hugo_categories: 搭建博客站点 #+OPTIONS: author:nil   subtree 下面是一个subtree的内容(为了防止转义，前面都加了#号，实际中无#号)，下面一行一行介绍：\n 第一行是一级标题，这里也就是一个subtree，也是文章标题，后面冒号间的文字是标签，对应markdown文件中的tag，注意，冒号需要为英文符号，也可以使用 C-c C-c 快捷键输入tag；标题前的 DONE 表示完成状态，除此之外还有 TODO 状态，对应markdown文件中的 draft ， TODO 状态时，会认为是草稿，不会发布到站点，还要注意的是，状态不是手动敲上去的，而是光标放在标题行，通过Shift和左右键切换 第二行是文章创建的时间，对应markdown文件的date 第三四五行，EXPORT_FILE_NAME是输出markdown文件的名称，这里是subtree的属性描述，可使用参数应该还有很多，不过暂时没了解 最后就是博客内容了，二级标题和三级标题   1 2 3 4 5 6 7  #* DONE title_level1 :hugo:emacs: # CLOSED: \u0026lt;2019-09-13 五 14:22\u0026gt; # :PROPERTIES: # :EXPORT_FILE_NAME: Thinkpad_S2 # :END: #** title_level2 #*** title_level3   特殊需求  外链：可以使用 C-c C-l (这里是小写L)快捷键，输入链接和链接说明 图片：官方提供的方式如下(这里为了防止转义使用的小括号，实际为英文大括号)：   1  ((\u0026lt;figure src=\u0026#34;/image/cook/image0.jpg\u0026#34; title=\u0026#34;图片\u0026#34; \u0026gt;))   由于我还是希望对图片显示大小和位置能够控制，也许有其他方法还不知道，不过在这里写一个html格式的图片引用，能够实现我想要的效果，方式如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;    subtree中设置分类，如下，@后是分类，:后是标签（为了防止转义，添加了#号，实际中无#号）   1  # :@笔记:昨天:今天:明天:    脚注：在需要插入脚注的地方写下 “【fn:1】” ，在文章末尾添加脚注的说明 “【fn:1】 脚注说明” ，这里为了防止转义使用了中文符号，实际中记得使用英文符号  org文件转为markdown文件  将所有subtree都转为对应的Hugo markdown文件，快捷键 C-c C-e H A ，其中 C-c C-e 是导出快捷键，可选的有很多，比如h代表html，l代表laTex等，H代表Hugo，后面的A代表All（快捷键操作过程中会有提示，详细信息可以看提示信息） 将某subtree转为对应的Hugo markdown文件，首先光标移至对应的subtree，再通过快捷键 C-c C-e H H ，其中 C-c C-e 是导出快捷键，H代表Hugo，后面的H代表subtree（快捷键操作过程中会有提示，详细信息可以看提示信息） 其他说明：content不存在对应的目录也没关系，ox-hugo会自动创建  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":48,"section":"docs","tags":["hugo","emacs"],"title":"使用org-mode和ox-hugo写博客","uri":"https://wenhui.space/zh/docs/create_blog_site/org_mode_and_ox_hugo.html"},{"content":"本文 主要介绍如何为自己的博客自定义域名。\n   版本 说明     0.1 初版发布   0.2 解决push后自定义域名失效问题    背景  需要购买域名，我使用的是阿里云  参考  GitHub Pages 绑定来自阿里云的域名 个人独立博客如何与阿里云域名绑定  准备域名 购买域名 点击进入阿里云域名注册页面，选择自己喜欢的域名，点击查询，看一下是否被注册以及售价，我使用的是 wenhui.space ，售价十年179元，还可以。当然购买之前要先登录账户，这里使用支付宝登录即可，登录后需要实名认证，可以选择支付宝快速完成实名认证。选择心仪的域名，进行购买。\n完成域名持有者认证 需要上传个人身份证正面照片，提交认证，一般当天可以认证完成。\n域名解析 找到github page的IP地址 需要ping一下自己的github page网址，如下图，红色部分就是IP地址。\n  ping github IP    配置阿里云域名解析 登录你的阿里云账号,进入管理控制台,在左侧菜单找到 域名与网站(万网), 然后进入你的阿里云的解析域名列表，选择你想要解析的域名，点击后面的解析。输入如下图内容：\n  ping github IP    说明：  记录类型  A记录： 将域名指向一个IPv4地址（例如：8.8.8.8） CNAME：将域名指向另一个域名（例如www.qcloud.com）   主机记录  www： 解析后的域名为www.qcloud.com。 @： 直接解析主域名 qcloud.com。    配置github pages的custom domain 进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：\n     设置到这里,你就可以 通过你的域名访问你的博客啦!(可以适当等几分钟再使用新的网址访问自己的博客) 解决push后自定义域名失效问题 自定义域名失效是因为仓库中没有CNAME文件，该文件是指向你自定义域名的文件。\n 创建CNAME文件，打开终端，进入博客根目录，输入以下命令（替换为你自己的域名）：   1  echo www.wenhui.space \u0026gt;CNAME    修改issue.sh脚本，使其在每次上传public文件时，不会破坏CNAME，issue.sh如下：   1 2 3 4 5 6 7 8 9 10 11 12  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ cp ./CNAME ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":49,"section":"docs","tags":["hugo"],"title":"给自己的博客自定义域名","uri":"https://wenhui.space/zh/docs/create_blog_site/modify_url_for_blog.html"},{"content":"本文 主要介绍了一个hugo博客内容的使用技巧。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  插入图片 1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;/image/me.jpg\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; github新建仓库 \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   这里显示的是插入本地图片，图片位置放在博客站点根目录下的static文件内，上文所示路径对应文件存放路径为 “my_blog/static/image/me.jpg” ，这里可以对图片大小，显示位置，图片标题进行设置。也可以将相对路径改为网址全路径，也就是引用网上图片，这时候需要图床工具，PicGo是一个不错的选择，可参考我的另一篇帖子PicGo的安装。\n注意：static目录下的所有文件名不要使用下划线，否则会导致图片索引错误，可以使用 \u0026ldquo;-\u0026rdquo; 连字符。\n其他 我相信还有其他使用技巧，待后续补充，如果你有好的用法，欢迎推荐。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":50,"section":"docs","tags":["hugo"],"title":"hugo博客内容的使用技巧","uri":"https://wenhui.space/zh/docs/create_blog_site/hugo_content_tips.html"},{"content":"本文 主要介绍了如何将hugo创建的博客站点部署到github。\n   版本 说明     0.1 初版发布   0.2 修改issue.sh脚本    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  git的安装与介绍 请参考我的另一篇帖子git的安装。\n部署过程 在github创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    在这里要创建两个仓库，一个私有仓库，名字自定义，可以为“my\\_blog”，用来存放博客站点文件；另一个公共仓库，名字为 **username.github.io** ，记住，一定为 **username.github.io** (username替换为你的用户名），后面启用 **github page** 时会解释为什么如此命名。 克隆仓库 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。\n启用github page功能 GitHub Pages 是一个静态网站托管服务，简单说就是他可以实现创建个人网页。我们需要给名为 username.github.io 的仓库启用github page功能，需要以下几步：\n 首先空仓库是不能启用page功能的，你需要添加一个文件（无所谓什么文件，可以写个readme），通过以下git命令，上传到远程仓库。这里可能需要输入账户密码，可以使用 \u0026quot;git config \u0026ndash;global credential.helper store\u0026quot; ，避免重复输入账户密码。   1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push    打开github，进入名为 username.github.io 的仓库，然后点击 settings ，拉到最下面会看到 Github Pages ，此时关于github page是 None 状态，将其选择为 master branch （如果是私有仓库是无法开通的，所以创建时我们选择了公共仓库），如果有显示 “Your site is published at https://username.github.io/” ，就是启动了page功能，你可以使用此网址访问你的个人网页了，只不过目前什么内容都没有。这里对page的网址说明一下，如果仓库名为 username.github.io ，那网址就为 “https://username.github.io/” ，如果仓库名为其他，则网址中会带有仓库名，也就是 “https://username.github.io/reponame/” ，如果是这样，使用hugo时，本地相对路径索引的图片上传后通过网页是无法加载的，hugo生成的图片链接没有仓库名，这里是经过试错得到结论。  生成博客站点静态文件并上传到远程仓库  打开终端，进入博客站点根目录 my_blog ，使用 “hugo server” 命令预览博客，无问题的话输入 \u0026ldquo;hugo\u0026rdquo; 命令，生成博客站点静态文件 public ，我们将 public 内文件全部粘贴到 username.github.io 仓库，并上传到远程仓库，命令参考上文。 打开浏览器，输入开启github page时提示的网址，就看到你的个人博客网页了，到此部署成功。 我们也可以写一个脚本方便处理，我起名为 issue.sh ，如下：   1 2 3 4 5 6 7 8 9 10 11  #!/bin/bash  hugo rm -rf ../cao-arvin.github.io/* mv ./public/* ../cao-arvin.github.io/ rm -rf ./public cd ../cao-arvin.github.io/ git add . git commit -m \u0026#34;rebuilding site $(date)\u0026#34; git push -u origin +master cd -   维护自己的博客内容和环境 最初我们创建了两个仓库，目的就是一个开启page功能，将博客静态文件发布到网络，另一个就是维护博客内容和环境文件。\n 复制仓库的http链接，使用 “git clone http\u0026hellip;” 命令，将创建的仓库克隆到本地，如果是新仓库的话，会提示你 似乎你克隆了一个空仓库 ，可以不用管。 将博客站点根目录my_blog中的所有文件复制到克隆的仓库文件（仓库名也可以为my_blog） 这里themes中的jane本身是一个git仓库，我们可以不用上传到远程仓库，生成的public是中间文件也不需要上传到远程仓库，所以添加一个 .gitignore 文件，git可以自动忽略 .gitignore 列出的文件，不上传到远程仓库。终端中进入博客站点根目录，输入如下命令即可：   1 2  echo themes \u0026gt;\u0026gt;.gitignore echo public \u0026gt;\u0026gt;.gitignore    将博客内容和环境文件上传之远程仓库，命令参考上文。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":51,"section":"docs","tags":["hugo"],"title":"将hugo博客部署到github","uri":"https://wenhui.space/zh/docs/create_blog_site/hugo_deploy_to_github.html"},{"content":"牛人博客   贤民的比特记忆： Hugo jane主题作者 \u0026amp; 丽江白沙那里国际青年旅舍的掌柜 \u0026amp; emacs使用者\n  子龙山人：emacs大牛\n  骏的世界：CPU从业者 \u0026amp; Linux强人 \u0026amp; IC验证\n  ManateeLazyCat：emacs elisp大牛 \u0026amp; Deepin and Emacs 开源贡献者\n  学习网站   在线EDA仿真网站\n  在线Verilog仿真网站\n  学习systemverilog和UVM的好网站\n  在线编程学习网站：实验楼\n  ","description":"","id":52,"section":"","tags":null,"title":"Links","uri":"https://wenhui.space/zh/links.html"},{"content":"本文 主要介绍了markdown基本语法。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  什么是markdown？ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。可能听起来有些抽象，简单来说就是纯文本编辑方式，依据特殊语法，经过工具渲染，可以达到很漂亮的显示效果，除此之外还能支持更多复杂功能，比如数学符号的显示等等。\nMarkdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此很多博客平台都支持markdown，比如简书和CSDN，对markdown都有很好的支持，有些网站的评论窗口也支持markdown。目前markdown因为简单易用的特点，已经被广泛使用。不过各平台对markdown的支持情况也不太统一，所以存在部分兼容问题，不过不用担心，常用语法还是一致的。\n语法介绍 标题 注意，中间有空格。\n1 2 3 4 5 6  # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题   字体  加粗：将要加粗的文字左右分别用**号包起来，如“**粗体**” （好像用下划线包起来也可以，如“__粗体__”） 斜体：将要倾斜的文字左右分别用*号包起来，如“*斜体*” （好像用下划线包起来也可以，如“_斜体_”） 斜体加粗：将要倾斜和加粗的文字左右分别用三个*号包起来，如“***粗斜体***” （好像用下划线包起来也可以，如“___粗斜体___”） 删除线：将要加删除线的文字左右分别用两个~~号包起来，如“删除线” 高亮：将要加高亮的文字左右分别用两个==号包起来，如“==高亮==”  分割线 三个或者三个以上的 - 或者 * 都可以。\n1  ---   图片 图片名称就是显示在图片下面的文字，相当于对图片内容的解释。图片标题就是当鼠标移到图片上时显示的内容。图片标题可加可不加。\n1  ![图片名称](图片网址 \u0026#39;\u0026#39;图片标题\u0026#39;\u0026#39;)   当然也可以使用html格式，这里添加了对图片的大小和显示位置做了控制，如下：\n1 2 3 4  \u0026lt;center\u0026gt; \u0026lt;img width=\u0026#34;800\u0026#34; src=\u0026#34;图片网址\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;color:darkorange;\u0026#34;\u0026gt; \u0026lt;b\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt;   超链接 title可不加\n1 2  [超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) [百度](http://baidu.com)   列表  无序列表(注意，符号与内容间有空格)   1 2  - 列表内容 + 列表内容    有序列表(注意，符号与内容间有空格)   1 2  1. 列表内容 2. 列表内容    列表嵌套   1 2 3 4  - 一级无序列表内容 1. 二级有序列表内容 2. 二级有序列表内容 3. 二级有序列表内容   表格 第二行分割表头和内容，其中“-”有一个就行，也可以为了对齐多加几个；文字默认左对齐，“-”两边加“:”表示文字居中，\u0026quot;-\u0026ldquo;右边加“:”表示文字右对齐。注意，符号为英文符号。\n1 2 3 4  |表头|表头|表头| |---|:--:|---:| |内容|内容|内容| |内容|内容|内容|   代码  单行代码，代码之间分别用一个反引号包起来   1  `代码内容`    多行代码，代码之间分别用三个反引号包起来   1 2 3 4 5  ``` 代码... 代码... 代码... ```   段落、换行、缩进 Markdown语法中，两个段落之间是用空白行分隔的，如果作为两个段落，编辑时请在中间加空白行，不过中间加即时多个空白行却只显示一个空白行，如果想加多个空白行，就要借助html的换行命令，如下；如果想首行缩进，需要输入全角空格，不过不建议使用，markdown是用空白行来区分段落的，而不是缩进。\n1  \u0026lt;br\u0026gt;   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":53,"section":"docs","tags":["markdown"],"title":"markdown语法","uri":"https://wenhui.space/zh/docs/create_blog_site/markdown.html"},{"content":"本文 主要介绍了如何下载和使用hugo。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  hugo官网 hugo中文文档  hugo的介绍和安装 可查看本站另一篇帖子 hugo的安装。\n快速使用 根据自己的摸索，保存了一个基于jane主题的基本使用框架，开箱及用，只需要在content目录下写markdown文件即可。查看我的百度网盘分享资源 链接：https://pan.baidu.com/s/1l4RU%5FJx-2XKI-pflL-a7zA 密码：pf03 。基于此框架你也可以根据个人需求，简单调整。\n使用hugo生成站点 使用Hugo生成站点，比如希望生成到当前目录，文件名为my_blog。打开终端，命令如下：\n1  hugo new site ./my_blog   这样就在当前目录下生成了初始站点 my_blog ，进去目录查看，其文件结构如下：\n├─archetypes ├─content ├─data ├─layouts ├─static ├─themes └─config.toml 这里对站点的几个文件介绍一下：\n archetypes：原型文件，里面存在一个markdown文件的模板，使用 “hugo new xx.md” 命令时会依据该模板创建markdown文件，我一般不使用 “hugo new” 命令，而是直接手动创建markdown文件，所以不关心模板 content：内容文件，所有的帖子都以markdown文件形式存在这里，hugo会自动索引，一般功能栏的 “关于” “友链” 等页面，我会存在content一级目录，其他帖子内容在content内另建post目录，而且根据不同分类可以在post内新建目录存储，hugo会自动层级索引，也就是只要在content内的markdown文件，hugo都能找到 data：这个目前还真不知道做什么的，但不影响使用，可暂不关心（如果有熟悉的可以帮忙解释一下） layouts：个人理解这里存放的应该是关于网站布局以及其他关于网站页面显示的文件（html），不过我们一般都会安装主题，所以这个可以不关心 static：静态文件，一般js(javascript)和css文件会存放在这里，这些文件主要是与博客网页显示相关的，我没这个需求，主要是也不懂，在这里我主要存放的就是博客中用到的图片了 themes：主题文件，可以寻找自己喜欢的主题，存放在这里，简单配置即可使用 config.toml：全局配置文件，博客站点所有的配置，都在此文件完成，最比如设置使用的主题  安装主题 hugo生成站点后，还不能正常使用，需要安装自己喜欢的主题，也叫皮肤。到hugo主题列表选择一款自己喜欢的主题，下载到themes目录下，每个主题都会有一个readme文件，介绍主题的特性和指导你如何使用主题。这里以我使用的主题为例，hugo-theme-jane，此主题是由贤民大哥开发的，可以先浏览一下他的主页 贤民的比特记忆，看一下效果。\n下载jane主题  进入jane主题github网址，点击 [Clone or download] ，选择 [Download Zip] ，通过网页下载压缩包，解压后放到themes目录下 通过git下载，打开终端，进入themes目录，输入以下命令(这个网址就是github中 [Clone or download] 栏显示的网址)：   1  git clone https://github.com/xianmin/hugo-theme-jane.git    通过我的百度网盘分享资源下载， 链接：https://pan.baidu.com/s/1xQJXLyNcI0Jbymrr9uZRGQ 密码：rhaw  测试体验  存放主题文件和更名：将下载的jane主题文件放到站点的themes目录下，并将文件名hugo-theme-jane改为jane（因为exampleSite中config.toml文件对主题的选择是jane，当然你也可以修改config.toml） 复制一些示例文本：打开终端，进入站点根目录 my_blog ，输入以下命令(如果content有自己的文件，请先备份，此命令会覆盖content)   1  cp -rf themes/jane/exampleSite/content ./    复制默认的站点设置：打开终端，进入站点根目录 my_blog ，输入以下命令(如果config.toml有自己的内容，请先备份，此命令会覆盖config.toml)   1  cp -rf themes/jane/exampleSite/config.toml ./    启动 hugo server：打开终端，进入站点根目录 my_blog ，输入以下命令   1  hugo server    查看博客效果：打开 http://localhost:1313/ ，你将会看到一个示例网站，效果如下    jane主题效果    配置主题 根据自己的需求，我做了如下改动：\n 修改菜单栏为中文显示，配置文件的修改详见下文 我的配置 将外链菜单，改为页面显示，需在content目录创建 links.md 文件，文件内容就是外链页面显示内容，配置文件的修改详见下文 我的配置 （添加新菜单页面都可以使用此方式） 将about菜单页面添加到配置文件，统一管理，目的是将“about”改为中文“关于”，需要将原about.md文件的 \u0026ldquo;menu: \u0026ldquo;main\u0026rdquo; 删除（其实将title改为中文“关于”也可以实现），配置文件的修改详见下文 我的配置 调整了菜单的顺序，更改weight值即可，配置文件的修改详见下文 我的配置 删除doc菜单，个人觉得不需要此功能，删除方法是将doc菜单下的几个帖子对应的markdown文件打开，删除下面所示的代码设置（这也是一种加功能菜单的方法，需要时可以用起来）   1 2 3 4  menu: main: parent: \u0026#34;docs\u0026#34; weight: 3    删除社交链接，本人觉得不需要，所以将所有社交链接注释掉了，但还有一个RSS订阅图标，有点强迫症，还是想把它删掉，于是进入主题jane，找到 \u0026quot;./layouts/partials/social_links.html\u0026rdquo; ，将RSS图标显示相关代码注释掉了，如下   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!-- {{/* RSS icon */}} {{ with .Site.GetPage \u0026#34;home\u0026#34; -}} {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; -}} \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34; rel=\u0026#34;noopener {{ .Rel }}\u0026#34; type=\u0026#34;{{ .MediaType.Type }}\u0026#34; class=\u0026#34;iconfont\u0026#34; title=\u0026#34;rss\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; {{ partial \u0026#34;svg/rss.svg\u0026#34; }} \u0026lt;/a\u0026gt; {{ end -}} {{- end -}} --\u0026gt;    下面展示一下 我的配置 ，基本每一处都做了注释，并标注了需要改的地方：   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177  # 基础设置 #------------------------------------------------------------------- baseURL = \u0026#34;https://wenhui.space\u0026#34; # 博客部署网址 ：部署到github时需要改 title = \u0026#34;Wenhui\u0026#39;s Rotten Pen\u0026#34; # 网址名称 ：改 enableRobotsTXT = true # 是否支持Robots协议，也就是机器人协议/爬虫协议，简单说可以通过搜索引擎搜索到你的主页（不确定） enableEmoji = true # 是否支持Emoji表情符号 theme = \u0026#34;jane\u0026#34; # 选用jane主题 hasCJKLanguage = true # 自动检测是否包含 中文\\日文\\韩文 paginate = 10 # 首页每页显示的文章数目 rssLimit = 20 # 限制 Rss 文章输出数量 disqusShortname = \u0026#34;\u0026#34; # disqus_shortname googleAnalytics = \u0026#34;\u0026#34; # 配置google统计，这里设置一个 google 的统计配置id,格式为UA-XXXXXXXX-X copyright = \u0026#34;\u0026#34; # 默认为下面配置的author.name， # 关于语言 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 默认博客语言环境，可选：en, zh-cn (选项由theme中i18n文件支持所决定) [languages.zh-cn] # 语言支持 en/zh-cn/other... 可查看theme中i18n文件 languageCode = \u0026#34;zh-cn\u0026#34; # 关于语法高亮，具体使用可查看https://gohugo.io/content-management/syntax-highlighting/ PygmentsCodeFences = true # Enable syntax highlighting with GitHub flavoured code fences PygmentsUseClasses = true # Use CSS classes to format highlighted code PygmentsCodefencesGuessSyntax = true # PygmentsOptions = \u0026#34;linenos=table\u0026#34; # 开启显示行号 [author] # 作者名称 ：改 name = \u0026#34;文辉\u0026#34; [sitemap] # 暂不清楚 changefreq = \u0026#34;weekly\u0026#34; priority = 0.5 filename = \u0026#34;sitemap.xml\u0026#34; #------------------------------------------------------------------- #菜单设置 #------------------------------------------------------------------- [[menu.main]] name = \u0026#34;主页\u0026#34; weight = 10 identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; [[menu.main]] name = \u0026#34;归档\u0026#34; weight = 20 identifier = \u0026#34;archives\u0026#34; url = \u0026#34;/post/\u0026#34; [[menu.main]] name = \u0026#34;分类\u0026#34; weight = 30 identifier = \u0026#34;categories\u0026#34; url = \u0026#34;/categories/\u0026#34; [[menu.main]] name = \u0026#34;标签\u0026#34; weight = 40 identifier = \u0026#34;tags\u0026#34; url = \u0026#34;/tags/\u0026#34; [[menu.main]] name = \u0026#34;关于\u0026#34; weight = 50 identifier = \u0026#34;about\u0026#34; url = \u0026#34;/about/\u0026#34; [[menu.main]] name = \u0026#34;友链\u0026#34; weight = 60 identifier = \u0026#34;links\u0026#34; url = \u0026#34;/links/\u0026#34; [[menu.main]] name = \u0026#34;订阅\u0026#34; weight = 70 identifier = \u0026#34;feed\u0026#34; url = \u0026#34;/index.xml\u0026#34; #------------------------------------------------------------------- #其他参数设置 #------------------------------------------------------------------- [params] since = \u0026#34;2019\u0026#34; # 站点建立时间 homeFullContent = false # 主页是否显示全部文章内容，否的话仅显示摘要，建议设为否 rssFullContent = true # if false, Rss feed instead of the summary logoTitle = \u0026#34;文辉的烂笔头\u0026#34; # 博客标题，默认值是上面设置的title，也就是网址名称 keywords = [\u0026#34;Hugo\u0026#34;, \u0026#34;linux\u0026#34;, \u0026#34;emacs\u0026#34;, \u0026#34;CPU\u0026#34;] # 关键字，应该是与搜索引擎搜索有关，博客内无展示 description = \u0026#34;\u0026#34; # 网页描述，应该是与搜索引擎搜索有关，博客内无展示 archive-paginate = 30 # 归档、标签、分类每页显示的文章数目，建议修改为一个较大的值 dateFormatToUse = \u0026#34;2006-01-02\u0026#34; # 日期显示格式，查看可支持的格式见https://gohugo.io/functions/format/ moreMeta = true # 是否显示字数统计与阅读时间 showMenuLanguageChooser = true # 显示语言选择开关 showAuthorInfo = true # 文章末尾显示作者信息 # 一些全局开关，这些是默认值，也可以在每一篇内容的 front matter 中对单篇内容关闭或开启某些功能，在 archetypes/default.md 查看更多信息。 toc = true # 是否开启目录 photoswipe = true # 是否启用PhotoSwipe（图片可点击） bootcdn = true # 是否使用bootcdn(@Deprecated: 请使用[params.publicCDN])（好像可以加快网页访问速度） mathjax = false # 是否使用mathjax（数学公式） contentCopyright = \u0026#39;文辉原创文章，如需转载请注明出处，谢谢！！！\u0026#39; # 改 customCSS = [] # if [\u0026#39;custom.css\u0026#39;], load \u0026#39;/static/css/custom.css\u0026#39; file customJS = [] # if [\u0026#39;custom.js\u0026#39;], load \u0026#39;/static/js/custom.js\u0026#39; file #------------------------------------------------------------------- # CDN设置，据说是提高访问速度的，具体也没感受到 #------------------------------------------------------------------- [params.publicCDN] # load these files from public cdn，若启用公共CDN，需自行定义 enable = true jquery = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js\u0026#34; integrity=\u0026#34;sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; slideout = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js\u0026#34; integrity=\u0026#34;sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentJS = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; gitmentCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipe = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.js\u0026#34; integrity=\u0026#34;sha256-AC9ChpELidrhGHX23ZU53vmRdz3FhKaN9E28+BbcWBw=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeUI = \u0026#39;\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js\u0026#34; integrity=\u0026#34;sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; photoswipeCSS = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css\u0026#34; integrity=\u0026#34;sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; photoswipeSKIN = \u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css\u0026#34; integrity=\u0026#34;sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026#39; #------------------------------------------------------------------- # 下面是关于评论系统，更新显示commit内容，谷歌搜索，文章打赏，访问数据统计等等，个人觉得不需要，全部false掉了 #------------------------------------------------------------------- [params.utteranc] # utteranc is a comment system based on GitHub issues. see https://utteranc.es enable = false repo = \u0026#34;xianmin/comments-for-hugo-theme-jane\u0026#34; # The repo to store comments issueTerm = \u0026#34;pathname\u0026#34; [params.gitment] # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment owner = \u0026#34;\u0026#34; # Your GitHub ID repo = \u0026#34;\u0026#34; # The repo to store comments clientId = \u0026#34;\u0026#34; # Your client ID clientSecret = \u0026#34;\u0026#34; # Your client secret [params.livere] #LiveRe comment. see https://www.livere.com/ uid = \u0026#34;\u0026#34; [params.reward] # 文章打赏 enable = false wechat = \u0026#34;/path/to/your/wechat-qr-code.png\u0026#34; # 微信二维码 alipay = \u0026#34;/path/to/your/alipay-qr-code.png\u0026#34; # 支付宝二维码 [params.counter.busuanzi] # a Chinese visitor counter # 卜算子计数器 enable = false [params.counter.leancloud] # Chinese leancloud visitor counter # leancloud 计数器 enable = false appId = \u0026#34;\u0026#34; appKey = \u0026#34;\u0026#34; [params.commentCount.disqus] # show counts of comments for Disqus enable = false [params.search.google] # google custom search, see https://cse.google.com enable = false id = \u0026#34;002186711602136249422:q1gkomof_em\u0026#34; title = \u0026#34;Search\u0026#34; [params.gitInfo] gitRepo = \u0026#34;https://github.com/xianmin/xianmin.org\u0026#34; showCommitMessage = false #------------------------------------------------------------------- #社交链接，不需要可注释掉 #------------------------------------------------------------------- # [params.social] # a-email = \u0026#34;mailto:your@email.com\u0026#34; # b-stack-overflow = \u0026#34;http://localhost:1313\u0026#34; # c-twitter = \u0026#34;http://localhost:1313\u0026#34; # d-facebook = \u0026#34;http://localhost:1313\u0026#34; # e-linkedin = \u0026#34;http://localhost:1313\u0026#34; # f-google = \u0026#34;http://localhost:1313\u0026#34; # g-github = \u0026#34;http://localhost:1313\u0026#34; # h-weibo = \u0026#34;http://localhost:1313\u0026#34; # i-zhihu = \u0026#34;http://localhost:1313\u0026#34; # j-douban = \u0026#34;http://localhost:1313\u0026#34; # k-pocket = \u0026#34;http://localhost:1313\u0026#34; # l-tumblr = \u0026#34;http://localhost:1313\u0026#34; # m-instagram = \u0026#34;http://localhost:1313\u0026#34; # n-gitlab = \u0026#34;http://localhost:1313\u0026#34; # o-goodreads = \u0026#34;http://localhost:1313\u0026#34; # p-coding = \u0026#34;http://localhost:1313\u0026#34; # q-bilibili = \u0026#34;http://localhost:1313\u0026#34; # r-codeforces = \u0026#34;http://localhost:1313\u0026#34; # s-mastodon = \u0026#34;http://localhost:1313\u0026#34; #-------------------------------------------------------------------   到此，你可以启动 hugo server ，查看一下自己的博客了，若仍有不满意的，可以尝试继续修改。\n开始写帖子 hugo是对markdown支持的，若对markdown语法不了解，可参考另一篇帖子 markdown基本语法。这里只对hugo使用的markdown文件头部进行说明（其他参数可以查看hugo官方文档）:\n date ： 文件创建时间 draft ： 是否为草稿，草稿文件不会发布到站点 title ： 文件标题 tag ： 标签 categories ： 分类 toc ： 是否开启目录   1 2 3 4 5 6 7 8  +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; tags = [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] categories = [\u0026#34;分类1\u0026#34;] toc = true +++   可以开始书写你的博客内容了，顺便说一句，markdown的编辑器可使用typora。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":54,"section":"docs","tags":["hugo"],"title":"hugo的使用","uri":"https://wenhui.space/zh/docs/create_blog_site/hugo_usage.html"},{"content":"本文 主要介绍了如何为firefox手动安装flash player插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0 flash player版本：32.0  参考  firefox帮助：安装 Flash 插件 百度经验：deepin linux下firefox怎么升级flash player  安装过程 为什么安装Flash插件 由于deepin没有发现简单易用的图片处理软件，比如调整大小、拼图、裁剪等等，最佳选择就是使用美图秀秀网页版了，但是发现缺少可用的Flash插件，于是开始了安装过程。\n下载Flash插件  你可以到官网下载，请进入Adobe Flash Player下载页面，选择要下载的版本，我这里选择的是 .tar.gz 适用于 Linux 也可以选择我的百度网盘分享资源 链接：https://pan.baidu.com/s/18FLcCARtjnogcBB%5F950s-Q 密码：xbcu  解压安装 将下载的安装包解压，放到自己合适的位置，比如我的 “~/Treasury/tools_and_drives/flash_player/” ，“Treasure”的意思就是财富宝藏了，没错，我的所有“财富”都在这里。然后将下载的文件包中 libflashplayer.so 复制到firefox的插件目录 “/usr/lib/mozilla/plugins/” 。打开终端进入下载的文件包目录，输入如下命令(中途会提示输入用户密码)：\n1  sudo cp ./libflashplayer.so /usr/lib/mozilla/plugins/   如果没有firefox的插件目录，需要自己创建：\n1  sudo mkdir -p /usr/lib/mozilla/plugins/   查看 重启firefox，点击菜单打开 附加组件 或快捷键 Ctrl+Shift+A ，点击左侧的“插件”即可看到flash palyer的版本。\n  flash player版本为32.0    如果还没有的话，可以试试点击 **齿轮图标** 选择 **从文件安装附加组件** 。 文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":55,"section":"docs","tags":["firefox"],"title":"为firefox安装flash player插件","uri":"https://wenhui.space/zh/docs/install_software/install_flash_player_for_firefox.html"},{"content":"本文 主要介绍emacs如何安装插件。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本：Linux GNU Emacs 26.3  安装过程 给emacs安装插件可以使用emacs的包管理器，首先添加以下代码到.emacs中（或.emacs.d/init.el），然后 “M-x package-list-packages” （初学者可能不知道什么意思，那你就需要了解了解emacs了， M就是Alt键，打开emacs，敲击组合键 Alt+x ，启动命令窗口，然后输入命令“package-list-packages”（tab键可以补全）），接下来你会看到所有插件的列表，找到“ox-hugo”，可以点击，然后根据提示下载安装，也可以使用快捷键操作，如下：\n i ： 选择要安装的包 d ： 选择要删除的包 U ： 升级已安装的包 x ： 执行操作 d ： 选择要删除的包   1 2 3 4  (require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;http://melpa.milkbox.net/packages/\u0026#34;) t) (package-initialize)   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":56,"section":"docs","tags":["emacs"],"title":"emacs如何安装插件","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_package_install.html"},{"content":"本文 主要介绍emacs的基本使用方法。\n   版本 说明     0.1 初版发布    获取教程的途径  子龙山人的《21天学会Emacs》电子书在线阅读 打开emacs，快捷键C-h t，获取emacs的快速指南  帮助的使用 使用emacs最重要的是学会查找帮助。 C-h 是使用帮助功能，下面描述常用的几种查找帮助：\n C-h ? Emacs会告诉你它提供了哪些帮助 C-h t 打开Emacs快速指南 C-h c 命令说明【C-h c后面加要查询的命令】 C-h k 查看某个快捷键对应的命令【C-h k后面加要查询的快捷键】 C-h w 查看某个命令对应的快捷键 (where-is) C-h m 查看某个mode的文档 C-h f 解释一个函数【需要输入函数名】 C-h i 阅读手册【也就是通常讲的 Info】 C-h r Emacs使用手册【也就是通常讲的 Manual】  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":57,"section":"docs","tags":["emacs"],"title":"emacs的基本使用","uri":"https://wenhui.space/zh/docs/about_emacs/emacs_useguide_aa.html"},{"content":"本文 主要对正则表达式的常用语法进行整理和介绍。\n   版本 说明     0.1 初版发布   0.2 添加正则表达式在线测试网址    背景  Linux  什么是正则表达式？ 正则表达式（regular expression 简称regex），正则表达式是一种文本处理工具，用途就两种：一是进行搜索，二是进行搜索和替换。但是它比普通的搜索更强大，具体可以在如下场景中体现：\n 在某文本中搜索或搜索加替换单词car，但是并不将carry等包含car字符的单词作为目标 在某文本中搜索或搜索加替换单词car，但是只将行末位置作为目标 在某文本中搜索或搜索加替换begin****end，这里将begin和end以及中间任意字符作为目标  总之，正则表达式就是一个文本处理功能强大的工具，主要任务就是用正则表达式语言构造特定的目标来进行搜索和替换操作。但是它又不能算作一个独立的工具或语言，二是嵌入在其他语言和工具中，换句话说，其他大多数工具和语言都支持正则表达式。\n正则表达式知识点 任意字符“.”  “.”字符可以匹配任何单个字符、字母、数字以及“.”字符本身。 “.”字符可以在同一正则表达式在任意位置出现任意次数。 如果想搜索“.”字符本身，需要自“.”字符前加“\\”字符进行转义，即“\\.”。  字符集合[]  [ns]a\t匹配na和sa，将部分字符集合作为目标 [Rr]eg\t匹配Reg和reg，特定位置区分大小写和不区分大小写 [0-9]\t匹配任意数字，这里“-”为连字符（仅限于字符集合[]内，字符集合外为普通字符-），常用为0-9，A-Z，a-z [A-Za-z0-9]\t匹配任意大小写字母和数字，字符集合中可以出现多个区间 [^0-9]\t匹配非数字任意字符，取非字符“^”，主要取非的含义是对整个字符集合，而不是^后紧跟的那个集合  使用元字符  特殊字符需要转义，如\\\\匹配\\，\\.匹配.，\\[匹配[ 匹配空白字符，\\f换页符，\\n换行符，\\r回车符，\\t制表符（如匹配空白行，linux下将换行符作为文本结束标志，而windows将回车符换行符作为文本结束标志，所以linux匹配空白行即\\n\\n，windows下陪陪空白行即\\r\\t\\r\\t） 匹配某类字符，\\d匹配任何数字字符，\\D匹配任意非数字字符，\\w匹配任意字母数字下划线字符（不区分大小写），\\W匹配任意非字母数字下划线 匹配空白字符，\\s匹配任意空白字符（等同于[\\f\\n\\r\\t\\v]），\\S匹配任意空白字符（等同于[^\\f\\n\\r\\t\\v]）  重复匹配  [0-9]或\\d代表任意一个数字，[0-9]+或\\d+代表任意一个或多个连续数字 +和*和？的使用区别，+代表重复出现一次或多次，*代表重复出现0次或多次，？代表重复出现0次或1次。举例：https+匹配https和httpss…，https*匹配http和https和httpss…，https？匹配http和https。 设定重复次数，a{5}匹配aaaaa，重复5次；a{3,5}匹配aaa和aaaa和aaaaa，重复3-5次；a{3,}匹配a重复最少3次 防止过度匹配：+，*，{3,}这样的无限重复都属于贪婪型，容易造成过度匹配，举例如下，AxxxB 555 AmmmmB，正则表达式为A.*B，本意是将AxxxB和AmmmmB匹配，实际匹配为AxxxB 555 AmmmmB，显然不是我们希望的结果，在贪婪型元字符+和*和{3,}后加?可以将贪婪型转为懒惰型，如A.*?B，匹配结果为AxxxB和AmmmmB。  位置匹配  单词边界符\\b：例如匹配car，可能将carry也作为了目标，这时候需要使用单词边界，\\bcar\\b。这里对\\b的匹配说明一下，他并不知道什么是单词边界，只是找到构成单词的字符（字母数字下划线\\w）和一个不能构成单词的字符（\\W）之间位置。 字符串的边界：开头^，结尾$，比如^.*$，在语法上完全正确，而且总能匹配到一个结果，但是却无任何用途。这里字符串边界符要搭配分行匹配模式(?m)来使用的，举例说明：匹配verilog代码中的注释行内容：(?m)^\\s*//.*$，解释：(?m)分行匹配模式，将一行内容作为一个字符串处理；^字符串开头；\\s*任意一个或多个空白符，如空格、制表符、换行符等等；//为verilog中的注释符；.*为任意字符重复0次或多次，其实这里代表注释内容；$代表字符串结尾。 总之，比较难理解的是字符串边界的使用，这里对常用的几个举例：  ^\\s*：代表文本开头的有效内容处（这里有效内容是排除空行、空格、tab等） \\s*$：代表文本末尾的有效内容处（这里有效内容是排除空行、空格、tab等） 搭配(?m)作为行处理：(?m)^\\s*代表行首有效内容；(?m)\\s*$代表行尾有效内容    子表达式  什么是子表达式？举一个简单例子，as{2}匹配的内容是ass，因为{2}是以紧跟自己上一个字符作为操作对象的，而当你想匹配asas时，需要写为(as){2}，这里括号里内容就是子表达式，括号就是子表达式的标志，这样{2}以子表达式内容为操作对象。 另一举例：文本内容为1965，匹配年份数字，正则表达式为19|20\\d{2}，实际匹配到内容为19，而本意是将19xx和20xx的年份数字匹配出来，问题出在|操作，这里|或操作是将符号两边都作为整体来处理，即19和20\\d{2}，所以这里需要子表达式将19|20作为整体，即(19|20)\\d{2} 子表达式的嵌套，这里对于子表达式的嵌套没什么好讲的，就是支持无限嵌套，但是也要适可而止，以便于阅读分析。这里举个例子：匹配三个连续0-255的数字（注意，正则表达式不会有任何计算，它只关心字符），正则表达式为：((\\d{1,2})|(1\\d{1,2})|(2[0-4]\\d)|(25[0-5])){3}；这里就是将0-99，100-199，200-249,250-255分段描述。  回溯引用  回溯引用其实就是后面匹配引用前面匹配的结果，简单的就是前后一致匹配。例如：+(\\w+)+\\1，解释为+代表任意一个或多个空格；(\\w+)代表任意一个或多个数字字母下划线；+代表任意一个或多个空格；\\1为前面子表达式(\\w+)匹配的内容，这里就是回溯引用。这段表达式实际功能就是在匹配两个连续单词的出现，如and and，we we等等。 回溯引用通过\\1，\\2等来表达的，这里数字是通过相对位置来引用的，即此处\\1，代表表达式中第一个子表达式（嵌套表达式是如何暂不清楚，认为是指引用层级相同的子表达式），注意数字从1开始。 回溯引用在替换中的应用：  将电话号码重新排版，将313-555-1234和251-555-2031排版为(313) 555-1234和(251) 555-2031。匹配表达式：(\\d{3})(-)(5{3})(-)(\\d{4})，替换表达式：($1) $3-$5。 大小写转换：元字符（\\E作为结束标志；\\l把下一个字符转换为小写；\\u把下一个字符转换为大写；）举例：AaBbCcDd，匹配：([Aa]{2})([Bb]{2})([Cc]{2})([Dd]{2})，替换：$1\\U$2$3\\E$4，替换效果为AaBBCCDd（将第二第三表达式全部替换为大写）    前后查找  什么是前后查找？前后查找就是将匹配部分作为位置标记，选择前面内容还是后面内容，而作为位置标记的内容不作为匹配目标或者说不做内容提取。 向前查找?=，向后查找?\u0026lt;=，作为查找位置的匹配写在=后面，且必须作为子表达式，换句话说必须括起来，如(?=:)。 举例：http:xxxx和https:ssss，匹配：.+(?=:)，匹配结果http和https，注意无:本身。 举例：001:$0.23和002:\\(1.54，匹配：(?\u0026lt;=\\))[\\d.]+，匹配结果0.23和1.54，注意无$本身。向后匹配要注意内容的匹配条件，不要过多匹配，其实用的最多还是向前匹配，以及向前向后匹配合用。 举例：begin 12345678 end，匹配(?\u0026lt;=begin).+(?=end)，匹配结果 12345678 ，注意无begin和end。 之前描述的向前向后查找被称为正向前查找和正向后查找，除此外，还有负向前查找(?!)和负向后查找(?\u0026lt;!)，用法相同，只是将非匹配位置作为搜索条件，注意，对于使用负向前和符负向后查找时，可以适当加单词边界符\\b。举例：\\(30 for 10 apples，匹配：(?\u0026lt;!\\))\\d+，匹配结果为$30 for 10 apples，因为$30中的0并不是\\(开头，所以会作为匹配目标，只需加字符边界符\\b就可以解决：\\b(?\u0026lt;!\\))\\d+\\b。  嵌入条件  嵌入条件使用?来表示，在两种情况下使用：一是根据一个回溯引用来进行条件处理；二是根据一个前后查找来进行条件处理。 回溯引用使用嵌入条件，举例：123-456-7890和(123)456-7890，匹配：(\\()?\\d{3}(?(1)\\)|-)\\d{3}-\\d{4}，解释：(\\()?是一个可选（?为0或1个）的左括号(；\\d{3}是区号123；(?(1)\\)|-)是引用条件第一个子表达式成立则匹配右括号)，否则必须匹配-符号；\\d{3}-\\d{4}是后面7位号码。 前后查找条件的嵌入条件，举例：11111和44444-444，匹配：\\d{5}(?(?=-)-\\d{4})，解释：\\d{5}表示前五位数字；(?(?=-)-\\d{4}向前查找是否存在-，如果存在-再后续查找-\\d{4}也就是连字符-和三个数字。 总之，嵌入条件的模式还是很复杂的，建议先对该模式的各个组成部分一一调试，然后再组合到一起，还有，工作中使用到如此复杂的情况还是比较少见的，建议还是用更简单的方法实现同样的目的。  元字符列表 注意：因为org-mode下列表中“|”符号为特殊符号，为了防止描述真实的“|”符号时被转义，文中使用中文 “竖线” 替代。\n基本元字符    元字符 说明     . 匹配任意单个字符   竖线 逻辑或操作符   [] 匹配字符集合中的任意一个字符   [^] 对字符集合取非   - 定义一个区间，如A-Z   \\ 对下一个字符转义    数量元字符    元字符 说明     * 匹配前一个字符或子表达式零次或多次重复   *? *的懒惰型，懒惰型的理解可参考第五节内容重复匹配   + 匹配前一个字符或子表达式一次或多次重复   +? +的懒惰型   ? 匹配前一个字符或表达式重复一次或零次（可以理解为有无该字符）   {n} 匹配前一个字符或表达式重复n次，n为具体数值   {n,m} 匹配前一个字符或表达式重复m次至n次   {n,} 匹配前一个字符或表达式重复至少n次   {n,}? {n，}的懒惰型    特殊字符元字符    元字符 说明     [\\b] 匹配一个退格字符   \\c 匹配一个控制字符   \\d 匹配任意数字字符   \\D \\d的反义   \\f 换页符   \\n 换行符   \\r 回车符   \\s 匹配一个空白字符   \\§ \\s的反义(大写S)   \\t 制表符tab   \\v 垂直制表符   \\w 任意数字字母下划线   \\W \\w的反义   \\x 匹配一个十六进制数   \\0 匹配一个八进制数    回溯引用和前后查找    元字符 说明     () 定义子表达式   \\1 匹配第一个子表达式，若是\\2表示匹配第二个子表达式   ?= 向前查找   ?\u0026lt;= 向后查找   ?! 负向前查找   ?\u0026lt;! 负向后查找   ?() 条件if then   ?()加竖线 条件if then else    大小写转换    元字符 说明     \\E 结束\\L或\\U转换标志   \\l 把下面一个字符转义为小写   \\L 把下面字符转义为小写直至\\E   \\u 把下面一个字符转义为大写   \\U 把下面字符转义为大写直至\\E    匹配模式    元字符 说明     (?m) 分行匹配模式    其他说明 使用正则表达式的难点不在于将一个匹配情况考虑清楚并且写出一个符合要求的正则表达式，难点在于将不需要匹配的情况考虑清楚将其排除在外。\n在线测试  正则表达式在线测试  典型应用 待补充。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":58,"section":"docs","tags":["shell"],"title":"正则表达式语法简明教程","uri":"https://wenhui.space/zh/docs/about_linux/regular_expression.html"},{"content":"本文 主要介绍hugo和记录hugo的安装过程。\n   版本 说明     0.1 初版发布   0.2 添加特别说明 和 分享hugo_extended_0.65.3_Linux-64bit.tar.gz    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 hugo版本： hugo 0.58  参考  Hugo中文文档  什么是hugo？ Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。简单来说就是你可以用它来生成自己的博客站点，而且安装极简单，无依赖。类似此功能的工具还有Hexo，， Jekyll, Ghost，我强烈推荐Hugo。更多内容可以查看Hugo中文文档。\n安装hugo 下载 推荐二进制安装，也就是直接下载可执行程序，方便简单。\n 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe） 采用我的百度网盘分享资源（里面包含hugo_0.58和extend_hugo_0.61两个版本，选其一即可） 链接：https://pan.baidu.com/s/1ub-6LSw9VABaf0GNe7oeGQ 密码：pvb4  安装 将下载的文件解压，找到hugo文件，将其放入 “/usr/local/bin/” 目录，若其为非可执行文件，请更改文件属性。可参考以下执行命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./hugo #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./hugo /usr/local/bin/hugo   特别说明 如果使用某些主题时，提示HUGO版本不支持某些特性，首先考虑自己的版本是不是太低，然后最可能的情况是需要安装扩展版本。\n如错误信息为：\nBuilding sites … ERROR 2020/03/06 14:23:59 Transformation failed: TOCSS: failed to transform \u0026quot;main_parsed.scss\u0026quot; (text/x-scss): this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information Built in 218 ms Error: Error building site: logged 1 error(s) 这里分享一个 hugo_extended_0.65.3_Linux-64bit 版本： *链接：https://pan.baidu.com/s/1DUleZmjcLCl7wJP9i3smJA 密码：n86i*。\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":59,"section":"docs","tags":["hugo"],"title":"hugo的安装","uri":"https://wenhui.space/zh/docs/install_software/install_hugo.html"},{"content":"本文 主要介绍图床工具PicGo和记录PicGo的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 PicGo版本： picgo-2.1.2-x86_64.AppImage  参考  在Linux上安装PicGO  什么是PicGo？ PicGo是一款功能实用、操作简捷的图床工具，图床工具简单来说就是本地图片上传自动转换成链接的一款工具。网络上的图床工具有很多，PicGo算得上一款比较优秀的图床工具了，它可以支持微博， 七牛云， 腾讯云COS， 又拍云， GitHub， 阿里云OSS， SM.MS， imgur 等8种常用图床，功能强大，简单易用。\n为什么安装PicGo？ 写博客内容时，常常会用到图片，最初是将图片放在本地并随博客public一同上传至github，但是在本地网址显示好好的图片，上传至github就打不开了，其主要原因还是因为填写的是相对地址，上传github后，往往地址会发生变化，导致图片索引不到，所以只好通过图床工具转化为链接，作为全路径添加到博客内容，这样就可以解决了。网上搜索了一下图床工具，好像PicGo有点独步天下的意思，网上评价PicGo是最好的图床工具，没有之一。所以，开始折腾起来，下载安装。\n安装过程 下载PicGo  去PicGo官方github页面下载最新版本的PicGo，我这里选择的是picgo-2.1.2-x86_64.AppImage 采用我的百度资源分享 链接：https://pan.baidu.com/s/14ZhG87VBDfNi9w7%5FK4my1A 密码：4zvy ，另附有一张logo图  安装 安装很简单，其实下载的就是一个可执行程序，放到自己的 系统变量PATH 即可，我习惯是放在 “/usr/local/bin/” 。打开终端进入下载解压后的picgo目录，执行以下命令：\n1 2 3 4 5 6 7 8  #查看系统变量 echo $PATH #更改文件属性为可执行 chmod 755 ./picgo-2.1.2-x86_64.AppImage #复制到/usr/local/bin/目录，也可以选择自己$PATH的某一路径 sudo cp ./picgo-2.1.2-x86_64.AppImage /usr/local/bin/picgo   添加到启动器 可参考另一篇帖子 将软件添加到deepin启动器 。\n安装依赖 虽然PicGo已经开始运行了，可是有些功能需要依赖其他程序来实现。在程序内实现粘贴板上传需要用到xclip，不装的话会报 \u0026ldquo;xclip not found\u0026rdquo; 的错误。可以通过包管理器安装，命令如下：\n1  sudo apt install xclip -y   ","description":"","id":60,"section":"docs","tags":null,"title":"PicGo的安装","uri":"https://wenhui.space/zh/docs/install_software/install_picgo.html"},{"content":"本文 主要介绍词典工具GoldenDict和记录GoldenDict的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 GoldenDict版本：1.5.0-RC2+git  参考  安装使用 GoldenDict 查词神器  什么是GoldenDict？ GoldenDict是一款优秀的的词典软件，其特点如下：\n 免费 纯净无广告 跨平台：Windows / Mac / Linux 支持多种词典格式 支持查维基百科 / 支持在线翻译（需配置） 支持屏幕取词 支持听取 forvo.com 上的发音 更多特点可详见GoldenDict 官网    GoldenDict就是它了    安装GoldenDict  可选择使用deepin软件商店安装，操作简单 可通过软件包管理工具下载（版本不一定是最新的，但应该比软件商店提供的版本新，安装后按需手动添加到启动器），命令如下：   1 2 3 4 5  # Ubuntu / Debian sudo apt install goldendict -y # CentOS sudo yum install goldendict -y   添加离线词典  下载词典 ，我这里使用的是三个词典，百度网盘分享资源 链接： https://pan.baidu.com/s/1wXbxsUlLLsGl9namvO4q-g 密码：45o3  en-zh：牛津现代英汉双解词典 zh-en：朗道汉英字典 zh-zh：新华字典   存放词典 ，解压后根据个人喜好选择存放位置，且后续不能移动，我这里放在 “~/Treasury/tools_and_drives/GoldenDict/” 下 导入词典 ，菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【文件】\u0026gt;【添加】 ，选择上一步的词典位置打开，并勾选上递归搜索，点击 “重新扫描” 完成后点击 【应用】 即可 功能测试 ，在搜索栏分别输入“you”和“你”，回车，查看翻译结果。  添加网页翻译（有道）  菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【网站】\u0026gt; 【添加】 ，输入名称为“youdao”，输入地址， 勾选已启用，点击 【应用】 。 地址内容为“http://dict.youdao.com/search?q=%GDWORD%\u0026amp;ue=utf8” 功能测试，在搜索栏输入“you”，回车，查看youdao翻译结果 也可以使用其他网页翻译以及搜索引擎  添加google翻译（translate-shell） 以上添加的离线词典只能翻译词典里存在的词汇，不能对整句整段进行翻译，而有道翻译的页面广告多，让人不舒服，所以我们为词典添加一个google翻译。translate-shell是命令行版google翻译，在终端命令行可以直接通过 “trans” 命令使用，也可以将命令添加到GoldenDict使用。\n下载安装 translate-shell 安装方法有三种：\n 直接下载可执行文件，百度网盘分享资源 链接：https://pan.baidu.com/s/1kQYl%5F%5FhptxA5X0k9h7ZYcg 密码：sxeq ，打开终端进入下载目录，执行以下命令：   1 2  chmod 755 ./trans sudo mv trans /usr/local/bin/    手动安装，下载trans_shell安装包，以下是使用git工具进行下载，也可以登录网址通过浏览器下载压缩包，或使用我的百度网盘分享资源 链接：https://pan.baidu.com/s/1aHXNwKm6QYcXMtuk77roPg 密码：yzxu ，安装命令如下：   1 2 3 4  git clone https://github.com/soimort/translate-shell cd translate-shell make sudo make install    通过包管理器安装，命令如下：   1 2  sudo apt install translate-shell which trans   trans_shell的使用 本文目的主要是安装trans_shell给GoldenDictionary使用，不过在终端也可以使用，使用方法如下：\n1 2  trans en:zh \u0026#39;Hello World\u0026#39; trans zh:en \u0026#34;你好\u0026#34;   为GoldenDict添加trans_shell 菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【词典来源】\u0026gt;【程序】\u0026gt; 【添加】 ，类型选择纯文本，勾选已启用，名字（可以自己命名）与命令行内容如下：\n 名字：google_2_en  命令行：trans -e google -s auto -t en-US -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”   名字：google_2_zh  命令行：trans -e google -s auto -t zh-CN -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages n -show-original-dictionary n -show-dictionary n -show-alternatives n “%GDWORD%”    填写完之后点击 【应用】 即可。\n为GoldenDict分组 分组的目的是为了方便快速翻译，更加快速准确的找到自己想要的内容。菜单栏选择 【编辑】\u0026gt;【词典】\u0026gt;【群组】 ，此时左栏会看到已启用的词典（牛津现代英汉双解词典、google_2_zh、youdao、新华字典、朗道汉英字典5.0、google-2-en）。点击 【添加群组】 ，进行命名，选择词典加入该群组，并且可以在群组内调整词典的优先级，也可以根据个人需求为群组设置快捷键。我的分组如下：\n en_zh： google-2-zh、牛津现代英汉双解词典 zh_en： google-2-en、朗道汉英字典5.0 zh_zh： 新华字典 youdao： youdao    给词典进行分组    使用技巧 快捷键 Ctrl+C+C ，翻译剪切板中的内容，通过鼠标或快捷键选择群组，快速找到想要的内容。更多快捷键、屏幕取词以及其他使用技巧，可查看 【编辑】\u0026gt; 【首选项】 。（个人不太喜欢屏幕取词，工具会自动调用 Ctrl-C 命令，在终端中会误杀死进程）\n文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":61,"section":"docs","tags":null,"title":"GoldenDict的安装","uri":"https://wenhui.space/zh/docs/install_software/install_goldendict.html"},{"content":"本文 主要介绍了如何将手动安装的软件添加到deepin启动器中显示。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1  操纵过程 手动安装的工具可在终端运行，但对于某些软件来说使用不方便，也可以将可执行程序放在桌面，但是又使桌面不整洁美观，也可以添加至任务栏，但会导致任务栏工具繁多杂乱，最好的方式就是将其加入到deepin的启动器，以firefox为例，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Name、Icon、Exec、Categories、Comment，其他建议不要修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":62,"section":"docs","tags":["deepin"],"title":"将软件添加到deepin启动器","uri":"https://wenhui.space/zh/docs/install_software/add_software_to_deepin_launcher.html"},{"content":"本文 主要介绍firefox浏览器和记录firefox浏览器的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 firefox版本： Mozilla Firefox 71.0  参考  deepin linux如何安装最新版firefox火狐浏览器 firefox帮助中心 firefox官网  什么是firefox？ Mozilla Firefox，中文俗称 “火狐” ，是一个自由及开放源代码的网页浏览器，使用Gecko排版引擎，支持多种操作系统，如Windows、Mac OS X及GNU/Linux等。\n为什么选择firefox？ firefox浏览器有如下特点：\n 风格简洁，同时支持多主题，可自行选择 据说相对其他浏览器，启动速度慢（这一点我没有明显体验，大多数用户的浏览器处于常开状态，启动速度也就无关紧要了） 安全性高，有隐私保护机制，拦截多种常见的跟踪器和有害的脚本，减少第三方搜集浏览行为数据的能力 拓展性强，有丰富的拓展性插件支持 多平台支持，同步数据无障碍  选择firefox主要因为其两个特点，一是丰富的插件，虽然谷歌插件也很丰富，但国内环境无法访问应用商店，导致安装起插件来比较麻烦，所以放弃；二是多平台支持，支持Linux、Windows、Mac OS以及移动端，同步数据无障碍。\n安装firefox deepin的软件商店自带firefox浏览器，不过不是最新版的，通过软件商店安装firefox就不介绍了，只介绍手动安装过程。\n 打开firefox下载中心，不要点击 “立即下载” ，而是点击下方 “高级安装选项和其他平台” ，选择 “Linux 64-bit” 进行下载 将下载的最新版的firefox压缩包进行解压 打开文件管理器，并进入刚刚解压后的目录，双击运行目录下的 \u0026ldquo;firefox\u0026rdquo; 可执行文件，firefox浏览器就启动了 在任务栏中右键点击firefox，选择驻留可添加至任务栏，也可以将执行程序发送到桌面 将firefox可执行文件放在 \u0026quot;/usr/local/bin/” 目录，可以在终端命令打开firefox，命令就是 “firefox”  如何将firefox添加至deepin的启动器 如果不想将firefox的可执行程序放在桌面，影响美观，又不想添加至任务栏，导致任务栏工具繁多，可以选择将其加入到deepin的启动器，方法如下：\n 打开终端，进入 ”/usr/share/applications/“ 目录 新建 ”firefox.desktop“ 文件(需要root权限) 打开新建的文件，输入如下内容：   1 2 3 4 5 6 7 8  [Desktop Entry] Type=Application #类型，一般不改动 Name=Firefox #显示在启动器中的名字 Icon=/home/caowenhui/Treasury/tools_and_drives/firefox/browser/chrome/icons/default/default128.png #firefox的图标路径 Exec=/usr/local/bin/firefox #firefox的可执行程序路径 Terminal=false #是否在终端运行 Categories=Network;WebBrowser; #分类 Comment=a web browser #说明   注意，需要修改的就只有Icon和Exec两项，其他无需修改，并且，保存前 删除掉注释! 删除掉注释! 删除掉注释! ，否则不会生效。\n 完成保存，打开启动器查看并运行程序。  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":63,"section":"docs","tags":["firefox"],"title":"firefox的安装","uri":"https://wenhui.space/zh/docs/install_software/install_firefox.html"},{"content":"本文 主要介绍git和记录git的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 git版本： git version 2.11.0  参考  Deepin 系统下安装git  什么是Git？什么是Github？ Git是一个帮我们管理文件版本的程序，专业名称叫：分布式版本控制系统。GitHub是基于git的代码库托管站，也算是程序员的SMS（以码会友），其中一个主要的开源代码发布或托管站git的作用就是对文件进行版本管理，方便在不同版本进行切换修改，类似文件分不同时间备份然后需要时可以找回其中一个版本。GitHub某种程度上就是代码的网盘，也有开源开发商作为代码发布、存放、征集Bug和意见用。类似于相同功能的，国内版为Gitee（码云）。\n对了，还有人称gitub为世界上最大的同性交友网站，貌似也有道理。\n下载Git 打开终端，命令行输入以下命令，然后等待系统自动安装：\n1  sudo apt install git   结束后在终端输入命令 “git \u0026ndash;version” ，查看git是否安装成功，输出版本号则代表安装成功。\ngithub的使用指南 登录github，会显示 Learn Git and GitHub without any code! ，点击 Read the Guide 可查看使用指南，会点击这里。\ngit的使用指南 创建仓库 首先登录 github官网，如果没有账户需先用邮箱注册一个账户，然后点击 Repositories [new] ，新建仓库，新建页面如下。\n 1位置是用户名 2位置是仓库名 3位置是选择公开还是私有 4位置点击创建仓库    github新建仓库    克隆仓库到本地 github每个仓库页面都会有一个 [Clone or download] 绿色图标，点击后复制自己仓库的 \u0026quot;https://github.com\u0026hellip;\u0026hellip;/\u0026quot; 链接（其实就是仓库e页面网址后加.git），打开终端输入以下命令\n1  git clone https://github.com/......   等待克隆完成（终端会显示进度），克隆完成后在本地会看到自己的仓库文件。\npush 和 pull 首先搞清楚两个概念，本地仓库和远程仓库，本地仓库也就是你本地电脑的文件了，远程仓库就是指github。 pull 就是将远程仓库的最新文件下拉到本地（会输入用户名和密码），命令如下：\n1  git pull   push 就是将本地文件上传到远程仓库，不过需要经过三步，一是add，添加追踪或修改的文件，也就是想要把哪些文件提交上去就进行添加；二是commit，添加提交注释，提交到缓存区；三是push，刚刚提交到缓存区，也仅仅是在本地，我们需要上传到远程仓库。命令如下(会输入用户名和密码)（其中 add . 是指添加本地所有文件，也可以指定某文件，输入路径和文件名即可）：\n1 2 3  git add . git commit -m \u0026#34;first push\u0026#34; git push   详细使用技巧 至此，其实已经可以基本使用git了，其他详细使用技巧请期待后续帖子更新。也可以参考网上教程廖雪峰git使用教程。\n","description":"","id":64,"section":"docs","tags":["git"],"title":"git的安装","uri":"https://wenhui.space/zh/docs/install_software/install_git.html"},{"content":"本文 主要介绍emacs和记录emacs的安装过程。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Deepin GNU/Linux 15.11 内核： Debian 6.3.0-18+deb9u1 emacs版本： Linux GNU Emacs 26.3  什么是emacs？ emacs是一款功能强大的编辑器，被公认为是最受专业程序员喜爱的代码编辑器之一，而另一个就是vim，在业界vim被称为编辑器之神，而emacs被称为神之编辑器。对于初学者可能都有这样的疑问，那就是究竟是Vim还是Emacs好呢？这样的问题已经争辩了十几年，但至今无解，不过为了让初学者有一定的了解，还是做个简单介绍。\nVim ：\n 开箱即用，大多数操作系统自带，不需要安装 体量小，启动快 采用双模式（命令模式和编辑模式），这样按键组合少，但是要频繁进行模式切换 vim的上下左右jkhl，右手控制相对舒服 相对emacs使用人群多，配置和使用技巧可参考内容较多  Emacs ：\n 需要自己安装，碰到依赖库的问题，还是有点麻烦的 体积大，启动慢，但功能强大 主模式操作，不用切换模式，但按键组合就多了，Ctrl、Alt、Shift是离不开的，让你的小拇指粗壮起来 emacs的上下左右pnbf放在了两个手，还要配合Ctrl键，需要适应 缓存机制个人感觉很有用 可扩展性极强，可重新定义变量和快捷键绑定，可自己定制插件，也可通过内置的包管理系统安装和卸载大神们的插件，目前可使用的插件还是很丰富的 不同的语言环境对应不同的模式，每个模式都有自己独特的功能，本人最常用的就是org-mode和verilog-mode，org写工程日记，verilog就不说了，IC工程师离不开的  总之，Vim和Emacs功能都很强大，选择一款适合自己的编辑器即可。\n安装emacs 下载emacs安装包  可查看emacs官网或国内镜像文件，当前最新版本是emacs-26.3（更新时间29-Aug-2019) 可查看我的百度网盘分享资源(linux emacs-26.3版本) 链接：https://pan.baidu.com/s/1VZ88kGZpBiC59qGU7sk7tA 密码：lki0 可直接使用我的可执行程序，无需安装，将其放在自己的 “/usr/local/bin/” 目录即可，百度网盘分享资源 链接：https://pan.baidu.com/s/18K8WNnr5ytIkx%5Fe7n%5FuAcQ 密码：rrtt  安装依赖库 开启终端，输入以下命令，安装相应的依赖库。\n1 2 3 4 5  sudo apt-get install libgtk2.0-dev --fix-missing sudo apt-get install libxpm-dev sudo apt-get install libjpeg62-turbo-dev sudo apt-get install libgif-dev sudo apt-get install libtiff5-dev   编译和安装 开启终端，进入emacs安装包目录，输入以下命令：\n1  sudo ./configure   已经安装了相应的依赖，此时应该不会发生error，经过configure后，执行以下命令：\n1 2  sudo make sudo make install   查看是否安装成功 终端中输入以下命令：\n1  emacs --version   正常显示emacs版本号，即安装成功，安装的可执行程序默认在 “/usr/local/bin/” 。\n启动emacs 启动命令为 emacs ，如下：\n1  emacs ~/Destop/demo.txt   启动页面会有简单的使用说明，熟悉熟悉即可上手操作。\n  emacs启动页面      emacs org mode    文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":65,"section":"docs","tags":["emacs"],"title":"emacs的安装","uri":"https://wenhui.space/zh/docs/install_software/install_emacs.html"},{"content":"本文 主要介绍如何为deepin系统安装 rtl8821ce 无线网卡驱动。\n   版本 说明     0.1 初版发布    背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11 无线驱动：rtl8821ce  参考  LINUX 下无线网卡 rtl8821CE/rtl8723de 驱动 无法驱动解决办法  查看自己的网卡型号 在终端输入以下命令：\n1  dmesg | grep -i eth   显示如下：\n1 2 3 4 5 6 7 8 9 10  [18690.091602] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19611.409023] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19669.877403] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [19974.291420] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20093.240319] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20484.342884] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20605.303770] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20893.593415] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20937.945192] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000 [20990.361341] RTW: rtl8821c_sethwreg(wlp2s0): [HW_VAR_MACID_WAKEUP] macid=0, org reg_0x4d4=0x00000000   下载驱动  rtl8821CE git源网址 rtl8723de git源网址 百度网盘分享资源（rtl8821CE） 链接：https://pan.baidu.com/s/1zkMNEdvtXpuh8PnnJkfkLQ 密码：gxwh  安装驱动  解压rtl8821ce.zip 修改 Makefile 文件，将 TopDIR 变量改为 Makefile 文件所在路径，如下：   1 2 3  export TopDIR ?= $(srctree)/drivers/net/wireless/rtl8821ce #modify to export TopDIR ?= /home/caowenhui/Treasury/tools_and_drives/wireless/rtl8821ce    安装，打开终端，进入Makefile所在路径，输入以下命令：   1 2 3  make sudo make install sudo modprobe -a 8821ce   文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":66,"section":"docs","tags":["deepin"],"title":"为deepin系统安装无线网卡驱动","uri":"https://wenhui.space/zh/docs/install_software/install_rtl8821ce_wireless_drive.html"},{"content":"本文 主要介绍deepin系统和记录deepin系统的安装过程。\n   版本 说明     0.1 初版发布    参考  deepin官网-如何安装 实操：安装深度DeepinLinux桌面操作系统（替代微软Windows的国产开源系统）  背景  主机： Thinkpad S2 系统： Win10 deppin版本： Deepin GNU/Linux 15.11  什么是deepin？ deepin操作系统是由武汉深之度科技有限公司开发的Linux发行版。deepin操作系统是一个基于Debian的Linux操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。它包含了所有您需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等。以上内容摘自百度百科，了解详细信息可登录deepin操作系统官网。\n简而言之，deepin是基于Debian内核、简单易用又美观的Linux操作系统，适合轻量应用的普通用户和初识Linux的学习者。deepin从使用习惯上是最接近Windows的Linux操作系统，它自带应用商店、文件管理器、系统监视器、深度截屏、深度录屏、深度录音、深度影院等等，深度应用商店中提供的软件还是很丰富的，涉及网络应用、社交沟通、音乐欣赏、视频播放、图形图像、游戏娱乐、办公学习、阅读翻译、编程开发和系统管理，比如微信、QQ、百度网盘、迅雷、网易云音乐等都可以使用，但是有些软件版本较低且部分功能不支持，不过好在还是可以用的，你也可以通过手动安装最新版本，也可以发掘其他好玩好用的Linux版软件。这里说一下，deepin对游戏支持不太好，如果玩游戏的话建议还是整个Windows稳定环境吧。\n安装deepin 下载安装包和启动盘制作工具 打开deepin官网下载页面，下载ISO镜像文件，我选择的是左边第一个的 “官方下载” ，启动盘制作工具下载链接在deepin官网下载页面最下面的 “下载深度启动盘制作工具” ，或者点击这里。官网下载的深度启动盘制作工具在Windows下运行总是提示内存无法访问，不知道其他使用者情况，我再提供一个自己使用过的启动盘制作工具，百度网盘分享资源 链接：https://pan.baidu.com/s/1ph70bhA4h70cgB1PLoxPOg 密码：mphc 。\n制作启动盘  准备好一个不小于8G的U盘，最好格式化 插入准备的U盘并打开启动盘制作工具，选择深度操作系统镜像文件以及准备好的U盘，这里会有勾选项 “格式化磁盘可提高制作成功率” ，若之前U盘未格式化，在备份好内容的前提下建议勾选上 点击 “开始” 即可制作  准备分区 我的存储系统是一块256G的固态硬盘，现在要压缩出50G给deepin系统使用，方法如下：\n 选中 “此电脑” ，右键选择 \u0026ldquo;管理\u0026rdquo; ，然后选择并打开 “磁盘管理” 选择要压缩的磁盘，我这里就一个256G盘，也就没什么选择的了，然后右键选中 “压缩卷” ，输入压缩空间大小，单位是MB，50G=1024MBx50=51200MB，点击 “压缩” 这里出现了一个未分配的50G磁盘，这就是留给deepin使用的磁盘空间了  安装系统  将制作好的启动盘插入电脑 重启电脑，在屏幕处于黑屏状态时连续敲 F12（Fn+F12） ，进入启动项选择页面，选择插入的U盘，回车 系统进入安装界面，选择需要安装的语言，简体中文 进入账户界面，输入系统用户名和密码 点击 “下一步” 进入选择安装位置页面，这里选择之前压缩出的未分配磁盘，并且选择默认的 “简单” 安装即可，若对Linux磁盘分区有了解的话可以选择 “高级” ，因为是双系统，所以不建议选择 “全盘安装” ，可能会影响Windows系统的数据。 点击 “继续” ，系统开始自动化安装了 安装完成后，拔掉U盘，开始体验deepin吧    deepin主页      deepin启动器      deepin应用商店    开机启动 安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，第一选项是deepin，其他选项有Windows和硬盘等，默认等待时间是5秒，在5秒内可以选择进入win10系统还是deepin系统，不选择默认第一启动项deepin。\n如何删除deepin系统 有可能deepin安装体验后，并不喜欢，没关系，我们可以删除它。\n删除磁盘：\n 重启电脑，在启动页面选择Windows启动，进入Windows系统 选中此电脑，右键选择管理，然后选择并打开磁盘管理，选中deepin的磁盘，右键选择删除卷 原deepin磁盘此时处于未分配状态，选择要扩展的磁盘（未分配空间会添加到此盘），右键选择 \u0026ldquo;扩展卷\u0026rdquo; ，进入使用扩展向导 点击 “下一步” ，选择扩展的空间容量，这里一般选择最大值即可，设置完毕，点击 “下一步” 完成扩展向导，点击 *“完成”*，即可扩展成功，扩展之后发现扩展磁盘空间增大了  设置开机启动顺序：\n安装完deepin和win10双系统，开机启动后会默认进入deepin的开机引导页面，虽然删除了deepin的磁盘，但还会进入deepin的开机引导页面，这样会出现问题，所以需要修改开机启动项顺序。方法如下：\n 重启电脑，在屏幕处于黑屏状态时连续敲 F1（Fn+F1） ，进入BIOS页面 通过左右键选择 “Startup” 在 “Startup” 页面选择 “Boot” 项，回车 当前 “deepin” 是第一项，此时将 “Windows Boot Manager” 设为第一项 按 “F10” ，保存并退出 重启电脑，此时电脑直接进入Win10系统，与安装deepin系统前一样  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":67,"section":"docs","tags":["deepin"],"title":"deepin系统安装","uri":"https://wenhui.space/zh/docs/install_software/install_deepin_os.html"},{"content":"本文 主要介绍购买笔记本电脑前的选择和购买后的使用测评。\n   版本 说明     0.1 初版发布    背景 购置需求 本人IC工程师，但不会在个人电脑运行大型软件，不爱好游戏，不涉及图像视频相关工作，主要应用场景也就是轻量办公和轻量娱乐，所以对性能要求不高，对显卡要求不高，对屏幕显示要求不高。最大的要求就是小巧轻便，续航能力强，不想再背着联想大G跑来跑去了。\n购置理由 最终选择了这款Thinkpad S2，其购置理由如下：\n 13.3英寸，1.47Kg，厚度19.1mm，满足小巧轻便要求。 待机时长5~7小时，满足续航要求。 黑色机身，经典Thinkpad外观，商务风格（由于只有A面是金属的，其余为塑料材质，感觉银色款缺少了金属质感，所以放弃）。 接口丰富，USB3.0，Type-C，HDMI，同时具有可扩展性，足够满足日常使用（好像大多数电脑都满足这些要求了）。 可升级，ThinkPad的电脑的内存和存储都是可以升级的，内存最大升级为32G，所以买了基本配置8G+256G，后续可升级。 价格中等，6000上下，可以接受  为什么  为什么处理器不买i7？ 太贵！！！ 为什么不买x1？ 太贵！！！  图片 外观   Black Boy    接口   接口展示    参数    部件名称 部件描述     CPU型号 i5-8250U   CPU主频 1.60GHz   最高睿频 3.4GHz   总线规格 4 GT/s   CPU缓存 6 MB   核心/线程数 4/8   制程工艺 光刻 14nm   指令集 64-bit   功耗 15 W   内存容量 8GB   内存类型 2400MHz DDR4   插槽数量 2个内存插槽（一个插有8G内存，另一个空余供升级使用）   最大内存容量 32GB（每个插槽最大16GB）   硬盘容量 256GB (M.2 SSD) (可升级)   光驱 无   触控屏 不支持   屏幕尺寸 13.3英寸   显示比例 16:9   屏幕分辨率 1366x768   屏幕技术 LED背光TN显示屏，防眩目显示屏   显卡类型 集成显卡   显卡芯片 Intel UHD Graphics 620   显存容量 共享系统内存   DirectX版本 DirectX 12   摄像头 720p 高清摄像头   音频系统 HD Audio，Realtek ALC3287 codec   扬声器 立体扬声器 2Wx2   麦克风 DualArray Microphone（内置双阵列麦克风）   无线网卡 支持802.11AC协议的无线网卡   有线网卡 内置Intel Ethernet Connection I219-V（Jacksonville）   蓝牙 无线网卡集成   数据接口 2个USB3.0 Gen1（其中一个为Always On），2个USB3.0 Type-C   视频接口 HDMI   音频接口 Combo jack（麦克风/耳机二合一接口）   读卡器 MicroSD 读卡器   指纹识别 支持   键盘 6行全尺寸键盘（不带背光）   电池类型 3芯45Wh   续航时间 5-7小时   电源适配器 65W USB C型 AC Adapter   预装操作系统 Win10家庭中文版64位   WWAN 不支持    使用测评  整机算是比较轻，但算不上薄，毕竟不是超级本，不过也是thinkpad中小巧轻便的了，整体不错。 机身材料只有A面是金属的，其它全是塑料材质，这个买之前就已经知晓了，不过选的黑色款，外观还不错，不知道银色款怎么样，唯一的吐槽点是开箱时塑料味稍微有点大。 接口丰富，一个USB给无线键鼠使用，一个可供存储读取使用，其中一个USB口是Always On的，也就是在关机时直插可以给手机充电，两个Type-C都可以充电，HDMI可扩展屏幕，还有mini网口和SD卡读口，足够满足日常需求了，个别需求需要另购扩展坞或转换头。 电池续航能力亲测可以，满足日常办公待机5～6小时，可以设置电池充电至90%，这样接电源使用对电池比较好。 键盘手感还可以，本人要求不高，中间的红色指杆，是ThinkPad经典标志，不过我觉得现在挺鸡肋的，反正我不会去用，触控板已足够。 网上有人说风扇和散热的问题，我这里没发现什么异常 在Win10系统，无线网不自动刷新连接，手动刷新有时候找不到自己的网络，估计也不是电脑的问题，回头重装系统试试。 联想客服，可以添加微信公众号，绑定自己的设备，有啥问题都可以咨询人工客服  文章原创，可能存在部分错误，欢迎指正，联系邮箱 cao_arvin@163.com。\n","description":"","id":68,"section":"docs","tags":null,"title":"My Black Boy","uri":"https://wenhui.space/zh/docs/install_software/thinkpad_s2.html"},{"content":"  这就是我了    你好，欢迎来到这里，我叫文辉，一位一直从事于CPU行业的IC工程师，这是我的个人博客站点，在此总结一些技术经验和记录生活中的点点滴滴。\n关于我 漂于北京的雄安土著 我是一个漂于北京的雄安土著。2017年4月1日，我多了个称号 “雄安土著” 。当时我还在西安上学，成立雄安新区的消息竟然还是室友告诉我的，想想也是有意思。2017年8月，我来到了长沙工作，一年后又到了北京，成为了一只漂于北京的雄安土著。\nCPU行业从事者 我是一个CPU行业从事者。CPU的启蒙是从 “计算机组成原理” 这门课程开始的，紧接着完成了 “基于MIPS指令集的多周期处理器” 的课程设计，对处理器产生了浓厚的兴趣，后续又完成了 \u0026ldquo;兼容ARM指令集的五级流水处理器\u0026rdquo; 的毕业设计，期间还读了一本姚永斌先生写的 《超标量处理器设计》 一书，对现代处理器的设计有了基础认识。毕业之后顺利进入一家处理器设计公司，任职 微处理器逻辑设计工程师 ，开启了我CPU领域的职业之旅。在长沙工作期间，要特别感谢王老师、高老师、赵老师、郑老师对我工作的指导，使我有了很大的进步。一年后来到北京，从事了一段时间CPU验证工作，要特别感谢文彬师兄，在CPU验证方面传授了很多经验给我，也感谢浩哥，从北京CPU产业方面了解到很多东西，相对于从前的我，视野更开阔了。更要感谢我的女朋友，对我一直以来的支持和鼓励，包括对一个工科男的包容和理解。总之，我很荣幸从事于自己喜欢的CPU行业，也很荣幸有一路帮助我的人们，我会一直坚持在CPU领域努力前行。\nEmacs User 我是一个忠实的 Emacs User 。开始使用Emacs是受王老师推荐，演示了一版 verilog mode 中 AUTO机制 的惊艳操作，从此开始成为一名 Emacs User 。对于 emacs 我主要使用 org mode 和 verilog mode ， org mode 主要用来写博客写笔记，支持大纲浏览和导出各种格式； verilog mode 主要用于代码编辑， AUTO机制 可实现自动顶层连线、自动声明端口列表、自动声明连线等等。\n美食爱好者（吃货） 我是一个美食爱好者（吃货）。本人自出生以来就喜欢吃，喜欢吃肉，喜欢吃甜食，绝对的 资深吃货 。出去旅游必去的是小吃街：\n 在西安吃过泡馍（包括小炒泡馍，牛羊肉泡馍，葫芦头泡馍\u0026hellip;）、葫芦鸡、定家小酥肉、贾三灌汤包、水盆羊肉、胡辣汤、葱油饼、凉皮、肉夹馍、油糕、柿饼、甑糕、各种面食\u0026hellip;\u0026hellip; 感觉可以发一个长帖了 “论在西安的吃喝四年（读大学）” 。 在兰州吃过灰豆、牛肉饼、甜蓓子、酿皮、牛肉面，都好吃，不过甜蓓子吃了不少，火车上我肚子胀的跟小皮球儿似的，难道在我肚子里发酵了 在天水吃过荞面凉粉、天水呱呱，不过个人不太喜欢，在天水吃的最好吃的竟然是永和豆浆的红烧肉盖饭 在洛阳吃过丸子汤，汤是牛肉汤，丸子焦酥，美味极了 在邢台吃过石头饼，很好吃 在长沙吃过小龙虾、辣椒炒肉、带皮羊肉、卜豆角炒肉、卜辣椒炒肉、梅干菜扣肉饼、糖油粑粑、葱油粑粑、臭豆腐\u0026hellip;\u0026hellip; 在我老家，要说好吃的，我强烈推荐五香流油烤鸭蛋和小鱼咸菜加贴饼  生活在一个地方，最喜欢逛的是菜市场和超市，在西安，我认识了火晶小柿子，认识了拐枣，认识了秦椒\u0026hellip; 在长沙认识了花生芽、擂辣椒、卜豆角、卜辣椒、凉薯、红菜苔、白菜苔、腊鱼腊肉和腊肠\u0026hellip; 在北京好像更国际一些，五道口的帝玛进口超市，认识了更多西餐使用的罗勒酱、迷迭香、鱼露、各种果醋、日本酱油、小洋葱\u0026hellip;\n对于吃，我还有个小癖好，那就是收集老菜谱，那些破烂的、发黄的、散发着陈年油墨味的老菜谱，就是我的收集对象了。目前我也收集了十几本老菜谱了，包括六十年代、七十年代、八十年代、九十年代，也有手写油印版的，也许研究他们就是我老了以后的主要工作了。\n在北京，一个不大的出租屋里，我却置办了很多炊具，想吃炒菜买了炒锅，想吃米饭和粥买了电饭锅，想吃粉蒸肉买了电蒸锅，想吃鸡蛋饼买了电饼铛，想吃红烧肉买了电压力锅，想喝豆浆买了豆浆机，想吃烤肉买了烤箱，不知道下一个我要买的会是什么。\n台球爱好者 我是一个台球爱好者。说到台球，不得不讲我大学期间的三个目标， “爱上一座城市 爱上一个人 爱上一项运动” ，完成这三个目标的大学生活才是圆满的。如果单从一项运动来讲，没有比在悠哉的大学生活时期去培养更适合了，我已经充分感受到了工作中的忙碌，很难有足够的时间和精力去认真学习一项运动，比如台球。\n我是从大三开始打台球的，那时候找来教学视频，一点点学起，包括手架、握杆、站位、瞄点、发力\u0026hellip;\u0026hellip; 不得不说，台球技巧性很强的，要想学好需要花费不少的时间和精力。我之前看的教学视频是庞卫国老师的，不过是斯诺克教学视频，本人也很喜欢庞卫国老师的解说，尤其是和主持人姜毅搭档。现在教学视频也多了，可以看看前斯诺克职业球手刘松的，还有新锐台球教练王桁的，也可以关注他们的公众号。以前看直播是在星期五台球网，现在有中国体育直播APP方便了，基本所有赛事都有直播，包括八球和斯诺克，而且一般的斯诺克赛事刘松都会主播，刘教练划线很准的。顺便说一句，我的球杆就是野豹中国体育定制款的，千元球杆，打感还可以。\n我平时斯诺克比赛看的多一些，八球比赛很少看，喜欢的球员当然是火老师，打球那叫一个行云流水，还有墨菲，喜欢他打球的节奏，还有中国一哥丁俊晖，喜欢的八球球员就是二宝郑宇伯，打球就两个字 “痛快” 。近年来国内台球很热，好多年轻小将涌现，进入斯诺克职业赛了，比如颜丙涛、周跃龙、袁思俊、赵心童、雷佩凡、斯佳辉\u0026hellip; 斯佳辉是刘松教练的徒弟，雷佩凡是陕西安康人，我室友也是安康人，还记得大二时跟他回家玩，去球厅看到小小的雷佩凡一个人在练球，那年他十一岁，如今也是职业球手了。今年的世界斯诺克中国公开赛在北京国家奥林匹克体育中心体育馆举行，我终于圆了自己一个梦想，看了一次现场斯诺克比赛，前几轮比赛的票价很便宜，毕竟斯诺克是小众运动，我买了99元票坐到了199的位置，还记得当时包括我只有两个观众看了布雷切尔的比赛，下半场我就偷偷溜到二号台，看了马叔两杆破败一杆50+，不过没坚持到比赛结束，太晚了就回家了。斯诺克的票价真的不贵，你可见过黄牛票都打折。在北京的朋友可以看一看中国公开赛，一般举行时间是4月1日到4月7日。\n再来说一说为什么喜欢台球。首先台球是一项绅士运动，不像足球篮球碰撞性那么强，我怕把别人撞坏了，更怕别人把我撞坏了。打台球最让人极致舒适的不是一杆进洞，而是一杆进洞的同时伴随着漂亮的走位，对白球的控制才是让人最爽的。打台球真正的敌人不是对手，而是自己，你需要的是自己的完美发挥。打台球像一场博弈，有进攻，有防守，有思考，有抉择，不仅需要娴熟的技艺，还需要沉着冷静的头脑。打台球更像是解决一道难题，目标就是一杆致胜，但达到目标需要解决一路障碍。我们看下图的球形，开球后9号球落袋，白球位置不太好打全色球，所以击打15号选定花色球，同时白球K停5号，这样12号和14号左下袋口进球线路打开，同时叫到11号左上袋口，击打11号时根据白球角度可以选择轻K12号，也可以单叫10号，打完10号可以顺势解决12号和14号，最后通过13号叫8号球，完成清台。当然这是A计划，如果击球过程中走位出现失误，那就要执行B计划了（防守）。找一个安全的位置，最好对手看不到目标球，其次是无进球线路，在其次是进球难度高的位置，贴库位置是个不错的选择，配合自己的球形大脑里快速评估一下防守成功率，然后进行方案决策以及实施。可是如果对手有袋口球，让你无处可防怎么办，此时要么破坏袋口球的同时白球走一个相对安全位置，要么将对手某目标球锁死，比如赌袋口，实在不行就大捅一杆，洗洗牌，也许会出现对自己有利的球形哦。总之，B计划的宗旨就一个，增加对手清台难度，一杆打不死我，老子就有机会上来收拾你。怎么样，也许看到这里你也喜欢上了台球。\n  台球    我喜欢的  节目  强烈推荐优酷的 《圆桌派》 ，这是一个聊天节目，一个圆桌，一个话题，一炉焚香，四位嘉宾开始畅谈，各自表述观点和想法，作为听众有时也会陷入深思，不知不觉融入其中。圆桌派的话题涉及很广，有发人深省的，也有幽默风趣的，最主要的是全部贴近生活。最喜欢的是陈晓卿参加的那期 “饭局” 。   音乐和歌手  郑钧：私奔、赤裸裸 李志：天空之城、梵高、和你在一起、不多 伍佰：再度重相逢、晚风 吴宁越：羊肉面 马条：阳光中的向日葵 赵雷：鼓楼 奇葩的歌：少林奥运、李伯伯、罗马表、我想我想\u0026hellip;\u0026hellip; 最近听的：Chris Stapleton的Tennessee Whiskey、北野武的浅草キッド、John Lennon的Imagine、老王乐队的我还年轻、杨学的泸沽湖、鱼大叔的后来的我、丢火车的火车日记、莫染的给英格兰友人、房东的猫的下一站茶山刘\u0026hellip;\u0026hellip;   喜欢的电影  我喜欢看轻松娱乐类的电影，比如无名之辈、情圣、人在囧途、让子弹飞\u0026hellip;\u0026hellip; 严重抵触悬疑惊悚类，天生胆小 有点喜欢战争类，非神剧，比如天空之眼、狂怒、猎杀红色十月、拆弹部队、美国狙击手、孤独的幸存者、兵临城下\u0026hellip;\u0026hellip; 不怎么看电视剧，感觉没时间追剧    关于本博客 本博客主要内容 本博客主要是总结一些工作中的技术经验，以及记录生活中的一些点点滴滴。\n本博客名字由来 我始终坚持一句话， “第一次问过或查过的问题，就应该记下来；第二次再问或再查的问题，就必须记下来。” 既然没有强大的大脑，那就多动动手，记录下来，正所谓好记性不如烂笔头，本博客就是我的 烂笔头 。\n本博客创建过程 实际上整个过程是这样的，最初自己只做一些工程上的笔记，使用工具就是word了；后来熟悉了emacs的org mode，开始用org来记笔记，可以导出html文件用浏览器查看；再后来从emacs china论坛中发现有人开发了基于org的笔记管理系统，但是已经不再维护了，所以只是简单了解了一下；接下来仍一直在寻找一种笔记管理方法，网上有人推荐了hexo，一个博客站点生成器，折腾了一段时间，从安装hexo工具到配置主题就要晕死了；在折腾hexo的过程中又发现了hugo博客站点生成器，免安装，还有天然支持org转markdown的插件，简直太舒服了。使用emacs和hugo构建自己的博客，目前对我来说是最舒服的方式没有之一。整个过程是不是很曲折，如果你看到这里，推荐你直接使用hugo搭建自己的博客站点，非emacs用户的话可以直接书写markdown文件，顺便推荐一款markdown编辑器 Typora 。这里就不对如何使用hugo搭建自己的博客站点进行介绍了，有单独的一篇帖子介绍详细的搭建过程。\n","description":"","id":69,"section":"","tags":null,"title":"About","uri":"https://wenhui.space/zh/about.html"}]